///////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2019, ООО 1С-Софт
// Все права защищены. Эта программа и сопроводительные материалы предоставляются 
// в соответствии с условиями лицензии Attribution 4.0 International (CC BY 4.0)
// Текст лицензии доступен по ссылке:
// https://creativecommons.org/licenses/by/4.0/legalcode
///////////////////////////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

#Область ИнициализацияОбмена
// Добавляет строку в таблицу правил конвертации и инициализирует значение в колонке "Свойства".
// Используется в модуле менеджера обмена при заполнении таблицы правил конвертации объектов.
//
// Параметры:
//  ПравилаКонвертации - см. КоллекцияПравилКонвертации
//
// Возвращаемое значение:
//  СтрокаТаблицыЗначений - строка таблицы правил конвертации.
//
Функция ИнициализироватьПравилоКонвертацииОбъекта(ПравилаКонвертации) Экспорт
	
	ПравилоКонвертации = ПравилаКонвертации.Добавить();
	ПравилоКонвертации.Свойства = ИнициализироватьТаблицуСвойствДляПравилаКонвертации();
	Возврат ПравилоКонвертации;
	
КонецФункции

// Инициализирует компоненты обмена.
//
// Параметры:
//  НаправлениеОбмена - Строка - направление выполнения обмена: "Отправка" | "Получение".
//
// Возвращаемое значение:
//   Структура - содержит компоненты обмена (правила обмена и параметры обмена):
//     * ВерсияФорматаОбмена - Строка - номер версии формата обмена.
//     * XMLСхема - Строка - пространство имен формата обмена.
//     * МенеджерОбмена - ОбщийМодуль - модуль с правилами конвертации.
//     * УзелКорреспондента - ПланОбменаСсылка - ссылка на узел плана обмена.
//     * УзелКорреспондентаОбъект - ПланОбменаОбъект - объект узла плана обмена.
//     * ВерсияФорматаМенеджераОбмена - Строка - номер версии формата модуля с правилами конвертации.
//     * НаправлениеОбмена - Строка - "Отправка" или "Получение".
//     * ЭтоОбменЧерезПланОбмена - Булево - признак выполнения обмена по плану обмена.
//     * ФлагОшибки - Булево - признак наличия ошибки при выполнении действия обмена.
//     * СтрокаСообщенияОбОшибке - Строка - описание ошибки при выполнении действия обмена.
//     * КлючСообщенияЖурналаРегистрации - Строка - имя события для записи информации об ошибках в журнал регистрации.
//     * ИспользоватьКвитирование - Булево - признак использования квитирования для удаления регистрации изменений.
//     * ВыгруженныеОбъекты - Массив из ЛюбаяСсылка - коллекция выгруженных объектов.
//     * НеВыгруженныеОбъекты - Массив из ЛюбаяСсылка - коллекция не выгруженных объектов.
//     * ВыгруженныеПоСсылкеОбъекты - Массив из ЛюбаяСсылка - коллекция объектов, выгруженных "по ссылке".
//     * ДокументыДляОтложенногоПроведения - ТаблицаЗначений - коллекция документов для отложенного проведения:
//       ** ДокументСсылка - ДокументСсылка - ссылка на документ.
//       ** ДатаДокумента - Дата - дата документа.
//     * ПоддерживаемыеОбъектыXDTO - Массив из Строка - коллекция идентификаторов объектов формата.
//     * ЗагруженныеОбъекты - ТаблицаЗначений - коллекция загруженных объектов:
//       ** ИмяОбработчика - Строка - имя обработчика.
//       ** Объект - СправочникОбъект, ДокументОбъект - загруженный объект.
//       ** Параметры - Произвольный - произвольные параметры.
//       ** СсылкаНаОбъект - ЛюбаяСсылка - ссылка на загруженный объект.
//     * ПравилаОбработкиДанных - см. ТаблицаПравилОбработкиДанных
//     * СостояниеОбменаДанными - Структура - описание состояния выполнения обмена:
//       ** УзелИнформационнойБазы - ПланОбменаСсылка - узел плана обмена.
//       ** ДействиеПриОбмене - ПеречислениеСсылка.ДействияПриОбмене - выполняемое действие.
//       ** ДатаНачала - Дата - дата начала выполнения действия.
//       ** ДатаОкончания - Дата - дата окончания выполнения действия.
//       ** РезультатВыполненияОбмена - ПеречислениеСсылка.РезультатыВыполненияОбмена, Неопределено - результат
//           выполнения действия.
//     * ТаблицаДанныхЗаголовкаПакета - см. НоваяТаблицаДанныхЗаголовкаПакета
// 
Функция ИнициализироватьКомпонентыОбмена(НаправлениеОбмена) Экспорт
	
	КомпонентыОбмена = Новый Структура;
	КомпонентыОбмена.Вставить("ВерсияФорматаОбмена");
	КомпонентыОбмена.Вставить("XMLСхема");
	КомпонентыОбмена.Вставить("МенеджерОбмена");
	КомпонентыОбмена.Вставить("УзелКорреспондента");
	КомпонентыОбмена.Вставить("УзелКорреспондентаОбъект");
	КомпонентыОбмена.Вставить("ВерсияФорматаМенеджераОбмена");
		
	КомпонентыОбмена.Вставить("НаправлениеОбмена", НаправлениеОбмена);
	КомпонентыОбмена.Вставить("ЭтоОбменЧерезПланОбмена", Истина);
	КомпонентыОбмена.Вставить("ФлагОшибки", Ложь);
	КомпонентыОбмена.Вставить("СтрокаСообщенияОбОшибке", "");
	КомпонентыОбмена.Вставить("КлючСообщенияЖурналаРегистрации", ОбменДаннымиСервер.СобытиеЖурналаРегистрацииОбменДанными());
	КомпонентыОбмена.Вставить("ИспользоватьКвитирование", Истина);
	
	КомпонентыОбмена.Вставить("ОбменДаннымиСВнешнейСистемой", Ложь);
	КомпонентыОбмена.Вставить("ИдентификаторКорреспондента",  "");
	
	КомпонентыОбмена.Вставить("ТолькоНастройкиXDTO", Ложь);
	// Перечень поддерживаемых объектов формата для текущего сеанса обмена.
	// Содержит набор совместно поддерживаемых объектов этой базы и базы корреспондента
	// в контексте конкретного действия обмена (отправки/получения).
	// Подробнее см. ОбменДаннымиXDTOСервер.ЗаполнитьПоддерживаемыеОбъектыXDTO
	КомпонентыОбмена.Вставить("ПоддерживаемыеОбъектыXDTO", Новый Массив);
	
	СостояниеОбменаДанными = Новый Структура;
	СостояниеОбменаДанными.Вставить("УзелИнформационнойБазы");
	СостояниеОбменаДанными.Вставить("ДействиеПриОбмене");
	СостояниеОбменаДанными.Вставить("ДатаНачала");
	СостояниеОбменаДанными.Вставить("ДатаОкончания");
	СостояниеОбменаДанными.Вставить("РезультатВыполненияОбмена");
	КомпонентыОбмена.Вставить("СостояниеОбменаДанными", СостояниеОбменаДанными);
	
	ВедениеПротоколаДанных = Новый Структура;
	ВедениеПротоколаДанных.Вставить("ФайлПротоколаДанных", Неопределено);
	ВедениеПротоколаДанных.Вставить("ВыводВПротоколИнформационныхСообщений", Ложь);
	ВедениеПротоколаДанных.Вставить("ДописыватьДанныеВПротоколОбмена", Истина);
	
	КомпонентыОбмена.Вставить("ВедениеПротоколаДанных", ВедениеПротоколаДанных);
	
	КомпонентыОбмена.Вставить("ИспользоватьТранзакции", Истина);
	
	// Структура настроек XDTO этой базы.
	// Участвует в формировании списка поддерживаемых объектов (см. "ПоддерживаемыеОбъектыXDTO")
	// При отправке по ней будет сформирована заголовочная часть сообщения обмена - в этом случае
	// будет содержать перечень всех доступных объектов формата с детализацией по версиям.
	КомпонентыОбмена.Вставить("НастройкиXDTO", Новый Структура);
	КомпонентыОбмена.НастройкиXDTO.Вставить("Формат",                "");
	КомпонентыОбмена.НастройкиXDTO.Вставить("ПоддерживаемыеОбъекты", Новый ТаблицаЗначений);
	КомпонентыОбмена.НастройкиXDTO.Вставить("ПоддерживаемыеВерсии",  Новый Массив);
	
	ИнициализироватьТаблицуПоддерживаемыхОбъектовФормата(
		КомпонентыОбмена.НастройкиXDTO.ПоддерживаемыеОбъекты, "ОтправкаПолучение");
	
	Если НаправлениеОбмена = "Отправка" Тогда
		
		КомпонентыОбмена.Вставить("ВыгруженныеОбъекты", Новый Массив);
		КомпонентыОбмена.Вставить("КоличествоОбъектовКВыгрузке", 0);
		КомпонентыОбмена.Вставить("СчетчикВыгруженныхОбъектов", 0);
		КомпонентыОбмена.Вставить("СоответствиеРегистрацияПоНеобходимости", Новый Соответствие);
		КомпонентыОбмена.Вставить("ВыгруженныеПоСсылкеОбъекты", Новый Массив);
		
		КомпонентыОбмена.Вставить("СценарийВыгрузки");
		
		КомпонентыОбмена.Вставить("ТаблицаПравилаРегистрацииОбъектов");
		КомпонентыОбмена.Вставить("СвойстваУзлаПланаОбмена");
		
		КомпонентыОбмена.Вставить("ПропускатьОбъектыСОшибкамиПроверкиПоСхеме", Ложь);
		КомпонентыОбмена.Вставить("НеВыгруженныеОбъекты", Новый Массив);
		
	Иначе
		
		КомпонентыОбмена.Вставить("НомерВходящегоСообщения");
		КомпонентыОбмена.Вставить("НомерСообщенияПолученногоКорреспондентом");
		
		КомпонентыОбмена.Вставить("РежимЗагрузкиДанныхВИнформационнуюБазу", Истина);
		КомпонентыОбмена.Вставить("СчетчикЗагруженныхОбъектов", 0);
		КомпонентыОбмена.Вставить("КоличествоОбъектовНаТранзакцию", 0);
		КомпонентыОбмена.Вставить("КоличествоОбъектовКЗагрузке", 0);
		КомпонентыОбмена.Вставить("РазмерФайлаСообщенияОбмена", 0);
		
		ДокументыДляОтложенногоПроведения = Новый ТаблицаЗначений;
		ДокументыДляОтложенногоПроведения.Колонки.Добавить("ДокументСсылка");
		ДокументыДляОтложенногоПроведения.Колонки.Добавить("ДатаДокумента", Новый ОписаниеТипов("Дата"));
		КомпонентыОбмена.Вставить("ДокументыДляОтложенногоПроведения", ДокументыДляОтложенногоПроведения);
		
		ЗагруженныеОбъекты = Новый ТаблицаЗначений;
		ЗагруженныеОбъекты.Колонки.Добавить("ИмяОбработчика");
		ЗагруженныеОбъекты.Колонки.Добавить("Объект");
		ЗагруженныеОбъекты.Колонки.Добавить("Параметры");
		ЗагруженныеОбъекты.Колонки.Добавить("СсылкаНаОбъект");
		ЗагруженныеОбъекты.Индексы.Добавить("СсылкаНаОбъект");
		КомпонентыОбмена.Вставить("ЗагруженныеОбъекты", ЗагруженныеОбъекты);
		
		ТаблицаОбъектовСозданныхПоСсылкам = Новый ТаблицаЗначений();
		ТаблицаОбъектовСозданныхПоСсылкам.Колонки.Добавить("СсылкаНаОбъект");
		ТаблицаОбъектовСозданныхПоСсылкам.Колонки.Добавить("УдалятьСозданныеПоКлючевымСвойствам");
		ТаблицаОбъектовСозданныхПоСсылкам.Индексы.Добавить("СсылкаНаОбъект");
		КомпонентыОбмена.Вставить("ТаблицаОбъектовСозданныхПоСсылкам", ТаблицаОбъектовСозданныхПоСсылкам);
		
		КомпонентыОбмена.Вставить("ТаблицаДанныхЗаголовкаПакета", НоваяТаблицаДанныхЗаголовкаПакета());
		КомпонентыОбмена.Вставить("ТаблицыДанныхСообщенияОбмена", Новый Соответствие);
		
		КомпонентыОбмена.Вставить("ОбъектыДляОтложеннойЗаписи", Новый Соответствие);
		
		// Структура настроек XDTO корреспондента, зачитываемая из сообщения обмена.
		КомпонентыОбмена.Вставить("НастройкиXDTOКорреспондента", Новый Структура);
		КомпонентыОбмена.НастройкиXDTOКорреспондента.Вставить("Формат",                "");
		КомпонентыОбмена.НастройкиXDTOКорреспондента.Вставить("ПоддерживаемыеОбъекты", Новый ТаблицаЗначений);
		КомпонентыОбмена.НастройкиXDTOКорреспондента.Вставить("ПоддерживаемыеВерсии",  Новый Массив);
		
		ИнициализироватьТаблицуПоддерживаемыхОбъектовФормата(
			КомпонентыОбмена.НастройкиXDTOКорреспондента.ПоддерживаемыеОбъекты, "ОтправкаПолучение");
		
		КомпонентыОбмена.Вставить("ПрефиксКорреспондента");
		
		КомпонентыОбмена.Вставить("УдалятьСозданныеПоКлючевымСвойствам", Ложь);
		КомпонентыОбмена.Вставить("ПомеченныеНаУдалениеОбъекты",         Новый Массив);
		
	КонецЕсли;
	
	Возврат КомпонентыОбмена;
	
КонецФункции

// Инициализирует таблицы значений с правилами обмена и помещает их в КомпонентыОбмена.
//
// Параметры:
//  КомпонентыОбмена - Структура - содержит все правила и параметры обмена.
//
Процедура ИнициализироватьТаблицыПравилОбмена(КомпонентыОбмена) Экспорт
	
	НаправлениеОбмена = КомпонентыОбмена.НаправлениеОбмена;
	XMLСхема = КомпонентыОбмена.XMLСхема;
	МенеджерОбмена = КомпонентыОбмена.МенеджерОбмена;
	
	// Вычисление версии формата менеджера обмена - от этого зависит формирование правил.
	Попытка
		КомпонентыОбмена.Вставить("ВерсияФорматаМенеджераОбмена", МенеджерОбмена.ВерсияФорматаМенеджераОбмена());
	Исключение
		КомпонентыОбмена.Вставить("ВерсияФорматаМенеджераОбмена", "1");
	КонецПопытки;
	
	// Инициализация таблиц правил обмена.
	КомпонентыОбмена.Вставить("ПравилаОбработкиДанных", ТаблицаПравилОбработкиДанных(XMLСхема, МенеджерОбмена, НаправлениеОбмена));
	КомпонентыОбмена.Вставить("ПравилаКонвертацииОбъектов", ТаблицаПравилКонвертации(
		XMLСхема, МенеджерОбмена, НаправлениеОбмена, КомпонентыОбмена.ПравилаОбработкиДанных, КомпонентыОбмена.ВерсияФорматаМенеджераОбмена));
	
	КомпонентыОбмена.Вставить("ПравилаКонвертацииПредопределенныхДанных",
		ТаблицаПравилКонвертацииПредопределенныхДанных(XMLСхема, МенеджерОбмена, НаправлениеОбмена));
	
	КомпонентыОбмена.Вставить("ПараметрыКонвертации", СтруктураПараметровКонвертации(МенеджерОбмена));
	
КонецПроцедуры

// Инициализирует таблицу значений для хранения правил конвертации свойств объекта.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица для хранения правил конвертации свойств:
//     * СвойствоКонфигурации - Строка -
//     * СвойствоФормата - Строка -
//     * ПравилоКонвертацииСвойства - Строка -
//     * ИспользуетсяАлгоритмКонвертации - Булево -
//     * ОбработкаКлючевогоСвойства - Булево -
//     * ОбработкаПоисковогоСвойства - Булево -
//     * ИмяТЧ - Строка -
//
Функция ИнициализироватьТаблицуСвойствДляПравилаКонвертации() Экспорт
	
	ТаблицаПКС = Новый ТаблицаЗначений;
	ТаблицаПКС.Колонки.Добавить("СвойствоКонфигурации", Новый ОписаниеТипов("Строка"));
	ТаблицаПКС.Колонки.Добавить("СвойствоФормата", Новый ОписаниеТипов("Строка"));
	ТаблицаПКС.Колонки.Добавить("ПравилоКонвертацииСвойства", Новый ОписаниеТипов("Строка",,Новый КвалификаторыСтроки(50)));
	ТаблицаПКС.Колонки.Добавить("ИспользуетсяАлгоритмКонвертации", Новый ОписаниеТипов("Булево"));
	ТаблицаПКС.Колонки.Добавить("ОбработкаКлючевогоСвойства", Новый ОписаниеТипов("Булево"));
	ТаблицаПКС.Колонки.Добавить("ОбработкаПоисковогоСвойства", Новый ОписаниеТипов("Булево"));
	ТаблицаПКС.Колонки.Добавить("ИмяТЧ", Новый ОписаниеТипов("Строка"));

	Возврат ТаблицаПКС;
	
КонецФункции

// Заполняет колонку со свойствами табличных частей пустой таблицей значений с определенными колонками.
// Используется в текущем модуле, а также в модуле менеджера обмена при заполнении таблицы правил конвертации объектов.
//
// Параметры:
//  ПравилоКонвертации - СтрокаТаблицыЗначений - правило конвертации объектов.
//  ИмяКолонки - Строка - имя заполняемой колонки таблицы правил конвертации.
Процедура ИнициализироватьСвойстваТабличныхЧастей(ПравилоКонвертации, ИмяКолонки = "СвойстваТабличныхЧастей") Экспорт
	СвойстваТабличныхЧастей = Новый ТаблицаЗначений;
	СвойстваТабличныхЧастей.Колонки.Добавить("ТЧКонфигурации",          Новый ОписаниеТипов("Строка"));
	СвойстваТабличныхЧастей.Колонки.Добавить("ТЧФормата",               Новый ОписаниеТипов("Строка"));
	СвойстваТабличныхЧастей.Колонки.Добавить("Свойства",                Новый ОписаниеТипов("ТаблицаЗначений"));
	СвойстваТабличныхЧастей.Колонки.Добавить("ИспользуетсяАлгоритмКонвертации", Новый ОписаниеТипов("Булево"));
	
	ПравилоКонвертации[ИмяКолонки] = СвойстваТабличныхЧастей;
КонецПроцедуры

#КонецОбласти

#Область ВедениеПротокола
// Создает объект для записи протокола обмена и помещает его в КомпонентыОбмена.
//
// Параметры:
//  КомпонентыОбмена        - Структура - содержит все правила и параметры обмена.
//  ИмяФайлаПротоколаОбмена - Строка - содержит полное имя файла протокола.
//
Процедура ИнициализироватьВедениеПротоколаОбмена(КомпонентыОбмена, ИмяФайлаПротоколаОбмена) Экспорт
	
	КомпонентыОбмена.ВедениеПротоколаДанных.ФайлПротоколаДанных = Неопределено;
	Если Не ПустаяСтрока(ИмяФайлаПротоколаОбмена) Тогда
		
		// Попытка записи в файл протокола обмена.
		Попытка
			КомпонентыОбмена.ВедениеПротоколаДанных.ФайлПротоколаДанных = Новый ЗаписьТекста(
				ИмяФайлаПротоколаОбмена,
				КодировкаТекста.UTF8,
				,
				КомпонентыОбмена.ВедениеПротоколаДанных.ДописыватьДанныеВПротоколОбмена);
		Исключение
			
			СтрокаСообщения = НСтр("ru = 'Ошибка при попытке записи в файл протокола данных: %1. Описание ошибки: %2'",
				ОбщегоНазначения.КодОсновногоЯзыка());
			СтрокаСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщения, ИмяФайлаПротоколаОбмена, ОписаниеОшибки());
			
			ЗаписьЖурналаРегистрацииОбменДанными(СтрокаСообщения, КомпонентыОбмена, УровеньЖурналаРегистрации.Предупреждение);
			
		КонецПопытки;
		
	КонецЕсли;
	
КонецПроцедуры

// Завершает запись в протокол обмена.
//
// Параметры:
//  КомпонентыОбмена - Структура - содержит все правила и параметры обмена.
//
Процедура ЗавершитьВедениеПротоколаОбмена(КомпонентыОбмена) Экспорт
	
	Если КомпонентыОбмена.ВедениеПротоколаДанных.ФайлПротоколаДанных <> Неопределено Тогда
		
		КомпонентыОбмена.ВедениеПротоколаДанных.ФайлПротоколаДанных.Закрыть();
		КомпонентыОбмена.ВедениеПротоколаДанных.ФайлПротоколаДанных = Неопределено;
		
	КонецЕсли;
	
КонецПроцедуры

// Сохраняет в протокол выполнения (или выводит на экран) сообщения указанной структуры.
//
// Параметры:
//  КомпонентыОбмена - Структура - содержит все правила и параметры обмена.
//  КодОшибки        - Число, Строка, Структура - информация об ошибке.
//                       Число - код ошибки, см. ОбменДаннымиПовтИсп.СообщенияОбОшибках().
//                       Строка - описание ошибки.
//                       Структура - структура с кратким и подробным описанием ошибки.
//                         * КраткоеПредставлениеОшибки - описание ошибки для протокола (для пользователя).
//                         * ПодробноеПредставлениеОшибки - описание ошибки для журнала регистрации.
//                         * Уровень - УровеньЖурналаРегистрации - уровень важности ошибки.
//  СтруктураЗаписи   - Структура - Структура записи протокола.
//  ВзвестиФлагОшибок - Булево - Если истина, то - это сообщение об ошибке. Взводится ФлагОшибки.
//  Уровень           - Число - отступ слева, количество табуляций.
//  Выравнивание      - Число - отступ в тексте, для выравнивания текста выводимого в виде Ключ - Значение.
//  БезусловнаяЗаписьВПротоколОбмена - Булево - флаг безусловной записи информации в протокол.
//
// Возвращаемое значение:
//  Строка - текст ошибки, которая была записана в протокол.
//
Функция ЗаписатьВПротоколВыполнения(КомпонентыОбмена,
		КодОшибки = "",
		СтруктураЗаписи = Неопределено,
		ВзвестиФлагОшибок = Истина,
		Уровень = 0,
		Выравнивание = 22,
		БезусловнаяЗаписьВПротоколОбмена = Ложь) Экспорт
	
	ФайлПротоколаДанных = КомпонентыОбмена.ВедениеПротоколаДанных.ФайлПротоколаДанных;
	ВыводВПротоколИнформационныхСообщений = КомпонентыОбмена.ВедениеПротоколаДанных.ВыводВПротоколИнформационныхСообщений;
	
	Отступ = "";
	Для Сч = 0 По Уровень - 1 Цикл
		Отступ = Отступ + Символы.Таб;
	КонецЦикла; 
	
	КраткоеПредставлениеОшибки   = "";
	ПодробноеПредставлениеОшибки = "";
	
	Если ТипЗнч(КодОшибки) = Тип("Число") Тогда
		
		СообщенияОбОшибках = ОбменДаннымиПовтИсп.СообщенияОбОшибках();
		
		КраткоеПредставлениеОшибки   = СообщенияОбОшибках[КодОшибки];
		ПодробноеПредставлениеОшибки = СообщенияОбОшибках[КодОшибки];
		
	ИначеЕсли ТипЗнч(КодОшибки) = Тип("Структура") Тогда
		
		КодОшибки.Свойство("КраткоеПредставлениеОшибки",   КраткоеПредставлениеОшибки);
		КодОшибки.Свойство("ПодробноеПредставлениеОшибки", ПодробноеПредставлениеОшибки);
		
	Иначе
		
		КраткоеПредставлениеОшибки   = КодОшибки;
		ПодробноеПредставлениеОшибки = КодОшибки;
		
	КонецЕсли;

	КраткоеПредставлениеОшибки   = Отступ + Строка(КраткоеПредставлениеОшибки);
	ПодробноеПредставлениеОшибки = Отступ + Строка(ПодробноеПредставлениеОшибки);
	
	Если СтруктураЗаписи <> Неопределено Тогда
		
		Для Каждого Поле Из СтруктураЗаписи Цикл
			
			Значение = Поле.Значение;
			Если Значение = Неопределено Тогда
				Продолжить;
			КонецЕсли; 
			
			КраткоеПредставлениеОшибки  = КраткоеПредставлениеОшибки + Символы.ПС + Отступ + Символы.Таб
				+ СтроковыеФункцииКлиентСервер.ДополнитьСтроку(Поле.Ключ, Выравнивание, " ", "Справа") + " =  " + Строка(Значение);
			ПодробноеПредставлениеОшибки  = ПодробноеПредставлениеОшибки + Символы.ПС + Отступ + Символы.Таб
				+ СтроковыеФункцииКлиентСервер.ДополнитьСтроку(Поле.Ключ, Выравнивание, " ", "Справа") + " =  " + Строка(Значение);
			
		КонецЦикла;
		
	КонецЕсли;
	
	КомпонентыОбмена.СтрокаСообщенияОбОшибке = КраткоеПредставлениеОшибки;
	
	Если ВзвестиФлагОшибок Тогда
		
		КомпонентыОбмена.ФлагОшибки = Истина;
		Если КомпонентыОбмена.СостояниеОбменаДанными.РезультатВыполненияОбмена = Неопределено Тогда
			КомпонентыОбмена.СостояниеОбменаДанными.РезультатВыполненияОбмена = Перечисления.РезультатыВыполненияОбмена.Ошибка;
		КонецЕсли;
		
	КонецЕсли;
	
	Если ФайлПротоколаДанных <> Неопределено Тогда
		
		Если ВзвестиФлагОшибок Тогда
			
			ФайлПротоколаДанных.ЗаписатьСтроку(Символы.ПС + "Ошибка.");
			
		КонецЕсли;
		
		Если ВзвестиФлагОшибок
			Или БезусловнаяЗаписьВПротоколОбмена
			Или ВыводВПротоколИнформационныхСообщений Тогда
			
			ФайлПротоколаДанных.ЗаписатьСтроку(Символы.ПС + КомпонентыОбмена.СтрокаСообщенияОбОшибке);
		
		КонецЕсли;
		
	КонецЕсли;
	
	УровеньЖР = Неопределено;
	Если Не ТипЗнч(КодОшибки) = Тип("Структура")
		Или Не КодОшибки.Свойство("Уровень", УровеньЖР)
		Или УровеньЖР = Неопределено Тогда
		
		Если РезультатВыполненияОбменаОшибка(КомпонентыОбмена.СостояниеОбменаДанными.РезультатВыполненияОбмена) Тогда
			УровеньЖР = УровеньЖурналаРегистрации.Ошибка;
		ИначеЕсли РезультатВыполненияОбменаПредупреждение(КомпонентыОбмена.СостояниеОбменаДанными.РезультатВыполненияОбмена) Тогда
			УровеньЖР = УровеньЖурналаРегистрации.Предупреждение;
		Иначе
			УровеньЖР = УровеньЖурналаРегистрации.Информация;
		КонецЕсли;
		
	КонецЕсли;
	
	ПозицияСсылки = СтрНайти(ПодробноеПредставлениеОшибки, "e1cib/data/");
	Если ПозицияСсылки > 0 Тогда
		ПозицияУИД = СтрНайти(ПодробноеПредставлениеОшибки, "?ref=");
		СтрокаСсылки = Сред(ПодробноеПредставлениеОшибки, ПозицияСсылки, ПозицияУИД - ПозицияСсылки + 37);
		ПерваяТочка = СтрНайти(СтрокаСсылки, "e1cib/data/");
		ВтораяТочка = СтрНайти(СтрокаСсылки, "?ref=");
		ПредставлениеТипа = Сред(СтрокаСсылки, ПерваяТочка + 11, ВтораяТочка - ПерваяТочка - 11);
		ШаблонЗначения = ЗначениеВСтрокуВнутр(ПредопределенноеЗначение(ПредставлениеТипа + ".ПустаяСсылка"));
		ЗначениеСсылки = СтрЗаменить(ШаблонЗначения, "00000000000000000000000000000000", Сред(СтрокаСсылки, ВтораяТочка + 5));
		СсылкаНаОбъект = ЗначениеИзСтрокиВнутр(ЗначениеСсылки);
	Иначе
		СсылкаНаОбъект = Неопределено;
	КонецЕсли;
	
	// Фиксируем событие в журнале регистрации.
	ЗаписьЖурналаРегистрацииОбменДанными(
		ПодробноеПредставлениеОшибки,
		КомпонентыОбмена,
		УровеньЖР,
		СсылкаНаОбъект);
	
	Возврат КомпонентыОбмена.СтрокаСообщенияОбОшибке;
	
КонецФункции

#КонецОбласти

#Область ПоискПравилОбмена
// Выполняет поиск правила конвертации объекта по имени.
//
// Параметры:
//  КомпонентыОбмена - Структура - содержит все правила и параметры обмена.
//  Имя              - Строка - имя правила.
//
// Возвращаемое значение:
//  СтрокаТаблицыЗначений - Строка таблицы правил обмена, в которой содержится искомое правило.
//
Функция ПКОПоИмени(КомпонентыОбмена, Имя) Экспорт
	
	ПравилоКонвертации = КомпонентыОбмена.ПравилаКонвертацииОбъектов.Найти(Имя, "ИмяПКО");
	
	Если ПравилоКонвертации = Неопределено Тогда
		
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Не найдено ПКО с именем %1'"), Имя);
			
	Иначе
		Возврат ПравилоКонвертации;
	КонецЕсли;

КонецФункции

#КонецОбласти

#Область ОтправкаДанных
// Выполняет выгрузку данных в соответствии с правилами и параметрами обмена.
//
// Параметры:
//  КомпонентыОбмена - см. ИнициализироватьКомпонентыОбмена
//
Процедура ПроизвестиВыгрузкуДанных(КомпонентыОбмена) Экспорт
	
	УзелДляОбмена = КомпонентыОбмена.УзелКорреспондента;
	
	Если КомпонентыОбмена.ЭтоОбменЧерезПланОбмена Тогда
		ОчиститьСписокОшибокПриВыгрузкеДанных(УзелДляОбмена);
	КонецЕсли;
	
	Попытка
		КомпонентыОбмена.МенеджерОбмена.ПередКонвертацией(КомпонентыОбмена);
	Исключение
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Направление: %1.
			|Обработчик: ПередКонвертацией.
			|
			|Ошибка выполнения обработчика.
			|%2.'"),
			КомпонентыОбмена.НаправлениеОбмена,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	НомерОтправленного = 0;
	
	Если КомпонентыОбмена.ЭтоОбменЧерезПланОбмена Тогда
	
		НомерОтправленного = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(УзелДляОбмена, "НомерОтправленного") + 1;
		
		ВыполнитьВыгрузкуЗарегистрированныхДанных(КомпонентыОбмена, НомерОтправленного);
		
	Иначе
		
		Для Каждого Строка Из КомпонентыОбмена.СценарийВыгрузки Цикл
			ПравилоОбработки = ПОДПоИмени(КомпонентыОбмена, Строка.ИмяПОД);
			
			ВыборкаДанных = ВыборкаДанных(КомпонентыОбмена, ПравилоОбработки);
			Для Каждого ОбъектВыборки Из ВыборкаДанных Цикл
				ВыгрузкаОбъектаВыборки(КомпонентыОбмена, ОбъектВыборки, ПравилоОбработки);
			КонецЦикла;
		КонецЦикла;
		
	КонецЕсли;
	
	Если КомпонентыОбмена.ФлагОшибки Тогда
		ВызватьИсключение НСтр("ru = 'При формировании сообщения обмена данными произошли ошибки. Подробнее см. в журнале регистрации.'");
	КонецЕсли;
	
	Попытка
		КомпонентыОбмена.МенеджерОбмена.ПослеКонвертации(КомпонентыОбмена);
	Исключение
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Событие: %1.
				|Обработчик: ПослеКонвертации.
				|
				|Ошибка выполнения обработчика.
				|%2.'"),
			КомпонентыОбмена.НаправлениеОбмена,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	Если КомпонентыОбмена.ЭтоОбменЧерезПланОбмена Тогда
		
		// Сбрасываем номер отправленного сообщения у не выгруженных объектов.
		Если КомпонентыОбмена.ПропускатьОбъектыСОшибкамиПроверкиПоСхеме Тогда
			Для Каждого ОбъектСсылка Из КомпонентыОбмена.НеВыгруженныеОбъекты Цикл
				ПланыОбмена.ЗарегистрироватьИзменения(УзелДляОбмена, ОбъектСсылка);
			КонецЦикла;
		КонецЕсли;
		
		// Назначаем номер отправленного сообщения для объектов, выгруженных по ссылке.
		Если КомпонентыОбмена.ВыгруженныеПоСсылкеОбъекты.Количество() > 0 Тогда
			// Выполняем регистрацию объектов на текущем узле, которые были выгружены по ссылке.
			Для Каждого Элемент Из КомпонентыОбмена.ВыгруженныеПоСсылкеОбъекты Цикл
				ПланыОбмена.ЗарегистрироватьИзменения(УзелДляОбмена, Элемент);
			КонецЦикла;
			
			ОбменДаннымиСервер.ВыбратьИзменения(УзелДляОбмена, НомерОтправленного, КомпонентыОбмена.ВыгруженныеПоСсылкеОбъекты);
		КонецЕсли;
		
		НачатьТранзакцию();
		Попытка
		    Блокировка = Новый БлокировкаДанных;
		    ЭлементБлокировки = Блокировка.Добавить(ОбщегоНазначения.ИмяТаблицыПоСсылке(УзелДляОбмена));
		    ЭлементБлокировки.УстановитьЗначение("Ссылка", УзелДляОбмена);
		    Блокировка.Заблокировать();
		    
			ЗаблокироватьДанныеДляРедактирования(УзелДляОбмена);
			Получатель = УзелДляОбмена.ПолучитьОбъект();
			
			Получатель.НомерОтправленного = НомерОтправленного;
			Получатель.ОбменДанными.Загрузка = Истина;

		    Получатель.Записать();

		    ЗафиксироватьТранзакцию();
		Исключение
		    ОтменитьТранзакцию();
		    ВызватьИсключение;
		КонецПопытки;
		
	КонецЕсли;
	
	КомпонентыОбмена.ФайлОбмена.ЗаписатьКонецЭлемента(); // Body
	КомпонентыОбмена.ФайлОбмена.ЗаписатьКонецЭлемента(); // Message
	
	// Фиксация успешного завершения обмена.
	Если КомпонентыОбмена.СостояниеОбменаДанными.РезультатВыполненияОбмена = Неопределено Тогда
		КомпонентыОбмена.СостояниеОбменаДанными.РезультатВыполненияОбмена = Перечисления.РезультатыВыполненияОбмена.Выполнено;
	КонецЕсли;
	
	Если КомпонентыОбмена.СостояниеОбменаДанными.РезультатВыполненияОбмена = Перечисления.РезультатыВыполненияОбмена.Выполнено
		И (КомпонентыОбмена.ПропускатьОбъектыСОшибкамиПроверкиПоСхеме
			И КомпонентыОбмена.НеВыгруженныеОбъекты.Количество() > 0) Тогда
		КомпонентыОбмена.СостояниеОбменаДанными.РезультатВыполненияОбмена = Перечисления.РезультатыВыполненияОбмена.ВыполненоСПредупреждениями;
	КонецЕсли;
	
КонецПроцедуры

// Выполняет выгрузку объекта информационной базы.
//
// Параметры:
//   КомпонентыОбмена - см. ОбменДаннымиXDTOСервер.ИнициализироватьКомпонентыОбмена
//   Объект           - ЛюбаяСсылка - ссылка на объект информационной базы.
//   ПравилоОбработки - СтрокаТаблицыЗначений - строка таблицы правил обработки данных, 
//                      соответствующая правилу обработки типа выгружаемого объекта.
//                      Если параметр не задан, правило будет найдено по объекту метаданных выгружаемого объекта.
//
Процедура ВыгрузкаОбъектаВыборки(КомпонентыОбмена, Объект, ПравилоОбработки = Неопределено) Экспорт
	
	ОбъектСсылочногоТипа = (ТипЗнч(Объект) <> Тип("Структура"))
		И ОбщегоНазначения.ЭтоОбъектСсылочногоТипа(Объект.Метаданные());
		
	Если (ТипЗнч(Объект) <> Тип("Структура"))
		И ПравилоОбработки = Неопределено Тогда
		ПолучитьПравилоОбработкиДляОбъекта(КомпонентыОбмена, Объект, ПравилоОбработки);
	КонецЕсли;
	
	КомпонентыОбмена.ВыгруженныеОбъекты.Добавить(?(ОбъектСсылочногоТипа, Объект.Ссылка, Объект));
	
	// Отработка ПОД
	ИспользованиеПКО = Новый Структура;
	Для Каждого ТекущееПКО Из ПравилоОбработки.ИспользуемыеПКО Цикл
		ИспользованиеПКО.Вставить(ТекущееПКО, Истина);
	КонецЦикла;
	
	ПрерватьОбработку = Ложь;
	ВзвестиФлагОшибки = Ложь;
	
	ПриОбработкеПОД(
		КомпонентыОбмена,
		ПравилоОбработки,
		Объект,
		ИспользованиеПКО,
		ПрерватьОбработку);
	
	Если ПрерватьОбработку Тогда
		ВзвестиФлагОшибки = Истина;
	КонецЕсли;
	
	Если Не ПрерватьОбработку Тогда
		// Отработка ПКО
		НесколькоПКО = (ИспользованиеПКО.Количество() > 1);
		ЕстьКолонкаОчисткаДанных = КомпонентыОбмена.ПравилаОбработкиДанных.Колонки.Найти("ОчисткаДанных") <> Неопределено;
		
		Для Каждого ТекущееПКО Из ИспользованиеПКО Цикл
			ПравилоКонвертации = КомпонентыОбмена.ПравилаКонвертацииОбъектов.Найти(ТекущееПКО.Ключ, "ИмяПКО");
			Если ПравилоКонвертации = Неопределено Тогда
				// Допустимо указание ПКО, не предназначенного для текущей версии формата данных.
				Продолжить;
			КонецЕсли;
			
			Если Не ОбъектФорматаПроходитПоФильтруXDTO(КомпонентыОбмена, ПравилоКонвертации.ОбъектФормата) Тогда
				Продолжить;
			КонецЕсли;
			
			Если Не ТекущееПКО.Значение Тогда
				// Если правил конвертации несколько, и некоторые из них не используются -
				// необходимо выгрузить удаление объекта на случай если  ранее он был выгружен по этим правилам.
				Если НесколькоПКО
					И ОбъектСсылочногоТипа 
					И (Не ЕстьКолонкаОчисткаДанных
						Или ПравилоОбработки.ОчисткаДанных) Тогда
					ВыгрузитьУдаление(КомпонентыОбмена, Объект.Ссылка, ПравилоКонвертации);
				КонецЕсли;
				Продолжить;
			КонецЕсли;
			
			ПропуститьОбработку = Ложь;
			Попытка
				// 2. Конвертируем Данные в Структуру по правилам конвертации.
				ДанныеXDTO = ДанныеXDTOИзДанныхИБ(КомпонентыОбмена, Объект, ПравилоКонвертации, Неопределено);
				
				Если ДанныеXDTO = Неопределено Тогда
					Продолжить;
				КонецЕсли;
				
				// 3. Конвертируем Структуру в ОбъектXDTO.
				СсылкиИзОбъекта = Новый Массив;
				ОбъектXDTO = ОбъектXDTOИзДанныхXDTO(КомпонентыОбмена, ДанныеXDTO, ПравилоКонвертации.ТипXDTO, , СсылкиИзОбъекта);
			Исключение
				ПропуститьОбработку = Истина;
				ВзвестиФлагОшибки   = Истина;
				
				ОписаниеОшибки = ОписаниеОшибкиПКО(
					КомпонентыОбмена.НаправлениеОбмена,
					ПравилоОбработки.Имя,
					ПравилоКонвертации.ИмяПКО,
					ПредставлениеОбъектаДляПротокола(Объект, ПравилоКонвертации.ОбъектДанных),
					ИнформацияОбОшибке());
					
				ЗафиксироватьПроблемуПриОбработкеОбъекта(КомпонентыОбмена,
					Объект,
					Перечисления.ТипыПроблемОбменаДанными.ОшибкаВыполненияКодаОбработчиковПриОтправкеДанных,
					ОписаниеОшибки.ПодробноеПредставление,
					ОписаниеОшибки.КраткоеПредставление);
			КонецПопытки;
				
			Если Не ПропуститьОбработку Тогда
				ОшибкаПроверкиПоСхеме = Ложь;
				ОписаниеОшибкиПроверкиПоСхеме = Неопределено;
				
				Контекст = Новый Структура;
				Контекст.Вставить("НаправлениеОбмена",    КомпонентыОбмена.НаправлениеОбмена);
				Контекст.Вставить("ИмяПОД",               ПравилоОбработки.Имя);
				Контекст.Вставить("ИмяПКО",               ПравилоКонвертации.ИмяПКО);
				Контекст.Вставить("ПредставлениеОбъекта", ПредставлениеОбъектаДляПротокола(Объект, ПравилоКонвертации.ОбъектДанных));
				
				ПроверитьОбъектXDTOПоСхеме(ОбъектXDTO, ПравилоКонвертации.ТипXDTO, Контекст, ОшибкаПроверкиПоСхеме, ОписаниеОшибкиПроверкиПоСхеме);
				
				Если ОшибкаПроверкиПоСхеме Тогда
					ПропуститьОбработку = Истина;
					
					ЗафиксироватьПроблемуПриОбработкеОбъекта(КомпонентыОбмена,
						Объект,
						Перечисления.ТипыПроблемОбменаДанными.ОшибкаПроверкиСконвертированногоОбъекта,
						ОписаниеОшибкиПроверкиПоСхеме.ПодробноеПредставление,
						ОписаниеОшибкиПроверкиПоСхеме.КраткоеПредставление);
				КонецЕсли;
			КонецЕсли;
		
			Если ПропуститьОбработку Тогда
				ПрерватьОбработку = Истина;
				Продолжить;
			КонецЕсли;
			
			ВыгрузитьОбъектыПоСсылке(КомпонентыОбмена, СсылкиИзОбъекта);
			
			// 4. Записываем ОбъектXDTO в XML-файл.
			ФабрикаXDTO.ЗаписатьXML(КомпонентыОбмена.ФайлОбмена, ОбъектXDTO);
		КонецЦикла;
	КонецЕсли;
	
	Если ПрерватьОбработку Тогда
		КомпонентыОбмена.НеВыгруженныеОбъекты.Добавить(?(ОбъектСсылочногоТипа, Объект.Ссылка, Объект));
	КонецЕсли;
	
	Если ВзвестиФлагОшибки Тогда
		КомпонентыОбмена.ФлагОшибки = Истина;
		КомпонентыОбмена.СостояниеОбменаДанными.РезультатВыполненияОбмена = Перечисления.РезультатыВыполненияОбмена.Ошибка;
	КонецЕсли;
	
КонецПроцедуры

// Выполняет преобразование структуры с данными в объект XDTO указанного типа в соответствии с правилами.
//
// Параметры:
//  КомпонентыОбмена - Структура - содержит все правила и параметры обмена.
//  Источник         - Структура - источник данных, которые необходимо преобразовать в объект XDTO.
//  ТипXDTO          - Строка - тип объекта или тип значения XDTO, к которому надо преобразовать данные.
//  Приемник         - ОбъектXDTO - объект, в который будет помещен результат.
//  СсылкиИзОбъекта  - Массив - содержит общий список выгруженных по ссылкам объектов.
//  ПроведеноЗаполнениеСвойств - Булево - параметр для определения заполненности общих составных свойств.
//
// Возвращаемое значение:
//  ОбъектXDTO - результат преобразования. 
// 
Функция ОбъектXDTOИзДанныхXDTO(
		КомпонентыОбмена,
		Знач Источник,
		Знач ТипXDTO,
		Приемник = Неопределено,
		СсылкиИзОбъекта = Неопределено,
		ПроведеноЗаполнениеСвойств = Ложь) Экспорт
	
	Если СсылкиИзОбъекта = Неопределено Тогда
		СсылкиИзОбъекта = Новый Массив;
	КонецЕсли;
	
	Если Приемник = Неопределено Тогда
		Приемник = ФабрикаXDTO.Создать(ТипXDTO);
	КонецЕсли;
	
	Для Каждого Свойство Из ТипXDTO.Свойства Цикл
		
		ЗначениеСвойства = Неопределено;
		СвойствоНайдено = Ложь;
		
		Если ТипЗнч(Источник) = Тип("Структура") Тогда
			СвойствоНайдено = Источник.Свойство(Свойство.Имя, ЗначениеСвойства);
		ИначеЕсли ТипЗнч(Источник) = Тип("СтрокаТаблицыЗначений")
			И Источник.Владелец().Колонки.Найти(Свойство.Имя) <> Неопределено Тогда
			СвойствоНайдено = Истина;
			ЗначениеСвойства = Источник[Свойство.Имя];
		КонецЕсли;
		
		ТипСвойства = Неопределено;
		Если ТипЗнч(Свойство.Тип) = Тип("ТипЗначенияXDTO") Тогда
			ТипСвойства = "ОбычноеСвойство";
		ИначеЕсли ТипЗнч(Свойство.Тип) = Тип("ТипОбъектаXDTO") Тогда
			
			Если Свойство.Имя = "AdditionalInfo" Тогда
				ТипСвойства = "AdditionalInfo";
			ИначеЕсли ЭтоТаблицаОбъекта(Свойство) Тогда
				ТипСвойства = "Таблица";
			ИначеЕсли Свойство.Имя = "КлючевыеСвойства"
				Или СтрНайти(Свойство.Тип.Имя, "КлючевыеСвойства") > 0 Тогда
				ТипСвойства = "КлючевыеСвойства";
			Иначе
				Если СвойствоНайдено Тогда
					Если ТипЗнч(ЗначениеСвойства) = Тип("Структура") 
						И (ЗначениеСвойства.Свойство("Значение")
							Или СтрНайти(СокрЛП(Свойство.Тип), "ОбщиеСвойства") > 0) Тогда
						ТипСвойства = "ОбщееСоставноеСвойство";
					Иначе
						ТипСвойства = "СвойствоСоставногоТипа";
					КонецЕсли;
				Иначе
					ТипСвойства = "ОбщееСоставноеСвойство";
				КонецЕсли;
			КонецЕсли;
			
		Иначе
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неизвестный тип свойства <%1>. Тип объекта: %2'"),
				Свойство.Имя,
				Строка(ТипXDTO));
		КонецЕсли;
		
		Попытка
			Если ТипСвойства = "ОбщееСоставноеСвойство" Тогда
				
				ПроведеноЗаполнениеВложенныхСвойств = Ложь;
				Если ТипЗнч(Источник) = Тип("Структура") И СвойствоНайдено Тогда
					ЗначениеXDTO = ОбъектXDTOИзДанныхXDTO(КомпонентыОбмена, ЗначениеСвойства, 
						Свойство.Тип,, СсылкиИзОбъекта, ПроведеноЗаполнениеВложенныхСвойств);
				Иначе
					ЗначениеXDTO = ОбъектXDTOИзДанныхXDTO(КомпонентыОбмена, Источник, 
						Свойство.Тип,, СсылкиИзОбъекта, ПроведеноЗаполнениеВложенныхСвойств);
				КонецЕсли;
				
				Если Не ПроведеноЗаполнениеВложенныхСвойств Тогда
					Продолжить;
				КонецЕсли;
				
			Иначе
				
				Если Не СвойствоНайдено Тогда
					Продолжить;
				КонецЕсли;
				
				// Проверка на заполненность.
				Если ЗначениеСвойства = Null
					Или Не ЗначениеЗаполнено(ЗначениеСвойства) Тогда
					
					Если Свойство.ВозможноПустое Тогда
						Приемник[Свойство.Имя] = Неопределено;
					КонецЕсли;
					
					Продолжить;
					
				КонецЕсли;
				
				ЗначениеXDTO = Неопределено;
				Если ТипСвойства = "КлючевыеСвойства" Тогда
					ЗначениеXDTO = ОбъектXDTOИзДанныхXDTO(КомпонентыОбмена, ЗначениеСвойства, Свойство.Тип,,СсылкиИзОбъекта);
				ИначеЕсли ТипСвойства = "ОбычноеСвойство" Тогда
					
					СвойствоТипЗначения = Свойство.Тип; // ТипЗначенияXDTO
					
					Если ЭтоСсылкаXDTO(СвойствоТипЗначения) Тогда // Конвертация ссылки
						
						ЗначениеXDTO = КонвертироватьСсылкуВXDTO(КомпонентыОбмена, ЗначениеСвойства, СвойствоТипЗначения);
						
						Если СсылкиИзОбъекта.Найти(ЗначениеСвойства) = Неопределено Тогда
							СсылкиИзОбъекта.Добавить(ЗначениеСвойства);
						КонецЕсли;
						
					ИначеЕсли СвойствоТипЗначения.Фасеты <> Неопределено
						И СвойствоТипЗначения.Фасеты.Перечисления <> Неопределено
						И СвойствоТипЗначения.Фасеты.Перечисления.Количество() > 0 Тогда // Конвертация перечисления
						ЗначениеXDTO = КонвертироватьПеречислениеВXDTO(КомпонентыОбмена, ЗначениеСвойства, СвойствоТипЗначения);
					Иначе // Конвертация обычного значения.
						ЗначениеXDTO = ФабрикаXDTO.Создать(СвойствоТипЗначения, ЗначениеСвойства);
					КонецЕсли;
					
				ИначеЕсли ТипСвойства = "AdditionalInfo" Тогда
					ЗначениеXDTO = СериализаторXDTO.ЗаписатьXDTO(ЗначениеСвойства);
					
				ИначеЕсли ТипСвойства = "Таблица" Тогда
					
					ЗначениеXDTO = ФабрикаXDTO.Создать(Свойство.Тип);
					
					ТипТаблицы = Свойство.Тип.Свойства[0].Тип;
					
					ИмяСвойстваСтроки = Свойство.Тип.Свойства[0].Имя;
					
					СписокXDTO = ЗначениеXDTO[ИмяСвойстваСтроки]; // СписокXDTO
					
					Для Каждого ИсточникСтрока Из ЗначениеСвойства Цикл
						
						ПриемникСтрока = ОбъектXDTOИзДанныхXDTO(КомпонентыОбмена, ИсточникСтрока, ТипТаблицы,,СсылкиИзОбъекта);
						
						СписокXDTO.Добавить(ПриемникСтрока);
						
					КонецЦикла;
					
				ИначеЕсли ТипСвойства = "СвойствоСоставногоТипа" Тогда
					
					Для Каждого СвойствоСоставногоТипа Из Свойство.Тип.Свойства Цикл
						
						СоставноеЗначениеXDTO = Неопределено;
						Если ТипЗнч(ЗначениеСвойства) = Тип("Структура")
							И ЗначениеСвойства.ТипСоставногоСвойства = СвойствоСоставногоТипа.Тип Тогда
							
							// Свойство составного типа, содержащие элементы только типа КлючевыеСвойства.
							СоставноеЗначениеXDTO = ОбъектXDTOИзДанныхXDTO(КомпонентыОбмена, ЗначениеСвойства, СвойствоСоставногоТипа.Тип,,СсылкиИзОбъекта);
						// Свойство составного типа простое, и значение простое.
						ИначеЕсли (ТипЗнч(ЗначениеСвойства) = Тип("Строка")
							И СтрНайти(СвойствоСоставногоТипа.Тип.Имя,"string")>0)
							ИЛИ (ТипЗнч(ЗначениеСвойства) = Тип("Число")
							И СтрНайти(СвойствоСоставногоТипа.Тип.Имя,"decimal")>0)
							ИЛИ (ТипЗнч(ЗначениеСвойства) = Тип("Булево")
							И СтрНайти(СвойствоСоставногоТипа.Тип.Имя,"boolean")>0)
							ИЛИ (ТипЗнч(ЗначениеСвойства) = Тип("Дата")
							И СтрНайти(СвойствоСоставногоТипа.Тип.Имя,"date")>0) Тогда
							СоставноеЗначениеXDTO = ЗначениеСвойства;

						ИначеЕсли ТипЗнч(ЗначениеСвойства) = Тип("Строка")
							И ТипЗнч(СвойствоСоставногоТипа.Тип) = Тип("ТипЗначенияXDTO")
							И СвойствоСоставногоТипа.Тип.Фасеты <> Неопределено Тогда
							Если СвойствоСоставногоТипа.Тип.Фасеты.Количество() = 0 Тогда
								СоставноеЗначениеXDTO = ЗначениеСвойства;
							Иначе
								
								Для Каждого Фасет Из СвойствоСоставногоТипа.Тип.Фасеты Цикл
									Если Фасет.Значение = ЗначениеСвойства Тогда
										СоставноеЗначениеXDTO = ЗначениеСвойства;
										Прервать;
									КонецЕсли;
								КонецЦикла;
								
							КонецЕсли;
						КонецЕсли;
						
						Если СоставноеЗначениеXDTO <> Неопределено Тогда
							Прервать;
						КонецЕсли;
						
					КонецЦикла;
					
					// Если передается значение с типом, которое не поддерживается в формате - не передаем.
					Если СоставноеЗначениеXDTO = Неопределено Тогда
						Продолжить;
					КонецЕсли;
					
					ЗначениеXDTO = ФабрикаXDTO.Создать(Свойство.Тип);
					ЗначениеXDTO.Установить(СвойствоСоставногоТипа, СоставноеЗначениеXDTO);
				КонецЕсли;
				
			КонецЕсли;
		Исключение
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка формирования объекта XDTO: Тип свойства <%1>. Имя свойства: <%2>.
				|
				|%3'"),
				ТипСвойства,
				Свойство.Имя,
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
		
		Приемник[Свойство.Имя] = ЗначениеXDTO;
		ПроведеноЗаполнениеСвойств = Истина;
		
	КонецЦикла;
	
	Возврат Приемник;
КонецФункции

// Выполняет преобразование данных информационной базы в структуру с данными в соответствии с правилами.
//
// Параметры:
//  КомпонентыОбмена    - см. ИнициализироватьКомпонентыОбмена
//  Источник            - ЛюбаяСсылка - Ссылка на выгружаемый объект информационной базы.
//  ПравилоКонвертации  - СтрокаТаблицыЗначений - Строка таблицы правил конвертации объектов, 
//                        в соответствии с которой выполняется преобразование.
//  СтекВыгрузки        - массив - ссылки на выгружаемые объекты с учетом вложенности.
//
// Возвращаемое значение:
//  Структура - результат преобразования.
//
Функция ДанныеXDTOИзДанныхИБ(КомпонентыОбмена, Источник, Знач ПравилоКонвертации, СтекВыгрузки = Неопределено) Экспорт
	
	Приемник = Новый Структура;
	
	Если СтекВыгрузки = Неопределено Тогда
		СтекВыгрузки = Новый Массив;
	КонецЕсли;
	
	Если ПравилоКонвертации.ЭтоСсылочныйТип Тогда
		
		ПозицияВСтеке = СтекВыгрузки.Найти(Источник.Ссылка);
		
		// Проверяем, выгружался ли объект по ссылке, чтобы не допустить зацикливания.
		Если ПозицияВСтеке <> Неопределено Тогда
			
			Если ПозицияВСтеке > 0 Тогда
				Возврат Неопределено;
			ИначеЕсли СтекВыгрузки.Количество() > 1 Тогда
				// Необходимо искать перебором.
				ПерваяИтерация = Истина;
				Для Каждого ЭлементСтека Из СтекВыгрузки Цикл
					Если ПерваяИтерация Тогда
						ПерваяИтерация = Ложь;
						Продолжить;
					КонецЕсли;
					Если ЭлементСтека = Источник.Ссылка Тогда
						Возврат Неопределено;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		
		СтекВыгрузки.Добавить(Источник.Ссылка);
		
		Если Не ОбщегоНазначения.СсылкаСуществует(Источник.Ссылка) Тогда
			Возврат Неопределено;
		КонецЕсли;
		
	Иначе
		СтекВыгрузки.Добавить(Источник);
	КонецЕсли;
	
	Если ПравилоКонвертации.ЭтоКонстанта Тогда
		
		Если ПравилоКонвертации.ТипXDTO.Свойства.Количество() = 1 Тогда
			
			Приемник.Вставить(ПравилоКонвертации.ТипXDTO.Свойства[0].Имя, Источник.Значение);
			
		Иначе
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка XML-схемы. Для приемника должно быть задано одно свойство.
				|Тип источника: %1
				|Тип приемника: %2'"),
				Строка(ТипЗнч(Источник)),
				ПравилоКонвертации.ТипXDTO);
		КонецЕсли;
		
	Иначе
		
		// Выполнение ПКС, 1-й этап
		Для Каждого ПКС Из ПравилоКонвертации.Свойства Цикл
			
			Если ПравилоКонвертации.ОбъектДанных <> Неопределено
				И ПКС.СвойствоКонфигурации = ""
				И ПКС.ИспользуетсяАлгоритмКонвертации Тогда
				Продолжить;
			КонецЕсли;
			
			Если СтекВыгрузки.Количество() > 1 И Не ПКС.ОбработкаКлючевогоСвойства Тогда
				Продолжить;
			КонецЕсли;
			
			ВыгрузитьСвойство(
				КомпонентыОбмена,
				Источник,
				Приемник,
				ПКС,
				СтекВыгрузки,
				1);
		КонецЦикла;
		
		// Выполнение ПКС для ТЧ (прямая конвертация).
		Если СтекВыгрузки.Количество() = 1 Тогда
			Для Каждого ТЧИСвойства Из ПравилоКонвертации.СвойстваТабличныхЧастей Цикл
				Если НЕ (ЗначениеЗаполнено(ТЧИСвойства.ТЧКонфигурации) И ЗначениеЗаполнено(ТЧИСвойства.ТЧФормата)) Тогда
					Продолжить;
				КонецЕсли;
				// ТЧ пустая.
				Если Источник[ТЧИСвойства.ТЧКонфигурации].Количество() = 0 Тогда
					Продолжить;
				КонецЕсли;
				НоваяТЧПриемника = СоздатьТЧПриемникаПоПКС(ТЧИСвойства.Свойства);
				Для Каждого СтрокаТЧКонфигурации Из Источник[ТЧИСвойства.ТЧКонфигурации] Цикл
					СтрокаТЧПриемник = НоваяТЧПриемника.Добавить();
					Для Каждого ПКС Из ТЧИСвойства.Свойства Цикл
						Если ПКС.ИспользуетсяАлгоритмКонвертации Тогда
							Продолжить;
						КонецЕсли;
						ВыгрузитьСвойство(
							КомпонентыОбмена,
							СтрокаТЧКонфигурации,
							СтрокаТЧПриемник,
							ПКС,
							СтекВыгрузки,
							1);
					КонецЦикла;
				КонецЦикла;
				Приемник.Вставить(ТЧИСвойства.ТЧФормата, НоваяТЧПриемника);
			КонецЦикла;
		КонецЕсли;
		
		// {Обработчик: ПриОтправкеДанных} Начало
		Если ПравилоКонвертации.ЕстьОбработчикПриОтправкеДанных Тогда
			
			Если Не Приемник.Свойство("КлючевыеСвойства") Тогда
				Приемник.Вставить("КлючевыеСвойства", Новый Структура);
			КонецЕсли;
			
			ПриОтправкеДанных(Источник, Приемник, ПравилоКонвертации.ПриОтправкеДанных, КомпонентыОбмена, СтекВыгрузки);
			
			Если Приемник = Неопределено Тогда
				Возврат Неопределено;
			КонецЕсли;
			
			Если СтекВыгрузки.Количество() > 1 Тогда
				Для Каждого КлючевоеСвойство Из Приемник.КлючевыеСвойства Цикл
					Приемник.Вставить(КлючевоеСвойство.Ключ, КлючевоеСвойство.Значение);
				КонецЦикла;
				Приемник.Удалить("КлючевыеСвойства");
			КонецЕсли;
			
			// Выполнение ПКС, 2-й этап
			Для Каждого ПКС Из ПравилоКонвертации.Свойства Цикл
				Если ПКС.СвойствоФормата = "" 
					Или (СтекВыгрузки.Количество() > 1 И Не ПКС.ОбработкаКлючевогоСвойства) Тогда
					Продолжить;
				КонецЕсли;
				
				// Выполняем конвертацию, если в свойство помещена инструкция.
				ЗначениеСвойства = Неопределено;
				Если СтекВыгрузки.Количество() = 1 И ПКС.ОбработкаКлючевогоСвойства Тогда
					Приемник.КлючевыеСвойства.Свойство(ПКС.СвойствоФормата, ЗначениеСвойства);
				Иначе
					СвойствоФормата_Имя = СокрЛП(ПКС.СвойствоФормата);
					ВложенныеСвойства = СтрРазделить(СвойствоФормата_Имя,".",Ложь);
					// Указано полное имя свойства, входящего в группу общих свойств.
					Если ВложенныеСвойства.Количество() > 1 Тогда
						ПолучитьЗначениеВложенныхСвойств(Приемник, ВложенныеСвойства, ЗначениеСвойства);
					Иначе
						Приемник.Свойство(СвойствоФормата_Имя, ЗначениеСвойства);
					КонецЕсли;
				КонецЕсли;
				Если ЗначениеСвойства = Неопределено Тогда
					Продолжить;
				КонецЕсли;
				
				Если ПКС.ИспользуетсяАлгоритмКонвертации Тогда
					
					Если ТипЗнч(ЗначениеСвойства) = Тип("Структура")
						И ЗначениеСвойства.Свойство("Значение")
						И ЗначениеСвойства.Свойство("ИмяПКО")
						Или ПКС.ПравилоКонвертацииСвойства <> ""
						И ТипЗнч(ЗначениеСвойства) <> Тип("Структура") Тогда
						
						ВыгрузитьСвойство(
							КомпонентыОбмена,
							Источник,
							Приемник,
							ПКС,
							СтекВыгрузки,
							2);
							
					КонецЕсли;
						
				КонецЕсли;
			КонецЦикла;
			
			// Выполнение ПКС для ТЧ
			Если СтекВыгрузки.Количество() = 1 Тогда
				
				// Формируем структуру новых табличных частей по ПКС.
				СвойстваТЧПриемника = Новый Структура;
				Для Каждого ТЧИСвойства Из ПравилоКонвертации.СвойстваТабличныхЧастей Цикл
					
					ИмяТЧПриемника = ТЧИСвойства.ТЧФормата;
					
					Если ПустаяСтрока(ИмяТЧПриемника) Тогда
						Продолжить;
					КонецЕсли;
					
					Если Не СвойстваТЧПриемника.Свойство(ИмяТЧПриемника) Тогда
						ТаблицаПКС = Новый ТаблицаЗначений;
						ТаблицаПКС.Колонки.Добавить("СвойствоФормата", Новый ОписаниеТипов("Строка"));
						
						СвойстваТЧПриемника.Вставить(ИмяТЧПриемника, ТаблицаПКС);
					КонецЕсли;
					
					ТаблицаПКС = СвойстваТЧПриемника[ИмяТЧПриемника];
					Для Каждого ПКС Из ТЧИСвойства.Свойства Цикл
						СтрокаСвойство = ТаблицаПКС.Добавить();
						СтрокаСвойство.СвойствоФормата = ПКС.СвойствоФормата;
					КонецЦикла;
					
				КонецЦикла;
				
				Для Каждого ТЧИСвойства Из ПравилоКонвертации.СвойстваТабличныхЧастей Цикл
					
					Если Не ТЧИСвойства.ИспользуетсяАлгоритмКонвертации Тогда
						Продолжить;
					КонецЕсли;
					
					ПКСДляТЧ = ТЧИСвойства.Свойства;
					ИмяТЧПриемника = ТЧИСвойства.ТЧФормата;
					
					ТЧПриемника = Неопределено; // ТаблицаЗначений
					Если Не ЗначениеЗаполнено(ИмяТЧПриемника)
						Или Не Приемник.Свойство(ИмяТЧПриемника, ТЧПриемника) Тогда
						Продолжить;
					КонецЕсли;
					
					// Создаем новую ТЗ, в которой нет ограничений типа для колонок.
					НоваяТЧПриемника = СоздатьТЧПриемникаПоПКС(СвойстваТЧПриемника[ИмяТЧПриемника]);
					
					// Убираем лишние колонки, которые могли добавить в приемнике.
					УдаляемыеКолонки = Новый Массив;
					Для Каждого Колонка Из ТЧПриемника.Колонки Цикл
						Если НоваяТЧПриемника.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
							УдаляемыеКолонки.Добавить(Колонка);
						КонецЕсли;
					КонецЦикла;
					Для Каждого Колонка Из УдаляемыеКолонки Цикл
						ТЧПриемника.Колонки.Удалить(Колонка);
					КонецЦикла;
					
					// Копируем данные в новую таблицу приемника.
					Для Каждого СтрокаТЧПриемника Из ТЧПриемника Цикл
						СтрокаНовойТЧПриемника = НоваяТЧПриемника.Добавить();
						ЗаполнитьЗначенияСвойств(СтрокаНовойТЧПриемника, СтрокаТЧПриемника);
					КонецЦикла;
					Приемник[ИмяТЧПриемника] = НоваяТЧПриемника;
					
					Для Каждого Строка Из НоваяТЧПриемника Цикл
						
						Для Каждого ПКС Из ПКСДляТЧ Цикл
							
							Если НЕ ПКС.ИспользуетсяАлгоритмКонвертации Тогда
								Продолжить;
							КонецЕсли;
							
							ВыгрузитьСвойство(
								КомпонентыОбмена,
								Источник,
								Строка,
								ПКС,
								СтекВыгрузки,
								2);
								
						КонецЦикла;
						
					КонецЦикла;
					
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЕсли;
		// {Обработчик: ПриОтправкеДанных} Окончание
		
		Если СтекВыгрузки.Количество() > 1 Тогда
			Приемник.Вставить("ТипСоставногоСвойства", ПравилоКонвертации.ТипКлючевыхСвойствОбъектаXDTO);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Приемник;
	
КонецФункции

// Выгружает свойство объекта информационной базы в соответствии с правилами.
//
// Параметры:
//  КомпонентыОбмена   - Структура - содержит все правила и параметры обмена.
//  ДанныеИБ           - ЛюбаяСсылка - ссылка на выгружаемый объект информационной базы.
//  ПолучательСвойства - Структура - Получатель данных типа Структура, в которой должно храниться значение выгруженного свойства.
//  ПКС                - СтрокаТаблицыЗначений - Строка таблицы правил конвертации свойств, в соответствии с которой
//                                               выполняется преобразование.
//  СтекВыгрузки       - Массив - ссылки на выгружаемые объекты с учетом вложенности.
//  ЭтапВыгрузки       - Число - содержит информацию об этапе выгрузки
//     1 - выгрузка до выполнения алгоритма ПриОтправкеДанных, 
//     2 - выгрузка после выполнения алгоритма ПриОтправкеДанных.
//
Процедура ВыгрузитьСвойство(КомпонентыОбмена, ДанныеИБ, ПолучательСвойства, ПКС, СтекВыгрузки, ЭтапВыгрузки = 1) Экспорт
	// Свойство формата не указано - данное ПКС используется только при загрузке.
	Если СокрЛП(ПКС.СвойствоФормата) = "" Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоФормата_Имя = СокрЛП(ПКС.СвойствоФормата);
	ВложенныеСвойства = СтрРазделить(СвойствоФормата_Имя,".",Ложь);
	// Указано полное имя свойства, входящего в группу общих свойств.
	УказаноПолноеИмяСвойства = Ложь;
	Если ВложенныеСвойства.Количество() > 1 Тогда
		УказаноПолноеИмяСвойства = Истина;
		СвойствоФормата_Имя = ВложенныеСвойства[ВложенныеСвойства.Количество()-1];
	КонецЕсли;
	
	ЗначениеСвойства = Неопределено;
	Если ЭтапВыгрузки = 1 Тогда
		Если ЗначениеЗаполнено(ПКС.СвойствоКонфигурации) Тогда
			ЗначениеСвойства = ДанныеИБ[ПКС.СвойствоКонфигурации];
		ИначеЕсли ТипЗнч(ДанныеИБ) = Тип("Структура") Тогда
			// Это ПКС из ПКО с источником-структурой
			Если УказаноПолноеИмяСвойства Тогда
				ПолучитьЗначениеВложенныхСвойств(ДанныеИБ, ВложенныеСвойства, ЗначениеСвойства);
			Иначе
				ДанныеИБ.Свойство(СвойствоФормата_Имя, ЗначениеСвойства);
			КонецЕсли;
			Если ЗначениеСвойства = Неопределено Тогда
				Возврат;
			КонецЕсли;
		КонецЕсли;
	Иначе
		
		Если ТипЗнч(ПолучательСвойства) = Тип("СтрокаТаблицыЗначений") Тогда
			КолонкиТЧ = ПолучательСвойства.Владелец().Колонки;
			УровеньМаксимальный = ВложенныеСвойства.Количество() - 1;
			Если УказаноПолноеИмяСвойства Тогда
				Для Уровень = 0 По УровеньМаксимальный Цикл
					ИмяКолонки = ВложенныеСвойства[Уровень];
					Если КолонкиТЧ.Найти(ИмяКолонки) = Неопределено Тогда
						Продолжить;
					КонецЕсли;
					ЗначениеВКолонке = ПолучательСвойства[ИмяКолонки];
					Если Уровень = УровеньМаксимальный Тогда
						ЗначениеСвойства = ЗначениеВКолонке;
					ИначеЕсли ТипЗнч(ЗначениеВКолонке) = Тип("Структура") Тогда
						// Значение вложенного свойства упаковано в структуру, которая может быть многоуровневой.
						ИсточникВложенногоСвойства = ЗначениеВКолонке;
						ЗначениеВложенногоСвойства = Неопределено;
						Для УровеньПодчиненный = Уровень + 1 По УровеньМаксимальный Цикл
							ИмяВложенногоСвойства = ВложенныеСвойства[УровеньПодчиненный];
							Если НЕ ИсточникВложенногоСвойства.Свойство(ИмяВложенногоСвойства, ЗначениеВложенногоСвойства) Тогда
								Продолжить;
							КонецЕсли;
							Если УровеньПодчиненный = УровеньМаксимальный Тогда
								ЗначениеСвойства = ЗначениеВложенногоСвойства;
							ИначеЕсли ТипЗнч(ЗначениеВложенногоСвойства) = Тип("Структура") Тогда
								ИсточникВложенногоСвойства = ЗначениеВложенногоСвойства;
								ЗначениеВложенногоСвойства = Неопределено;
							Иначе
								Прервать;
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
				КонецЦикла;
			Иначе
				Если КолонкиТЧ.Найти(СвойствоФормата_Имя) = Неопределено Тогда
					Возврат;
				Иначе
					ЗначениеСвойства = ПолучательСвойства[СвойствоФормата_Имя];
				КонецЕсли;
			КонецЕсли;
		Иначе
			Если УказаноПолноеИмяСвойства Тогда
				ПолучитьЗначениеВложенныхСвойств(ДанныеИБ, ВложенныеСвойства, ЗначениеСвойства);
			Иначе
				ПолучательСвойства.Свойство(СвойствоФормата_Имя, ЗначениеСвойства);
			КонецЕсли;
			Если ЗначениеСвойства = Неопределено
				И Не (СтекВыгрузки.Количество() = 1 И ПолучательСвойства.КлючевыеСвойства.Свойство(СвойствоФормата_Имя, ЗначениеСвойства)) Тогда
				Возврат;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
		
	ПравилоКонвертацииСвойства = ПКС.ПравилоКонвертацииСвойства;
	
	// Значение может быть в формате инструкции.
	Если ТипЗнч(ЗначениеСвойства) = Тип("Структура") Тогда
		Если ЗначениеСвойства.Свойство("ИмяПКО") Тогда
			ПравилоКонвертацииСвойства = ЗначениеСвойства.ИмяПКО;
		КонецЕсли;
		Если ЗначениеСвойства.Свойство("Значение") Тогда
			ЗначениеСвойства = ЗначениеСвойства.Значение;
		КонецЕсли;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ЗначениеСвойства) Тогда
	
		Если СокрЛП(ПравилоКонвертацииСвойства) <> "" Тогда
			
			ПКПД = КомпонентыОбмена.ПравилаКонвертацииПредопределенныхДанных.Найти(ПравилоКонвертацииСвойства, "ИмяПКПД");
			Если ПКПД <> Неопределено Тогда
				ЗначениеСвойства = ПКПД.КонвертацииЗначенийПриОтправке.Получить(ЗначениеСвойства);
			Иначе
			
				ПравилоКонвертации = ПКОПоИмени(КомпонентыОбмена, ПравилоКонвертацииСвойства);
				
				ОтветвлениеСтекаВыгрузки = Новый Массив;
				Для Каждого Элемент Из СтекВыгрузки Цикл
					ОтветвлениеСтекаВыгрузки.Добавить(Элемент);
				КонецЦикла;
				
				ЗначениеСвойства = ДанныеXDTOИзДанныхИБ(
					КомпонентыОбмена,
					ЗначениеСвойства,
					ПравилоКонвертации,
					ОтветвлениеСтекаВыгрузки);
					
			КонецЕсли;
			
		КонецЕсли;
		
	Иначе
		ЗначениеСвойства = Неопределено;
	КонецЕсли;
	
	Если СтекВыгрузки.Количество() = 1 И ПКС.ОбработкаКлючевогоСвойства Тогда
		Если Не ПолучательСвойства.Свойство("КлючевыеСвойства") Тогда
			ПолучательСвойства.Вставить("КлючевыеСвойства", Новый Структура);
		КонецЕсли;
		ПолучательСвойства.КлючевыеСвойства.Вставить(СвойствоФормата_Имя, ЗначениеСвойства);
	Иначе
		Если ТипЗнч(ПолучательСвойства) = Тип("СтрокаТаблицыЗначений") Тогда
			Если УказаноПолноеИмяСвойства Тогда
				ПоместитьЗначениеВложенныхСвойств(ПолучательСвойства, ВложенныеСвойства, ЗначениеСвойства, Истина);
			Иначе
				ПолучательСвойства[СвойствоФормата_Имя] = ЗначениеСвойства;
			КонецЕсли;
		Иначе
			Если УказаноПолноеИмяСвойства Тогда
				ПоместитьЗначениеВложенныхСвойств(ПолучательСвойства, ВложенныеСвойства, ЗначениеСвойства, Ложь);
			Иначе
				ПолучательСвойства.Вставить(СвойствоФормата_Имя, ЗначениеСвойства);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Открывает файл выгрузки данных, записывает заголовок файла в соответствие с форматом обмена.
//
// Параметры:
//  КомпонентыОбмена - Структура - содержит все правила и параметры обмена.
//  ИмяФайлаОбмена - строка - имя файла обмена.
//
Процедура ОткрытьФайлВыгрузки(КомпонентыОбмена, ИмяФайлаОбмена = "") Экспорт

	ФайлОбмена = Новый ЗаписьXML;
	Если ИмяФайлаОбмена <> "" Тогда
		ФайлОбмена.ОткрытьФайл(ИмяФайлаОбмена);
	Иначе
		ФайлОбмена.УстановитьСтроку();
	КонецЕсли;
	ФайлОбмена.ЗаписатьОбъявлениеXML();
	
	ЗаписьСообщения = Неопределено;
	
	Если КомпонентыОбмена.ЭтоОбменЧерезПланОбмена Тогда

		ЗаписьСообщения = Новый Структура("НомерПринятого, НомерСообщения, Получатель");
		ЗаписьСообщения.Получатель = КомпонентыОбмена.УзелКорреспондента;
		
		Если ТранзакцияАктивна() Тогда
			ВызватьИсключение НСтр("ru = 'Блокировка на обмен данными не может быть установлена в активной транзакции.'");
		КонецЕсли;
		
		// Устанавливаем блокировку на узел получателя.
		Попытка
			ЗаблокироватьДанныеДляРедактирования(ЗаписьСообщения.Получатель);
		Исключение
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка установки блокировки на обмен данными.
				|Возможно, обмен данными выполняется другим сеансом.
				|
				|Подробности:
				|%1'"),
				КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
		
		ДанныеПолучателя = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(ЗаписьСообщения.Получатель, "НомерОтправленного, НомерПринятого, Код");
		
		ЗаписьСообщения.НомерСообщения = ДанныеПолучателя.НомерОтправленного + 1;
		ЗаписьСообщения.НомерПринятого = ДанныеПолучателя.НомерПринятого;
		
	КонецЕсли;
	
	ПараметрыЗаголовка = ПараметрыЗаголовкаСообщенияОбмена();
	
	ПараметрыЗаголовка.ФорматОбмена                 = КомпонентыОбмена.XMLСхема;
	ПараметрыЗаголовка.ЭтоОбменЧерезПланОбмена      = КомпонентыОбмена.ЭтоОбменЧерезПланОбмена;
	ПараметрыЗаголовка.ОбменДаннымиСВнешнейСистемой = КомпонентыОбмена.ОбменДаннымиСВнешнейСистемой;
	ПараметрыЗаголовка.ВерсияФорматаОбмена          = КомпонентыОбмена.ВерсияФорматаОбмена;
	
	Если КомпонентыОбмена.ЭтоОбменЧерезПланОбмена Тогда
		
		ПараметрыЗаголовка.УзелКорреспондента = КомпонентыОбмена.УзелКорреспондента;
		ПараметрыЗаголовка.ИдентификаторОтправителя = ОбменДаннымиСервер.ИдентификаторЭтогоУзлаДляОбмена(КомпонентыОбмена.УзелКорреспондента);
		
		Если Не КомпонентыОбмена.ТолькоНастройкиXDTO Тогда
			ПараметрыЗаголовка.НомерСообщения = ЗаписьСообщения.НомерСообщения;
			ПараметрыЗаголовка.НомерПринятого = ЗаписьСообщения.НомерПринятого;
		КонецЕсли;
		
		ПараметрыЗаголовка.ПоддерживаемыеВерсии  = КомпонентыОбмена.НастройкиXDTO.ПоддерживаемыеВерсии;
		ПараметрыЗаголовка.ПоддерживаемыеОбъекты = КомпонентыОбмена.НастройкиXDTO.ПоддерживаемыеОбъекты;
		
		Если Не КомпонентыОбмена.ОбменДаннымиСВнешнейСистемой Тогда
			ПараметрыЗаголовка.ИмяПланаОбмена = ОбменДаннымиПовтИсп.ПолучитьИмяПланаОбмена(КомпонентыОбмена.УзелКорреспондента);
			ПараметрыЗаголовка.ПсевдонимПредопределенногоУзла = ОбменДаннымиСервер.ПсевдонимПредопределенногоУзла(КомпонентыОбмена.УзелКорреспондента);
			
			ПараметрыЗаголовка.ИдентификаторПолучателя  = ОбменДаннымиСервер.ИдентификаторУзлаКорреспондентаДляОбмена(КомпонентыОбмена.УзелКорреспондента);
			
			ПараметрыЗаголовка.Префикс = ОбменДаннымиСервер.ПрефиксИнформационнойБазы();
		КонецЕсли;
		
	КонецЕсли;
	
	ЗаписатьЗаголовокСообщенияОбмена(ФайлОбмена, ПараметрыЗаголовка);
	
	Если Не КомпонентыОбмена.ТолькоНастройкиXDTO Тогда
		// Записываем элемент <Body>
		ФайлОбмена.ЗаписатьНачалоЭлемента("Body");
		ФайлОбмена.ЗаписатьСоответствиеПространстваИмен("", КомпонентыОбмена.XMLСхема);
	КонецЕсли;
	
	КомпонентыОбмена.Вставить("ФайлОбмена", ФайлОбмена);
	
КонецПроцедуры

#КонецОбласти

#Область ПолучениеДанных

// Возвращает объект информационной базы, соответствующий полученным данным.
// 
// Параметры:
//   КомпонентыОбмена - см. ОбменДаннымиXDTOСервер.ИнициализироватьКомпонентыОбмена
//   ДанныеXDTO       - Структура - структура, имитирующая объект XDTO.
//
//   ПравилоКонвертации - СтрокаТаблицыЗначений, Структура - параметры текущего правила конвертации.
//                        СтрокаТаблицыЗначений - строка таблицы правил конвертации объектов.
//                        Структура - описание правила конвертации объекта.
//                          * ПравилоКонвертации - СтрокаТаблицыЗначений - строка таблицы правил конвертации объектов.
//                                                 Обязательное свойство.
//                          * УдалятьСозданныеПоКлючевымСвойствам - Булево - признак необходимости удаления объектов,
//                                                                  созданных только по значениям ключевых свойств.
//                                                                  Необязательное свойство, по умолчанию Ложь.
//
//   Действие - Строка - определяет цель получения объекта ИБ:
//                       "ПолучитьСсылку" - идентификация объекта,
//                       "КонвертироватьИЗаписать" - полноценная загрузка объекта.
//
// Возвращаемое значение:
//   - Объект - объект ИБ, если передано действие "КонвертироватьИЗаписать",
//              либо если передано действие "ПолучитьСсылку" и в процессе ее получения был создан объект.
//   - ЛюбаяСсылка - ссылка на объект ИБ или пустая ссылка заданного типа, если было передано действие "ПолучитьСсылку"
//                   и в процессе ее получения объект не был создан.
//
Функция СтруктураОбъектаXDTOВДанныеИБ(КомпонентыОбмена, ДанныеXDTO, Знач ПравилоКонвертации, Действие = "КонвертироватьИЗаписать") Экспорт
	
	УдалятьСозданныеПоКлючевымСвойствам = КомпонентыОбмена.УдалятьСозданныеПоКлючевымСвойствам;
	Если ТипЗнч(ПравилоКонвертации) = Тип("Структура") Тогда
		Если ПравилоКонвертации.Свойство("УдалятьСозданныеПоКлючевымСвойствам") Тогда
			УдалятьСозданныеПоКлючевымСвойствам = ПравилоКонвертации.УдалятьСозданныеПоКлючевымСвойствам;
		КонецЕсли;
		ПравилоКонвертации = ПравилоКонвертации.ПравилоКонвертации;
	КонецЕсли;
	
	ДанныеИБ = Неопределено;
	ПолученныеДанные = ИнициализироватьПолученныеДанные(ПравилоКонвертации);
	СоставСвойств = "Все";
	ПолученныеДанныеСсылка = Неопределено;
	ДанныеXDTOСодержатСсылку = ДанныеXDTO.Свойство("Ссылка");
	Если ПравилоКонвертации.ЭтоСсылочныйТип Тогда
		ПолученныеДанныеСсылка = ПолученныеДанные.Ссылка;
		ВариантИдентификации = СокрЛП(ПравилоКонвертации.ВариантИдентификации);
		Если ДанныеXDTOСодержатСсылку
			И (ВариантИдентификации = "ПоУникальномуИдентификатору"
				Или ВариантИдентификации = "СначалаПоУникальномуИдентификаторуПотомПоПолямПоиска") Тогда
			
			ПолученныеДанныеСсылка = СсылкаОбъектаПоУИДОбъектаXDTO(
				ДанныеXDTO.Ссылка.Значение,
				ПравилоКонвертации.ТипДанных,
				КомпонентыОбмена);
				
			ПолученныеДанные.УстановитьСсылкуНового(ПолученныеДанныеСсылка);
			
			ДанныеИБ = ПолученныеДанныеСсылка.ПолучитьОбъект();
			
			Если Действие = "ПолучитьСсылку" Тогда
				
				Если ДанныеИБ <> Неопределено Тогда
					// Задача: получение ссылки.
					// Идентификация: по УИД или УИД + поля поиска.
					// Объект с полученной ссылкой (или с таким публичным идентификатором) существует.
					ЗаписатьПриНеобходимостиПубличныйИдентификатор(
						ДанныеИБ,
						ПолученныеДанныеСсылка,
						ДанныеXDTO.Ссылка.Значение,
						КомпонентыОбмена.УзелКорреспондента,
						ПравилоКонвертации);
						
					Возврат ДанныеИБ.Ссылка;
				ИначеЕсли ВариантИдентификации = "ПоУникальномуИдентификатору" Тогда
					// Задача: получение ссылки.
					// Идентификация: по УИД.
					// Объект с полученной ссылкой (или с таким публичным идентификатором) не найден.
					
					Возврат ПолученныеДанныеСсылка;
				КонецЕсли;
				
			КонецЕсли;
		Иначе
			ПолученныеДанныеСсылка = ПравилоКонвертации.МенеджерОбъекта.ПолучитьСсылку(Новый УникальныйИдентификатор());
			ПолученныеДанные.УстановитьСсылкуНового(ПолученныеДанныеСсылка);
		КонецЕсли;
		// Определяем, какие свойства нужно конвертировать.
		СоставСвойств = ?(Действие = "ПолучитьСсылку" И УдалятьСозданныеПоКлючевымСвойствам, "СвойстваПоиска", "Все");
	КонецЕсли;
	
	// Конвертация свойств, для которых не нужно выполнение обработчика.
	КонвертацияСвойствСтруктурыОбъектаXDTO(
		КомпонентыОбмена,
		ДанныеXDTO,
		ПолученныеДанные,
		ПравилоКонвертации,
		1,
		СоставСвойств);
		
	Если Действие = "ПолучитьСсылку" Тогда
		ДанныеXDTO = Новый Структура("КлючевыеСвойства",
			ОбщегоНазначения.СкопироватьРекурсивно(ДанныеXDTO));
	КонецЕсли;
	
	ПриКонвертацииДанныхXDTO(
		ДанныеXDTO,
		ПолученныеДанные,
		КомпонентыОбмена,
		ПравилоКонвертации.ПриКонвертацииДанныхXDTO);
		
	Если Действие = "ПолучитьСсылку" Тогда
		ДанныеXDTO = ОбщегоНазначения.СкопироватьРекурсивно(ДанныеXDTO.КлючевыеСвойства);
	КонецЕсли;
		
	КонвертацияСвойствСтруктурыОбъектаXDTO(
		КомпонентыОбмена,
		ДанныеXDTO,
		ПолученныеДанные,
		ПравилоКонвертации,
		2,
		СоставСвойств);
		
	// В результате конвертации свойств объект мог быть записан в случае наличия циклической ссылки.
	Если ПолученныеДанныеСсылка <> Неопределено И ОбщегоНазначения.СсылкаСуществует(ПолученныеДанныеСсылка) Тогда
		ДанныеИБ = ПолученныеДанныеСсылка.ПолучитьОбъект();
	КонецЕсли;
	
	Если ДанныеИБ = Неопределено Тогда
		Если ПравилоКонвертации.ЭтоРегистр Тогда
			// Идентификация не производится, отбор набора записей выполняется в алгоритмах правил.
			ДанныеИБ = Неопределено;
		ИначеЕсли ВариантИдентификации = "ПоПолямПоиска"
			Или ВариантИдентификации = "СначалаПоУникальномуИдентификаторуПотомПоПолямПоиска" Тогда
			
			ДанныеИБ = СсылкаОбъектаПоСвойствамОбъектаXDTO(
				ПравилоКонвертации,
				ПолученныеДанные,
				ДанныеXDTOСодержатСсылку,
				КомпонентыОбмена.УзелКорреспондента);
			Если Не ЗначениеЗаполнено(ДанныеИБ) Тогда
				ДанныеИБ = Неопределено;
			КонецЕсли;
			
			Если ДанныеИБ <> Неопределено И ПравилоКонвертации.ЭтоСсылочныйТип Тогда
				Если Действие = "ПолучитьСсылку" Тогда
					// Задача: получение ссылки.
					// Идентификация: по УИД + поля поиска.
					// Объект найден по полям поиска.
					Если ДанныеXDTOСодержатСсылку Тогда
						ЗаписатьПриНеобходимостиПубличныйИдентификатор(
							ДанныеИБ.ПолучитьОбъект(),
							ДанныеИБ,
							ДанныеXDTO.Ссылка.Значение,
							КомпонентыОбмена.УзелКорреспондента,
							ПравилоКонвертации);
					КонецЕсли;
					
					Возврат ДанныеИБ;
				Иначе
					ДанныеИБ = ДанныеИБ.ПолучитьОбъект();
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	ЗаписыватьОбъектВИБ = ?(Действие = "КонвертироватьИЗаписать", Истина, Ложь);
	
	Если КомпонентыОбмена.РежимЗагрузкиДанныхВИнформационнуюБазу
		И (ВариантИдентификации = "ПоПолямПоиска"
			Или ВариантИдентификации = "СначалаПоУникальномуИдентификаторуПотомПоПолямПоиска") Тогда
		// Объекты, при идентификации которых используются поля поиска,
		// должны быть записаны в информационную базу с целью получения одной и той же ссылки на объект при каждом поиске.
		ЗаписыватьОбъектВИБ = Истина;
	КонецЕсли;
	
	Если ЗаписыватьОбъектВИБ Тогда
		
		ЭтоПолнаяЗагрузкаОбъекта = Действие = "КонвертироватьИЗаписать"
			Или ПравилоКонвертации.РазрешитьСоздаватьОбъектИзСтруктуры
			Или (Действие = "ПолучитьСсылку"
				И Не УдалятьСозданныеПоКлючевымСвойствам
				И ДанныеИБ = Неопределено);
			
		Если ЭтоПолнаяЗагрузкаОбъекта
			И ПравилоКонвертации.ЕстьОбработчикПередЗаписьюПолученныхДанных Тогда
			
			// Полноценная загрузка объекта, удаление временного объекта.
			Если ДанныеИБ <> Неопределено Тогда
				СтрокаОбъекта = КомпонентыОбмена.ТаблицаОбъектовСозданныхПоСсылкам.Найти(ДанныеИБ.Ссылка, "СсылкаНаОбъект");
				Если СтрокаОбъекта <> Неопределено Тогда
					ОбменДаннымиСервер.УстановитьОбменДаннымиЗагрузка(ДанныеИБ, Истина, Ложь, КомпонентыОбмена.УзелКорреспондента);
					УдалитьОбъект(ДанныеИБ, Истина, КомпонентыОбмена);
					ДанныеИБ = Неопределено;
					ПолученныеДанные.УстановитьСсылкуНового(СтрокаОбъекта.СсылкаНаОбъект);
				КонецЕсли;
			КонецЕсли;
			
			ПередЗаписьюПолученныхДанных(
				ПолученныеДанные,
				ДанныеИБ,
				КомпонентыОбмена,
				ПравилоКонвертации.ПередЗаписьюПолученныхДанных,
				ПравилоКонвертации.Свойства);
			
		КонецЕсли;
		
		Если ДанныеИБ = Неопределено Тогда
			ДанныеДляЗаписиВИБ = ПолученныеДанные;
		Иначе
			Если ПолученныеДанные <> Неопределено Тогда
				ЗаполнитьДанныеИБПоПолученнымДанным(ДанныеИБ, ПолученныеДанные, ПравилоКонвертации);
			КонецЕсли;
			ДанныеДляЗаписиВИБ = ДанныеИБ;
		КонецЕсли;
		
		Если ДанныеДляЗаписиВИБ = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Если КомпонентыОбмена.ЭтоОбменЧерезПланОбмена
			И ПравилоКонвертации.ЭтоСсылочныйТип
			И ДанныеXDTOСодержатСсылку Тогда
			
			ЗаписатьПриНеобходимостиПубличныйИдентификатор(
				ДанныеИБ,
				?(ДанныеДляЗаписиВИБ.ЭтоНовый(), ДанныеДляЗаписиВИБ.ПолучитьСсылкуНового(), ДанныеДляЗаписиВИБ.Ссылка),
				ДанныеXDTO.Ссылка.Значение,
				КомпонентыОбмена.УзелКорреспондента,
				ПравилоКонвертации);
				
		КонецЕсли;
		
		Если ПравилоКонвертации.ЭтоСсылочныйТип И ЭтоПолнаяЗагрузкаОбъекта Тогда
			ПровестиГенерациюКодаНомераПриНеобходимости(ДанныеДляЗаписиВИБ);
		КонецЕсли;
		
		Если КомпонентыОбмена.ЭтоОбменЧерезПланОбмена И Не ПравилоКонвертации.ЭтоРегистр Тогда
			ПолучениеЭлемента = ПолучениеЭлементаДанных.Авто;
			ОтправкаНазад = Ложь;
			СтандартныеПодсистемыСервер.ПриПолученииДанныхОтГлавного(
				ДанныеДляЗаписиВИБ, ПолучениеЭлемента, ОтправкаНазад, КомпонентыОбмена.УзелКорреспондентаОбъект);
			ДанныеДляЗаписиВИБ.ДополнительныеСвойства.Вставить("ПолучениеЭлементаДанных", ПолучениеЭлемента);
			
			Если ПолучениеЭлемента = ПолучениеЭлементаДанных.Игнорировать Тогда
				Возврат ДанныеДляЗаписиВИБ;
			КонецЕсли;
		КонецЕсли;
		
		Если ПравилоКонвертации.ЭтоСсылочныйТип И ДанныеДляЗаписиВИБ.ПометкаУдаления Тогда
			ДанныеДляЗаписиВИБ.ПометкаУдаления = Ложь;
		КонецЕсли;
		
		Если ПравилоКонвертации.ЭтоДокумент Тогда
			
			Попытка
				
				Если ПравилоКонвертации.ДокументМожетПроводиться Тогда
				
					Если ДанныеДляЗаписиВИБ.Проведен Тогда
						
						ДанныеДляЗаписиВИБ.Проведен = Ложь;
						Если Не ДанныеДляЗаписиВИБ.ЭтоНовый()
							И ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ДанныеДляЗаписиВИБ.Ссылка, "Проведен") Тогда
							// Записываем новую версию документа с отменой проведения.
							Результат = ОтменитьПроведениеОбъектаВИБ(ДанныеДляЗаписиВИБ, КомпонентыОбмена.УзелКорреспондента);
						Иначе
							// Записываем новую версию документа.
							ЗаписатьОбъектВИБ(КомпонентыОбмена, ДанныеДляЗаписиВИБ, ПравилоКонвертации.ТипДанных);
							Если ДанныеДляЗаписиВИБ = Неопределено Тогда
								Возврат Неопределено;
							КонецЕсли;
						КонецЕсли;
						
						СтрокаТаблицы = КомпонентыОбмена.ДокументыДляОтложенногоПроведения.Добавить();
						СтрокаТаблицы.ДокументСсылка = ДанныеДляЗаписиВИБ.Ссылка;
						СтрокаТаблицы.ДатаДокумента  = ДанныеДляЗаписиВИБ.Дата;
						
					Иначе
						Если ДанныеДляЗаписиВИБ.ЭтоНовый() Тогда
							ЗаписатьОбъектВИБ(КомпонентыОбмена, ДанныеДляЗаписиВИБ, ПравилоКонвертации.ТипДанных);
							Если ДанныеДляЗаписиВИБ = Неопределено Тогда
								Возврат Неопределено;
							КонецЕсли;
						Иначе
							ОтменитьПроведениеОбъектаВИБ(ДанныеДляЗаписиВИБ, КомпонентыОбмена.УзелКорреспондента);
						КонецЕсли;
					КонецЕсли;
					
				Иначе
					ЗаписатьОбъектВИБ(КомпонентыОбмена, ДанныеДляЗаписиВИБ, ПравилоКонвертации.ТипДанных);
					Если ДанныеДляЗаписиВИБ = Неопределено Тогда
						Возврат Неопределено;
					КонецЕсли;
				КонецЕсли;
				
			Исключение
				ЗаписатьВПротоколВыполнения(КомпонентыОбмена, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			КонецПопытки;
			
		Иначе
			
			ЗаписатьОбъектВИБ(КомпонентыОбмена, ДанныеДляЗаписиВИБ, ПравилоКонвертации.ТипДанных);
			Если ДанныеДляЗаписиВИБ = Неопределено Тогда
				Возврат Неопределено;
			КонецЕсли;
			Если ПравилоКонвертации.ЭтоСсылочныйТип Тогда
				КомпонентыОбмена.ОбъектыДляОтложеннойЗаписи.Вставить(
					ДанныеДляЗаписиВИБ.Ссылка, 
					ДанныеДляЗаписиВИБ.ДополнительныеСвойства);
			КонецЕсли;
		КонецЕсли;
		
		ЗапомнитьОбъектДляОтложенногоЗаполнения(ДанныеДляЗаписиВИБ, ПравилоКонвертации, КомпонентыОбмена);
		
	Иначе
		
		ДанныеДляЗаписиВИБ = ПолученныеДанные;
		
	КонецЕсли;
	
	Если ПравилоКонвертации.ЭтоСсылочныйТип Тогда
		// Объекты, создаваемые по ссылке, запоминаем в таблицу,
		// чтобы после загрузки всех данных удалить объекты, 
		// которые так и не были загружены полностью ("временные объекты").
		// При загрузке объектов "целиком" удаляем объекты из таблицы,
		// переводя их из состояния "временных" в "постоянные".
		ТаблицаОбъектовСозданныхПоСсылкам = КомпонентыОбмена.ТаблицаОбъектовСозданныхПоСсылкам;
			
		Если Действие = "ПолучитьСсылку"
			И ЗаписыватьОбъектВИБ
			И Не ПравилоКонвертации.РазрешитьСоздаватьОбъектИзСтруктуры Тогда
			
			СтрокаОбъекта = ТаблицаОбъектовСозданныхПоСсылкам.Найти(ДанныеДляЗаписиВИБ.Ссылка, "СсылкаНаОбъект");
			
			Если СтрокаОбъекта = Неопределено Тогда
				НоваяСтрока = ТаблицаОбъектовСозданныхПоСсылкам.Добавить();
				НоваяСтрока.СсылкаНаОбъект = ДанныеДляЗаписиВИБ.Ссылка;
				НоваяСтрока.УдалятьСозданныеПоКлючевымСвойствам = УдалятьСозданныеПоКлючевымСвойствам;
			Иначе
				Если Не УдалятьСозданныеПоКлючевымСвойствам Тогда
					СтрокаОбъекта.УдалятьСозданныеПоКлючевымСвойствам = Ложь;
				КонецЕсли;
			КонецЕсли;
			
		ИначеЕсли Действие = "КонвертироватьИЗаписать" Тогда
			
			СтрокаОбъекта = ТаблицаОбъектовСозданныхПоСсылкам.Найти(ДанныеДляЗаписиВИБ.Ссылка, "СсылкаНаОбъект");
			
			Если СтрокаОбъекта <> Неопределено Тогда
				ТаблицаОбъектовСозданныхПоСсылкам.Удалить(СтрокаОбъекта);
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Возврат ДанныеДляЗаписиВИБ;
	
КонецФункции

// Выполняет чтение файла данных при загрузке.
//
// Параметры:
//  КомпонентыОбмена - см. ИнициализироватьКомпонентыОбмена
//  ТаблицыДляЗагрузки - ТаблицаЗначений - Таблица, в которую следует загрузить данные (при интерактивном сопоставлении данных).
//
Процедура ПроизвестиЧтениеДанных(КомпонентыОбмена, ТаблицыДляЗагрузки = Неопределено) Экспорт
	
	КомпонентыОбмена.ТаблицаОбъектовСозданныхПоСсылкам.Очистить();
	
	Если ТипЗнч(ТаблицыДляЗагрузки) = Тип("ТаблицаЗначений")
		И ТаблицыДляЗагрузки.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если КомпонентыОбмена.ЭтоОбменЧерезПланОбмена
		И КомпонентыОбмена.УзелКорреспондентаОбъект = Неопределено Тогда
		КомпонентыОбмена.УзелКорреспондентаОбъект = КомпонентыОбмена.УзелКорреспондента.ПолучитьОбъект();
	КонецЕсли;
	
	Если КомпонентыОбмена.ЭтоОбменЧерезПланОбмена Тогда
		ОчиститьСписокОшибокПриЗагрузкеДанных(КомпонентыОбмена.УзелКорреспондента);
	КонецЕсли;
	
	Результаты = Неопределено;
	ПрочитатьСообщениеОбмена(КомпонентыОбмена, Результаты, ТаблицыДляЗагрузки);
	
	Если Не КомпонентыОбмена.ФлагОшибки
		И КомпонентыОбмена.РежимЗагрузкиДанныхВИнформационнуюБазу Тогда
		
		ОбменДаннымиСлужебный.ОтключитьОбновлениеКлючейДоступа(Истина);
		Попытка
			ПрименитьУдалениеОбъектов(КомпонентыОбмена, Результаты.МассивОбъектовКУдалению, Результаты.МассивЗагруженныхОбъектов);
			УдалитьВременныеОбъектыСозданныеПоСсылкам(КомпонентыОбмена);
			ОтложенноеЗаполнениеОбъектов(КомпонентыОбмена);
		
			ОбменДаннымиСлужебный.ОтключитьОбновлениеКлючейДоступа(Ложь);
		Исключение
			ОбменДаннымиСлужебный.ОтключитьОбновлениеКлючейДоступа(Ложь);
			ВызватьИсключение;
		КонецПопытки;
		
		КомпонентыОбмена.ПомеченныеНаУдалениеОбъекты = ОбщегоНазначения.СкопироватьРекурсивно(Результаты.МассивОбъектовКУдалению);
		
		Если Не КомпонентыОбмена.ФлагОшибки Тогда
			Попытка
				КомпонентыОбмена.МенеджерОбмена.ПослеКонвертации(КомпонентыОбмена);
			Исключение
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Направление: %1.
					|Обработчик: ПослеКонвертации.
					|
					|Ошибка выполнения обработчика.
					|%2.'"),
					КомпонентыОбмена.НаправлениеОбмена,
					ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			КонецПопытки;
				
			ОбменДаннымиСлужебный.ОтключитьОбновлениеКлючейДоступа(Истина);
			Попытка
				ВыполнитьОтложенноеПроведениеДокументов(КомпонентыОбмена);
				ОбменДаннымиСервер.ВыполнитьОтложеннуюЗаписьОбъектов(
					КомпонентыОбмена.ОбъектыДляОтложеннойЗаписи, КомпонентыОбмена.УзелКорреспондента);
				
				ОбменДаннымиСлужебный.ОтключитьОбновлениеКлючейДоступа(Ложь);	
			Исключение
				ОбменДаннымиСлужебный.ОтключитьОбновлениеКлючейДоступа(Ложь);	
				ВызватьИсключение;
			КонецПопытки;
				
		КонецЕсли;
	КонецЕсли;
	
	// Фиксация успешного завершения обмена.
	Если КомпонентыОбмена.СостояниеОбменаДанными.РезультатВыполненияОбмена = Неопределено Тогда
		КомпонентыОбмена.СостояниеОбменаДанными.РезультатВыполненияОбмена = Перечисления.РезультатыВыполненияОбмена.Выполнено;
	КонецЕсли;
	
КонецПроцедуры

// Выполняет чтение файла данных при загрузке в режиме анализа (при интерактивной синхронизации данных).
//
// Параметры:
//  КомпонентыОбмена - см. ИнициализироватьКомпонентыОбмена
//  ПараметрыАнализа - Структура - параметры интерактивной загрузки данных.
//
Процедура ПроизвестиЧтениеДанныхВРежимеАнализа(КомпонентыОбмена, ПараметрыАнализа = Неопределено) Экспорт
	
	Результаты = Неопределено;
	ПрочитатьСообщениеОбмена(КомпонентыОбмена, Результаты, , Истина);
	
	ПрименитьУдалениеОбъектов(КомпонентыОбмена, Результаты.МассивОбъектовКУдалению, Результаты.МассивЗагруженныхОбъектов);
	
КонецПроцедуры

// Открывает файл загрузки данных, записывает заголовок файла в соответствие с форматом обмена.
//
// Параметры:
//  КомпонентыОбмена - Структура - содержит все правила и параметры обмена.
//  ИмяФайлаОбмена - строка - Имя файла обмена.
//
Процедура ОткрытьФайлЗагрузки(КомпонентыОбмена, ИмяФайлаОбмена) Экспорт
	
	ЭтоОбменЧерезПланОбмена = КомпонентыОбмена.ЭтоОбменЧерезПланОбмена;
	
	ЧтениеXML = Новый ЧтениеXML;
	
	КомпонентыОбмена.ФлагОшибки = Истина;
	
	ПрерватьЦикл = Ложь;
	Пока Не ПрерватьЦикл Цикл
		ПрерватьЦикл = Истина;
		
		Попытка
			ЧтениеXML.ОткрытьФайл(ИмяФайлаОбмена);
			КомпонентыОбмена.Вставить("ФайлОбмена", ЧтениеXML);
		Исключение
			СтрокаСообщенияОбОшибке = НСтр("ru = 'Ошибка при загрузке данных: %1'");
			СтрокаСообщенияОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ОписаниеОшибки());
			ЗаписатьВПротоколВыполнения(КомпонентыОбмена, СтрокаСообщенияОбОшибке);
			Прервать;
		КонецПопытки;
		
		ЧтениеXML.Прочитать(); // Message
		Если (ЧтениеXML.ТипУзла <> ТипУзлаXML.НачалоЭлемента
			Или ЧтениеXML.ЛокальноеИмя <> "Message") Тогда
			Если СообщениеОтНеобновленнойНастройки(ЧтениеXML) Тогда
				СтрокаСообщенияОбОшибке = НСтр("ru = 'Получение данных от источника, в котором не выполнено
					|обновление настройки синхронизации данных. Необходимо:'")
					+ Символы.ПС + НСтр("ru = '1) Выполнить повторную синхронизацию данных через некоторое время.'")
					+ Символы.ПС + НСтр("ru = '2) Выполнить синхронизацию данных на стороне источника, после этого 
					|повторно выполнить синхронизацию данных в этой информационной базе.'")
					+ Символы.ПС + НСтр("ru = '(1 - для вида транспорта Через интернет, 2 - для вида транспорта Другое)'");
				ЗаписатьВПротоколВыполнения(КомпонентыОбмена, СтрокаСообщенияОбОшибке);
			Иначе
				ЗаписатьВПротоколВыполнения(КомпонентыОбмена, 9);
			КонецЕсли;
			Прервать;
		КонецЕсли;
		
		ЧтениеXML.Прочитать(); // Header
		Если ЧтениеXML.ТипУзла <> ТипУзлаXML.НачалоЭлемента
			Или ЧтениеXML.ЛокальноеИмя <> "Header" Тогда
			ЗаписатьВПротоколВыполнения(КомпонентыОбмена, 9);
			Прервать;
		КонецЕсли;
		
		Header = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML, ФабрикаXDTO.Тип(XMLБазоваяСхема(), "Header"));
		
		URIФормата = Header.Format;
		
		Если ЭтоОбменЧерезПланОбмена Тогда
			
			Если Не Header.Установлено("Confirmation") Тогда
				ЗаписатьВПротоколВыполнения(КомпонентыОбмена, 9);
				Прервать;
			КонецЕсли;
			
			Confirmation = Header.Confirmation;
			
			Если КомпонентыОбмена.ОбменДаннымиСВнешнейСистемой Тогда
				ИмяПланаОбмена = ОбменДаннымиПовтИсп.ПолучитьИмяПланаОбмена(КомпонентыОбмена.УзелКорреспондента);
			Иначе
				ИмяПланаОбмена = Confirmation.ExchangePlan;
			
				Если Метаданные.ПланыОбмена.Найти(ИмяПланаОбмена) = Неопределено Тогда
					ЗаписатьВПротоколВыполнения(КомпонентыОбмена, 177);
					Прервать;
				КонецЕсли;
			КонецЕсли;
			
			ФорматПланаОбмена = ОбменДаннымиСервер.ЗначениеНастройкиПланаОбмена(ИмяПланаОбмена, "ФорматОбмена");
			
			КомпонентыОбмена.ТолькоНастройкиXDTO =
				Не ОбменДаннымиСервер.НастройкаСинхронизацииЗавершена(КомпонентыОбмена.УзелКорреспондента)
					Или (URIФормата = ФорматПланаОбмена);
			
			Если Confirmation.MessageNo <> Неопределено Тогда		
				КомпонентыОбмена.НомерВходящегоСообщения = Confirmation.MessageNo;
			Иначе
				КомпонентыОбмена.НомерВходящегоСообщения = 0;
			КонецЕсли;
			Если Confirmation.ReceivedNo <> Неопределено Тогда
				КомпонентыОбмена.НомерСообщенияПолученногоКорреспондентом = Confirmation.ReceivedNo;
			Иначе
				КомпонентыОбмена.НомерСообщенияПолученногоКорреспондентом = 0;
			КонецЕсли;
			
			КодОтКого = Confirmation.From;
			КодКому   = Confirmation.To;
			
			Если Не КомпонентыОбмена.ТолькоНастройкиXDTO Тогда
				КомпонентыОбмена.XMLСхема = URIФормата;
				
				ФорматОбмена = РазложитьФорматОбмена(КомпонентыОбмена.XMLСхема);
				
				// Проверяем базовый формат.
				Если ФорматПланаОбмена <> ФорматОбмена.БазовыйФормат Тогда
					СтрокаСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Формат сообщения обмена ""%1"" не соответствует формату плана обмена ""%2"".'"),
						ФорматОбмена.БазовыйФормат,
						ФорматПланаОбмена);
					ЗаписатьВПротоколВыполнения(КомпонентыОбмена, СтрокаСообщения);
					Прервать;
				КонецЕсли;
				
				// Проверяем версию формата сообщения обмена.
				Если ВерсииФорматаОбменаМассив(КомпонентыОбмена.УзелКорреспондента).Найти(ФорматОбмена.Версия) = Неопределено Тогда
					СтрокаСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Версия ""%1"" формата сообщения обмена ""%2"" не поддерживается.'"),
						ФорматОбмена.Версия, ФорматОбмена.БазовыйФормат);
					ЗаписатьВПротоколВыполнения(КомпонентыОбмена, СтрокаСообщения);
					Прервать;
				КонецЕсли;
				
				КомпонентыОбмена.ВерсияФорматаОбмена = ФорматОбмена.Версия;
				КомпонентыОбмена.МенеджерОбмена      = МенеджерОбменаВерсииФормата(КомпонентыОбмена.ВерсияФорматаОбмена,
					КомпонентыОбмена.УзелКорреспондента);
					
				Если КомпонентыОбмена.НомерВходящегоСообщения <= 0 Тогда
					КомпонентыОбмена.ИспользоватьКвитирование = Ложь;
				КонецЕсли;
					
				Если Не КомпонентыОбмена.ОбменДаннымиСВнешнейСистемой Тогда
					
					КодОтКогоНовый = "";
					Если Header.Установлено("NewFrom") Тогда
						КодОтКогоНовый = Header.NewFrom;
					КонецЕсли;
					
					ПолучательИзСообщения = ОбменДаннымиСервер.УзелПланаОбменаПоКоду(ИмяПланаОбмена, КодКому);
					Если ПолучательИзСообщения <> ПланыОбмена[ИмяПланаОбмена].ЭтотУзел() Тогда
						// Возможно, задан виртуальный код получателя.
						ПсевдонимПредопределенногоУзла = ОбменДаннымиСервер.ПсевдонимПредопределенногоУзла(КомпонентыОбмена.УзелКорреспондента);
						Если ПсевдонимПредопределенногоУзла <> КодКому Тогда
							ЗаписатьВПротоколВыполнения(КомпонентыОбмена, 178);
							Прервать;
						КонецЕсли;
					КонецЕсли;
					
					ОтправительИзСообщения = ОбменДаннымиСервер.УзелПланаОбменаПоКоду(ИмяПланаОбмена, КодОтКого);
					Если (ОтправительИзСообщения = Неопределено
							Или ОтправительИзСообщения <> КомпонентыОбмена.УзелКорреспондента)
						И ЗначениеЗаполнено(КодОтКогоНовый) Тогда
						ОтправительИзСообщения = ОбменДаннымиСервер.УзелПланаОбменаПоКоду(ИмяПланаОбмена, КодОтКогоНовый);
					КонецЕсли;
					
					Если ОтправительИзСообщения = Неопределено
						Или ОтправительИзСообщения <> КомпонентыОбмена.УзелКорреспондента Тогда
						
						СтрокаСообщения = НСтр("ru = 'Не найден узел обмена для загрузки данных. План обмена: %1, Идентификатор: %2'");
						СтрокаСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщения, ИмяПланаОбмена, КодОтКого);
						ЗаписатьВПротоколВыполнения(КомпонентыОбмена, СтрокаСообщения);
						Прервать;
						
					КонецЕсли;
				КонецЕсли;
				
				Если КомпонентыОбмена.ИспользоватьКвитирование Тогда
					
					НомерПринятого = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(КомпонентыОбмена.УзелКорреспондента, "НомерПринятого");
					
					Если НомерПринятого >= КомпонентыОбмена.НомерВходящегоСообщения Тогда
						// Номер сообщения меньше либо равен ранее принятому.
						КомпонентыОбмена.СостояниеОбменаДанными.РезультатВыполненияОбмена =
							Перечисления.РезультатыВыполненияОбмена.Предупреждение_СообщениеОбменаБылоРанееПринято;
							
						ЗаписатьВПротоколВыполнения(КомпонентыОбмена, 174,,,,, Истина);
						КомпонентыОбмена.ТолькоНастройкиXDTO = Истина;
					Иначе
						// Добавляем публичные идентификаторы для ссылочных объектов, о получении которых отчитался узел-корреспондент.
						ДобавитьВыгруженныеОбъектыВРегистрПубличныеИдентификаторы(КомпонентыОбмена);
						
						// Удаляем регистрацию изменений, о получении которых отчитался узел-корреспондент.
						ПланыОбмена.УдалитьРегистрациюИзменений(КомпонентыОбмена.УзелКорреспондента, КомпонентыОбмена.НомерСообщенияПолученногоКорреспондентом);
						
						// Снимаем признак начальной выгрузки данных.
						РегистрыСведений.ОбщиеНастройкиУзловИнформационныхБаз.СнятьПризнакНачальнойВыгрузкиДанных(
							КомпонентыОбмена.УзелКорреспондента, КомпонентыОбмена.НомерСообщенияПолученногоКорреспондентом);
					КонецЕсли;
					
				КонецЕсли;
					
			КонецЕсли;
			
			Если КомпонентыОбмена.ОбменДаннымиСВнешнейСистемой Тогда
				КомпонентыОбмена.ИдентификаторКорреспондента = КодОтКого;
			КонецЕсли;
			
			ЗаполнитьСтруктуруНастроекXDTOКорреспондента(КомпонентыОбмена.НастройкиXDTOКорреспондента,
				Header, Не (URIФормата = ФорматПланаОбмена), КомпонентыОбмена.УзелКорреспондента);
				
			Если Header.Установлено("Prefix") Тогда
				КомпонентыОбмена.ПрефиксКорреспондента = Header.Prefix;
			КонецЕсли;
			
			// Проверяем поддержку кодировки по УИДам в корреспонденте.
			КомпонентыОбмена.Вставить("КорреспондентПоддерживаетИдентификаторОбменаДанными",
				ВерсияПоддерживается(КомпонентыОбмена.НастройкиXDTOКорреспондента.ПоддерживаемыеВерсии, НомерВерсииСПоддержкойИдентификатораОбменаДанными()));
				
		Иначе
				
			КомпонентыОбмена.XMLСхема = URIФормата;
			
			ФорматОбмена = РазложитьФорматОбмена(КомпонентыОбмена.XMLСхема);
			
			КомпонентыОбмена.ВерсияФорматаОбмена = ФорматОбмена.Версия;
			КомпонентыОбмена.МенеджерОбмена      = МенеджерОбменаВерсииФормата(КомпонентыОбмена.ВерсияФорматаОбмена);
			
		КонецЕсли;
		
		Если Не КомпонентыОбмена.ТолькоНастройкиXDTO Тогда
			Если ЧтениеXML.ТипУзла <> ТипУзлаXML.НачалоЭлемента
				Или ЧтениеXML.ЛокальноеИмя <> "Body" Тогда
				ЗаписатьВПротоколВыполнения(КомпонентыОбмена, 9);
				Прервать;
			КонецЕсли;
			
			ЧтениеXML.Прочитать(); // Body
		КонецЕсли;
		
		КомпонентыОбмена.ФлагОшибки = Ложь;
		
	КонецЦикла;
	
	Если КомпонентыОбмена.ФлагОшибки Тогда
		ЧтениеXML.Закрыть();
	Иначе
		КомпонентыОбмена.Вставить("ФайлОбмена", ЧтениеXML);
	КонецЕсли;
	
КонецПроцедуры

// Выполняет преобразование объекта XDTO в структуру с данными.
//
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - значение, которое необходимо преобразовать.
//
// Возвращаемое значение:
//  Структура - Структура, имитирующая объект XDTO.
//    Ключи структуры соответствуют свойствам объекта XDTO.
//    Значения соответствуют значениям свойств объекта XDTO.
//
Функция ОбъектXDTOВСтруктуру(ОбъектXDTO) Экспорт
	
	Приемник = Новый Структура;
	
	Для Каждого Свойство Из ОбъектXDTO.Свойства() Цикл
		
		КонвертацияСвойстваXDTOВЭлементСтруктуры(ОбъектXDTO, Свойство, Приемник);
		
	КонецЦикла;
	
	ЗначениеСсылки = Неопределено;
	Если Приемник.Свойство("КлючевыеСвойства")
		И Приемник.КлючевыеСвойства.Свойство("Ссылка", ЗначениеСсылки) Тогда
		Приемник.Вставить("Ссылка", ЗначениеСсылки);
	КонецЕсли;
	
	Возврат Приемник;
КонецФункции

// Преобразует строковое представление УИД в ссылку на объект текущей информационной базы.
// Сначала выполняется поиск УИД в регистре публичных идентификаторов.
// При удачном поиске возвращается ссылка из регистра, при неудачном
// возвращается либо ссылка с исходным УИД (если она еще не сопоставлена),
// либо выполняется генерация новой ссылки со случайным УИД.
// И в том и в другом случае в регистре публичных идентификаторов создается запись.
// 
// Параметры:
//  УИДОбъектаXDTO       - Строка - Уникальный идентификатор объекта XDTO, для которого необходимо 
//                                  получить ссылку соответствующего объекта информационной базы.
//
//  ТипЗначенияОбъектаИБ - Тип - Тип объекта информационной базы, которому должна соответствовать
//                               получаемая ссылка.
//
//  КомпонентыОбмена     - Структура - Содержит все необходимые данные, инициализированные при начале
//                                     выполнения обмена (ПКО, ПКПД, ПОД и т.д.).
//
// Возвращаемое значение:
//  СправочникСсылка, ДокументСсылка и т.п. - ссылка на объект информационной базы.
// 
Функция СсылкаОбъектаПоУИДОбъектаXDTO(УИДОбъектаXDTO, ТипЗначенияОбъектаИБ, КомпонентыОбмена) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Определение ссылки на объект через публичную ссылку.
	ПубличнаяСсылка = НайтиСсылкуПоПубличномуИдентификатору(УИДОбъектаXDTO, КомпонентыОбмена.УзелКорреспондента, ТипЗначенияОбъектаИБ);
	Если ПубличнаяСсылка <> Неопределено Тогда
		// Найден публичный идентификатор.
		Возврат ПубличнаяСсылка;
	КонецЕсли;
	
	// Поиск ссылки по исходному УИД.
	СсылкаПоУИД = СсылкаПоУИД(ТипЗначенияОбъектаИБ, УИДОбъектаXDTO, КомпонентыОбмена.УзелКорреспондента);
	
	// Найдена ссылка по УИД или создана новая ссылка.
	Возврат СсылкаПоУИД;
	
КонецФункции

// Записывает объект в информационную базу.
//
// Параметры:
//  КомпонентыОбмена - Структура - Содержит все необходимые данные, 
//                инициализированные при начале выполнения обмена (ПКО, ПКПД, ПОД и т.д.).
//  Объект - Произвольный - СправочникОбъект, ДокументОбъект и др записываемый объект.
//  Тип - Строка - Тип объекта строкой.
//  ЗаписатьОбъект - Булево - переменная принимает значение Ложь если запись объекта не была выполнена.
//  ОтправкаНазад - Булево - служебный флаг для установки соответствующего параметра обмена данными объекта.
//  УникальныйИдентификаторСтрокой - строка - уникальный идентификатор объекта в виде строки.
// 
Процедура ЗаписатьОбъектВИБ(КомпонентыОбмена, Объект, Тип, ЗаписатьОбъект = Ложь, Знач ОтправкаНазад = Ложь, УникальныйИдентификаторСтрокой = "") Экспорт
	
	Если Не РазрешенаЗаписьОбъекта(Объект, КомпонентыОбмена) Тогда
		СтрокаСообщенияОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Попытка изменения неразделенных данных (%1: %2) в разделенном режиме.'"),
			Объект.Метаданные().ПолноеИмя(), Строка(Объект));

		Если КомпонентыОбмена.СостояниеОбменаДанными.РезультатВыполненияОбмена = Неопределено
			Или КомпонентыОбмена.СостояниеОбменаДанными.РезультатВыполненияОбмена = Перечисления.РезультатыВыполненияОбмена.Выполнено Тогда
			КомпонентыОбмена.СостояниеОбменаДанными.РезультатВыполненияОбмена = Перечисления.РезультатыВыполненияОбмена.ВыполненоСПредупреждениями;
		КонецЕсли;
		
		КодОшибки = Новый Структура;
		КодОшибки.Вставить("КраткоеПредставлениеОшибки",   СтрокаСообщенияОбОшибке);
		КодОшибки.Вставить("ПодробноеПредставлениеОшибки", СтрокаСообщенияОбОшибке);
		КодОшибки.Вставить("Уровень",                      УровеньЖурналаРегистрации.Предупреждение);
		
		ЗаписатьВПротоколВыполнения(КомпонентыОбмена, КодОшибки, , Ложь);
		
		Объект = Неопределено;
		Возврат;
	КонецЕсли;
	
	Если КомпонентыОбмена.ЭтоОбменЧерезПланОбмена Тогда
		// Устанавливаем режим загрузки данных для объекта.
		ОбменДаннымиСервер.УстановитьОбменДаннымиЗагрузка(Объект,, ОтправкаНазад, КомпонентыОбмена.УзелКорреспондента);
	Иначе
		ОбменДаннымиСервер.УстановитьОбменДаннымиЗагрузка(Объект,, ОтправкаНазад);
	КонецЕсли;
	
	// Выполняем проверку на пометку удаления предопределенного элемента.
	СнятьПометкуУдаленияСПредопределенногоЭлемента(Объект, Тип, КомпонентыОбмена);
	
	НачатьТранзакцию();
	Попытка
		
		// Записываем объект в транзакцию.
		Объект.Записать();
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		ОтменитьТранзакцию();
		
		ЗаписатьОбъект = Ложь;
		
		ЗП         = ЗаписьПротоколаОбмена(26, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ЗП.Объект  = Объект;
		
		Если Тип <> Неопределено Тогда
			ЗП.ТипОбъекта = Тип;
		КонецЕсли;
		
		ЗаписатьВПротоколВыполнения(КомпонентыОбмена, 26, ЗП);
		
		ВызватьИсключение КомпонентыОбмена.СтрокаСообщенияОбОшибке;
		
	КонецПопытки;
	
КонецПроцедуры

// Выполняет отложенное проведение загруженных документов после загрузки всех данных.
//
// Параметры:
//  КомпонентыОбмена - Структура - содержит все правила и параметры обмена.
//
Процедура ВыполнитьОтложенноеПроведениеДокументов(КомпонентыОбмена) Экспорт
	
	ОбменДаннымиСервер.ВыполнитьОтложенноеПроведениеДокументов(
		КомпонентыОбмена.ДокументыДляОтложенногоПроведения,
		КомпонентыОбмена.УзелКорреспондента);
	
КонецПроцедуры

// Выполняет проведение документа при его загрузке в информационную базу.
//
// Параметры:
//  КомпонентыОбмена                         - Структура - содержит все правила и параметры обмена.
//  Объект                                   - ДокументОбъект - Загруженный документ.
//  РегистрироватьПроблемыВРезультатахОбмена - Булево - необходимо регистрировать проблемы.
//
Процедура ВыполнитьПроведениеДокументаПриЗагрузке(
		КомпонентыОбмена,
		Объект,
		РегистрироватьПроблемыВРезультатахОбмена = Истина) Экспорт
	
	ОбменДаннымиСервер.ВыполнитьПроведениеДокументаПриЗагрузке(
		КомпонентыОбмена.УзелКорреспондента,
		Объект.Ссылка,
		РегистрироватьПроблемыВРезультатахОбмена);
	
КонецПроцедуры

// Отменяет проведение объекта в информационной базе.
//
// Параметры:
//  Объект      - ДокументОбъект - Документ для отмены проведения.
//  Отправитель - ПланОбменаСсылка - Ссылка на узел плана обмена, который является отправителем данных.
//
// Возвращаемое значение:
//   Булево - признак успешной отмены проведения.
Функция ОтменитьПроведениеОбъектаВИБ(Объект, Отправитель) Экспорт
	
	РегистрыСведений.РезультатыОбменаДанными.ЗарегистрироватьУстранениеПроблемы(Объект,
		Перечисления.ТипыПроблемОбменаДанными.НепроведенныйДокумент);
	
	// Устанавливаем режим загрузки данных для объекта.
	ОбменДаннымиСервер.УстановитьОбменДаннымиЗагрузка(Объект, Истина, Ложь, Отправитель);
	
	// Проверка на коллизии дат запрета загрузки.
	Объект.ДополнительныеСвойства.Вставить("ПропуститьПроверкуЗапретаИзменения");
	
	ПроведениеДокументаОтменено = Ложь;
	
	НачатьТранзакцию();
	Попытка
		
		// Отменяем проведение документа.
		Объект.Проведен = Ложь;
		Объект.Записать();
		
		ОбменДаннымиСервер.УдалитьДвиженияУДокумента(Объект);
		ПроведениеДокументаОтменено = Истина;
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
	КонецПопытки;
	
	Возврат ПроведениеДокументаОтменено;
	
КонецФункции

// Процедура заполняет табличную часть объекта с учетом предыдущей версии табличной части (до загрузки данных).
//
// Параметры:
//  ТабличнаяЧастьОбъектаПослеОбработки - ТабличнаяЧасть - Табличная часть, которая содержит измененные данные.
//  ТабличнаяЧастьОбъектаДоОбработки    - ТаблицаЗначений - Таблица значений, содержимое табличной части объекта до
//                                                          загрузки данных.
//  КлючевыеПоля                        - Строка - Колонки, по которым происходит поиск строк в табличной части (строка через
//                                        запятую).
//  КолонкиДляВключения                 - Строка - Другие колонки (кроме ключевых), значения которых должны измениться (строка
//                                        через запятую).
//  КолонкиДляИсключения                - Строка - Колонки, значения которых не должны измениться (строка через запятую).
//
Процедура ЗаполнитьТабличнуюЧастьОбъектаНачальнымиДанными(
	ТабличнаяЧастьОбъектаПослеОбработки, 
	ТабличнаяЧастьОбъектаДоОбработки,
	Знач КлючевыеПоля = "",
	КолонкиДляВключения = "", 
	КолонкиДляИсключения = "") Экспорт
	
	Если ТипЗнч(КлючевыеПоля) = Тип("Строка") Тогда
		Если КлючевыеПоля = "" Тогда
			Возврат; // Без ключевых полей нельзя получить соответствие новых и старых данных.
		Иначе
			КлючевыеПоля = СтрРазделить(КлючевыеПоля, ",");
		КонецЕсли;
	КонецЕсли;
	
	СоответствиеСтарыхИНовыхДанныхТЧ = СоответствиеСтарыхИНовыхДанныхТЧ(
		ТабличнаяЧастьОбъектаПослеОбработки, 
		ТабличнаяЧастьОбъектаДоОбработки,
		КлючевыеПоля);
	
	Для Каждого СтрокаНовойТЧ Из ТабличнаяЧастьОбъектаПослеОбработки Цикл
		СтрокаСтаройТЧ = СоответствиеСтарыхИНовыхДанныхТЧ.Получить(СтрокаНовойТЧ);
		Если СтрокаСтаройТЧ <> Неопределено Тогда
			ЗаполнитьЗначенияСвойств(СтрокаНовойТЧ, СтрокаСтаройТЧ, КолонкиДляВключения, КолонкиДляИсключения);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

// Возвращает таблицу поддерживаемых в обмене объектов формата для указанного плана обмена.
// Перечень формируется на основании правил обмена из модулей менеджера обмена по соответствующим версиям.
//
// Параметры:
//  ИмяПланаОбмена - Строка - Имя плана обмена XDTO.
//  Режим          - Строка - Вид запрашиваемой информации: "Отправка" | "Получение" | "ОтправкаПолучение".
//                            "Отправка" - будут возвращены все объекты, для которых поддерживается отправка;
//                            "Получение" - будут возвращены все объекты, для которых поддерживается получение;
//                            "ОтправкаПолучение" - будут возвращены все поддерживаемые объекты.
//                            По умолчанию "ОтправкаПолучение".
//  УзелОбмена     - ПланОбменаСсылка, Неопределено - узел плана обмена, соответствующий корреспонденту.
//
// Возвращаемое значение:
//  ТаблицаЗначений - состав поддерживаемых объектов формата в разрезе версий.
//    * Версия    - Строка - Версия формата, например, "1.5".
//    * Объект    - Строка - Имя объекта формата, например, "Справочник.Номенклатура".
//    * Отправка  - Булево - Признак поддержки отправки данного объекта формата.
//    * Получение - Булево - Признак поддержки получения данного объекта формата.
//
Функция ПоддерживаемыеОбъектыФормата(ИмяПланаОбмена, Режим = "ОтправкаПолучение", УзелОбмена = Неопределено) Экспорт
	
	ТаблицаОбъекты = Новый ТаблицаЗначений;
	ИнициализироватьТаблицуПоддерживаемыхОбъектовФормата(ТаблицаОбъекты, Режим);
	
	ВерсииФормата = ОбменДаннымиСервер.ЗначениеНастройкиПланаОбмена(ИмяПланаОбмена, "ВерсииФорматаОбмена");
	
	Для Каждого Версия Из ВерсииФормата Цикл
		
		Если СтрНайти(Режим, "Отправка") Тогда
			КомпонентыОбмена = ИнициализироватьКомпонентыОбмена("Отправка");
			
			КомпонентыОбмена.ВерсияФорматаОбмена = Версия.Ключ;
			КомпонентыОбмена.МенеджерОбмена = Версия.Значение;
			
			КомпонентыОбмена.XMLСхема = ФорматОбмена(ИмяПланаОбмена, КомпонентыОбмена.ВерсияФорматаОбмена);
			
			ИнициализироватьТаблицыПравилОбмена(КомпонентыОбмена);
			
			ЗаполнитьПоддерживаемыеОбъектыФорматаПоКомпонентамОбмена(ТаблицаОбъекты, КомпонентыОбмена);
		КонецЕсли;
		
		Если СтрНайти(Режим, "Получение") Тогда
			КомпонентыОбмена = ИнициализироватьКомпонентыОбмена("Получение");
			
			КомпонентыОбмена.ВерсияФорматаОбмена = Версия.Ключ;
			КомпонентыОбмена.МенеджерОбмена = Версия.Значение;
			
			КомпонентыОбмена.XMLСхема = ФорматОбмена(ИмяПланаОбмена, КомпонентыОбмена.ВерсияФорматаОбмена);
			
			ИнициализироватьТаблицыПравилОбмена(КомпонентыОбмена);
			
			ЗаполнитьПоддерживаемыеОбъектыФорматаПоКомпонентамОбмена(ТаблицаОбъекты, КомпонентыОбмена);
		КонецЕсли;
		
	КонецЦикла;
	
	ЕстьАлгоритм = ОбменДаннымиСервер.ЕстьАлгоритмМенеджераПланаОбмена(
		"ПриОпределенииПоддерживаемыхОбъектовФормата", ИмяПланаОбмена);
	Если ЕстьАлгоритм Тогда
		ПланыОбмена[ИмяПланаОбмена].ПриОпределенииПоддерживаемыхОбъектовФормата(ТаблицаОбъекты, Режим, УзелОбмена);
	КонецЕсли;
	
	Возврат ТаблицаОбъекты;
	
КонецФункции

// Возвращает таблицу поддерживаемых в обмене объектов формата для указанного корреспондента.
//
// Параметры:
//  УзелОбмена - ПланОбменаСсылка - Узел плана обмена XDTO соответствующего корреспондента.
//  Режим          - Строка - Вид запрашиваемой информации: "Отправка" | "Получение" | "ОтправкаПолучение".
//                            "Отправка" - будут возвращены все объекты, для которых поддерживается отправка;
//                            "Получение" - будут возвращены все объекты, для которых поддерживается получение;
//                            "ОтправкаПолучение" - будут возвращены все поддерживаемые объекты.
//                            По умолчанию "ОтправкаПолучение".
//
// Возвращаемое значение:
//  ТаблицаЗначений - состав поддерживаемых объектов формата в разрезе версий.
//    * Версия    - Строка - Версия формата, например, "1.5".
//    * Объект    - Строка - Имя объекта формата, например, "Справочник.Номенклатура".
//    * Отправка  - Булево - Признак поддержки корреспондентом отправки данного объекта формата.
//    * Получение - Булево - Признак поддержки корреспондентом получения данного объекта формата.
//
Функция ПоддерживаемыеОбъектыФорматаКорреспондента(УзелОбмена, Режим = "ОтправкаПолучение") Экспорт
	
	ТаблицаОбъекты = Новый ТаблицаЗначений;
	ИнициализироватьТаблицуПоддерживаемыхОбъектовФормата(ТаблицаОбъекты, Режим);
	
	НастройкиКорреспондента = РегистрыСведений.НастройкиОбменаДаннымиXDTO.ЗначениеНастройкиКорреспондента(УзелОбмена, "ПоддерживаемыеОбъекты");
	
	Если Не НастройкиКорреспондента = Неопределено Тогда
		
		Для Каждого СтрокаНастройкиКорреспондента Из НастройкиКорреспондента Цикл
			
			Если (СтрНайти(Режим, "Отправка") И СтрокаНастройкиКорреспондента.Отправка)
				Или (СтрНайти(Режим, "Получение") И СтрокаНастройкиКорреспондента.Получение) Тогда
				СтрокаОбъекты = ТаблицаОбъекты.Добавить();
				ЗаполнитьЗначенияСвойств(СтрокаОбъекты, СтрокаНастройкиКорреспондента);
			КонецЕсли;
			
		КонецЦикла;
		
	Иначе
		
		Если Не ОбменДаннымиСервер.НастройкаСинхронизацииЗавершена(УзелОбмена) Тогда
			Возврат ТаблицаОбъекты;
		КонецЕсли;
		
		ИмяПланаОбмена = ОбменДаннымиПовтИсп.ПолучитьИмяПланаОбмена(УзелОбмена);
		
		ТаблицаОбъектыБазы = ПоддерживаемыеОбъектыФормата(ИмяПланаОбмена,
			"ОтправкаПолучение", ?(УзелОбмена.Пустая(), Неопределено, УзелОбмена));
		
		Для Каждого СтрокаОбъектыБазы Из ТаблицаОбъектыБазы Цикл
			
			СтрокаОбъектыКорреспондента = ТаблицаОбъекты.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаОбъектыКорреспондента, СтрокаОбъектыБазы, "Версия, Объект");
			
			Если СтрНайти(Режим, "Отправка") > 0 Тогда
				СтрокаОбъектыКорреспондента.Отправка = СтрокаОбъектыБазы.Получение;
			КонецЕсли;
			Если СтрНайти(Режим, "Получение") > 0 Тогда
				СтрокаОбъектыКорреспондента.Получение = СтрокаОбъектыБазы.Отправка;
			КонецЕсли;
			
		КонецЦикла;		
	КонецЕсли;
	
	ИмяПланаОбмена = ОбменДаннымиПовтИсп.ПолучитьИмяПланаОбмена(УзелОбмена);
	ЕстьАлгоритм = ОбменДаннымиСервер.ЕстьАлгоритмМенеджераПланаОбмена(
		"ПриОпределенииПоддерживаемыхКорреспондентомОбъектовФормата", ИмяПланаОбмена);
	Если ЕстьАлгоритм Тогда
		ПланыОбмена[ИмяПланаОбмена].ПриОпределенииПоддерживаемыхКорреспондентомОбъектовФормата(УзелОбмена, ТаблицаОбъекты, Режим);
	КонецЕсли;
	
	ТаблицаОбъекты.Индексы.Добавить("Объект");
	
	Возврат ТаблицаОбъекты;
	
КонецФункции

// Возвращает признак режима пропуска при выгрузке объектов формата, не прошедших проверку по схеме.
// Может быть использована для установки нового значения режима.
//
// Параметры:
//   УзелИнформационнойБазы - ПланОбменаСсылка - узел плана обмена, соответствующий корреспонденту.
//   НовоеЗначение - Булево, Неопределено - новое значение режима для установки.
//                                          Если Неопределено, то значение режима не изменяется.
//
// Возвращаемое значение:
//   Булево - Истина, если при отправке данных необходимо пропускать объекты формата.
//
Функция ПропускатьОбъектыСОшибкамиПроверкиПоСхеме(УзелИнформационнойБазы, НовоеЗначение = Неопределено) Экспорт
	
	Режим = Ложь;
	
	УстановитьПривилегированныйРежим(Истина);
	
	МенеджерЗаписи = РегистрыСведений.НастройкиОбменаДаннымиXDTO.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.УзелИнформационнойБазы = УзелИнформационнойБазы;
	МенеджерЗаписи.Прочитать();
	
	Если НовоеЗначение = Неопределено Тогда
		Если МенеджерЗаписи.Выбран() Тогда
			Режим = МенеджерЗаписи.ПропускатьОбъектыСОшибкамиПроверкиПоСхеме;
		КонецЕсли;
	Иначе
		МенеджерЗаписи.ПропускатьОбъектыСОшибкамиПроверкиПоСхеме = НовоеЗначение;
		МенеджерЗаписи.Записать(Истина);
		
		Режим = НовоеЗначение;
	КонецЕсли;
	
	Возврат Режим;
	
КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

#Область ИнициализацияОбмена
// Создает таблицу значений для хранения заголовка пакета с данными.
//
// Возвращаемое значение:
//  ТаблицаЗначений - набор данных заголовка пакета:
//    * ТипОбъектаСтрокой - Строка -
//    * КоличествоОбъектовВИсточнике - Число -
//    * ПоляПоиска - Строка -
//    * ПоляТаблицы - Строка -
//    * ТипИсточникаСтрокой - Строка -
//    * ТипПриемникаСтрокой - Строка -
//    * СинхронизироватьПоИдентификатору - Булево -
//    * ЭтоУдалениеОбъекта - Булево -
//    * ЭтоКлассификатор - Булево -
//    * ИспользоватьПредварительныйПросмотр - Булево -
//
Функция НоваяТаблицаДанныхЗаголовкаПакета() Экспорт
	
	ТаблицаДанныхЗаголовкаПакета = Новый ТаблицаЗначений;
	Колонки = ТаблицаДанныхЗаголовкаПакета.Колонки;
	
	Колонки.Добавить("ТипОбъектаСтрокой",            Новый ОписаниеТипов("Строка"));
	Колонки.Добавить("КоличествоОбъектовВИсточнике", Новый ОписаниеТипов("Число"));
	Колонки.Добавить("ПоляПоиска",                   Новый ОписаниеТипов("Строка"));
	Колонки.Добавить("ПоляТаблицы",                  Новый ОписаниеТипов("Строка"));
	
	Колонки.Добавить("ТипИсточникаСтрокой", Новый ОписаниеТипов("Строка"));
	Колонки.Добавить("ТипПриемникаСтрокой", Новый ОписаниеТипов("Строка"));
	
	Колонки.Добавить("СинхронизироватьПоИдентификатору", Новый ОписаниеТипов("Булево"));
	Колонки.Добавить("ЭтоУдалениеОбъекта", Новый ОписаниеТипов("Булево"));
	Колонки.Добавить("ЭтоКлассификатор", Новый ОписаниеТипов("Булево"));
	Колонки.Добавить("ИспользоватьПредварительныйПросмотр", Новый ОписаниеТипов("Булево"));
	
	Возврат ТаблицаДанныхЗаголовкаПакета;
	
КонецФункции

// Получает правила регистрации объектов для плана обмена.
//
// Возвращаемое значение:
//  ТаблицаЗначений - 
//
Функция ПравилаРегистрацииОбъектов(УзелПланаОбмена) Экспорт
	
	ПравилаРегистрацииОбъектов = ОбменДаннымиСобытия.ПравилаРегистрацииОбъектовПланаОбмена(
		ОбменДаннымиПовтИсп.ПолучитьИмяПланаОбмена(УзелПланаОбмена));
	ТаблицаПравилаРегистрацииОбъектов = ПравилаРегистрацииОбъектов.Скопировать(, "ОбъектМетаданныхИмя, ИмяРеквизитаФлага");
	ТаблицаПравилаРегистрацииОбъектов.Индексы.Добавить("ОбъектМетаданныхИмя");
	
	Возврат ТаблицаПравилаРегистрацииОбъектов;
	
КонецФункции

// Параметры:
//   XMLСхема - Строка -
//   МенеджерОбмена - ОбщийМодуль -
//   НаправлениеОбмена - Строка -
// 
// Возвращаемое значение:
//   ТаблицаЗначений - таблица правил обработки (ПОД):
//     * Имя - Строка -
//     * ОбъектВыборкиФормат - Строка -
//     * ТипСсылкиXDTO - ТипЗначенияXDTO, ТипОбъектаXDTO -
//     * ОбъектВыборкиМетаданные - ОбъектМетаданных -
//     * ВыборкаДанных - Строка -
//     * ИмяТаблицыДляВыборки - Строка -
//     * ПриОбработке - Строка -
//     * ИспользуемыеПКО - Массив из Строка -
// 
Функция ТаблицаПравилОбработкиДанных(XMLСхема, МенеджерОбмена , НаправлениеОбмена) Экспорт
	
	// Инициализация таблицы правил обработки данных.
	ПравилаОбработкиДанных = Новый ТаблицаЗначений;
	ПравилаОбработкиДанных.Колонки.Добавить("Имя");
	ПравилаОбработкиДанных.Колонки.Добавить("ОбъектВыборкиФормат");
	ПравилаОбработкиДанных.Колонки.Добавить("ТипСсылкиXDTO");
	ПравилаОбработкиДанных.Колонки.Добавить("ОбъектВыборкиМетаданные");
	ПравилаОбработкиДанных.Колонки.Добавить("ВыборкаДанных");
	ПравилаОбработкиДанных.Колонки.Добавить("ИмяТаблицыДляВыборки");
	ПравилаОбработкиДанных.Колонки.Добавить("ПриОбработке", Новый ОписаниеТипов("Строка"));
	
	// ИспользуемыеПКО - массив, содержащий в себе имена ПКО, в которые может быть направлен объект из данного ПОД.
	ПравилаОбработкиДанных.Колонки.Добавить("ИспользуемыеПКО", Новый ОписаниеТипов("Массив"));
	
	МенеджерОбмена.ЗаполнитьПравилаОбработкиДанных(НаправлениеОбмена, ПравилаОбработкиДанных);
	
	КоличествоСтрок = ПравилаОбработкиДанных.Количество();
	Для НомерИтерации = 1 По КоличествоСтрок Цикл
		
		ИндексСтроки = КоличествоСтрок - НомерИтерации;
		ПОД = ПравилаОбработкиДанных.Получить(ИндексСтроки);
		
		Если НаправлениеОбмена = "Получение" Тогда
			
			ТипXDTO = ФабрикаXDTO.Тип(XMLСхема, ПОД.ОбъектВыборкиФормат);
			
			Если ТипXDTO = Неопределено Тогда
				ПравилаОбработкиДанных.Удалить(ПОД);
				Продолжить;
			КонецЕсли;
			
			КлючевыеСвойства = ТипXDTO.Свойства.Получить("КлючевыеСвойства");
			Если КлючевыеСвойства <> Неопределено Тогда
				
				ТипКлючевыхСвойствОбъектаXDTO = КлючевыеСвойства.Тип;
				СвойствоСсылкаXDTO = ТипКлючевыхСвойствОбъектаXDTO.Свойства.Получить("Ссылка");
				Если СвойствоСсылкаXDTO <> Неопределено Тогда
					ПОД.ТипСсылкиXDTO = СвойствоСсылкаXDTO.Тип;
				КонецЕсли;
				
			КонецЕсли;
			
		ИначеЕсли ПОД.ОбъектВыборкиМетаданные <> Неопределено Тогда
			ПОД.ИмяТаблицыДляВыборки = ПОД.ОбъектВыборкиМетаданные.ПолноеИмя();
		КонецЕсли;
		
	КонецЦикла;
	
	Если НаправлениеОбмена = "Отправка" Тогда
		ПравилаОбработкиДанных.Индексы.Добавить("Имя");
		ПравилаОбработкиДанных.Индексы.Добавить("ОбъектВыборкиМетаданные");
	Иначе
		ПравилаОбработкиДанных.Индексы.Добавить("ОбъектВыборкиФормат");
		ПравилаОбработкиДанных.Индексы.Добавить("ТипСсылкиXDTO");
	КонецЕсли;
	
	Возврат ПравилаОбработкиДанных;
КонецФункции

// Получает свойства узла плана обмена.
//
// Возвращаемое значение:
//  Структура (ключ соответствует имени свойства, а значение - значению свойства).
Функция СвойстваУзлаПланаОбмена(Узел) Экспорт
	
	СвойстваУзлаПланаОбмена = Новый Структура;
	
	// получаем имена реквизитов
	ИменаРеквизитов = ОбщегоНазначения.ИменаРеквизитовПоТипу(Узел, Тип("ПеречислениеСсылка.РежимыВыгрузкиОбъектовОбмена"));
	
	// Получаем значения реквизитов.
	Если Не ПустаяСтрока(ИменаРеквизитов) Тогда
		
		СвойстваУзлаПланаОбмена = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Узел, ИменаРеквизитов);
		
	КонецЕсли;
	
	Возврат СвойстваУзлаПланаОбмена;
КонецФункции

#КонецОбласти

#Область ПолучениеДанных

// Функция проверяет формат сообщения обмена: соответствует ли он формату обмена через EnterpriseData.
//
// Параметры:
//  ЧтениеXML - ЧтениеXML - сообщение обмена.
//
// Возвращаемое значение
//  Истина - формат соответствует, ложь - не соответствует.
Функция ПроверитьФорматСообщенияОбмена(ЧтениеXML) Экспорт
	
	Если (ЧтениеXML.ТипУзла <> ТипУзлаXML.НачалоЭлемента
		Или ЧтениеXML.ЛокальноеИмя <> "Message") Тогда
		Возврат Ложь;
	КонецЕсли;
		
	ЧтениеXML.Прочитать(); // Header
	Если ЧтениеXML.ТипУзла <> ТипУзлаXML.НачалоЭлемента
		Или ЧтениеXML.ЛокальноеИмя <> "Header" Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Попытка
		Header = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML, ФабрикаXDTO.Тип(XMLБазоваяСхема(), "Header"));
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
	Если ЧтениеXML.ТипУзла <> ТипУзлаXML.НачалоЭлемента
		Или ЧтениеXML.ЛокальноеИмя <> "Body" Тогда
		Возврат Ложь;
	КонецЕсли;
	Если Не Header.Установлено("Confirmation") Тогда
		Возврат Ложь;
	КонецЕсли;
	Confirmation = Header.Confirmation;
	
	ИмяПланаОбмена = Confirmation.ExchangePlan;
	
	Если Метаданные.ПланыОбмена.Найти(ИмяПланаОбмена) = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	Возврат Истина;
КонецФункции

Процедура ПослеОткрытияФайлаЗагрузки(КомпонентыОбмена, Отказ, ИнициализироватьТаблицыПравил = Истина) Экспорт
	
	Если КомпонентыОбмена.ФлагОшибки Тогда
		ЗавершитьВедениеПротоколаОбмена(КомпонентыОбмена);
		Если КомпонентыОбмена.Свойство("ФайлОбмена") Тогда
			КомпонентыОбмена.ФайлОбмена.Закрыть();
		КонецЕсли;
		Отказ = Истина;
		Возврат;
	КонецЕсли;
	
	Если КомпонентыОбмена.ЭтоОбменЧерезПланОбмена Тогда
		
		Если КомпонентыОбмена.ОбменДаннымиСВнешнейСистемой Тогда
			ИзмененИдентификаторУзла = Ложь;
			ИнформационноеСообщение  = "";
			
			НачатьТранзакцию();
			Попытка
				Блокировка = Новый БлокировкаДанных;
				ЭлементБлокировки = Блокировка.Добавить(ОбщегоНазначения.ИмяТаблицыПоСсылке(КомпонентыОбмена.УзелКорреспондента));
				ЭлементБлокировки.УстановитьЗначение("Ссылка", КомпонентыОбмена.УзелКорреспондента);
				Блокировка.Заблокировать();
				
				КодУзлаКорреспондента = СокрЛП(ОбщегоНазначения.ЗначениеРеквизитаОбъекта(КомпонентыОбмена.УзелКорреспондента, "Код"));
				Если ЗначениеЗаполнено(КомпонентыОбмена.ИдентификаторКорреспондента)
					И Не КодУзлаКорреспондента = КомпонентыОбмена.ИдентификаторКорреспондента Тогда
					УзелКорреспондентаОбъект = КомпонентыОбмена.УзелКорреспондента.ПолучитьОбъект();
					УзелКорреспондентаОбъект.Код = КомпонентыОбмена.ИдентификаторКорреспондента;
					УзелКорреспондентаОбъект.ОбменДанными.Загрузка = Истина;
					УзелКорреспондентаОбъект.Записать();
					
					ИзмененИдентификаторУзла = Истина;
					
					ИнформационноеСообщение = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Изменен идентификатор узла корреспондента (%1 -> %2).'"),
						КодУзлаКорреспондента,
						КомпонентыОбмена.ИдентификаторКорреспондента);
				КонецЕсли;
			
				ЗафиксироватьТранзакцию();
			Исключение
				ОтменитьТранзакцию();
				ВызватьИсключение;
			КонецПопытки;
			
			Если ИзмененИдентификаторУзла Тогда
				ЗаписатьВПротоколВыполнения(КомпонентыОбмена, ИнформационноеСообщение, , Ложь, , , Истина);
			КонецЕсли;
			
		КонецЕсли;
		
		ОбновитьНастройкиXDTOКорреспондента(КомпонентыОбмена);
		ОбновитьПрефиксКорреспондента(КомпонентыОбмена);
		
		Если Не КомпонентыОбмена.ТолькоНастройкиXDTO
			И ИнициализироватьТаблицыПравил Тогда
			ИнициализироватьТаблицыПравилОбмена(КомпонентыОбмена);
			ЗаполнитьСтруктуруНастроекXDTO(КомпонентыОбмена);
			ЗаполнитьПоддерживаемыеОбъектыXDTO(КомпонентыОбмена);
		КонецЕсли;
	КонецЕсли;
	
	Если КомпонентыОбмена.ТолькоНастройкиXDTO Тогда
		Если КомпонентыОбмена.Свойство("ФайлОбмена") Тогда
			КомпонентыОбмена.ФайлОбмена.Закрыть();
		КонецЕсли;
		Отказ = Истина;
		Возврат;
	КонецЕсли;
	
	Если КомпонентыОбмена.ЭтоОбменЧерезПланОбмена Тогда
		ИмяПланаОбмена = ОбменДаннымиПовтИсп.ПолучитьИмяПланаОбмена(КомпонентыОбмена.УзелКорреспондента);
		
		Если ОбменДаннымиСервер.ЕстьАлгоритмМенеджераПланаОбмена("ОбработчикПроверкиЗначенийПоУмолчанию", ИмяПланаОбмена) Тогда
			
			СообщениеОбОшибке = "";
			
			ПараметрыОбработчика = Новый Структура;
			ПараметрыОбработчика.Вставить("Корреспондент", КомпонентыОбмена.УзелКорреспондента);
			ПараметрыОбработчика.Вставить("ПоддерживаемыеОбъектыXDTO", КомпонентыОбмена.ПоддерживаемыеОбъектыXDTO);
			
			ПланыОбмена[ИмяПланаОбмена].ОбработчикПроверкиЗначенийПоУмолчанию(Отказ, ПараметрыОбработчика, СообщениеОбОшибке);
			
			Если Отказ Тогда
				ЗаписатьВПротоколВыполнения(КомпонентыОбмена, СообщениеОбОшибке);
				ЗавершитьВедениеПротоколаОбмена(КомпонентыОбмена);
				Возврат;
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ПроцедурыИФункцииВерсионированияФорматаОбмена
// Возвращает менеджер обмена данными, соответствующий указанной версии формата обмена.
//
// Параметры:
//  ВерсияФормата - Строка.
//  УзелИнформационнойБазы - ПланОбменаСсылка - узел плана обмена, для которого необходимо получить менеджер обмена.
//                                              Если обмен через формат осуществляется без использования плана обмена,
//                                              УзелИнформационнойБазы не передается.
//
Функция МенеджерОбменаВерсииФормата(Знач ВерсияФормата, Знач УзелИнформационнойБазы = Неопределено) Экспорт
	
	Результат = ВерсииФорматаОбмена(УзелИнформационнойБазы).Получить(ВерсияФормата);
	
	Если Результат = Неопределено Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не определен Менеджер конвертации для версии формата обмена <%1>.'"),
			ВерсияФормата);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает строку с форматом обмена.
// Формат обмена включает: 
//  Базовый формат, предусмотренный для плана обмена.
//  Версию базового формата.
//
// Параметры:
//  ИмяПланаОбмена - Строка.
//  ВерсияФормата - Строка.
//
Функция ФорматОбмена(Знач ИмяПланаОбмена, Знач ВерсияФормата) Экспорт
	
	ФорматОбмена = ОбменДаннымиСервер.ЗначениеНастройкиПланаОбмена(ИмяПланаОбмена, "ФорматОбмена");
	
	Если Не ПустаяСтрока(ВерсияФормата) Тогда
		ФорматОбмена = ФорматОбмена + "/" + ВерсияФормата;
	КонецЕсли;
	
	Возврат ФорматОбмена;
	
КонецФункции

// Возвращает строку с номером версии формата обмена, поддерживаемой получателем данных.
//
// Параметры:
//  Получатель - ссылка на узел плана обмена, в который производится выгрузка данных.
//
Функция ВерсияФорматаОбменаПриВыгрузке(Знач Получатель) Экспорт
	
	Результат = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Получатель, "ВерсияФорматаОбмена");
	Если Не ЗначениеЗаполнено(Результат) Тогда
		
		// Если версия формата обмена не задана, то используем минимальную версию.
		Результат = МинимальнаяВерсияФорматаОбмена(Получатель);
		
	КонецЕсли;
	
	Возврат СокрЛП(Результат);
КонецФункции

// Возвращает признак поддерживается ли для узла версия формата, для которой предусмотрена кодировка узлов
//  с использованием уникальных идентификаторов.
//
Функция ПоддерживаетсяВерсияСИдентификаторомОбменаДанными(Знач УзелИнформационнойБазы) Экспорт
	
	ИмяПланаОбмена = ОбменДаннымиПовтИсп.ПолучитьИмяПланаОбмена(УзелИнформационнойБазы);
	
	Если УзелИнформационнойБазы = ПланыОбмена[ИмяПланаОбмена].ЭтотУзел()
		Или Не ЗначениеЗаполнено(УзелИнформационнойБазы) Тогда
		ПоддерживаемыеВерсии = ВерсииФорматаОбменаМассив(УзелИнформационнойБазы);
	Иначе
		ПоддерживаемыеВерсии = Новый Массив;
		ПоддерживаемыеВерсии.Добавить(ОбщегоНазначения.ЗначениеРеквизитаОбъекта(УзелИнформационнойБазы, "ВерсияФорматаОбмена"));
	КонецЕсли;
	
	Возврат ВерсияПоддерживается(ПоддерживаемыеВерсии, НомерВерсииСПоддержкойИдентификатораОбменаДанными());
	
КонецФункции

Функция МаксимальнаяОбщаяВерсияФормата(ИмяПланаОбмена, ВерсииФорматаКорреспондента) Экспорт
	
	МаксимальнаяОбщаяВерсия = "0.0";
	
	ВерсииФормата = ВерсииФорматаОбменаМассив(ПланыОбмена[ИмяПланаОбмена].ЭтотУзел());
	
	Для Каждого ВерсияКорреспондента Из ВерсииФорматаКорреспондента Цикл
		ВерсияКорреспондента = СокрЛП(ВерсияКорреспондента);
		
		Если ВерсииФормата.Найти(ВерсияКорреспондента) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если СравнитьВерсии(ВерсияКорреспондента, МаксимальнаяОбщаяВерсия) >= 0 Тогда
			МаксимальнаяОбщаяВерсия = ВерсияКорреспондента;
		КонецЕсли;
	КонецЦикла;
	
	Возврат МаксимальнаяОбщаяВерсия;
	
КонецФункции

#КонецОбласти

#Область Прочее

// Процедура добавляет объект информационной базы в фильтр разрешенных объектов.
// Параметры:
//  Данные     - ссылка на объект ИБ, который необходимо добавить в фильтр разрешенных объектов.
//  Получатель - ПланОбменаСсылка - ссылка на план обмена, для которого выполняется проверка объекта.
//
Процедура ДобавитьОбъектВФильтрРазрешенныхОбъектов(Данные, Получатель) Экспорт
	
	РегистрыСведений.ДанныеОбъектовДляРегистрацииВОбменах.ДобавитьОбъектВФильтрРазрешенныхОбъектов(Данные, Получатель);
	
КонецПроцедуры

// Функция возвращает массив узлов, в которые объект ранее выгружался.
//
// Параметры:
//  Ссылка            - Ссылка на объект ИБ, для которого необходимо получить массив узлов.
//  ИмяПланаОбмена    - Строка - имя плана обмена, как объекта метаданных, по которому определяются узлы.
//  ИмяРеквизитаФлага - Строка - имя реквизита плана обмена, по которому устанавливается фильтр на выборку узлов.
// Возвращаемое значение:
//  МассивУзлов - Массив узлов плана обмена, для которых установлен признак «Выгружать при необходимости», изначально
//                пуст.
//
Функция МассивУзловДляРегистрацииВыгружатьПриНеобходимости(Ссылка, ИмяПланаОбмена, ИмяРеквизитаФлага) Экспорт
	
	ТекстЗапроса = "
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ШапкаПланаОбмена.Ссылка КАК Узел
	|ИЗ
	|	ПланОбмена.[ИмяПланаОбмена] КАК ШапкаПланаОбмена
	|ЛЕВОЕ СОЕДИНЕНИЕ
	|	РегистрСведений.ДанныеОбъектовДляРегистрацииВОбменах КАК ДанныеОбъектовДляРегистрацииВОбменах
	|ПО
	|	ШапкаПланаОбмена.Ссылка = ДанныеОбъектовДляРегистрацииВОбменах.УзелИнформационнойБазы
	|	И ДанныеОбъектовДляРегистрацииВОбменах.Ссылка = &Объект
	|ГДЕ
	|	     НЕ ШапкаПланаОбмена.ЭтотУзел
	|	И    ШапкаПланаОбмена.[ИмяРеквизитаФлага] = ЗНАЧЕНИЕ(Перечисление.РежимыВыгрузкиОбъектовОбмена.ВыгружатьПриНеобходимости)
	|	И НЕ ШапкаПланаОбмена.ПометкаУдаления
	|	И    ДанныеОбъектовДляРегистрацииВОбменах.Ссылка = &Объект
	|";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяПланаОбмена]",    ИмяПланаОбмена);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяРеквизитаФлага]", ИмяРеквизитаФлага);
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Объект",   Ссылка);
	
	МассивУзлов = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Узел");
	
	Возврат МассивУзлов;
	
КонецФункции

// Выполняет запись сообщения в журнал регистрации.
//
// Параметры:
//  Комментарий      - Строка, комментарий для записи в журнал регистрации.
//  Уровень          - Уровень сообщения журнала регистрации (по умолчанию Ошибка).
//  КомпонентыОбмена - Структура - содержит все правила и параметры обмена.
//
Процедура ЗаписьЖурналаРегистрацииОбменДанными(Комментарий, КомпонентыОбмена, Уровень = Неопределено, СсылкаНаОбъект = Неопределено) Экспорт
	
	УзелКорреспондента = КомпонентыОбмена.УзелКорреспондента;
	КлючСообщенияЖурналаРегистрации = КомпонентыОбмена.КлючСообщенияЖурналаРегистрации;
	
	Если Уровень = Неопределено Тогда
		Уровень = УровеньЖурналаРегистрации.Ошибка;
	КонецЕсли;
	
	ОбъектМетаданных = Неопределено;
	
	Если     УзелКорреспондента <> Неопределено
		И Не УзелКорреспондента.Пустая() Тогда
		
		ОбъектМетаданных = УзелКорреспондента.Метаданные();
		
	КонецЕсли;
	
	ЗаписьЖурналаРегистрации(КлючСообщенияЖурналаРегистрации, Уровень, ОбъектМетаданных, СсылкаНаОбъект, Комментарий);
	
КонецПроцедуры

// Параметры:
//   КомпонентыОбмена - см. ОбменДаннымиXDTOСервер.ИнициализироватьКомпонентыОбмена
// 
Процедура ЗаполнитьПоддерживаемыеОбъектыXDTO(КомпонентыОбмена) Экспорт
	
	Если Не КомпонентыОбмена.ЭтоОбменЧерезПланОбмена
		Или Не ЗначениеЗаполнено(КомпонентыОбмена.УзелКорреспондента) Тогда
		Возврат;
	КонецЕсли;
	
	Если КомпонентыОбмена.НаправлениеОбмена = "Отправка" Тогда
		
		// Для отправки поддерживаются объекты:
		// отправка которых поддерживается из этой базы
		// и получение которых поддерживается в базе-корреспонденте.
		
		ТаблицаОбъектыБазыКорреспондента = ПоддерживаемыеОбъектыФорматаКорреспондента(КомпонентыОбмена.УзелКорреспондента, "Получение");
		
	ИначеЕсли КомпонентыОбмена.НаправлениеОбмена = "Получение" Тогда
		
		// Для получения поддерживаются объекты:
		// получение которых поддерживается в этой базе
		// и отправка которых поддерживается в базе-корреспонденте.
		
		ТаблицаОбъектыБазыКорреспондента = ПоддерживаемыеОбъектыФорматаКорреспондента(КомпонентыОбмена.УзелКорреспондента, "Отправка");
		
	Иначе
		
		Возврат;
		
	КонецЕсли;
	
	ОтборПоВерсииИНаправлению = Новый Структура("Версия", КомпонентыОбмена.ВерсияФорматаОбмена);
	ОтборПоВерсииИНаправлению.Вставить(КомпонентыОбмена.НаправлениеОбмена, Истина);
	
	ТаблицаОбъектыБазыПоВерсии = КомпонентыОбмена.НастройкиXDTO.ПоддерживаемыеОбъекты.Скопировать(ОтборПоВерсииИНаправлению);
	
	ОтборПоВерсии = Новый Структура("Версия", КомпонентыОбмена.ВерсияФорматаОбмена);
	
	ТаблицаОбъектыБазыКорреспондентаПоВерсии = ТаблицаОбъектыБазыКорреспондента.Скопировать(ОтборПоВерсии);
	
	Для Каждого СтрокаОбъектыБазыПоВерсии Из ТаблицаОбъектыБазыПоВерсии Цикл
		Если ТаблицаОбъектыБазыКорреспондентаПоВерсии.Найти(СтрокаОбъектыБазыПоВерсии.Объект, "Объект") = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		КомпонентыОбмена.ПоддерживаемыеОбъектыXDTO.Добавить(СтрокаОбъектыБазыПоВерсии.Объект);
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ИнициализацияОбмена

// Параметры:
//   * ВерсияФорматаМенеджераОбмена - Строка -
// 
// Возвращаемое значение:
//   ТаблицаЗначений - таблица правил конвертации:
//     * ИмяПКО - Строка - 
//     * ОбъектДанных - Произвольный -
//     * ОбъектФормата - Строка - 
//     * ТипПолученныхДанныхСтрокой - Строка -
//     * ИмяТаблицыПолученныхДанных - Строка -
//     * ПредставлениеТипаПолученныхДанных - Строка
//     * Свойства - ТаблицаЗначений -
//     * ПоляПоиска - Массив из Строка -
//     * ПоляПредставленияОбъекта - Строка -
//     * РеквизитыШапкиПолученныхДанных - Массив из Строка -
//     * ПриОтправкеДанных - Строка -
//     * ПриКонвертацииДанныхXDTO - Строка -
//     * ПередЗаписьюПолученныхДанных - Строка -
//     * ПослеЗагрузкиВсехДанных - Строка -
//     * ПравилоДляГруппыСправочника - Булево -
//     * ВариантИдентификации - Строка -
//     * РазрешитьСоздаватьОбъектИзСтруктуры - Произвольный -
//     * СвойстваТабличныхЧастейОбработанные - ТаблицаЗначений -
//     * СвойстваТабличныхЧастей - Структура -
//                               -  ТаблицаЗначений -
// 
Функция КоллекцияПравилКонвертации(ВерсияФорматаМенеджераОбмена)
	
	// Инициализация таблицы правил конвертации.
	ПравилаКонвертации = Новый ТаблицаЗначений;
	ПравилаКонвертации.Колонки.Добавить("ИмяПКО", Новый ОписаниеТипов("Строка",,Новый КвалификаторыСтроки(50)));
	ПравилаКонвертации.Колонки.Добавить("ОбъектДанных");
	ПравилаКонвертации.Колонки.Добавить("ОбъектФормата",                         Новый ОписаниеТипов("Строка"));
	ПравилаКонвертации.Колонки.Добавить("ТипПолученныхДанныхСтрокой",            Новый ОписаниеТипов("Строка",,Новый КвалификаторыСтроки(300)));
	ПравилаКонвертации.Колонки.Добавить("ИмяТаблицыПолученныхДанных",            Новый ОписаниеТипов("Строка",,Новый КвалификаторыСтроки(300)));
	ПравилаКонвертации.Колонки.Добавить("ПредставлениеТипаПолученныхДанных",     Новый ОписаниеТипов("Строка",,Новый КвалификаторыСтроки(300)));
	ПравилаКонвертации.Колонки.Добавить("Свойства",                              Новый ОписаниеТипов("ТаблицаЗначений"));
	ПравилаКонвертации.Колонки.Добавить("ПоляПоиска",                            Новый ОписаниеТипов("Массив"));
	ПравилаКонвертации.Колонки.Добавить("ПоляПредставленияОбъекта",              Новый ОписаниеТипов("Строка",,Новый КвалификаторыСтроки(300)));
	ПравилаКонвертации.Колонки.Добавить("РеквизитыШапкиПолученныхДанных",        Новый ОписаниеТипов("Массив"));
	ПравилаКонвертации.Колонки.Добавить("ПриОтправкеДанных",                     Новый ОписаниеТипов("Строка"));
	ПравилаКонвертации.Колонки.Добавить("ПриКонвертацииДанныхXDTO",              Новый ОписаниеТипов("Строка"));
	ПравилаКонвертации.Колонки.Добавить("ПередЗаписьюПолученныхДанных",          Новый ОписаниеТипов("Строка"));
	ПравилаКонвертации.Колонки.Добавить("ПослеЗагрузкиВсехДанных",               Новый ОписаниеТипов("Строка"));
	ПравилаКонвертации.Колонки.Добавить("ПравилоДляГруппыСправочника",           Новый ОписаниеТипов("Булево"));
	ПравилаКонвертации.Колонки.Добавить("ВариантИдентификации",                  Новый ОписаниеТипов("Строка",,Новый КвалификаторыСтроки(60)));
	ПравилаКонвертации.Колонки.Добавить("РазрешитьСоздаватьОбъектИзСтруктуры");
	
	Если ВерсияФорматаМенеджераОбмена = "1" Тогда
		ОписаниеТиповСвойстваТЧ = Новый ОписаниеТипов("Структура");
		ПравилаКонвертации.Колонки.Добавить("СвойстваТабличныхЧастейОбработанные", Новый ОписаниеТипов("ТаблицаЗначений"));
	Иначе
		ОписаниеТиповСвойстваТЧ = Новый ОписаниеТипов("ТаблицаЗначений");
	КонецЕсли;
	ПравилаКонвертации.Колонки.Добавить("СвойстваТабличныхЧастей", ОписаниеТиповСвойстваТЧ);
	
	Возврат ПравилаКонвертации;
	
КонецФункции

Функция ТаблицаПравилКонвертации(XMLСхема, МенеджерОбмена , НаправлениеОбмена, ПравилаОбработкиДанных, ВерсияФорматаМенеджераОбмена)
	
	// Инициализация таблицы правил конвертации.
	ПравилаКонвертации = КоллекцияПравилКонвертации(ВерсияФорматаМенеджераОбмена);
	
	МенеджерОбмена.ЗаполнитьПравилаКонвертацииОбъектов(НаправлениеОбмена, ПравилаКонвертации);
	
	Если НаправлениеОбмена = "Получение" Тогда
		
		// Отберем строки правил конвертации, у которых не заполнен реквизит "РазрешитьСоздаватьОбъектИзСтруктуры".
		ПараметрыОтбора = Новый Структура("РазрешитьСоздаватьОбъектИзСтруктуры", Неопределено);
		СтрокиДляОбработки = ПравилаКонвертации.НайтиСтроки(ПараметрыОтбора);
		
		// Для найденных строк необходимо заполнить реквизит "РазрешитьСоздаватьОбъектИзСтруктуры".
		// Реквизит заполняется по следующему алгоритму:
		// если правило конвертации объекта формата не указано
		// в правилах обработки данных для данного объекта формата, 
		// тогда реквизит заполняется значением "Истина", 
		// т.к. полученные по этому ПКО данные не смогут быть загружены самостоятельно,
		// иначе заполняем значением "Ложь".
		Для Каждого СтрокаОбработки Из СтрокиДляОбработки Цикл
			СтрокаОбработки.РазрешитьСоздаватьОбъектИзСтруктуры = Истина;
			СтрокаПравилОбработкиДанных = ПравилаОбработкиДанных.Найти(СтрокаОбработки.ОбъектФормата, "ОбъектВыборкиФормат");
			Если СтрокаПравилОбработкиДанных <> Неопределено Тогда
				МассивИспользуемыхПКО = СтрокаПравилОбработкиДанных.ИспользуемыеПКО;
				СтрокаОбработки.РазрешитьСоздаватьОбъектИзСтруктуры = МассивИспользуемыхПКО.Найти(СтрокаОбработки.ИмяПКО) = Неопределено;
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	// Добавляем служебные поля таблицы правил конвертации.
	ПравилаКонвертации.Колонки.Добавить("ТипXDTO");
	ПравилаКонвертации.Колонки.Добавить("ТипСсылкиXDTO");
	ПравилаКонвертации.Колонки.Добавить("ТипКлючевыхСвойствОбъектаXDTO");
	ПравилаКонвертации.Колонки.Добавить("ТипДанных");
	
	ПравилаКонвертации.Колонки.Добавить("МенеджерОбъекта");
	ПравилаКонвертации.Колонки.Добавить("ПолноеИмя");
	
	ПравилаКонвертации.Колонки.Добавить("ЭтоДокумент",               Новый ОписаниеТипов("Булево"));
	ПравилаКонвертации.Колонки.Добавить("ЭтоРегистр",                Новый ОписаниеТипов("Булево"));
	ПравилаКонвертации.Колонки.Добавить("ЭтоСправочник",             Новый ОписаниеТипов("Булево"));
	ПравилаКонвертации.Колонки.Добавить("ЭтоПеречисление",           Новый ОписаниеТипов("Булево"));
	ПравилаКонвертации.Колонки.Добавить("ЭтоПланВидовХарактеристик", Новый ОписаниеТипов("Булево"));
	ПравилаКонвертации.Колонки.Добавить("ЭтоБизнесПроцесс",          Новый ОписаниеТипов("Булево"));
	ПравилаКонвертации.Колонки.Добавить("ЭтоЗадача",                 Новый ОписаниеТипов("Булево"));
	ПравилаКонвертации.Колонки.Добавить("ЭтоПланСчетов",             Новый ОписаниеТипов("Булево"));
	ПравилаКонвертации.Колонки.Добавить("ЭтоПланВидовРасчета",       Новый ОписаниеТипов("Булево"));
	ПравилаКонвертации.Колонки.Добавить("ЭтоКонстанта",              Новый ОписаниеТипов("Булево"));
	
	ПравилаКонвертации.Колонки.Добавить("ДокументМожетПроводиться", Новый ОписаниеТипов("Булево"));
	
	ПравилаКонвертации.Колонки.Добавить("ЭтоСсылочныйТип", Новый ОписаниеТипов("Булево"));
	
	ПравилаКонвертации.Колонки.Добавить("ЕстьОбработчикПриОтправкеДанных",            Новый ОписаниеТипов("Булево"));
	ПравилаКонвертации.Колонки.Добавить("ЕстьОбработчикПриКонвертацииДанныхXDTO",     Новый ОписаниеТипов("Булево"));
	ПравилаКонвертации.Колонки.Добавить("ЕстьОбработчикПередЗаписьюПолученныхДанных", Новый ОписаниеТипов("Булево"));
	ПравилаКонвертации.Колонки.Добавить("ЕстьОбработчикПослеЗагрузкиВсехДанных",      Новый ОписаниеТипов("Булево"));
	
	РазрешитьПроведениеДокумента = Метаданные.СвойстваОбъектов.Проведение.Разрешить;
	
	КоличествоСтрок = ПравилаКонвертации.Количество();
	Для НомерИтерации = 1 По КоличествоСтрок Цикл
		
		ИндексСтроки = КоличествоСтрок - НомерИтерации;
		ПравилоКонвертации = ПравилаКонвертации.Получить(ИндексСтроки);
		
		Если ЗначениеЗаполнено(ПравилоКонвертации.ОбъектФормата) Тогда
			ПравилоКонвертации.ТипXDTO = ФабрикаXDTO.Тип(XMLСхема, ПравилоКонвертации.ОбъектФормата);
			Если ПравилоКонвертации.ТипXDTO = Неопределено Тогда
				ПравилаКонвертации.Удалить(ПравилоКонвертации);
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		Если НаправлениеОбмена = "Получение" Тогда
			
			МетаданныеОбъекта = ПравилоКонвертации.ОбъектДанных;
		
			ПравилоКонвертации.ИмяТаблицыПолученныхДанных = МетаданныеОбъекта.ПолноеИмя();
			ПравилоКонвертации.ПредставлениеТипаПолученныхДанных = МетаданныеОбъекта.Представление();
			ПравилоКонвертации.ТипПолученныхДанныхСтрокой = ИмяТипаДанныхПоОбъектуМетаданных(ПравилоКонвертации.ОбъектДанных);
		
			ПравилоКонвертации.ПоляПредставленияОбъекта = ?(ПравилоКонвертации.ПоляПоиска.Количество() = 0, "", ПравилоКонвертации.ПоляПоиска[0]);
			
			// Реквизиты объекта получаемых данных.
			РеквизитыМассив = Новый Массив;
			
			Для Сч = 0 По МетаданныеОбъекта.СтандартныеРеквизиты.Количество() - 1 Цикл
				Реквизит = МетаданныеОбъекта.СтандартныеРеквизиты[Сч]; // ОписаниеСтандартногоРеквизита
				Если Реквизит.Имя = "Наименование"
					Или Реквизит.Имя = "Код"
					Или Реквизит.Имя = "ЭтоГруппа"
					Или Реквизит.Имя = "Родитель"
					Или Реквизит.Имя = "Владелец"
					Или Реквизит.Имя = "Дата"
					Или Реквизит.Имя = "Номер" Тогда
					РеквизитыМассив.Добавить(Реквизит.Имя);
				КонецЕсли;
			КонецЦикла;
			
			Для Сч = 0 По МетаданныеОбъекта.Реквизиты.Количество() - 1 Цикл
				Реквизит = МетаданныеОбъекта.Реквизиты[Сч]; // ОбъектМетаданныхРеквизит
				РеквизитыМассив.Добавить(Реквизит.Имя);
			КонецЦикла;

			ПравилоКонвертации.РеквизитыШапкиПолученныхДанных = РеквизитыМассив;
			
			ПравилоКонвертации.ЕстьОбработчикПриКонвертацииДанныхXDTO     = Не ПустаяСтрока(ПравилоКонвертации.ПриКонвертацииДанныхXDTO);
			ПравилоКонвертации.ЕстьОбработчикПередЗаписьюПолученныхДанных = Не ПустаяСтрока(ПравилоКонвертации.ПередЗаписьюПолученныхДанных);
			ПравилоКонвертации.ЕстьОбработчикПослеЗагрузкиВсехДанных      = Не ПустаяСтрока(ПравилоКонвертации.ПослеЗагрузкиВсехДанных);

		Иначе
			ПравилоКонвертации.ЕстьОбработчикПриОтправкеДанных            = Не ПустаяСтрока(ПравилоКонвертации.ПриОтправкеДанных);
		КонецЕсли;
		
		Если ПравилоКонвертации.ОбъектДанных <> Неопределено Тогда
			
			ПравилоКонвертации.ПолноеИмя                  = ПравилоКонвертации.ОбъектДанных.ПолноеИмя();
			ПравилоКонвертации.МенеджерОбъекта            = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПравилоКонвертации.ПолноеИмя);
			
			ПравилоКонвертации.ЭтоРегистр                = ОбщегоНазначения.ЭтоРегистр(ПравилоКонвертации.ОбъектДанных);
			ПравилоКонвертации.ЭтоДокумент               = ОбщегоНазначения.ЭтоДокумент(ПравилоКонвертации.ОбъектДанных);
			ПравилоКонвертации.ЭтоСправочник             = ОбщегоНазначения.ЭтоСправочник(ПравилоКонвертации.ОбъектДанных);
			ПравилоКонвертации.ЭтоПеречисление           = ОбщегоНазначения.ЭтоПеречисление(ПравилоКонвертации.ОбъектДанных);
			ПравилоКонвертации.ЭтоПланВидовХарактеристик = ОбщегоНазначения.ЭтоПланВидовХарактеристик(ПравилоКонвертации.ОбъектДанных);
			ПравилоКонвертации.ЭтоБизнесПроцесс          = ОбщегоНазначения.ЭтоБизнесПроцесс(ПравилоКонвертации.ОбъектДанных);
			ПравилоКонвертации.ЭтоЗадача                 = ОбщегоНазначения.ЭтоЗадача(ПравилоКонвертации.ОбъектДанных);
			ПравилоКонвертации.ЭтоПланСчетов             = ОбщегоНазначения.ЭтоПланСчетов(ПравилоКонвертации.ОбъектДанных);
			ПравилоКонвертации.ЭтоПланВидовРасчета       = ОбщегоНазначения.ЭтоПланВидовРасчета(ПравилоКонвертации.ОбъектДанных);
			ПравилоКонвертации.ЭтоКонстанта              = ОбщегоНазначения.ЭтоКонстанта(ПравилоКонвертации.ОбъектДанных);
			
			ПравилоКонвертации.ТипДанных = Тип(ИмяТипаДанныхПоОбъектуМетаданных(ПравилоКонвертации.ОбъектДанных));
			
			Если ПравилоКонвертации.ЭтоДокумент Тогда
				ПравилоКонвертации.ДокументМожетПроводиться = ПравилоКонвертации.ОбъектДанных.Проведение = РазрешитьПроведениеДокумента;
			КонецЕсли;
			
		КонецЕсли;
		
		
		ПравилоКонвертации.ЭтоСсылочныйТип = ПравилоКонвертации.ЭтоДокумент
			Или ПравилоКонвертации.ЭтоСправочник
			Или ПравилоКонвертации.ЭтоПланВидовХарактеристик
			Или ПравилоКонвертации.ЭтоБизнесПроцесс
			Или ПравилоКонвертации.ЭтоЗадача
			Или ПравилоКонвертации.ЭтоПланСчетов
			Или ПравилоКонвертации.ЭтоПланВидовРасчета;
		
		Если ЗначениеЗаполнено(ПравилоКонвертации.ОбъектФормата) Тогда
			КлючевыеСвойства = ПравилоКонвертации.ТипXDTO.Свойства.Получить("КлючевыеСвойства");
			Если КлючевыеСвойства <> Неопределено Тогда
				
				ТипКлючевыхСвойствОбъектаXDTO = КлючевыеСвойства.Тип;
				ПравилоКонвертации.ТипКлючевыхСвойствОбъектаXDTO = ТипКлючевыхСвойствОбъектаXDTO;
				
				СвойстваКлючевыхСвойств = Новый Массив;
				ЗаполнитьСписокСвойствОбъектаXDTO(ТипКлючевыхСвойствОбъектаXDTO, СвойстваКлючевыхСвойств);
				
				ПКСДляДобавления = Новый Массив;
				
				ТаблицаПКС = ПравилоКонвертации.Свойства;
				Для Каждого ПКС Из ТаблицаПКС Цикл
					
					Если СвойстваКлючевыхСвойств.Найти(ПКС.СвойствоФормата) <> Неопределено Тогда
						ПКС.ОбработкаКлючевогоСвойства = Истина;
						
						Если ПравилоКонвертации.ТипXDTO.Свойства.Получить(ПКС.СвойствоФормата) <> Неопределено Тогда
							ПКСДляДобавления.Добавить(ПКС);
						КонецЕсли;
					КонецЕсли;
					
				КонецЦикла;
				
				Для Каждого ПКС Из ПКСДляДобавления Цикл
					НовоеПКС = ТаблицаПКС.Добавить();
					ЗаполнитьЗначенияСвойств(НовоеПКС, ПКС, , "ОбработкаКлючевогоСвойства");
				КонецЦикла;
				
				СвойствоСсылкаXDTO = ТипКлючевыхСвойствОбъектаXDTO.Свойства.Получить("Ссылка");
				Если СвойствоСсылкаXDTO <> Неопределено Тогда
					
					ПравилоКонвертации.ТипСсылкиXDTO = СвойствоСсылкаXDTO.Тип;
					
					Если ПравилоКонвертации.ЭтоСсылочныйТип
						И НаправлениеОбмена = "Отправка" Тогда
						ПКСДляСсылки = ТаблицаПКС.Добавить();
						ПКСДляСсылки.СвойствоКонфигурации = "Ссылка";
						ПКСДляСсылки.СвойствоФормата = "Ссылка";
						ПКСДляСсылки.ОбработкаКлючевогоСвойства = Истина;
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЕсли;
		КонецЕсли;
		
		Если ПравилоКонвертации.ВариантИдентификации = "ПоПолямПоиска"
			Или ПравилоКонвертации.ВариантИдентификации = "СначалаПоУникальномуИдентификаторуПотомПоПолямПоиска" Тогда
			
			ТаблицаПКС = ПравилоКонвертации.Свойства;
			Для Каждого ПКС Из ТаблицаПКС Цикл
				
				Если ЗначениеЗаполнено(ПравилоКонвертации.ПоляПоиска) Тогда
					Для Каждого ЭлементПолейПоиска Из ПравилоКонвертации.ПоляПоиска Цикл
						ПоляПоискаМассивом = СтрРазделить(ЭлементПолейПоиска, ",");
						Для Каждого ПолеПоиска Из ПоляПоискаМассивом Цикл
							ПолеПоиска = СокрЛП(ПолеПоиска);
							Если ПолеПоиска = ПКС.СвойствоКонфигурации Тогда
								ПКС.ОбработкаПоисковогоСвойства = Истина;
								Прервать;
							КонецЕсли;
						КонецЦикла;
					КонецЦикла;
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
		
		Если ВерсияФорматаМенеджераОбмена = "1" Тогда
			ИнициализироватьСвойстваТабличныхЧастей(ПравилоКонвертации, "СвойстваТабличныхЧастейОбработанные");
			Для Каждого ТЧ Из ПравилоКонвертации.СвойстваТабличныхЧастей Цикл
				СтрокаСвойстваТабличныхЧастей = ПравилоКонвертации.СвойстваТабличныхЧастейОбработанные.Добавить();
				СтрокаСвойстваТабличныхЧастей.ИспользуетсяАлгоритмКонвертации = Истина;
				СтрокаСвойстваТабличныхЧастей.Свойства = ТЧ.Значение;
				Если НаправлениеОбмена = "Получение" Тогда
					СтрокаСвойстваТабличныхЧастей.ТЧКонфигурации = ТЧ.Ключ;
				Иначе
					СтрокаСвойстваТабличныхЧастей.ТЧФормата = ТЧ.Ключ;
				КонецЕсли;
			КонецЦикла;
		Иначе
			// Заполнение информации о конвертации свойств табличных частей.
			Для Каждого ПКСТЧ Из ПравилоКонвертации.СвойстваТабличныхЧастей Цикл
				Для Каждого ПКС Из ПКСТЧ.Свойства Цикл
					Если ПКС.ИспользуетсяАлгоритмКонвертации Тогда
						ПКСТЧ.ИспользуетсяАлгоритмКонвертации = Истина;
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	Если ВерсияФорматаМенеджераОбмена = "1" Тогда
		ПравилаКонвертации.Колонки.Удалить(ПравилаКонвертации.Колонки.СвойстваТабличныхЧастей);
		ПравилаКонвертации.Колонки.Добавить("СвойстваТабличныхЧастей", Новый ОписаниеТипов("ТаблицаЗначений"));
		Для Каждого ПравилоКонвертации Из ПравилаКонвертации Цикл
			ИнициализироватьСвойстваТабличныхЧастей(ПравилоКонвертации);
			Для Каждого СвойствоТЧ Из ПравилоКонвертации.СвойстваТабличныхЧастейОбработанные Цикл
				СтрокаСвойстваТабличныхЧастей = ПравилоКонвертации.СвойстваТабличныхЧастей.Добавить();
				ЗаполнитьЗначенияСвойств(СтрокаСвойстваТабличныхЧастей, СвойствоТЧ);
				Для Каждого ПКС Из СтрокаСвойстваТабличныхЧастей.Свойства Цикл
					Если ПКС.ИспользуетсяАлгоритмКонвертации Тогда
						СтрокаСвойстваТабличныхЧастей.ИспользуетсяАлгоритмКонвертации = Истина;
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;
		КонецЦикла;
		ПравилаКонвертации.Колонки.Удалить(ПравилаКонвертации.Колонки.СвойстваТабличныхЧастейОбработанные);
	КонецЕсли;
	
	// Добавляем индексы таблицы правил конвертации.
	ПравилаКонвертации.Индексы.Добавить("ИмяПКО");
	ПравилаКонвертации.Индексы.Добавить("ТипДанных");
	ПравилаКонвертации.Индексы.Добавить("ТипXDTO");
	Если НаправлениеОбмена = "Получение" Тогда
		ПравилаКонвертации.Индексы.Добавить("ТипСсылкиXDTO");
	КонецЕсли;
	
	Возврат ПравилаКонвертации;
КонецФункции

Функция ТаблицаПравилКонвертацииПредопределенныхДанных(XMLСхема, МенеджерОбмена , НаправлениеОбмена)
	
	// Инициализация таблицы правил конвертации.
	ПравилаКонвертации = Новый ТаблицаЗначений;
	ПравилаКонвертации.Колонки.Добавить("ТипДанных");
	ПравилаКонвертации.Колонки.Добавить("ТипXDTO");
	ПравилаКонвертации.Колонки.Добавить("КонвертацииЗначенийПриПолучении");
	ПравилаКонвертации.Колонки.Добавить("КонвертацииЗначенийПриОтправке");
	
	ПравилаКонвертации.Колонки.Добавить("ИмяПКПД", Новый ОписаниеТипов("Строка"));
	
	МенеджерОбмена.ЗаполнитьПравилаКонвертацииПредопределенныхДанных(НаправлениеОбмена, ПравилаКонвертации);
	
	Для Каждого ПравилоКонвертации Из ПравилаКонвертации Цикл
	
		ПравилоКонвертации.ТипXDTO = ФабрикаXDTO.Тип(XMLСхема, ПравилоКонвертации.ТипXDTO);
		ПравилоКонвертации.ТипДанных = Тип(ИмяТипаДанныхПоОбъектуМетаданных(ПравилоКонвертации.ТипДанных));
		
	КонецЦикла;
	
	ПравилаКонвертации.Индексы.Добавить("ИмяПКПД");
	ПравилаКонвертации.Индексы.Добавить("ТипДанных");
	ПравилаКонвертации.Индексы.Добавить("ТипДанных,ТипXDTO");
	
	Возврат ПравилаКонвертации;
	
КонецФункции

Функция СтруктураПараметровКонвертации(МенеджерОбмена)
	// Инициализация структуры с параметрами конвертации.
	//	Возможно, в будущем понадобится не структура, а таблица (если потребуется передавать параметры из одной базы в
	//	другую).
	ПараметрыКонвертации = Новый Структура();
	МенеджерОбмена.ЗаполнитьПараметрыКонвертации(ПараметрыКонвертации);
	Возврат ПараметрыКонвертации;
КонецФункции

#КонецОбласти

#Область ОтправкаДанных

Процедура ВыполнитьВыгрузкуЗарегистрированныхДанных(КомпонентыОбмена, НомерСообщения)
	
	УзелДляОбмена = КомпонентыОбмена.УзелКорреспондента;
	
	НачальнаяВыгрузкаДанных = ОбменДаннымиСервер.УстановленПризнакНачальнойВыгрузкиДанных(УзелДляОбмена);
	
	// Получаем выборку измененных данных.
	ВыборкаИзменений = ПланыОбмена.ВыбратьИзменения(УзелДляОбмена, НомерСообщения);
	
	КоличествоОбъектовКВыгрузке = 0;
	Пока ВыборкаИзменений.Следующий() Цикл
		КоличествоОбъектовКВыгрузке = КоличествоОбъектовКВыгрузке + 1;
	КонецЦикла;
	КомпонентыОбмена.Вставить("КоличествоОбъектовКВыгрузке", КоличествоОбъектовКВыгрузке);
	
	УзелДляОбменаОбъект = УзелДляОбмена.ПолучитьОбъект();
	
	//  Алгоритм выгрузки данных в XML-файл:
	// 1. Получаем Данные из ИБ
	// 2. Отправляем информацию об удалении либо выгружаем данные.
	// 3. Конвертируем Данные в Структуру по правилу конвертации.
	// 4. Конвертируем Данные в Структуру в обработчике ПриОтправкеДанных.
	// 5. Конвертируем Структуру в ОбъектXDTO.
	// 6. Записываем ОбъектXDTO в XML-файл.
	ВыборкаИзменений.Сбросить();
	Пока ВыборкаИзменений.Следующий() Цикл
		Данные = ВыборкаИзменений.Получить();
		
		Попытка
			Если ТипЗнч(Данные) = Тип("УдалениеОбъекта") Тогда
				ВыгрузитьУдаление(КомпонентыОбмена, Данные.Ссылка);
			Иначе
				ОтправкаЭлемента = ОтправкаЭлементаДанных.Авто;
				ОбменДаннымиСобытия.ПриОтправкеДанныхКорреспонденту(Данные, ОтправкаЭлемента, НачальнаяВыгрузкаДанных, УзелДляОбменаОбъект, Ложь);
				
				// Удаление регистра отсылаем в виде пустого набора записей.
				Если ОтправкаЭлемента = ОтправкаЭлементаДанных.Удалить
					И ОбщегоНазначения.ЭтоРегистр(Данные.Метаданные()) Тогда
					ОтправкаЭлемента = ОтправкаЭлементаДанных.Авто;
				КонецЕсли;
				
				Если ОтправкаЭлемента = ОтправкаЭлементаДанных.Удалить Тогда
					ВыгрузитьУдаление(КомпонентыОбмена, Данные.Ссылка);
				ИначеЕсли ОтправкаЭлемента = ОтправкаЭлементаДанных.Игнорировать Тогда
					// Ситуация, когда объект не соответствует условиям фильтра, но его не нужно отправлять как удаление.
					// Возникает в случае первоначальной выгрузки данных.
					Продолжить;
				Иначе
					ВыгрузкаОбъектаВыборки(КомпонентыОбмена, Данные);
				КонецЕсли;
			КонецЕсли;
			
			КомпонентыОбмена.СчетчикВыгруженныхОбъектов = КомпонентыОбмена.СчетчикВыгруженныхОбъектов + 1;
			ОбменДаннымиСервер.РассчитатьПроцентВыгрузки(КомпонентыОбмена.СчетчикВыгруженныхОбъектов, КомпонентыОбмена.КоличествоОбъектовКВыгрузке);
			
		Исключение
			Инфо = ИнформацияОбОшибке();
			ПредставлениеДанных = ПредставлениеОбъектаДляПротокола(Данные);
			
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Событие: %1.
				|Объект: %2.
				|
				|%3'"),
				КомпонентыОбмена.НаправлениеОбмена,
				ПредставлениеДанных,
				ПодробноеПредставлениеОшибки(Инфо));
		КонецПопытки;
	КонецЦикла;
	
КонецПроцедуры

Процедура ВыгрузитьОбъектыПоСсылке(КомпонентыОбмена, СсылкиИзОбъекта)
	
	Если Не КомпонентыОбмена.ЭтоОбменЧерезПланОбмена Тогда
		Возврат;
	КонецЕсли;
			
	Для Каждого ЗначениеСсылки Из СсылкиИзОбъекта Цикл
		
		Если КомпонентыОбмена.ВыгруженныеОбъекты.Найти(ЗначениеСсылки) = Неопределено
			И ВыгружатьОбъектПоНеобходимости(КомпонентыОбмена, ЗначениеСсылки) Тогда
			
			Если Не РегистрыСведений.ДанныеОбъектовДляРегистрацииВОбменах.ОбъектЕстьВРегистре(
				ЗначениеСсылки, КомпонентыОбмена.УзелКорреспондента) Тогда
				
				ОбъектВыгружаемыйПоСсылке = Неопределено;
				
				Если ОбщегоНазначения.СсылкаСуществует(ЗначениеСсылки) Тогда
					ОбъектВыгружаемыйПоСсылке = ЗначениеСсылки.ПолучитьОбъект();
				КонецЕсли;
				
				Если ОбъектВыгружаемыйПоСсылке <> Неопределено Тогда
					
					ВыгрузкаОбъектаВыборки(КомпонентыОбмена, ОбъектВыгружаемыйПоСсылке);
					КомпонентыОбмена.ВыгруженныеПоСсылкеОбъекты.Добавить(ЗначениеСсылки);
					РегистрыСведений.ДанныеОбъектовДляРегистрацииВОбменах.ДобавитьОбъектВФильтрРазрешенныхОбъектов(
						ЗначениеСсылки, КомпонентыОбмена.УзелКорреспондента);
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ЭтоСсылкаXDTO(Знач Тип)
	
	Возврат ФабрикаXDTO.Тип(XMLБазоваяСхема(), "Ref").ЭтоПотомок(Тип);
	
КонецФункции

Функция ВыгружатьОбъектПоНеобходимости(КомпонентыОбмена, Объект)
	
	ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗнч(Объект));
	
	Если ОбъектМетаданных = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Получаем настройку из КЭШа
	РегистрацияПоНеобходимости = КомпонентыОбмена.СоответствиеРегистрацияПоНеобходимости.Получить(ОбъектМетаданных);
	Если РегистрацияПоНеобходимости <> Неопределено Тогда
		Возврат РегистрацияПоНеобходимости;
	КонецЕсли;
	
	РегистрацияПоНеобходимости = Ложь;
	
	Отбор = Новый Структура("ОбъектМетаданныхИмя", ОбъектМетаданных.ПолноеИмя());
	МассивПравил = КомпонентыОбмена.ТаблицаПравилаРегистрацииОбъектов.НайтиСтроки(Отбор);
	
	Для Каждого Правило Из МассивПравил Цикл
		
		Если Не ПустаяСтрока(Правило.ИмяРеквизитаФлага) Тогда
			
			ЗначениеРеквизитаФлага = Неопределено;
			КомпонентыОбмена.СвойстваУзлаПланаОбмена.Свойство(Правило.ИмяРеквизитаФлага, ЗначениеРеквизитаФлага);
			
			РегистрацияПоНеобходимости = (ЗначениеРеквизитаФлага = Перечисления.РежимыВыгрузкиОбъектовОбмена.ВыгружатьПриНеобходимости
				Или ЗначениеРеквизитаФлага = Перечисления.РежимыВыгрузкиОбъектовОбмена.ПустаяСсылка());

			Если РегистрацияПоНеобходимости Тогда
				Прервать;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Сохраняем полученное значение в кэше.
	КомпонентыОбмена.СоответствиеРегистрацияПоНеобходимости.Вставить(ОбъектМетаданных, РегистрацияПоНеобходимости);
	Возврат РегистрацияПоНеобходимости;
	
КонецФункции

Процедура ЗаписатьУдалениеОбъектаXDTO(КомпонентыОбмена, Ссылка, ТипСсылкиXDTO)
	
	УИДОбъектаXDTO = РегистрыСведений.ПубличныеИдентификаторыСинхронизируемыхОбъектов.ПубличныйИдентификаторПоСсылкеОбъекта(
		КомпонентыОбмена.УзелКорреспондента, Ссылка);
		
	Если Не ЗначениеЗаполнено(УИДОбъектаXDTO) Тогда
		Возврат;
	КонецЕсли;
	
	XMLСхема = КомпонентыОбмена.XMLСхема;
	ТипXDTO  = ФабрикаXDTO.Тип(XMLСхема, "УдалениеОбъекта");
	
	Для Каждого Свойство Из ТипXDTO.Свойства[0].Тип.Свойства[0].Тип.Свойства Цикл
		Если Свойство.Тип = ТипСсылкиXDTO Тогда
			
			ЗначениеXDTOЛюбаяСсылка = ФабрикаXDTO.Создать(Свойство.Тип, УИДОбъектаXDTO);
			
			СсылкаНаОбъект = ФабрикаXDTO.Создать(ТипXDTO.Свойства[0].Тип.Свойства[0].Тип); // ОбъектXDTO
			СсылкаНаОбъект.Установить(Свойство, ЗначениеXDTOЛюбаяСсылка);
			
			ЛюбаяСсылкаОбъект = ФабрикаXDTO.Создать(ТипXDTO.Свойства[0].Тип);
			ЛюбаяСсылкаОбъект.СсылкаНаОбъект = СсылкаНаОбъект;
			
			ДанныеXDTO = ФабрикаXDTO.Создать(ТипXDTO); // ОбъектXDTO
			ДанныеXDTO.СсылкаНаОбъект = ФабрикаXDTO.Создать(ТипXDTO.Свойства[0].Тип);
			ДанныеXDTO.Установить(ТипXDTO.Свойства[0], ЛюбаяСсылкаОбъект);
			ФабрикаXDTO.ЗаписатьXML(КомпонентыОбмена.ФайлОбмена, ДанныеXDTO);
			Прервать;
			
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Параметры:
//   КомпонентыОбмена - структура, содержит все ключевые данные для обмена (ПКО, ПКПД, ПОД и т.д.).
//   Ссылка - удаленный объект.
//   ПравилоКонвертации  - Строка таблицы правил конвертации объектов, в соответствии с которой выполняется преобразование.
//
Процедура ВыгрузитьУдаление(КомпонентыОбмена, Ссылка, ПравилоКонвертации = Неопределено)
	
	Если ПравилоКонвертации <> Неопределено Тогда
		// ПКО передали явно (при вызове удаления для конкретного ПКО).
		Если Не ОбъектФорматаПроходитПоФильтруXDTO(КомпонентыОбмена, ПравилоКонвертации.ОбъектФормата) Тогда
			Возврат;
		КонецЕсли;
		
		ЗаписатьУдалениеОбъектаXDTO(КомпонентыОбмена, Ссылка, ПравилоКонвертации.ТипСсылкиXDTO);
	Иначе
		
		// Поиск ПКО
		МассивИменПКО = ПОДПоОбъектуМетаданных(КомпонентыОбмена, Ссылка.Метаданные()).ИспользуемыеПКО;
		
		// Массив нужен для "свертки" ПКО по типам XDTO.
		ОбработанныеТипыСсылокXDTO = Новый Массив;
		
		Для Каждого ПравилоКонвертацииИмя Из МассивИменПКО Цикл
			
			ПравилоКонвертации = КомпонентыОбмена.ПравилаКонвертацииОбъектов.Найти(ПравилоКонвертацииИмя, "ИмяПКО");
			
			Если ПравилоКонвертации = Неопределено Тогда
				// Допустимо указание ПКО, не предназначенного для текущей версии формата данных.
				Продолжить;
			КонецЕсли;
			
			Если Не ОбъектФорматаПроходитПоФильтруXDTO(КомпонентыОбмена, ПравилоКонвертации.ОбъектФормата) Тогда
				Продолжить;
			КонецЕсли;
			
			// "Свертка" ПКО по типу ссылки XDTO.
			ТипСсылкиXDTO = ПравилоКонвертации.ТипСсылкиXDTO;
			Если ОбработанныеТипыСсылокXDTO.Найти(ТипСсылкиXDTO) = Неопределено Тогда
				ОбработанныеТипыСсылокXDTO.Добавить(ТипСсылкиXDTO);
			Иначе
				Продолжить;
			КонецЕсли;
			
			ЗаписатьУдалениеОбъектаXDTO(КомпонентыОбмена, Ссылка, ТипСсылкиXDTO);
			
		КонецЦикла;
		
	КонецЕсли;
КонецПроцедуры

Функция КонвертироватьПеречислениеВXDTO(КомпонентыОбмена, ЗначениеПеречисления, ТипПеречисленияXDTO)
	Если ТипЗнч(ЗначениеПеречисления) = Тип("Строка") Тогда
	
		ЗначениеXDTO = ФабрикаXDTO.Создать(ТипПеречисленияXDTO, ЗначениеПеречисления);
		
	Иначе
	
		ПравилаКонвертацииПредопределенныхДанных = КомпонентыОбмена.ПравилаКонвертацииПредопределенныхДанных;
		
		ПравилоКонвертации = НайтиПравилоКонвертацииДляЗначения(
			ПравилаКонвертацииПредопределенныхДанных, ТипЗнч(ЗначениеПеречисления), ТипПеречисленияXDTO);
		
		ЗначениеXDTO = ФабрикаXDTO.Создать(ТипПеречисленияXDTO,
			ЗначениеПеречисленияXDTO(ПравилоКонвертации.КонвертацииЗначенийПриОтправке, ЗначениеПеречисления));
		
	КонецЕсли;
	Возврат ЗначениеXDTO;
КонецФункции

Функция НайтиПравилоКонвертацииДляЗначения(ПравилаКонвертацииПредопределенныхДанных, Знач Тип, Знач ТипXDTO = Неопределено)
	
	Если ТипXDTO = Неопределено Тогда
		
		НайденныеПравила = ПравилаКонвертацииПредопределенныхДанных.НайтиСтроки(Новый Структура("ТипДанных", Тип));
		
		Если НайденныеПравила.Количество() = 1 Тогда
			
			ПравилоКонвертации = НайденныеПравила[0];
			
			Возврат ПравилоКонвертации;
			
		ИначеЕсли НайденныеПравила.Количество() > 1 Тогда
			
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка правил конвертации предопределенных данных.
				|Задано более одного правила конвертации для типа источника <%1>.'"),
				Строка(Тип));
			
		КонецЕсли;
		
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка правил конвертации предопределенных данных.
			|Правило конвертации не определено для типа источника <%1>.'"),
			Строка(Тип));
			
	Иначе
		
		НайденныеПравила = ПравилаКонвертацииПредопределенныхДанных.НайтиСтроки(Новый Структура("ТипДанных, ТипXDTO", Тип, ТипXDTO, Ложь));
		
		Если НайденныеПравила.Количество() = 1 Тогда
			
			ПравилоКонвертации = НайденныеПравила[0];
			
			Возврат ПравилоКонвертации;
			
		ИначеЕсли НайденныеПравила.Количество() > 1 Тогда
			
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка правил конвертации предопределенных данных.
				|Задано более одного правила конвертации для типа источника <%1> и типа приемника <%2>.'"),
				Строка(Тип),
				Строка(ТипXDTO));
			
		КонецЕсли;
		
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка правил конвертации предопределенных данных.
			|Правило конвертации не определено для типа источника <%1> и типа приемника <%2>.'"),
			Строка(Тип),
			Строка(ТипXDTO));
		
	КонецЕсли;
	
КонецФункции

Функция ЗначениеПеречисленияXDTO(Знач КонвертацииЗначений, Знач Значение)
	
	ЗначениеXDTO = КонвертацииЗначений.Получить(Значение);
	
	Если ЗначениеXDTO = Неопределено Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не найдено правило конвертации для значения предопределенных данных.
			|Тип значения источника: <%1>
			|Значение источника: <%2>'"),
			ТипЗнч(Значение),
			Строка(Значение));
	КонецЕсли;
	
	Возврат ЗначениеXDTO;
КонецФункции

Функция КонвертироватьСсылкуВXDTO(КомпонентыОбмена, ЗначениеСсылки, ТипСсылкиXDTO)
	
	Если КомпонентыОбмена.ЭтоОбменЧерезПланОбмена Тогда
	
		УИДОбъектаXDTO = РегистрыСведений.ПубличныеИдентификаторыСинхронизируемыхОбъектов.ПубличныйИдентификаторПоСсылкеОбъекта(
			КомпонентыОбмена.УзелКорреспондента, ЗначениеСсылки);
		ЗначениеXDTO = ФабрикаXDTO.Создать(ТипСсылкиXDTO, УИДОбъектаXDTO);
			
		Возврат ЗначениеXDTO;
		
	Иначе
		Возврат СокрЛП(ЗначениеСсылки.УникальныйИдентификатор());
	КонецЕсли;
	
КонецФункции

Функция ЭтоТаблицаОбъекта(Знач СвойствоXDTO)
	
	Если ТипЗнч(СвойствоXDTO.Тип) = Тип("ТипОбъектаXDTO")
		И СвойствоXDTO.Тип.Свойства.Количество() = 1 Тогда
		
		Возврат СвойствоXDTO.Тип.Свойства[0].ВерхняяГраница <> 1;
		
	КонецЕсли;
	
	Возврат Ложь;
КонецФункции

Процедура ПолучитьЗначениеВложенныхСвойств(ИсточникСвойства, ВложенныеСвойства, ЗначениеСвойства)
	ТекущийИсточникСвойства = ИсточникСвойства;
	ТекущееЗначениеСвойства = Неопределено;
	Для Уровень = 0 По ВложенныеСвойства.Количество()-1 Цикл
		Если НЕ ТекущийИсточникСвойства.Свойство(ВложенныеСвойства[Уровень], ТекущееЗначениеСвойства) Тогда
			Прервать;
		КонецЕсли;
		Если Уровень = ВложенныеСвойства.Количество()-1 Тогда
			ЗначениеСвойства = ТекущееЗначениеСвойства;
		ИначеЕсли ТипЗнч(ТекущееЗначениеСвойства) <> Тип("Структура") Тогда
			Прервать;
		Иначе
			ТекущийИсточникСвойства = ТекущееЗначениеСвойства;
			ТекущееЗначениеСвойства = Неопределено;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Процедура ПоместитьЗначениеВложенныхСвойств(ПолучательСвойства, ВложенныеСвойства, ЗначениеСвойства, ЭтоСтрокаТЧ)
	ИмяСвойства = ВложенныеСвойства[0];
	ЗначениеВложенныхСвойств = Неопределено;
	Если ЭтоСтрокаТЧ Тогда
		Если ПолучательСвойства.Владелец().Колонки.Найти(ИмяСвойства) = Неопределено Тогда
			ПолучательСвойства.Владелец().Колонки.Добавить(ИмяСвойства);
		Иначе
			ЗначениеВложенныхСвойств = ПолучательСвойства[ИмяСвойства];
		КонецЕсли;
	Иначе
		Если НЕ ПолучательСвойства.Свойство(ИмяСвойства, ЗначениеВложенныхСвойств) Тогда
			ПолучательСвойства.Вставить(ИмяСвойства);
		КонецЕсли;
	КонецЕсли;
	Если ЗначениеВложенныхСвойств = Неопределено Тогда
		ЗначениеВложенныхСвойств = Новый Структура;
	КонецЕсли;
	СтруктураВложенныхСвойств = ЗначениеВложенныхСвойств;
	МаксимальныйУровень = ВложенныеСвойства.Количество() - 1;
	Для Уровень = 1 По МаксимальныйУровень Цикл
		ИмяВложенногоСвойства = ВложенныеСвойства[Уровень];
		Если Уровень = МаксимальныйУровень Тогда
			СтруктураВложенныхСвойств.Вставить(ИмяВложенногоСвойства, ЗначениеСвойства);
			Прервать;
		КонецЕсли;
		ПолучательВложенногоСвойства = Неопределено;
		СтруктураВложенныхСвойств.Свойство(ИмяВложенногоСвойства, ПолучательВложенногоСвойства);
		Если ПолучательВложенногоСвойства = Неопределено Тогда
			ПолучательВложенногоСвойства = Новый Структура;
		КонецЕсли;
		ПолучательВложенногоСвойства.Вставить(ИмяВложенногоСвойства, Новый Структура);
		СтруктураВложенныхСвойств = ПолучательВложенногоСвойства;
	КонецЦикла;
	ПолучательСвойства[ИмяСвойства] = ЗначениеВложенныхСвойств;
КонецПроцедуры

Функция СоздатьТЧПриемникаПоПКС(ПКСДляТЧ)
	
	НоваяТЧПриемника = Новый ТаблицаЗначений;
	Для Каждого ПКС Из ПКСДляТЧ Цикл
		ИмяКолонки = СокрЛП(ПКС.СвойствоФормата);
		// Возможно, это ПКС для вложенных свойств.
		Если СтрНайти(ИмяКолонки, ".") > 0 Тогда
			ВложенныеСвойства = СтрРазделить(ИмяКолонки,".",Ложь);
			МаксимальныйИндекс = ВложенныеСвойства.Количество() - 1;
			Для Индекс = 0 По МаксимальныйИндекс Цикл
				ИмяВложенногоСвойства = ВложенныеСвойства[Индекс];
				Если НоваяТЧПриемника.Колонки.Найти(ИмяВложенногоСвойства) = Неопределено Тогда
					НоваяТЧПриемника.Колонки.Добавить(ИмяВложенногоСвойства);
				КонецЕсли;
			КонецЦикла;
		Иначе
			НоваяТЧПриемника.Колонки.Добавить(ИмяКолонки);
		КонецЕсли;
	КонецЦикла;
	
	Возврат НоваяТЧПриемника;
	
КонецФункции

Процедура ВыгрузитьПоддерживаемыеОбъектыФормата(Header, ПоддерживаемыеОбъекты, УзелКорреспондента)
	
	ТаблицаВсеВерсии = Новый ТаблицаЗначений;
	ТаблицаВсеВерсии.Колонки.Добавить("Версия", Новый ОписаниеТипов("Строка"));
	
	Для Каждого AvailableVersion Из Header.AvailableVersion Цикл
		СтрокаТаблицаВсеВерсии = ТаблицаВсеВерсии.Добавить();
		СтрокаТаблицаВсеВерсии.Версия = AvailableVersion;
	КонецЦикла;
	
	ТаблицаВсеВерсии.Сортировать("Версия");
	
	СтрокаВсеВерсии = СтрСоединить(ТаблицаВсеВерсии.ВыгрузитьКолонку("Версия"), ",");
	
	ТаблицаПоддерживаемыеОбъекты = ПоддерживаемыеОбъекты.Скопировать();
	
	ТаблицаПоддерживаемыеОбъекты.Сортировать("Объект, Версия");
	
	AvailableObjectTypes = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(XMLБазоваяСхема(), "AvailableObjectTypes"));
	
	ТекущийОбъект = Неопределено;
	Для Каждого СтрокаПоддерживаемыеОбъекты Из ТаблицаПоддерживаемыеОбъекты Цикл
		Если ТекущийОбъект = Неопределено Тогда
			СоздатьНовыйОбъект = Истина;
		ИначеЕсли ТекущийОбъект.Name <> СтрокаПоддерживаемыеОбъекты.Объект Тогда
			
			Если ТекущийОбъект.Sending = СтрокаВсеВерсии Тогда
				ТекущийОбъект.Sending = "*";
			КонецЕсли;
			
			Если ТекущийОбъект.Receiving = СтрокаВсеВерсии Тогда
				ТекущийОбъект.Receiving = "*";
			КонецЕсли;
			
			AvailableObjectTypes.ObjectType.Добавить(ТекущийОбъект);
			СоздатьНовыйОбъект = Истина;
		Иначе
			СоздатьНовыйОбъект = Ложь;
		КонецЕсли;
		
		Если СоздатьНовыйОбъект Тогда
			ТекущийОбъект = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(XMLБазоваяСхема(), "ObjectType"));
			ТекущийОбъект.Name = СтрокаПоддерживаемыеОбъекты.Объект;
			
			ТекущийОбъект.Sending   = "";
			ТекущийОбъект.Receiving = "";
		КонецЕсли;
		
		Если СтрокаПоддерживаемыеОбъекты.Отправка Тогда
			Если ПустаяСтрока(ТекущийОбъект.Sending) Тогда
				ТекущийОбъект.Sending = СтрокаПоддерживаемыеОбъекты.Версия;
			Иначе
				ТекущийОбъект.Sending = ТекущийОбъект.Sending + "," + СтрокаПоддерживаемыеОбъекты.Версия;
			КонецЕсли;
		КонецЕсли;
		
		Если СтрокаПоддерживаемыеОбъекты.Получение Тогда
			Если ПустаяСтрока(ТекущийОбъект.Receiving) Тогда
				ТекущийОбъект.Receiving = СтрокаПоддерживаемыеОбъекты.Версия;
			Иначе
				ТекущийОбъект.Receiving = ТекущийОбъект.Receiving + "," + СтрокаПоддерживаемыеОбъекты.Версия;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если ТекущийОбъект <> Неопределено Тогда
		Если ТекущийОбъект.Sending = СтрокаВсеВерсии Тогда
			ТекущийОбъект.Sending = "*";
		КонецЕсли;
		
		Если ТекущийОбъект.Receiving = СтрокаВсеВерсии Тогда
			ТекущийОбъект.Receiving = "*";
		КонецЕсли;
		
		AvailableObjectTypes.ObjectType.Добавить(ТекущийОбъект);
	КонецЕсли;
	
	Если AvailableObjectTypes.ObjectType.Количество() > 0 Тогда
		Header.AvailableObjectTypes = AvailableObjectTypes;
	Иначе
		Header.AvailableObjectTypes = Неопределено;
	КонецЕсли;
	
	РегистрыСведений.НастройкиОбменаДаннымиXDTO.ОбновитьНастройки(
		УзелКорреспондента, "ПоддерживаемыеОбъекты", ТаблицаПоддерживаемыеОбъекты);
	
КонецПроцедуры

// Структура параметров заголовка сообщения по умолчанию.
// 
// Возвращаемое значение:
//   Структура - описание параметров заголовка сообщения обмена:
//     * ФорматОбмена - Строка - имя формата обмена.
//     * ЭтоОбменЧерезПланОбмена - Булево - признак обмена через план обмена.
//     * ОбменДаннымиСВнешнейСистемой - Булево - признак обмена с внешней системой.
//     * ВерсияФорматаОбмена - Строка - номер версии формата обмена.
//     * ИмяПланаОбмена - Строка - имя метаданных плана обмена.
//     * ПсевдонимПредопределенногоУзла - Строка - код предопределенного узла до перекодирования.
//     * ИдентификаторПолучателя - Строка - идентификатор узла получателя сообщения.
//     * ИдентификаторОтправителя - Строка - идентификатор узла отправителя сообщения.
//     * НомерСообщения - Число - номер исходящего сообщения.
//     * НомерПринятого - Число - номер сообщения, загруженного корреспондентом.
//     * ПоддерживаемыеВерсии - Массив из Строка - коллекция поддерживаемых версий формата.
//     * ПоддерживаемыеОбъекты - ТаблицаЗначений - коллекция поддерживаемых объектов формата.
//     * Префикс - Строка - префикс информационной базы корреспондента.
//     * УзелКорреспондента - ПланОбменаСсылка, Неопределено - узел плана обмена.
//
Функция ПараметрыЗаголовкаСообщенияОбмена() Экспорт
	
	ПараметрыЗаголовка = Новый Структура;
	ПараметрыЗаголовка.Вставить("ФорматОбмена",            "");
	ПараметрыЗаголовка.Вставить("ЭтоОбменЧерезПланОбмена", Ложь);
	ПараметрыЗаголовка.Вставить("ОбменДаннымиСВнешнейСистемой", Ложь);
	ПараметрыЗаголовка.Вставить("ВерсияФорматаОбмена",     "");
	
	ПараметрыЗаголовка.Вставить("ИмяПланаОбмена",                 "");
	ПараметрыЗаголовка.Вставить("ПсевдонимПредопределенногоУзла", "");
	
	ПараметрыЗаголовка.Вставить("ИдентификаторПолучателя", "");
	ПараметрыЗаголовка.Вставить("ИдентификаторОтправителя", "");
	
	ПараметрыЗаголовка.Вставить("НомерСообщения", 0);
	ПараметрыЗаголовка.Вставить("НомерПринятого", 0);
	
	ПараметрыЗаголовка.Вставить("ПоддерживаемыеВерсии",  Новый Массив);
	ПараметрыЗаголовка.Вставить("ПоддерживаемыеОбъекты", Новый ТаблицаЗначений);
	
	ПараметрыЗаголовка.Вставить("Префикс", "");
	
	ПараметрыЗаголовка.Вставить("УзелКорреспондента", Неопределено);
	
	Возврат ПараметрыЗаголовка;
	
КонецФункции

// Параметры:
//   ФайлОбмена - ЗаписьXML - объект для записи заголовка.
//   ПараметрыЗаголовка - см. ОбменДаннымиXDTOСервер.ПараметрыЗаголовкаСообщенияОбмена
// 
Процедура ЗаписатьЗаголовокСообщенияОбмена(ФайлОбмена, ПараметрыЗаголовка) Экспорт
	
	// Записываем элемент <Message>
	ФайлОбмена.ЗаписатьНачалоЭлемента("Message");
	ФайлОбмена.ЗаписатьСоответствиеПространстваИмен("msg", "http://www.1c.ru/SSL/Exchange/Message");
	ФайлОбмена.ЗаписатьСоответствиеПространстваИмен("xs",  "http://www.w3.org/2001/XMLSchema");
	ФайлОбмена.ЗаписатьСоответствиеПространстваИмен("xsi", "http://www.w3.org/2001/XMLSchema-instance");
	
	// Элемент <Header>
	Header = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(XMLБазоваяСхема(), "Header"));
	
	Header.Format       = ПараметрыЗаголовка.ФорматОбмена;
	Header.CreationDate = ТекущаяУниверсальнаяДата();
	
	AvailableVersion = Header.AvailableVersion; // СписокXDTO
	
	Если ПараметрыЗаголовка.ЭтоОбменЧерезПланОбмена Тогда
		
		Confirmation = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(XMLБазоваяСхема(), "Confirmation"));
		
		Если ПараметрыЗаголовка.ОбменДаннымиСВнешнейСистемой Тогда
			Confirmation.From = ПараметрыЗаголовка.ИдентификаторОтправителя;
		
			Confirmation.MessageNo  = ПараметрыЗаголовка.НомерСообщения;
			Confirmation.ReceivedNo = ПараметрыЗаголовка.НомерПринятого;
			
			Header.Confirmation = Confirmation;
			
			Для Каждого ВерсияФормата Из ПараметрыЗаголовка.ПоддерживаемыеВерсии Цикл
				AvailableVersion.Добавить(ВерсияФормата);
			КонецЦикла;
			
			ВыгрузитьПоддерживаемыеОбъектыФормата(Header,
				ПараметрыЗаголовка.ПоддерживаемыеОбъекты, ПараметрыЗаголовка.УзелКорреспондента);
		Иначе
			Confirmation.ExchangePlan = ПараметрыЗаголовка.ИмяПланаОбмена;
			Confirmation.To           = ПараметрыЗаголовка.ИдентификаторПолучателя;
			
			Если ЗначениеЗаполнено(ПараметрыЗаголовка.ПсевдонимПредопределенногоУзла) Тогда
				// Требуется корректировка кода узла отправителя.
				Confirmation.From = ПараметрыЗаголовка.ПсевдонимПредопределенногоУзла;
			Иначе
				Confirmation.From = ПараметрыЗаголовка.ИдентификаторОтправителя;
			КонецЕсли;
		
			Confirmation.MessageNo  = ПараметрыЗаголовка.НомерСообщения;
			Confirmation.ReceivedNo = ПараметрыЗаголовка.НомерПринятого;
			
			Header.Confirmation = Confirmation;
			
			Для Каждого ВерсияФормата Из ПараметрыЗаголовка.ПоддерживаемыеВерсии Цикл
				AvailableVersion.Добавить(ВерсияФормата);
			КонецЦикла;
			
			Если ЗначениеЗаполнено(ПараметрыЗаголовка.ПсевдонимПредопределенногоУзла) Тогда
				// Тип Header является Упорядоченным, поэтому важен порядок присвоения значений свойств.
				// В противном случае может быть не пройдена валидация по схеме.
				Header.NewFrom = ПараметрыЗаголовка.ИдентификаторОтправителя;
			КонецЕсли;
			
			ВыгрузитьПоддерживаемыеОбъектыФормата(Header,
				ПараметрыЗаголовка.ПоддерживаемыеОбъекты, ПараметрыЗаголовка.УзелКорреспондента);
			
			Header.Prefix = ПараметрыЗаголовка.Префикс;
		КонецЕсли;
		
	Иначе
		AvailableVersion.Добавить(ПараметрыЗаголовка.ВерсияФорматаОбмена);
	КонецЕсли;
	
	ФабрикаXDTO.ЗаписатьXML(ФайлОбмена, Header);
	
КонецПроцедуры

// Параметры:
//   ОбъектXDTO - ОбъектXDTO -
//   ТипXDTO - ТипОбъектаXDTO -
//   Контекст - Структура -
//   Отказ - Булево -
//   ОписаниеОшибки - Строка -
//
Процедура ПроверитьОбъектXDTOПоСхеме(ОбъектXDTO, ТипXDTO, Контекст, Отказ, ОписаниеОшибки)
	
	ПодробноеПредставление        = "";
	ПользовательскоеПредставление = "";
	
	Попытка
		ОбъектXDTO.Проверить();
	Исключение
		Отказ = Истина;
		ПодробноеПредставление = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Если Отказ Тогда
		СтекОшибок = Новый Массив;
		ЗаполнитьОшибкиПроверкиОбъектаXDTO(ОбъектXDTO, ТипXDTO, СтекОшибок);
		
		Если СтекОшибок.Количество() > 0 Тогда
			ПользовательскоеПредставление = ТипXDTO.Имя;
			Для Каждого ТекущаяОшибка Из СтекОшибок Цикл
				ПользовательскоеПредставление = ПользовательскоеПредставление + Символы.ПС + ТекущаяОшибка;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	ОписаниеОшибки = Новый Структура("КраткоеПредставление, ПодробноеПредставление");
	
	ШаблонПользовательскоеСообщениеОбОшибке =
	НСтр("ru = 'Не удалось выполнить конвертацию в объект формата ""%1"": 
	|%2
	|
	|Дополнительная информация:
	|Направление: %3.
	|ПОД: %4.
	|ПКО: %5.
	|Объект: %6.
	|
	|Подробнее см. в журнале регистрации.'");
	
	ШаблонСообщениеОбОшибкеЖР = 
	НСтр("ru = 'Направление: %1.
	|ПОД: %2.
	|ПКО: %3.
	|Объект: %4.
	|
	|%5'");
	
	ОписаниеОшибки.КраткоеПредставление = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		ШаблонПользовательскоеСообщениеОбОшибке,
		ТипXDTO.Имя,
		ПользовательскоеПредставление,
		Контекст.НаправлениеОбмена,
		Контекст.ИмяПОД,
		Контекст.ИмяПКО,
		Контекст.ПредставлениеОбъекта);
	ОписаниеОшибки.ПодробноеПредставление = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		ШаблонСообщениеОбОшибкеЖР,
		Контекст.НаправлениеОбмена,
		Контекст.ИмяПОД,
		Контекст.ИмяПКО,
		Контекст.ПредставлениеОбъекта,
		ПодробноеПредставление);
	
КонецПроцедуры

Процедура ЗаполнитьОшибкиПроверкиОбъектаXDTO(ОбъектXDTO, ТипОбъектаXDTO, СтекОшибок, Знач Уровень = 1)
	
	ВыводитьОшибку = (Уровень = 1);
	
	Для Каждого Свойство Из ТипОбъектаXDTO.Свойства Цикл
		Если Не ОбъектXDTO.Установлено(Свойство) Тогда
			Если Свойство.НижняяГраница = 1
				И Не Свойство.ВозможноПустое Тогда
				Отступ = СтроковыеФункцииКлиентСервер.СформироватьСтрокуСимволов("  ", Уровень);
				СообщениеОбОшибке = Отступ + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = '%1: не заполнено обязательное поле.'"),
					Свойство.Имя);
				СтекОшибок.Добавить(СообщениеОбОшибке);
			КонецЕсли;
			Продолжить;
		Иначе
			ЗначениеСвойстваXDTO = Неопределено;
			ЭтоСписокXDTO = Ложь;
			Если Свойство.ВерхняяГраница = 1 Тогда
				ЗначениеСвойстваXDTO = ОбъектXDTO.ПолучитьXDTO(Свойство);
			Иначе
				ЗначениеСвойстваXDTO = ОбъектXDTO.ПолучитьСписок(Свойство);
				ЭтоСписокXDTO = Истина;
			КонецЕсли;
			
			Если ЗначениеСвойстваXDTO = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Если ТипЗнч(ЗначениеСвойстваXDTO) = Тип("ЗначениеXDTO") Тогда
				Попытка
					Свойство.Тип.Проверить(ЗначениеСвойстваXDTO.ЛексическоеЗначение);
				Исключение
					Отступ = СтроковыеФункцииКлиентСервер.СформироватьСтрокуСимволов("  ", Уровень);
					СообщениеОбОшибке = Отступ + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = '%1: значение поля не соответствует заданным ограничениям.'"),
						Свойство.Имя);
					СтекОшибок.Добавить(СообщениеОбОшибке);
				КонецПопытки;
			ИначеЕсли ЭтоСписокXDTO Тогда
				Сч = 0;
				Для Каждого ЭлементСпискаXDTO Из ЗначениеСвойстваXDTO Цикл
					Сч = Сч + 1;
					НовыйСтекОшибок = Новый Массив;
					ЗаполнитьОшибкиПроверкиОбъектаXDTO(ЭлементСпискаXDTO, Свойство.Тип, НовыйСтекОшибок, Уровень + 1);
					
					Если НовыйСтекОшибок.Количество() > 0 Тогда
						Отступ = СтроковыеФункцииКлиентСервер.СформироватьСтрокуСимволов("  ", Уровень);
						СообщениеОбОшибке = Отступ + Свойство.Имя + "[" + XMLСтрока(Сч) + "]";
						СтекОшибок.Добавить(СообщениеОбОшибке);
						Для Каждого НоваяОшибка Из НовыйСтекОшибок Цикл
							СтекОшибок.Добавить(НоваяОшибка);
						КонецЦикла;
					КонецЕсли;
				КонецЦикла;
			Иначе
				НовыйСтекОшибок = Новый Массив;
				ЗаполнитьОшибкиПроверкиОбъектаXDTO(ЗначениеСвойстваXDTO, Свойство.Тип, НовыйСтекОшибок, Уровень + 1);
				
				Если НовыйСтекОшибок.Количество() > 0 Тогда
					Отступ = СтроковыеФункцииКлиентСервер.СформироватьСтрокуСимволов("  ", Уровень);
					СообщениеОбОшибке = Отступ + Свойство.Имя;
					СтекОшибок.Добавить(СообщениеОбОшибке);
					Для Каждого НоваяОшибка Из НовыйСтекОшибок Цикл
						СтекОшибок.Добавить(НоваяОшибка);
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область ПолучениеДанных

#Область КонвертацияОбъектов

#Область КонвертацияXDTOВСтруктуру

Процедура КонвертацияСвойстваXDTOВЭлементСтруктуры(Источник, Свойство, Приемник, ИмяДляСвойстваСоставногоТипа = "")
	
	Если Не Источник.Установлено(Свойство) Тогда
		Возврат;
	КонецЕсли;
	
	ИмяСвойства = ?(ИмяДляСвойстваСоставногоТипа = "", Свойство.Имя, ИмяДляСвойстваСоставногоТипа);
	
	ЗначениеXDTO = Источник.ПолучитьXDTO(Свойство);
	
	Попытка
		
		Если ТипЗнч(ЗначениеXDTO) = Тип("ЗначениеXDTO") Тогда
			
			Значение = ПрочитатьЗначениеXDTO(ЗначениеXDTO);
			
			Если ТипЗнч(Приемник) = Тип("Структура") Тогда
				Приемник.Вставить(ИмяСвойства, Значение);
			Иначе
				
				Если ТипЗнч(Приемник) = Тип("СтрокаТаблицыЗначений")
					И Приемник.Владелец().Колонки.Найти(ИмяСвойства) = Неопределено Тогда
					Возврат;
				КонецЕсли;
				
				Приемник[ИмяСвойства] = Значение;
			КонецЕсли;
			
		ИначеЕсли ТипЗнч(ЗначениеXDTO) = Тип("ОбъектXDTO") Тогда
			
			// В свойстве могут находиться:
			// - дополнительная информация
			// - табличная часть
			// - набор ключевых свойств
			// - набор общих свойств
			// - свойство составного типа.
			
			Если ИмяСвойства = "AdditionalInfo" Тогда // Дополнительная информация
				
				Значение = СериализаторXDTO.ПрочитатьXDTO(ЗначениеXDTO);
				Приемник.Вставить(ИмяСвойства, Значение);
				
			ИначеЕсли ЭтоТаблицаОбъекта(Свойство) Тогда
				
				// Инициализируем таблицу значений, которая отображает табличную часть объекта.
				Значение = ТаблицаОбъектаПоТипу(Свойство.Тип.Свойства[0].Тип);
				
				ТабличнаяЧастьXDTO = Источник.ПолучитьXDTO(ИмяСвойства).ПолучитьСписок("Строка");
				
				Для Индекс = 0 По ТабличнаяЧастьXDTO.Количество() - 1 Цикл
					
					СтрокаТЧ = Значение.Добавить();
					СтрокаXDTO = ТабличнаяЧастьXDTO.ПолучитьXDTO(Индекс);
					Для Каждого СвойствоСтрокиТЧ Из СтрокаXDTO.Свойства() Цикл
						
						КонвертацияСвойстваXDTOВЭлементСтруктуры(СтрокаXDTO, СвойствоСтрокиТЧ, СтрокаТЧ);
						
					КонецЦикла;
					
				КонецЦикла;
				
				Приемник.Вставить(ИмяСвойства, Значение);
				
			ИначеЕсли СтрНайти(ЗначениеXDTO.Тип().Имя, "КлючевыеСвойства") > 0 Тогда
				
				Значение = Новый Структура("ЭтоНаборКлючевыхСвойств");
				Значение.Вставить("ТипЗначения", СтрЗаменить(ЗначениеXDTO.Тип().Имя, "КлючевыеСвойства", ""));
				Для Каждого КлючевоеСвойство Из ЗначениеXDTO.Свойства() Цикл
					КонвертацияСвойстваXDTOВЭлементСтруктуры(ЗначениеXDTO, КлючевоеСвойство, Значение);
				КонецЦикла;
				
				
				Если ТипЗнч(Приемник) = Тип("Структура") Тогда
					Приемник.Вставить(ИмяСвойства, Значение);
				Иначе
					Приемник[ИмяСвойства] = Значение;
				КонецЕсли;
				
			ИначеЕсли СтрНайти(ЗначениеXDTO.Тип().Имя, "ОбщиеСвойства") > 0 Тогда
				Если ТипЗнч(Приемник) = Тип("Структура") Тогда 
					ПриемникГруппыСвойств = Новый Структура;
					Для Каждого ПодСвойство Из ЗначениеXDTO.Свойства() Цикл
						
						КонвертацияСвойстваXDTOВЭлементСтруктуры(ЗначениеXDTO, ПодСвойство, ПриемникГруппыСвойств);
						
					КонецЦикла;
					Приемник.Вставить(ИмяСвойства, ПриемникГруппыСвойств);
					// По возможности свойства из группы свойств надо продублировать в приемнике,
					// Для совместимости с существующими правилами и алгоритмами.
					ЕстьКлючевыеСвойства = Приемник.Свойство("КлючевыеСвойства");
					Для Каждого СвойствоГруппы Из ПриемникГруппыСвойств Цикл
						ИмяПодСвойства = СвойствоГруппы.Ключ;
						Если НЕ Приемник.Свойство(ИмяПодСвойства)
							И НЕ (ЕстьКлючевыеСвойства И Приемник.КлючевыеСвойства.Свойство(ИмяПодСвойства)) Тогда
							Приемник.Вставить(ИмяПодСвойства, СвойствоГруппы.Значение);
						КонецЕсли;
					КонецЦикла;
				Иначе
					
					Для Каждого ПодСвойство Из ЗначениеXDTO.Свойства() Цикл
						
						КонвертацияСвойстваXDTOВЭлементСтруктуры(ЗначениеXDTO, ПодСвойство, Приемник);
						
					КонецЦикла;
					
				КонецЕсли;
				
			Иначе
				
				// Свойство составного типа 
				Значение = Неопределено;
				Для Каждого ПодСвойство Из ЗначениеXDTO.Свойства() Цикл
					
					Если НЕ ЗначениеXDTO.Установлено(ПодСвойство) Тогда
						Продолжить;
					КонецЕсли;
					
					КонвертацияСвойстваXDTOВЭлементСтруктуры(ЗначениеXDTO, ПодСвойство, Приемник, ИмяСвойства);
					Прервать;
					
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЕсли;
	Исключение
		ПредставлениеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Ошибка чтения объекта XDTO, имя свойства: <%1>.'"), ИмяСвойства)
			+ Символы.ПС + Символы.ПС + ПредставлениеОшибки;
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
КонецПроцедуры

Функция ПрочитатьЗначениеXDTO(ЗначениеXDTO)
	
	Если ЗначениеXDTO = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ЭтоСсылкаXDTO(ЗначениеXDTO.Тип()) Тогда // Конвертация ссылки
		Значение = ПрочитатьЗначениеXDTOСложногоТипа(ЗначениеXDTO, "Ссылка");
	ИначеЕсли ЗначениеXDTO.Тип().Фасеты <> Неопределено
		И ЗначениеXDTO.Тип().Фасеты.Перечисления <> Неопределено
		И ЗначениеXDTO.Тип().Фасеты.Перечисления.Количество() > 0 Тогда // Конвертация перечисления
		
		Значение = ПрочитатьЗначениеXDTOСложногоТипа(ЗначениеXDTO, "Перечисление");
	Иначе // Конвертация обычного значения.
		
		Значение = ЗначениеXDTO.Значение;
		
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции

Функция ПрочитатьЗначениеXDTOСложногоТипа(ЗначениеXDTO, СложныйТип)
	
	СтруктураXDTO = Новый Структура;
	СтруктураXDTO.Вставить("ЭтоСсылка", СложныйТип = "Ссылка");
	СтруктураXDTO.Вставить("ЭтоПеречисление", СложныйТип = "Перечисление");
	СтруктураXDTO.Вставить("ТипЗначенияXDTO", ЗначениеXDTO.Тип());
	СтруктураXDTO.Вставить("Значение", ЗначениеXDTO.Значение);

	Возврат СтруктураXDTO;
	
КонецФункции

// Параметры:
//   Тип - ТипОбъектаXDTO - тип объекта.
//
Функция ТаблицаОбъектаПоТипу(Знач Тип)
	
	Результат = Новый ТаблицаЗначений;
	
	Для Каждого Колонка Из Тип.Свойства Цикл
		
		Если СтрНайти(Колонка.Тип.Имя, "ОбщиеСвойства") > 0 Тогда
			
			Для Каждого ПодКолонка Из Колонка.Тип.Свойства Цикл
				
				Результат.Колонки.Добавить(ПодКолонка.Имя);
				
			КонецЦикла;
			
		Иначе
			Результат.Колонки.Добавить(Колонка.Имя);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

#КонецОбласти

#Область КонвертацияСтруктурыВДанныеИБ

Процедура КонвертацияСвойствСтруктурыОбъектаXDTO(
		КомпонентыОбмена,
		ДанныеXDTO,
		ПолученныеДанные,
		ПравилоКонвертации,
		НомерЭтапа = 1,
		СоставСвойств = "Все")
	
	Попытка
		Для Каждого ПКС Из ПравилоКонвертации.Свойства Цикл
			
			Если СоставСвойств = "СвойстваПоиска"
				И Не ПКС.ОбработкаПоисковогоСвойства Тогда
				Продолжить;
			КонецЕсли;
			
			КонвертацияСвойстваСтруктурыОбъектаXDTO(
				КомпонентыОбмена,
				ДанныеXDTO,
				ПолученныеДанные.ДополнительныеСвойства,
				ПолученныеДанные,
				ПКС,
				НомерЭтапа);
			
		КонецЦикла;
			
		Если СоставСвойств = "СвойстваПоиска" Тогда
			Возврат;
		КонецЕсли;
		
		// Конвертация табличных частей.
		Для Каждого ТЧ Из ПравилоКонвертации.СвойстваТабличныхЧастей Цикл
			
			Если НомерЭтапа = 1 И ЗначениеЗаполнено(ТЧ.ТЧКонфигурации) И ЗначениеЗаполнено(ТЧ.ТЧФормата) Тогда
				
				// Прямая конвертация табличных частей.
				ТЧФормата = Неопределено; // ТаблицаЗначений
				Если НЕ ДанныеXDTO.Свойство(ТЧ.ТЧФормата, ТЧФормата) Тогда
					Продолжить;
				ИначеЕсли ТЧФормата.Количество() = 0 Тогда
					Продолжить;
				КонецЕсли;
				
				МассивКолонокТЧ = Новый Массив;
				Для Каждого КолонкаТЧ Из ТЧФормата.Колонки Цикл
					МассивКолонокТЧ.Добавить(КолонкаТЧ.Имя);
				КонецЦикла;
				
				ИменаКолонокСтрокой = СтрСоединить(МассивКолонокТЧ, ",");
				Для НомерСтроки = 1 По ТЧФормата.Количество() Цикл
					
					ДанныеСтрокиXDTO = ТЧФормата[НомерСтроки - 1];
					СтрокаТЧ = ПолученныеДанные[ТЧ.ТЧКонфигурации].Добавить();
					СтруктураДанныхСтрокиXDTO = Новый Структура(ИменаКолонокСтрокой);
					ЗаполнитьЗначенияСвойств(СтруктураДанныхСтрокиXDTO, ДанныеСтрокиXDTO);
					
					Для Каждого ПКС Из ТЧ.Свойства Цикл
						Если ПКС.ИспользуетсяАлгоритмКонвертации Тогда
							Продолжить;
						КонецЕсли;
						КонвертацияСвойстваСтруктурыОбъектаXDTO(
							КомпонентыОбмена,
							СтруктураДанныхСтрокиXDTO,
							ПолученныеДанные.ДополнительныеСвойства,
							СтрокаТЧ,
							ПКС,
							НомерЭтапа);
					КонецЦикла;
					
				КонецЦикла;
				
			КонецЕсли;
			
			Если НомерЭтапа = 2 И ТЧ.ИспользуетсяАлгоритмКонвертации
				И ЗначениеЗаполнено(ТЧ.ТЧКонфигурации)
				И ПолученныеДанные.ДополнительныеСвойства.Свойство(ТЧ.ТЧКонфигурации) Тогда
 				МассивСтруктурСДаннымиСтрок = ПолученныеДанные.ДополнительныеСвойства[ТЧ.ТЧКонфигурации];
				КоличествоСтрокТЧКонфигурации = ПолученныеДанные[ТЧ.ТЧКонфигурации].Количество();
				
				Для НомерСтроки = 1 По МассивСтруктурСДаннымиСтрок.Количество() Цикл
					
					// Возможно, строка уже была добавлена при прямой конвертации
					Если НомерСтроки <= КоличествоСтрокТЧКонфигурации Тогда
						СтрокаТЧ = ПолученныеДанные[ТЧ.ТЧКонфигурации][НомерСтроки - 1];
					Иначе
						СтрокаТЧ = ПолученныеДанные[ТЧ.ТЧКонфигурации].Добавить();
					КонецЕсли;
					
					Для Каждого ПКС Из ТЧ.Свойства Цикл
						
						Если НЕ ПКС.ИспользуетсяАлгоритмКонвертации Тогда
							Продолжить;
						КонецЕсли;
						
						КонвертацияСвойстваСтруктурыОбъектаXDTO(
							КомпонентыОбмена,
							ДанныеXDTO,
							ПолученныеДанные.ДополнительныеСвойства,
							СтрокаТЧ,
							ПКС,
							НомерЭтапа, 
							ТЧ.ТЧКонфигурации);
						
					КонецЦикла;
					
				КонецЦикла;
			КонецЕсли;
			
		КонецЦикла;
	Исключение
		ТекстОшибки = Символы.ПС + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Событие: %1.
				|Объект: %2.
				|
				|Ошибка конвертации свойств.
				|%3.'"),
			КомпонентыОбмена.НаправлениеОбмена,
			ПредставлениеОбъектаДляПротокола(ПолученныеДанные),
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
КонецПроцедуры

Процедура КонвертацияСвойстваСтруктурыОбъектаXDTO(
		КомпонентыОбмена,
		ДанныеXDTO,
		ДополнительныеСвойства,
		ПриемникДанных,
		ПКС,
		НомерЭтапа = 1,
		ИмяТЧ = "")
	// Обрабатывается ПКС где указано только свойство формата - оно используется только при выгрузке.
	Если СокрЛП(ПКС.СвойствоКонфигурации) = "" Тогда
		Возврат;
	КонецЕсли;
	
	ПравилоКонвертацииСвойства = ПКС.ПравилоКонвертацииСвойства;
	
	ЗначениеСвойства = "";
	Попытка
		Если НомерЭтапа = 1 Тогда
			
			Если Не ЗначениеЗаполнено(ПКС.СвойствоФормата) Тогда
				Возврат;
			КонецЕсли;
			
			Если ПКС.ОбработкаКлючевогоСвойства
				И Не ДанныеXDTO.Свойство("ЭтоНаборКлючевыхСвойств") Тогда
				ИсточникДанных = ДанныеXDTO.КлючевыеСвойства;
			Иначе
				ИсточникДанных = ДанныеXDTO;
			КонецЕсли;
			
			СвойствоФормата_Имя = СокрЛП(ПКС.СвойствоФормата);
			ПозицияТочки = СтрНайти(СвойствоФормата_Имя, ".");
			// Указано полное имя свойства, входящего в группу общих свойств.
			Если ПозицияТочки > 0 Тогда
				ВложенныеСвойства = СтрРазделить(СвойствоФормата_Имя,".",Ложь);
				ПолучитьЗначениеВложенныхСвойств(ИсточникДанных, ВложенныеСвойства, ЗначениеСвойства);
			Иначе
				ИсточникДанных.Свойство(СвойствоФормата_Имя, ЗначениеСвойства);
			КонецЕсли;
			
		ИначеЕсли НомерЭтапа = 2 Тогда
			
			Если НомерЭтапа = 2 И Не ПКС.ИспользуетсяАлгоритмКонвертации Тогда
				Возврат;
			КонецЕсли;
			
			// На 2-м этапе значения свойств получаются из дополнительных свойств объекта полученных данных
			// и представляют из себя структуру, содержащую инструкцию для конвертации, либо значение XDTO.
			// Если приемником значения является строка табличной части, то значение свойства располагается
			// в ДополнительныеСвойства[ИмяТабличнойЧасти][ИндексСтроки].
			Если ЗначениеЗаполнено(ИмяТЧ) Тогда
				ИсточникДанных = ДополнительныеСвойства[ИмяТЧ][ПриемникДанных.НомерСтроки - 1];
			Иначе
				ИсточникДанных = ДополнительныеСвойства;
			КонецЕсли;
			
			Если ИсточникДанных.Свойство(ПКС.СвойствоКонфигурации) Тогда
				ЗначениеСвойства = ИсточникДанных[ПКС.СвойствоКонфигурации];
			КонецЕсли;
			
		КонецЕсли;
		
		Если Не ЗначениеЗаполнено(ЗначениеСвойства) Тогда
			Возврат;
		КонецЕсли;
		
		УдалятьСозданныеПоКлючевымСвойствам = КомпонентыОбмена.УдалятьСозданныеПоКлючевымСвойствам;
		Если ТипЗнч(ЗначениеСвойства) = Тип("Структура")
			И ЗначениеСвойства.Свойство("ИмяПКО")
			И ЗначениеСвойства.Свойство("Значение") Тогда
			
			// Значением является инструкция.
			Если ЗначениеСвойства.Свойство("УдалятьСозданныеПоКлючевымСвойствам") Тогда
				УдалятьСозданныеПоКлючевымСвойствам = ЗначениеСвойства.УдалятьСозданныеПоКлючевымСвойствам;
			КонецЕсли;
			
			ПравилоКонвертацииСвойства = ЗначениеСвойства.ИмяПКО;
			ЗначениеСвойства           = ЗначениеСвойства.Значение;
			
		КонецЕсли;
		
		Если ТипЗнч(ЗначениеСвойства) = Тип("Структура") Тогда
			Если Не ЗначениеЗаполнено(ПравилоКонвертацииСвойства) Тогда
				Возврат;
			КонецЕсли;
			
			ПКПД = КомпонентыОбмена.ПравилаКонвертацииПредопределенныхДанных.Найти(ПравилоКонвертацииСвойства, "ИмяПКПД");
			Если ПКПД <> Неопределено Тогда
				
				Значение = ПКПД.КонвертацииЗначенийПриПолучении.Получить(ЗначениеСвойства.Значение);
				ПриемникДанных[ПКС.СвойствоКонфигурации] = Значение;
				Возврат;
				
			Иначе
				ПравилоКонвертацииСвойства = ПКОПоИмени(КомпонентыОбмена, ПравилоКонвертацииСвойства);
			КонецЕсли;
		Иначе
			// Конвертацию простых свойств выполняем только на 1-м этапе.
			ПриемникДанных[ПКС.СвойствоКонфигурации] = ЗначениеСвойства;
			Возврат;
		КонецЕсли;
		
		ПравилоКонвертации = Новый Структура("ПравилоКонвертации, УдалятьСозданныеПоКлючевымСвойствам",
			ПравилоКонвертацииСвойства, УдалятьСозданныеПоКлючевымСвойствам);
		ДанныеДляЗаписиВИБ = СтруктураОбъектаXDTOВДанныеИБ(КомпонентыОбмена, ЗначениеСвойства, ПравилоКонвертации, "ПолучитьСсылку");
		
		Если ДанныеДляЗаписиВИБ <> Неопределено Тогда
			ПриемникДанных[ПКС.СвойствоКонфигурации] = ДанныеДляЗаписиВИБ.Ссылка;
		КонецЕсли;
		
	Исключение
		ПредставлениеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Ошибка конвертации свойства объекта XDTO, имя свойства: <%1>.'"), ПКС.СвойствоКонфигурации)
			+ Символы.ПС + Символы.ПС + ПредставлениеОшибки;
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
КонецПроцедуры

Функция СсылкаОбъектаПоСвойствамОбъектаXDTO(ПравилоКонвертации, ПолученныеДанные, ДанныеXDTOСодержатСсылку, УзелОбмена)
	
	Результат = Неопределено;
	// ПравилоКонвертации.ПоляПоискаОбъекта - массив, содержит разные варианты поиска
	//	элементы массива - таблица значений с полями поиска.
	Если ПравилоКонвертации.ПоляПоиска = Неопределено
		ИЛИ ТипЗнч(ПравилоКонвертации.ПоляПоиска) <> Тип("Массив") Тогда
		Возврат Результат;
	КонецЕсли;
	
	Для Каждого ПопыткаПоиска Из ПравилоКонвертации.ПоляПоиска Цикл
		ПоляПоиска = Новый Структура(ПопыткаПоиска);
		ЗаполнитьЗначенияСвойств(ПоляПоиска, ПолученныеДанные);
		
		// Если хотя бы одно поле поиска не заполнено, вариант поиска пропускается.
		// (Кроме справочников и планов видов характеристик - для них допустимо
		// незаполненное поле поиска "Родитель").
		// Вариант поиска является полноценным, если заполнены все поля.
		// В противном случае должен сработать другой вариант поиска.
		ЕстьНезаполненныеПоля = Ложь;
		Для Каждого ПолеПоиска Из ПоляПоиска Цикл
			Если Не ЗначениеЗаполнено(ПолеПоиска.Значение) Тогда
				Если (ПравилоКонвертации.ЭтоСправочник Или ПравилоКонвертации.ЭтоПланВидовХарактеристик)
					И ПолеПоиска.Ключ = "Родитель" Тогда
					Продолжить;
				КонецЕсли;
				
				ЕстьНезаполненныеПоля = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если ЕстьНезаполненныеПоля Тогда
			// Переход к следующему варианту поиска.
			Продолжить;
		КонецЕсли;
		
		ВариантИдентификации = СокрЛП(ПравилоКонвертации.ВариантИдентификации);
		АнализироватьПубличныеИдентификаторы = ВариантИдентификации = "СначалаПоУникальномуИдентификаторуПотомПоПолямПоиска"
			И ДанныеXDTOСодержатСсылку
			И ЗначениеЗаполнено(УзелОбмена);
			
		ПоискЗапросом = Ложь;
		Если АнализироватьПубличныеИдентификаторы Тогда
			ПоискЗапросом = Истина;
		Иначе
			// Возможно, поиск можно выполнить платформенными методами.
			Если ПравилоКонвертации.ЭтоДокумент
				И ПоляПоиска.Количество() = 2
				И ПоляПоиска.Свойство("Дата")
				И ПоляПоиска.Свойство("Номер") Тогда
				Результат = ПравилоКонвертации.МенеджерОбъекта.НайтиПоНомеру(ПоляПоиска.Номер, ПоляПоиска.Дата);
				Результат = ?(Результат.Пустая(), Неопределено, Результат);
			ИначеЕсли ПравилоКонвертации.ЭтоСправочник
				И ПоляПоиска.Количество() = 1
				И ПоляПоиска.Свойство("Наименование") Тогда
				Результат = ПравилоКонвертации.МенеджерОбъекта.НайтиПоНаименованию(ПоляПоиска.Наименование, Истина);
			ИначеЕсли ПравилоКонвертации.ЭтоСправочник
				И ПоляПоиска.Количество() = 1
				И ПоляПоиска.Свойство("Код") Тогда
				Результат = ПравилоКонвертации.МенеджерОбъекта.НайтиПоКоду(ПоляПоиска.Код);
			Иначе
				ПоискЗапросом = Истина;
			КонецЕсли;
		КонецЕсли;
		
		Если ПоискЗапросом Тогда
			Запрос = Новый Запрос;
			
			ТекстЗапроса =
			"ВЫБРАТЬ
			|	Таблица.Ссылка КАК Ссылка
			|ИЗ
			|	[ПолноеИмя] КАК Таблица
			|ГДЕ
			|	[УсловиеОтбора]";
			
			Отбор = Новый Массив;
			
			Для Каждого ПолеПоиска Из ПоляПоиска Цикл
				
				Если ОбменДаннымиПовтИсп.ЭтоСтроковыйРеквизитНеограниченнойДлины(ПравилоКонвертации.ПолноеИмя, ПолеПоиска.Ключ) Тогда
					
					ОтборСтрокой = "ВЫРАЗИТЬ(Таблица.[Ключ] КАК СТРОКА([ДлинаСтроки])) = &[Ключ]";
					ОтборСтрокой = СтрЗаменить(ОтборСтрокой, "[Ключ]", ПолеПоиска.Ключ);
					ОтборСтрокой = СтрЗаменить(ОтборСтрокой, "[ДлинаСтроки]", Формат(СтрДлина(ПолеПоиска.Значение), "ЧГ=0"));
					Отбор.Добавить(ОтборСтрокой);
					
				Иначе
					
					Отбор.Добавить(СтрЗаменить("Таблица.[Ключ] = &[Ключ]", "[Ключ]", ПолеПоиска.Ключ));
					
				КонецЕсли;
				
				Запрос.УстановитьПараметр(ПолеПоиска.Ключ, ПолеПоиска.Значение);
				
			КонецЦикла;
			
			УсловиеОтбора = СтрСоединить(Отбор, " И ");
			
			Если АнализироватьПубличныеИдентификаторы Тогда
				// Из поиска необходимо исключить уже сопоставленные ранее объекты.
				ТекстСоединения = "	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ПубличныеИдентификаторыСинхронизируемыхОбъектов КАК ПубличныеИдентификаторы
					|	ПО ПубличныеИдентификаторы.Ссылка = Таблица.Ссылка И ПубличныеИдентификаторы.УзелИнформационнойБазы = &УзелОбмена";
				УсловиеОтбора = УсловиеОтбора + Символы.ПС + "	И ПубличныеИдентификаторы.Ссылка is null";
				ТекстЗапроса = СтрЗаменить(ТекстЗапроса,  "ГДЕ", ТекстСоединения + Символы.ПС + "	ГДЕ");
				Запрос.УстановитьПараметр("УзелОбмена", УзелОбмена);
			КонецЕсли;
			
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[УсловиеОтбора]", УсловиеОтбора);
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ПолноеИмя]", ПравилоКонвертации.ПолноеИмя);
			Запрос.Текст = ТекстЗапроса;
			
			РезультатЗапроса = Запрос.Выполнить();
			
			Если Не РезультатЗапроса.Пустой() Тогда
				
				Выборка = РезультатЗапроса.Выбрать();
				Выборка.Следующий();
				
				Результат = Выборка.Ссылка;
				
			КонецЕсли;
			
		КонецЕсли;
		Если ЗначениеЗаполнено(Результат) Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
КонецФункции

Процедура ЗаполнитьДанныеИБПоПолученнымДанным(ДанныеИБ, ПолученныеДанные, ПравилоКонвертации)
	
	ПоляКопии = ПравилоКонвертации.Свойства.ВыгрузитьКолонку("СвойствоКонфигурации");
	Если ПоляКопии.Количество() > 0 Тогда
		
		Для НомерПоля = 1 По ПоляКопии.Количество() Цикл
			ПоляКопии[НомерПоля - 1] = СокрЛП(ПоляКопии[НомерПоля - 1]);
		КонецЦикла;
		
		ПоляКопии = СтрСоединить(ПоляКопии, ",");
		ЗаполнитьЗначенияСвойств(ДанныеИБ, ПолученныеДанные, ПоляКопии);
	КонецЕсли;
	
	Для Каждого КонвертацииТЧ Из ПравилоКонвертации.СвойстваТабличныхЧастей Цикл
		
		ИмяТЧ = КонвертацииТЧ.ТЧКонфигурации;
		
		Если ПустаяСтрока(ИмяТЧ) Тогда
			Продолжить;
		КонецЕсли;
		
		ДанныеИБ[ИмяТЧ].Очистить();
		ДанныеИБ[ИмяТЧ].Загрузить(ПолученныеДанные[ИмяТЧ].Выгрузить());
		
	КонецЦикла;
	
КонецПроцедуры

Функция ИнициализироватьПолученныеДанные(ПравилоКонвертации)
	
	Если ПравилоКонвертации.ЭтоДокумент Тогда
		ПолученныеДанные = ПравилоКонвертации.МенеджерОбъекта.СоздатьДокумент();
	ИначеЕсли ПравилоКонвертации.ЭтоСправочник
		Или ПравилоКонвертации.ЭтоПланВидовХарактеристик Тогда
		Если ПравилоКонвертации.ПравилоДляГруппыСправочника Тогда
			ПолученныеДанные = ПравилоКонвертации.МенеджерОбъекта.СоздатьГруппу();
		Иначе
			ПолученныеДанные = ПравилоКонвертации.МенеджерОбъекта.СоздатьЭлемент();
		КонецЕсли;
	ИначеЕсли ПравилоКонвертации.ЭтоРегистр Тогда
		ПолученныеДанные = ПравилоКонвертации.МенеджерОбъекта.СоздатьНаборЗаписей();
	КонецЕсли;
	
	Возврат ПолученныеДанные;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СервисныеПроцедурыИФункции

Процедура ПровестиГенерациюКодаНомераПриНеобходимости(Объект)
	
	ИмяТипаОбъекта = ОбщегоНазначения.ВидОбъектаПоТипу(ТипЗнч(Объект.Ссылка));
	
	// По типу документа смотрим заполнен код или номер.
	Если ИмяТипаОбъекта = "Документ"
		Или ИмяТипаОбъекта = "БизнесПроцесс"
		Или ИмяТипаОбъекта = "Задача" Тогда
		
		Если Не ЗначениеЗаполнено(Объект.Номер) Тогда
			
			Объект.УстановитьНовыйНомер();
			
		КонецЕсли;
		
	ИначеЕсли ИмяТипаОбъекта = "Справочник"
		Или ИмяТипаОбъекта = "ПланВидовХарактеристик" Тогда
		
		Если Не ЗначениеЗаполнено(Объект.Код)
			И Объект.Метаданные().Автонумерация Тогда
			
			Объект.УстановитьНовыйКод();
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура СнятьПометкуУдаленияСПредопределенногоЭлемента(Объект, ТипОбъекта, КомпонентыОбмена)
	
	ПометкаПредопределенный = Новый Структура("ПометкаУдаления, Предопределенный", Ложь, Ложь);
	ЗаполнитьЗначенияСвойств(ПометкаПредопределенный, Объект);
	
	Если ПометкаПредопределенный.ПометкаУдаления
		И ПометкаПредопределенный.Предопределенный Тогда
			
		Объект.ПометкаУдаления = Ложь;
		
		// фиксируем событие в ЖР
		ЗП            = ЗаписьПротоколаОбмена(80);
		ЗП.ТипОбъекта = ТипОбъекта;
		ЗП.Объект     = Строка(Объект);
		
		КомпонентыОбмена.СостояниеОбменаДанными.РезультатВыполненияОбмена =
			Перечисления.РезультатыВыполненияОбмена.ВыполненоСПредупреждениями;
		ЗаписатьВПротоколВыполнения(КомпонентыОбмена, 80, ЗП, Ложь);
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ОтложенныеОперации
// Параметры:
//   ДанныеДляЗаписиВИБ - СправочникОбъект,
//                        ДокументОбъект - объект для записи.
//   ПравилоКонвертации - СтрокаТаблицыЗначений - строка с правилом конвертации.
//   КомпонентыОбмена - см. ОбменДаннымиXDTOСервер.ИнициализироватьКомпонентыОбмена
//
Процедура ЗапомнитьОбъектДляОтложенногоЗаполнения(ДанныеДляЗаписиВИБ, ПравилоКонвертации, КомпонентыОбмена)
	
	Если ПравилоКонвертации.ЕстьОбработчикПослеЗагрузкиВсехДанных Тогда
		
		// Занесем данные об объекте в таблицу отложенной обработки.
		НоваяСтрока = КомпонентыОбмена.ЗагруженныеОбъекты.Добавить();
		НоваяСтрока.ИмяОбработчика = ПравилоКонвертации.ПослеЗагрузкиВсехДанных;
		НоваяСтрока.Объект         = ДанныеДляЗаписиВИБ;
		НоваяСтрока.СсылкаНаОбъект = ДанныеДляЗаписиВИБ.Ссылка;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура УдалитьВременныеОбъектыСозданныеПоСсылкам(КомпонентыОбмена) Экспорт
	
	ТаблицаОбъектовСозданныхПоСсылкам = КомпонентыОбмена.ТаблицаОбъектовСозданныхПоСсылкам;
	
	СтрокиОбъектыДляУдаления = ТаблицаОбъектовСозданныхПоСсылкам.НайтиСтроки(Новый Структура("УдалятьСозданныеПоКлючевымСвойствам", Истина));
	
	Для Каждого СтрокаТаблицы Из СтрокиОбъектыДляУдаления Цикл
		
		СсылкаНаОбъект = СтрокаТаблицы.СсылкаНаОбъект;
		
		// Необходимо удалить ссылку на объект из таблицы для отложенного заполнения объектов.
		СтрокаТаблицыОтложенногоЗаполнения = КомпонентыОбмена.ЗагруженныеОбъекты.Найти(СсылкаНаОбъект, "СсылкаНаОбъект");
		Если СтрокаТаблицыОтложенногоЗаполнения <> Неопределено Тогда
			КомпонентыОбмена.ЗагруженныеОбъекты.Удалить(СтрокаТаблицыОтложенногоЗаполнения);
		КонецЕсли;
		
		Если ЗначениеЗаполнено(СсылкаНаОбъект) Тогда
			
			ОбъектСозданныйПоСсылке = СсылкаНаОбъект.ПолучитьОбъект();
			ОбменДаннымиСервер.УстановитьОбменДаннымиЗагрузка(ОбъектСозданныйПоСсылке, Истина, Ложь, КомпонентыОбмена.УзелКорреспондента);
			УдалитьОбъект(ОбъектСозданныйПоСсылке, Истина, КомпонентыОбмена);
			
		КонецЕсли;
		
	КонецЦикла;
	
	ТаблицаОбъектовСозданныхПоСсылкам.Очистить();
	
КонецПроцедуры

Процедура ОтложенноеЗаполнениеОбъектов(КомпонентыОбмена)
	
	ПараметрыКонвертации = КомпонентыОбмена.ПараметрыКонвертации;
	ЗагруженныеОбъекты   = КомпонентыОбмена.ЗагруженныеОбъекты;
	
	Попытка
		КомпонентыОбмена.МенеджерОбмена.ПередОтложеннымЗаполнением(КомпонентыОбмена);
	Исключение
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Направление: %1.
			|Обработчик: ПередОтложеннымЗаполнением.
			|
			|Ошибка выполнения обработчика.
			|%2.'"),
			КомпонентыОбмена.НаправлениеОбмена,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Для Каждого СтрокаТаблицы Из ЗагруженныеОбъекты Цикл
		
		Если СтрокаТаблицы.Объект.ЭтоНовый() Тогда
			Продолжить;
		КонецЕсли;
		
		НачатьТранзакцию();
		Попытка
		    Блокировка = Новый БлокировкаДанных;
		    ЭлементБлокировки = Блокировка.Добавить(ОбщегоНазначения.ИмяТаблицыПоСсылке(СтрокаТаблицы.Объект.Ссылка));
		    ЭлементБлокировки.УстановитьЗначение("Ссылка", СтрокаТаблицы.Объект.Ссылка);
		    Блокировка.Заблокировать();
		    
			ЗаблокироватьДанныеДляРедактирования(СтрокаТаблицы.Объект.Ссылка);
			Объект = СтрокаТаблицы.Объект.Ссылка.ПолучитьОбъект();
			
			
			// Перенос дополнительных свойств.
			Для Каждого Свойство Из СтрокаТаблицы.Объект.ДополнительныеСвойства Цикл
				Объект.ДополнительныеСвойства.Вставить(Свойство.Ключ, Свойство.Значение);
			КонецЦикла;
			
			ИмяОбработчика = СтрокаТаблицы.ИмяОбработчика;
			
			МенеджерОбмена = КомпонентыОбмена.МенеджерОбмена;
			
			СтруктураПараметров = Новый Структура;
			СтруктураПараметров.Вставить("Объект",              Объект);
			СтруктураПараметров.Вставить("КомпонентыОбмена",    КомпонентыОбмена);
			СтруктураПараметров.Вставить("ОбъектМодифицирован", Истина);
			
			Попытка
				МенеджерОбмена.ВыполнитьПроцедуруМодуляМенеджера(ИмяОбработчика, СтруктураПараметров);
			Исключение
				ТекстОшибки = Символы.ПС + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Событие: %1.
						|Обработчик: ОтложенноеЗаполнениеОбъектов.
						|Объект: %2.
						|
						|Ошибка выполнения обработчика.
						|%3.'"),
					КомпонентыОбмена.НаправлениеОбмена,
					ПредставлениеОбъектаДляПротокола(Объект.Ссылка),
					ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				ЗаписатьВПротоколВыполнения(КомпонентыОбмена, СокрЛП(ТекстОшибки),,,,, Истина);
				СтруктураПараметров.ОбъектМодифицирован = Ложь;
			КонецПопытки;
			
			Если СтруктураПараметров.ОбъектМодифицирован Тогда
				ОбменДаннымиСервер.УстановитьОбменДаннымиЗагрузка(Объект, Истина, Ложь, КомпонентыОбмена.УзелКорреспондента);
				Объект.ДополнительныеСвойства.Вставить("ПропуститьЗаписьВерсииОбъекта");
				Объект.Записать();
			КонецЕсли;

		    ЗафиксироватьТранзакцию();
		Исключение
		    ОтменитьТранзакцию();
		    ВызватьИсключение;
		КонецПопытки;
		
	КонецЦикла;

КонецПроцедуры

#КонецОбласти

#Область Прочее

Процедура ПрочитатьСообщениеОбмена(КомпонентыОбмена, Результаты, ТаблицыДляЗагрузки = Неопределено, РежимАнализа = Ложь)
	
	Попытка
		КомпонентыОбмена.МенеджерОбмена.ПередКонвертацией(КомпонентыОбмена);
	Исключение
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Направление: %1.
			|Обработчик: ПередКонвертацией.
			|
			|Ошибка выполнения обработчика.
			|%2.'"),
			КомпонентыОбмена.НаправлениеОбмена,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
		
	МассивОбъектовКУдалению   = Новый Массив;
	МассивЗагруженныхОбъектов = Новый Массив;
		
	Результаты = Новый Структура;	
	Результаты.Вставить("МассивОбъектовКУдалению",   МассивОбъектовКУдалению);
	Результаты.Вставить("МассивЗагруженныхОбъектов", МассивЗагруженныхОбъектов);
	
	ВзвестиФлагОшибки = Ложь;
		
	Пока КомпонентыОбмена.ФайлОбмена.ТипУзла = ТипУзлаXML.НачалоЭлемента Цикл
		ОбновитьСчетчикЗагруженныхОбъектов(КомпонентыОбмена);
		
		// Получаем из файла ОбъектXDTO.
		ТипОбъектаXDTO = ФабрикаXDTO.Тип(КомпонентыОбмена.ФайлОбмена.URIПространстваИмен, КомпонентыОбмена.ФайлОбмена.ЛокальноеИмя);
		ОбъектXDTO     = ФабрикаXDTO.ПрочитатьXML(КомпонентыОбмена.ФайлОбмена, ТипОбъектаXDTO);
		
		Если ТипОбъектаXDTO.Имя = "УдалениеОбъекта" Тогда
			// Загрузка признака удаления объекта - специфичная логика.
			ПрочитатьУдаление(КомпонентыОбмена, ОбъектXDTO, МассивОбъектовКУдалению, ТаблицыДляЗагрузки);
			Продолжить;
		КонецЕсли;
		
		// Отработка ПОД
		ПравилоОбработки = ПОДПоТипуОбъектаXDTO(КомпонентыОбмена, ТипОбъектаXDTO.Имя, Истина);
		
		Если Не ЗначениеЗаполнено(ПравилоОбработки) Тогда
			Продолжить;
		КонецЕсли;
		
		// Конвертируем ОбъектXDTO в Структуру.
		ДанныеXDTO = ОбъектXDTOВСтруктуру(ОбъектXDTO);
		
		ИспользованиеПКО = Новый Структура;
		Для Каждого ИмяПКО Из ПравилоОбработки.ИспользуемыеПКО Цикл
			ИспользованиеПКО.Вставить(ИмяПКО, Истина);
		КонецЦикла;
		
		ПрерватьОбработку = Ложь;
		
		ПриОбработкеПОД(
			КомпонентыОбмена,
			ПравилоОбработки,
			ДанныеXDTO,
			ИспользованиеПКО,
			ПрерватьОбработку);
		
		Если ПрерватьОбработку Тогда
			ВзвестиФлагОшибки = Истина;
			Продолжить;
		КонецЕсли;
		
		Для Каждого ТекущееПКО Из ИспользованиеПКО Цикл
			Попытка
				ПравилоКонвертации = ПКОПоИмени(КомпонентыОбмена, ТекущееПКО.Ключ);
			Исключение
				ВзвестиФлагОшибки   = Истина;
				
				ОписаниеОшибки = ОписаниеОшибкиПОД(
					КомпонентыОбмена.НаправлениеОбмена,
					ПравилоОбработки.Имя,
					ПредставлениеОбъектаXDTOДляПротокола(ТипОбъектаXDTO),
					ИнформацияОбОшибке());
					
				ЗафиксироватьПроблемуПриОбработкеОбъекта(КомпонентыОбмена,
					ДанныеXDTO,
					Перечисления.ТипыПроблемОбменаДанными.ОшибкаВыполненияКодаОбработчиковПриПолученииДанных,
					ОписаниеОшибки.ПодробноеПредставление,
					ОписаниеОшибки.КраткоеПредставление);
					
				Продолжить;
			КонецПопытки;
			
			Если Не ОбъектФорматаПроходитПоФильтруXDTO(КомпонентыОбмена, ПравилоКонвертации.ОбъектФормата) Тогда
				Продолжить;
			КонецЕсли;
			
			Если Не ОбъектПроходитПоФильтруТаблицДляЗагрузки(
					ТаблицыДляЗагрузки, ТипОбъектаXDTO.Имя, ПравилоКонвертации.ТипПолученныхДанныхСтрокой) Тогда
				Продолжить;
			КонецЕсли;
			
			СинхронизироватьПоИдентификатору = ПоискПоИдентификатору(ПравилоКонвертации.ВариантИдентификации)
				И ДанныеXDTO.Свойство("Ссылка");
				
			Если Не ТекущееПКО.Значение Тогда
				Если СинхронизироватьПоИдентификатору Тогда
					ДополнитьСписокОбъектовКУдалению(КомпонентыОбмена,
						ПравилоКонвертации.ТипДанных, ДанныеXDTO.Ссылка.Значение, МассивОбъектовКУдалению);
				КонецЕсли;
				Продолжить;
			КонецЕсли;
			
			Если РежимАнализа Тогда
				ДобавитьОбъектВТаблицуДанныхЗаголовкаПакета(КомпонентыОбмена,
					ПравилоКонвертации, ТипОбъектаXDTO.Имя, СинхронизироватьПоИдентификатору);
				
				Если СинхронизироватьПоИдентификатору Тогда
					МассивЗагруженныхОбъектов.Добавить(
						СсылкаОбъектаПоУИДОбъектаXDTO(ДанныеXDTO.Ссылка.Значение, ПравилоКонвертации.ТипДанных, КомпонентыОбмена));
				КонецЕсли;
			Иначе
				Если КомпонентыОбмена.РежимЗагрузкиДанныхВИнформационнуюБазу
					Или ТаблицыДляЗагрузки <> Неопределено Тогда
					
					ДанныеДляЗаписиВИБ = Неопределено;
					Попытка
						ДанныеДляЗаписиВИБ = СтруктураОбъектаXDTOВДанныеИБ(
							КомпонентыОбмена,
							ДанныеXDTO,
							ПравилоКонвертации,
							?(КомпонентыОбмена.РежимЗагрузкиДанныхВИнформационнуюБазу, "КонвертироватьИЗаписать", "Конвертировать"));
					Исключение
						ВзвестиФлагОшибки  = Истина;
						
						ОписаниеОшибки = ОписаниеОшибкиПКО(
							КомпонентыОбмена.НаправлениеОбмена,
							ПравилоОбработки.Имя,
							ПравилоКонвертации.ИмяПКО,
							ПредставлениеОбъектаXDTOДляПротокола(ТипОбъектаXDTO),
							ИнформацияОбОшибке());
							
						ЗафиксироватьПроблемуПриОбработкеОбъекта(КомпонентыОбмена,
							ДанныеXDTO,
							Перечисления.ТипыПроблемОбменаДанными.ОшибкаВыполненияКодаОбработчиковПриПолученииДанных,
							ОписаниеОшибки.ПодробноеПредставление,
							ОписаниеОшибки.КраткоеПредставление);
							
						Продолжить;
					КонецПопытки;
						
				КонецЕсли;
				
				Если ДанныеДляЗаписиВИБ = Неопределено Тогда
					Продолжить;
				КонецЕсли;
				
				Если КомпонентыОбмена.РежимЗагрузкиДанныхВИнформационнуюБазу Тогда
					
					Если ПоискПоИдентификатору(ПравилоКонвертации.ВариантИдентификации) Тогда
						МассивЗагруженныхОбъектов.Добавить(ДанныеДляЗаписиВИБ.Ссылка);
					КонецЕсли;
					
				ИначеЕсли ТаблицыДляЗагрузки <> Неопределено Тогда
					
					ПровестиГенерациюКодаНомераПриНеобходимости(ДанныеДляЗаписиВИБ);
					
					КлючТаблицыДанных = ОбменДаннымиСервер.КлючТаблицыДанных(
						ТипОбъектаXDTO.Имя, ПравилоКонвертации.ТипПолученныхДанныхСтрокой, Ложь);
					ТаблицаДанныхСообщенияОбмена = КомпонентыОбмена.ТаблицыДанныхСообщенияОбмена.Получить(КлючТаблицыДанных);
					
					УникальныйИдентификаторСтрокой = "";
					СтрокаТаблицы = Неопределено;
					Если ДанныеXDTO.Свойство("Ссылка") Тогда
						УникальныйИдентификаторСтрокой = ДанныеXDTO.Ссылка.Значение;
						СтрокаТаблицы = ТаблицаДанныхСообщенияОбмена.Найти(УникальныйИдентификаторСтрокой, "УникальныйИдентификатор");
					КонецЕсли;
					
					Если СтрокаТаблицы = Неопределено Тогда
						СтрокаТаблицы = ТаблицаДанныхСообщенияОбмена.Добавить();
						
						СтрокаТаблицы.ТипСтрокой              = ПравилоКонвертации.ТипПолученныхДанныхСтрокой;
						СтрокаТаблицы.УникальныйИдентификатор = УникальныйИдентификаторСтрокой;
					КонецЕсли;
					
					// Заполняем значения свойств объекта.
					ЗаполнитьЗначенияСвойств(СтрокаТаблицы, ДанныеДляЗаписиВИБ);
					
					Если СинхронизироватьПоИдентификатору Тогда
						СтрокаТаблицы.Ссылка = СсылкаОбъектаПоУИДОбъектаXDTO(ДанныеXDTO.Ссылка.Значение,
							ПравилоКонвертации.ТипДанных, КомпонентыОбмена);
					Иначе
						СтрокаТаблицы.Ссылка = Неопределено;
					КонецЕсли;
					
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Если ВзвестиФлагОшибки Тогда
		КомпонентыОбмена.ФлагОшибки = Истина;
		КомпонентыОбмена.СостояниеОбменаДанными.РезультатВыполненияОбмена = Перечисления.РезультатыВыполненияОбмена.Ошибка;
	КонецЕсли;
	
КонецПроцедуры

Процедура ДобавитьОбъектВТаблицуДанныхЗаголовкаПакета(КомпонентыОбмена,
		ПравилоКонвертации, ТипОбъектаXDTO, СинхронизироватьПоИдентификатору)
	
	СтрокаТаблицы = КомпонентыОбмена.ТаблицаДанныхЗаголовкаПакета.Добавить();
					
	СтрокаТаблицы.ТипОбъектаСтрокой = ПравилоКонвертации.ТипПолученныхДанныхСтрокой;
	СтрокаТаблицы.КоличествоОбъектовВИсточнике = 1;
	
	СтрокаТаблицы.ТипПриемникаСтрокой = ПравилоКонвертации.ТипПолученныхДанныхСтрокой;
	СтрокаТаблицы.ТипИсточникаСтрокой = ТипОбъектаXDTO;
	
	СтрокаТаблицы.ПоляПоиска  = ПравилоКонвертации.ПоляПредставленияОбъекта;
	СтрокаТаблицы.ПоляТаблицы = СтрСоединить(ПравилоКонвертации.РеквизитыШапкиПолученныхДанных, ",");
	
	СтрокаТаблицы.СинхронизироватьПоИдентификатору = СинхронизироватьПоИдентификатору;
		
	СтрокаТаблицы.ИспользоватьПредварительныйПросмотр = СтрокаТаблицы.СинхронизироватьПоИдентификатору;
	СтрокаТаблицы.ЭтоКлассификатор                    = ПравилоКонвертации.ВариантИдентификации = "СначалаПоУникальномуИдентификаторуПотомПоПолямПоиска";
	СтрокаТаблицы.ЭтоУдалениеОбъекта = Ложь;
	
КонецПроцедуры

Функция СоответствиеСтарыхИНовыхДанныхТЧ(ТабличнаяЧастьОбъектаПослеОбработки, ТабличнаяЧастьОбъектаДоОбработки, МассивКлючевыхПолей)
	
	СоответствиеСтрокНовойТЧСтрокамСтаройТЧ = Новый Соответствие;
	
	Для Каждого СтрокаНовойТЧ Из ТабличнаяЧастьОбъектаПослеОбработки Цикл
		
		НайденнаяСтрокаСтаройТЧ = Неопределено;
		
		СтруктураПоиска = Новый Структура;
		Для Каждого КлючевоеПоле Из МассивКлючевыхПолей Цикл
			СтруктураПоиска.Вставить(КлючевоеПоле, СтрокаНовойТЧ[КлючевоеПоле]);
		КонецЦикла;
		
		НайденныеСтрокиНовойТЧ = ТабличнаяЧастьОбъектаПослеОбработки.НайтиСтроки(СтруктураПоиска);
		
		Если НайденныеСтрокиНовойТЧ.Количество() = 1 Тогда
			
			НайденныеСтрокиСтаройТЧ = ТабличнаяЧастьОбъектаДоОбработки.НайтиСтроки(СтруктураПоиска);
			
			Если НайденныеСтрокиСтаройТЧ.Количество() = 1 Тогда
				НайденнаяСтрокаСтаройТЧ = НайденныеСтрокиСтаройТЧ[0];
			КонецЕсли;
			
		КонецЕсли;
		
		СоответствиеСтрокНовойТЧСтрокамСтаройТЧ.Вставить(СтрокаНовойТЧ, НайденнаяСтрокаСтаройТЧ);
		
	КонецЦикла;
	
	Возврат СоответствиеСтрокНовойТЧСтрокамСтаройТЧ;
	
КонецФункции

Функция РазложитьФорматОбмена(Знач ФорматОбмена)
	
	Результат = Новый Структура("БазовыйФормат, Версия");
	
	ЭлементыФормата = СтрРазделить(ФорматОбмена, "/");
	
	Если ЭлементыФормата.Количество() = 0 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Неканоническое имя формата обмена <%1>'"), ФорматОбмена);
	КонецЕсли;
	
	Результат.Версия = ЭлементыФормата[ЭлементыФормата.ВГраница()];
	
	ПроверитьВерсию(Результат.Версия);
	
	ЭлементыФормата.Удалить(ЭлементыФормата.ВГраница());
	
	Результат.БазовыйФормат = СтрСоединить(ЭлементыФормата, "/");
	
	Возврат Результат;
КонецФункции

Функция СсылкаПоУИД(ТипЗначенияОбъектаИБ, УИДОбъектаXDTO, УзелОбмена)
	
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(ТипЗначенияОбъектаИБ);
	ОписаниеТипов = Новый ОписаниеТипов(МассивТипов);
	ПустаяСсылка = ОписаниеТипов.ПривестиЗначение();

	МенеджерОбъектаМетаданных = ОбщегоНазначения.МенеджерОбъектаПоСсылке(ПустаяСсылка);
	
	НайденнаяСсылка = МенеджерОбъектаМетаданных.ПолучитьСсылку(Новый УникальныйИдентификатор(УИДОбъектаXDTO));
	Если Не ЗначениеЗаполнено(УзелОбмена)
		Или НайденнаяСсылка.Пустая()
		Или Не ОбщегоНазначения.СсылкаСуществует(НайденнаяСсылка) Тогда
		Возврат НайденнаяСсылка;
	КонецЕсли;
	СтруктураЗаписи = Новый Структура;
	СтруктураЗаписи.Вставить("Ссылка", НайденнаяСсылка);
	СтруктураЗаписи.Вставить("УзелИнформационнойБазы", УзелОбмена);
	
	Если НЕ РегистрыСведений.ПубличныеИдентификаторыСинхронизируемыхОбъектов.ЗаписьЕстьВРегистре(СтруктураЗаписи) Тогда
		Возврат НайденнаяСсылка;
	КонецЕсли;
	// Данному УИД уже сопоставлен другой объект. Нужно создавать ссылку с другим УИДом.
	НоваяСсылка = МенеджерОбъектаМетаданных.ПолучитьСсылку();
	
	Возврат НоваяСсылка;
	
КонецФункции

Функция НайтиСсылкуПоПубличномуИдентификатору(УИДОбъектаXDTO, УзелКорреспондента, ТипЗначенияОбъектаИБ)
	
	Если Не ЗначениеЗаполнено(УзелКорреспондента) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	РПИ.Ссылка КАК Ссылка
	|ИЗ
	|	РегистрСведений.ПубличныеИдентификаторыСинхронизируемыхОбъектов КАК РПИ
	|ГДЕ
	|	РПИ.УзелИнформационнойБазы = &УзелИнформационнойБазы
	|	И РПИ.Идентификатор = &Идентификатор");
	Запрос.УстановитьПараметр("УзелИнформационнойБазы", УзелКорреспондента);
	Запрос.УстановитьПараметр("Идентификатор",          УИДОбъектаXDTO);
	
	НайденнаяСсылка    = Неопределено;
	НекорректныеСсылки = Новый Массив;
	УдалитьВсеЗаписи   = Ложь;
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если ТипЗнч(Выборка.Ссылка) <> ТипЗначенияОбъектаИБ Тогда
			Продолжить;
		КонецЕсли;
		
		Если НайденнаяСсылка = Неопределено Тогда
			НайденнаяСсылка = Выборка.Ссылка;
		ИначеЕсли ОбщегоНазначения.СсылкаСуществует(Выборка.Ссылка) Тогда
			Если ОбщегоНазначения.СсылкаСуществует(НайденнаяСсылка) Тогда
				УдалитьВсеЗаписи = Истина;
				НайденнаяСсылка  = Неопределено;
				Прервать;
			Иначе
				// Удаление битой ссылки.
				НекорректныеСсылки.Добавить(НайденнаяСсылка);
				
				НайденнаяСсылка = Выборка.Ссылка;
			КонецЕсли;
		Иначе
			// Удаление битой ссылки.
			НекорректныеСсылки.Добавить(Выборка.Ссылка);
		КонецЕсли;
	КонецЦикла;
	
	Если НайденнаяСсылка <> Неопределено
		И НекорректныеСсылки.Количество() > 0
		И Не ОбщегоНазначения.СсылкаСуществует(НайденнаяСсылка) Тогда
		УдалитьВсеЗаписи = Истина;
		НайденнаяСсылка  = Неопределено;
	КонецЕсли;
	
	Если УдалитьВсеЗаписи Тогда
		
		СтруктураЗаписи = Новый Структура;
		СтруктураЗаписи.Вставить("Идентификатор",          УИДОбъектаXDTO);
		СтруктураЗаписи.Вставить("УзелИнформационнойБазы", УзелКорреспондента);
		
		РегистрыСведений.ПубличныеИдентификаторыСинхронизируемыхОбъектов.УдалитьЗапись(СтруктураЗаписи, Истина);
		
	ИначеЕсли НекорректныеСсылки.Количество() > 0 Тогда
		
		СтруктураЗаписи = Новый Структура;
		СтруктураЗаписи.Вставить("Идентификатор",          УИДОбъектаXDTO);
		СтруктураЗаписи.Вставить("УзелИнформационнойБазы", УзелКорреспондента);
		
		Для Каждого Ссылка Из НекорректныеСсылки Цикл
			СтруктураЗаписи.Вставить("Ссылка", Ссылка);
			РегистрыСведений.ПубличныеИдентификаторыСинхронизируемыхОбъектов.УдалитьЗапись(СтруктураЗаписи, Истина);
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат НайденнаяСсылка;
	
КонецФункции

// Чтение и обработка данных об удалении объекта.
//
// Параметры:
//  КомпонентыОбмена        - Структура - содержит все правила и параметры обмена.
//  ОбъектXDTO              - ОбъектXDTO - объект пакета XDTO "УдалениеОбъекта", который содержит информацию об
//                            удаленном объекте информационной базы.
//  МассивОбъектовКУдалению - Массив из ЛюбаяСсылка - массив в который будет помещена ссылка на объект, подлежащий удалению.
//                            Собственно удаление объектов происходит после загрузки всех данных, при этом учитывается
//                            какие объекты были загружены (не удаляются ссылки, которые были загружены как другие
//                            ОбъектыXDTO).
//  ТаблицыДляЗагрузки      - ТаблицаЗначений - коллекция загружаемых таблиц данных.
//
Процедура ПрочитатьУдаление(КомпонентыОбмена, ОбъектXDTO, МассивОбъектовКУдалению, ТаблицыДляЗагрузки = Неопределено)
	
	ТипСсылкиXDTO = Неопределено;
	
	Если Не ОбъектXDTO.Установлено("СсылкаНаОбъект") Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого СвойствоXDTO Из ОбъектXDTO.СсылкаНаОбъект.СсылкаНаОбъект.Свойства() Цикл
		
		Если Не ОбъектXDTO.СсылкаНаОбъект.СсылкаНаОбъект.Установлено(СвойствоXDTO) Тогда
			Продолжить;
		КонецЕсли;
		
		ЗначениеСвойстваXDTO = ОбъектXDTO.СсылкаНаОбъект.СсылкаНаОбъект.ПолучитьXDTO(СвойствоXDTO);
		ЗначениеСсылкиXDTO   = ПрочитатьЗначениеXDTOСложногоТипа(ЗначениеСвойстваXDTO, "Ссылка");
		
		// Определим тип ссылки
		ТипСсылкиXDTO = ЗначениеСсылкиXDTO.ТипЗначенияXDTO;
		УникальныйИдентификаторСтрокой = ЗначениеСсылкиXDTO.Значение;
		Прервать;
		
	КонецЦикла;
	
	Если ТипСсылкиXDTO = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	// Поиск ПКО
	ПОД = ПОДПоТипуСсылкиXDTO(КомпонентыОбмена, ТипСсылкиXDTO, Истина);
	
	Если Не ЗначениеЗаполнено(ПОД) Тогда
		Возврат;
	КонецЕсли;
		
	МассивИменПКО = ПОД.ИспользуемыеПКО;
	
	Для Каждого ПравилоКонвертацииИмя Из МассивИменПКО Цикл
		
		ПравилоКонвертации = ПКОПоИмени(КомпонентыОбмена, ПравилоКонвертацииИмя);
		
		Если Не ОбъектФорматаПроходитПоФильтруXDTO(КомпонентыОбмена, ПравилоКонвертации.ОбъектФормата) Тогда
			Продолжить;
		КонецЕсли;
		
		Если ПравилоКонвертации.ВариантИдентификации = "СначалаПоУникальномуИдентификаторуПотомПоПолямПоиска"
			Или ПравилоКонвертации.ВариантИдентификации = "ПоУникальномуИдентификатору" Тогда
			
			Если Не ОбъектПроходитПоФильтруТаблицДляЗагрузки(
					ТаблицыДляЗагрузки, ОбъектXDTO.Тип().Имя, ПравилоКонвертации.ТипПолученныхДанныхСтрокой) Тогда
				Продолжить;
			КонецЕсли;
			
			ДополнитьСписокОбъектовКУдалению(КомпонентыОбмена,
				ПравилоКонвертации.ТипДанных, УникальныйИдентификаторСтрокой, МассивОбъектовКУдалению);
			
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура ПрименитьУдалениеОбъектов(КомпонентыОбмена, МассивОбъектовКУдалению, МассивЗагруженныхОбъектов)
	
	Для Каждого ЗагруженныйОбъект Из МассивЗагруженныхОбъектов Цикл
		Пока МассивОбъектовКУдалению.Найти(ЗагруженныйОбъект) <> Неопределено Цикл
			МассивОбъектовКУдалению.Удалить(МассивОбъектовКУдалению.Найти(ЗагруженныйОбъект));
		КонецЦикла;
	КонецЦикла;
	
	ЗапретитьПроведениеДокумента = Метаданные.СвойстваОбъектов.Проведение.Запретить;
	
	Для Каждого ЭлементКУдалению Из МассивОбъектовКУдалению Цикл
		
		// Собственно удаление ссылки.
		Объект = ЭлементКУдалению.ПолучитьОбъект();
		Если Объект = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если КомпонентыОбмена.РежимЗагрузкиДанныхВИнформационнуюБазу Тогда
			Если КомпонентыОбмена.ЭтоОбменЧерезПланОбмена
				И ОбменДаннымиСобытия.ЗагрузкаЗапрещена(Объект, КомпонентыОбмена.УзелКорреспондентаОбъект) Тогда
				Возврат;
			КонецЕсли;
			МетаданныеОбъекта = Объект.Метаданные();
			Если Метаданные.Документы.Содержит(МетаданныеОбъекта) Тогда
				Если Объект.Проведен Тогда
					ЕстьРезультат = ОтменитьПроведениеОбъектаВИБ(Объект, КомпонентыОбмена.УзелКорреспондента);
					Если Не ЕстьРезультат Тогда
						Продолжить;
					КонецЕсли;
				ИначеЕсли МетаданныеОбъекта.Проведение = ЗапретитьПроведениеДокумента Тогда
					СделатьНеактивнымиДвиженияДокумента(Объект, КомпонентыОбмена.УзелКорреспондента);
				КонецЕсли;
			КонецЕсли;
			ОбменДаннымиСервер.УстановитьОбменДаннымиЗагрузка(Объект, Истина, Ложь, КомпонентыОбмена.УзелКорреспондента);
			УдалитьОбъект(Объект, Ложь, КомпонентыОбмена);
		Иначе
			
			ТипПолученныхДанныхСтрокой = ИмяТипаДанныхПоОбъектуМетаданных(Объект.Метаданные());
			
			СтрокаТаблицы = КомпонентыОбмена.ТаблицаДанныхЗаголовкаПакета.Добавить();
			
			СтрокаТаблицы.ТипОбъектаСтрокой = ТипПолученныхДанныхСтрокой;
			СтрокаТаблицы.КоличествоОбъектовВИсточнике = 1;
			СтрокаТаблицы.ТипПриемникаСтрокой = ТипПолученныхДанныхСтрокой;
			СтрокаТаблицы.ЭтоУдалениеОбъекта = Истина;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура УдалитьОбъект(Объект, УдалитьНепосредственно, КомпонентыОбмена)
	
	Если Не РазрешенаЗаписьОбъекта(Объект, КомпонентыОбмена) Тогда
		СтрокаСообщенияОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			?(УдалитьНепосредственно,
				НСтр("ru = 'Попытка удаления неразделенных данных (%1: %2) в разделенном режиме.'"),
				НСтр("ru = 'Попытка пометки на удаление неразделенных данных (%1: %2) в разделенном режиме.'")),
			Объект.Метаданные().ПолноеИмя(),
			Строка(Объект));

		Если КомпонентыОбмена.СостояниеОбменаДанными.РезультатВыполненияОбмена = Неопределено
			Или КомпонентыОбмена.СостояниеОбменаДанными.РезультатВыполненияОбмена = Перечисления.РезультатыВыполненияОбмена.Выполнено Тогда
			КомпонентыОбмена.СостояниеОбменаДанными.РезультатВыполненияОбмена = Перечисления.РезультатыВыполненияОбмена.ВыполненоСПредупреждениями;
		КонецЕсли;
		
		КодОшибки = Новый Структура;
		КодОшибки.Вставить("КраткоеПредставлениеОшибки",   СтрокаСообщенияОбОшибке);
		КодОшибки.Вставить("ПодробноеПредставлениеОшибки", СтрокаСообщенияОбОшибке);
		КодОшибки.Вставить("Уровень",                      УровеньЖурналаРегистрации.Предупреждение);
		
		ЗаписатьВПротоколВыполнения(КомпонентыОбмена, КодОшибки, , Ложь);
		
		Возврат;
	КонецЕсли;
	
	Предопределенный = Ложь;
	Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Объект, "Предопределенный") Тогда
		Предопределенный = Объект.Предопределенный;
	КонецЕсли;
	
	Если Предопределенный Тогда
		Возврат;
	КонецЕсли;
	
	Если УдалитьНепосредственно Тогда
		Объект.Удалить();
	Иначе
		УстановитьПометкуУдаленияУОбъекта(Объект);
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает пометку удаления.
//
// Параметры:
//  Объект          - Объект для установки пометки.
//  ПометкаУдаления - Булево - Флаг пометки удаления.
//  ИмяТипаОбъекта  - Строка - Тип объекта строкой.
//
Процедура УстановитьПометкуУдаленияУОбъекта(Объект)
	
	Если Объект.ДополнительныеСвойства.Свойство("НайденЗапретЗагрузкиДанных") Тогда
		Возврат;
	КонецЕсли;
	МетаданныеОбъекта = Объект.Метаданные();
	Если ОбщегоНазначения.ЭтоДокумент(МетаданныеОбъекта) Тогда
		ОбменДаннымиСервер.УстановитьОбменДаннымиЗагрузка(Объект, Ложь);
		РегистрыСведений.РезультатыОбменаДанными.ЗарегистрироватьУстранениеПроблемы(Объект,
			Перечисления.ТипыПроблемОбменаДанными.НепроведенныйДокумент);
	КонецЕсли;
	
	ОбменДаннымиСервер.УстановитьОбменДаннымиЗагрузка(Объект);
	
	// Для иерархических объектов пометку удаления ставим только у конкретного объекта.
	Если ОбщегоНазначения.ЭтоСправочник(МетаданныеОбъекта)
		Или ОбщегоНазначения.ЭтоПланВидовХарактеристик(МетаданныеОбъекта)
		Или ОбщегоНазначения.ЭтоПланСчетов(МетаданныеОбъекта) Тогда
		Объект.УстановитьПометкуУдаления(Истина, Ложь);
	Иначе
		Объект.УстановитьПометкуУдаления(Истина);
	КонецЕсли;
	
КонецПроцедуры

Функция СообщениеОтНеобновленнойНастройки(ЧтениеXML)
	Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента
		И ЧтениеXML.ЛокальноеИмя = "ФайлОбмена" Тогда
		Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
			Если ЧтениеXML.ЛокальноеИмя = "ВерсияФормата" 
				ИЛИ ЧтениеXML.ЛокальноеИмя = "ВерсияКонфигурацииИсточника" Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Возврат Ложь;
КонецФункции

// Снимает признак активности движений документа.
//
// Параметры:
//  Объект      - ДокументОбъект - Документ, движения которого необходимо обработать.
//  Отправитель - ПланОбменаСсылка - Ссылка на узел плана обмена, который является отправителем данных.
//
// Возвращаемое значение:
//   Булево - признак успешного снятия активности с движений.
Функция СделатьНеактивнымиДвиженияДокумента(Объект, Отправитель)
	
	Попытка
		
		Для Каждого Движение Из Объект.Движения Цикл
			
			Движение.Прочитать();
			ЕстьИзменения = Ложь;
			Для Каждого Строка Из Движение Цикл
				
				Если Строка.Активность = Ложь Тогда
					Продолжить;
				КонецЕсли;
				
				Строка.Активность   = Ложь;
				ЕстьИзменения = Истина;
				
			КонецЦикла;
			
			Если ЕстьИзменения Тогда
				Движение.Записывать = Истина;
				ОбменДаннымиСервер.УстановитьОбменДаннымиЗагрузка(Движение, Истина, Ложь, Отправитель);
				Движение.Записать();
			КонецЕсли;
			
		КонецЦикла;
		
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
	Возврат Истина;
	
КонецФункции

Процедура ОбновитьПрефиксКорреспондента(КомпонентыОбмена)
	
	Если ЗначениеЗаполнено(КомпонентыОбмена.ПрефиксКорреспондента) Тогда
		Префиксы = РегистрыСведений.ОбщиеНастройкиУзловИнформационныхБаз.ПрефиксыУзла(КомпонентыОбмена.УзелКорреспондента);
		Если Не ЗначениеЗаполнено(Префиксы.ПрефиксКорреспондента) Тогда
			РегистрыСведений.ОбщиеНастройкиУзловИнформационныхБаз.ОбновитьПрефиксы(
				КомпонентыОбмена.УзелКорреспондента, , КомпонентыОбмена.ПрефиксКорреспондента);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Параметры:
//   КомпонентыОбмена - см. ОбменДаннымиXDTOСервер.ИнициализироватьКомпонентыОбмена
//
Процедура ОбновитьНастройкиXDTOКорреспондента(КомпонентыОбмена)
	
	// Проверяем возможность увеличения версии в корреспонденте.
	НомерВерсииКорреспондента  = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(КомпонентыОбмена.УзелКорреспондента, "ВерсияФорматаОбмена");
	МаксимальнаяОбщаяВерсия    = МаксимальнаяОбщаяВерсияФормата(
		ОбменДаннымиПовтИсп.ПолучитьИмяПланаОбмена(КомпонентыОбмена.УзелКорреспондента),
		КомпонентыОбмена.НастройкиXDTOКорреспондента.ПоддерживаемыеВерсии);
	
	Если МаксимальнаяОбщаяВерсия <> НомерВерсииКорреспондента Тогда
		НачатьТранзакцию();
		Попытка
		    Блокировка = Новый БлокировкаДанных;
		    ЭлементБлокировки = Блокировка.Добавить(ОбщегоНазначения.ИмяТаблицыПоСсылке(КомпонентыОбмена.УзелКорреспондента));
		    ЭлементБлокировки.УстановитьЗначение("Ссылка", КомпонентыОбмена.УзелКорреспондента);
		    Блокировка.Заблокировать();
		    
			ЗаблокироватьДанныеДляРедактирования(КомпонентыОбмена.УзелКорреспондента);
			УзелКорреспондентаОбъект = КомпонентыОбмена.УзелКорреспондента.ПолучитьОбъект();
			
			УзелКорреспондентаОбъект.ВерсияФорматаОбмена = МаксимальнаяОбщаяВерсия;

			УзелКорреспондентаОбъект.Записать();
			
			ЗафиксироватьТранзакцию();
		Исключение
		    ОтменитьТранзакцию();
		    ВызватьИсключение;
		КонецПопытки;
		
		ЗаписатьВПротоколВыполнения(КомпонентыОбмена, 
			НСтр("ru = 'Изменен номер версии формата обмена.'"), , Ложь, , , Истина);
	КонецЕсли;
	
	РегистрыСведений.НастройкиОбменаДаннымиXDTO.ОбновитьНастройкиКорреспондента(КомпонентыОбмена.УзелКорреспондента,
		"ПоддерживаемыеОбъекты",
		КомпонентыОбмена.НастройкиXDTOКорреспондента.ПоддерживаемыеОбъекты);
	
КонецПроцедуры

Процедура ЗаполнитьСтруктуруНастроекXDTO(КомпонентыОбмена) Экспорт
	
	Если Не КомпонентыОбмена.ЭтоОбменЧерезПланОбмена
		Или Не ЗначениеЗаполнено(КомпонентыОбмена.УзелКорреспондента) Тогда
		Возврат;
	КонецЕсли;
	
	ИмяПланаОбмена = ОбменДаннымиПовтИсп.ПолучитьИмяПланаОбмена(КомпонентыОбмена.УзелКорреспондента);
	
	КомпонентыОбмена.НастройкиXDTO.Формат = ФорматОбмена(ИмяПланаОбмена, "");
	
	Если КомпонентыОбмена.НаправлениеОбмена = "Отправка" Тогда
		КомпонентыОбмена.НастройкиXDTO.ПоддерживаемыеОбъекты = ПоддерживаемыеОбъектыФормата(
			ИмяПланаОбмена, "ОтправкаПолучение", КомпонентыОбмена.УзелКорреспондента);
	Иначе
		ТаблицаОбъекты = Новый ТаблицаЗначений;
		ИнициализироватьТаблицуПоддерживаемыхОбъектовФормата(ТаблицаОбъекты, КомпонентыОбмена.НаправлениеОбмена);
		
		ЗаполнитьПоддерживаемыеОбъектыФорматаПоКомпонентамОбмена(ТаблицаОбъекты, КомпонентыОбмена);
		
		ЕстьАлгоритм = ОбменДаннымиСервер.ЕстьАлгоритмМенеджераПланаОбмена(
			"ПриОпределенииПоддерживаемыхОбъектовФормата", ИмяПланаОбмена);
		Если ЕстьАлгоритм Тогда
			ПланыОбмена[ИмяПланаОбмена].ПриОпределенииПоддерживаемыхОбъектовФормата(
				ТаблицаОбъекты, КомпонентыОбмена.НаправлениеОбмена, КомпонентыОбмена.УзелКорреспондента);
		КонецЕсли;
		
		КомпонентыОбмена.НастройкиXDTO.ПоддерживаемыеОбъекты = ТаблицаОбъекты;
	КонецЕсли;
	
	КомпонентыОбмена.НастройкиXDTO.ПоддерживаемыеВерсии = ВерсииФорматаОбменаМассив(КомпонентыОбмена.УзелКорреспондента);
	
КонецПроцедуры

// Параметры:
//   СтруктураНастроек - Структура - структура настроек:
//     * Формат - Строка - имя формата обмена.
//     * ПоддерживаемыеВерсии - Массив из Строка - коллекция поддерживаемых версий формата.
//     * ПоддерживаемыеОбъекты - см. ПоддерживаемыеОбъектыФормата
//   Header - ОбъектXDTO - заголовок сообщения обмена.
//   ФорматСодержитВерсию - Булево - Истина, если строка формата содержит номер версии.
//   УзелОбмена - ПланОбменаСсылка, Неопределено - узел плана обмена.
//
Процедура ЗаполнитьСтруктуруНастроекXDTOКорреспондента(СтруктураНастроек,
		Header, ФорматСодержитВерсию = Истина, УзелОбмена = Неопределено) Экспорт
	
	СтруктураНастроек.Вставить("Формат", "");
	СтруктураНастроек.Вставить("ПоддерживаемыеВерсии",  Новый Массив);
	СтруктураНастроек.Вставить("ПоддерживаемыеОбъекты", Новый ТаблицаЗначений);
	
	ИнициализироватьТаблицуПоддерживаемыхОбъектовФормата(
		СтруктураНастроек.ПоддерживаемыеОбъекты, "ОтправкаПолучение");
	
	Если ФорматСодержитВерсию Тогда
		ФорматОбмена = РазложитьФорматОбмена(Header.Format);
		СтруктураНастроек.Формат = ФорматОбмена.БазовыйФормат;
	Иначе
		СтруктураНастроек.Формат = Header.Format;
	КонецЕсли;
	
	Для Каждого AvailableVersion Из Header.AvailableVersion Цикл
		СтруктураНастроек.ПоддерживаемыеВерсии.Добавить(AvailableVersion);
	КонецЦикла;
	
	Если Не Header.Установлено("AvailableObjectTypes")
		И Не УзелОбмена = Неопределено
		И ФорматСодержитВерсию Тогда
		// Обратная совместимость с 2.x.
		// Поскольку от корреспондента нет и не может быть получено информации о поддержке объектов,
		// принимаем, что он умеет отправлять все объекты, которые эта база может получать,
		// и может получать все объекты, которые эта база может отправлять.
		// В качестве версии формата принимается максимальная общая версия.
		
		ИмяПланаОбмена = ОбменДаннымиПовтИсп.ПолучитьИмяПланаОбмена(УзелОбмена);
		
		ТаблицаОбъектыБазы = ПоддерживаемыеОбъектыФормата(ИмяПланаОбмена,
			"ОтправкаПолучение", ?(УзелОбмена.Пустая(), Неопределено, УзелОбмена));
		
		Для Каждого Версия Из СтруктураНастроек.ПоддерживаемыеВерсии Цикл
			ОтборПоВерсии = Новый Структура("Версия", Версия);
			
			СтрокиОбъектыБазы = ТаблицаОбъектыБазы.НайтиСтроки(ОтборПоВерсии);
			Для Каждого СтрокаОбъектыБазы Из СтрокиОбъектыБазы Цикл
				
				СтрокаОбъектыКорреспондента = СтруктураНастроек.ПоддерживаемыеОбъекты.Добавить();
				ЗаполнитьЗначенияСвойств(СтрокаОбъектыКорреспондента, СтрокаОбъектыБазы, "Версия, Объект");
				СтрокаОбъектыКорреспондента.Отправка = СтрокаОбъектыБазы.Получение;
				СтрокаОбъектыКорреспондента.Получение = СтрокаОбъектыБазы.Отправка;
				
			КонецЦикла;
		КонецЦикла;
		
		Возврат;
	КонецЕсли;
	
	Если Header.AvailableObjectTypes = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого ObjectType Из Header.AvailableObjectTypes.ObjectType Цикл
		
		Отправка  = Новый Массив;
		Получение = Новый Массив;
		
		Если Не ПустаяСтрока(ObjectType.Sending) Тогда
			
			Если ObjectType.Sending = "*" Тогда
				Для Каждого Версия Из СтруктураНастроек.ПоддерживаемыеВерсии Цикл
					Отправка.Добавить(СокрЛП(Версия));
				КонецЦикла;
			Иначе
				Для Каждого Версия Из СтрРазделить(ObjectType.Sending, ",", Ложь) Цикл
					Отправка.Добавить(СокрЛП(Версия));
				КонецЦикла;
			КонецЕсли;
			
		КонецЕсли;
		
		Если Не ПустаяСтрока(ObjectType.Receiving) Тогда
			
			Если ObjectType.Receiving = "*" Тогда
				Для Каждого Версия Из СтруктураНастроек.ПоддерживаемыеВерсии Цикл
					Получение.Добавить(СокрЛП(Версия));
				КонецЦикла;
			Иначе
				Для Каждого Версия Из СтрРазделить(ObjectType.Receiving, ",", Ложь) Цикл
					Получение.Добавить(СокрЛП(Версия));
				КонецЦикла;
			КонецЕсли;
			
		КонецЕсли;
		
		Для Каждого Версия Из Отправка Цикл
			
			СтрокаОбъект = СтруктураНастроек.ПоддерживаемыеОбъекты.Добавить();
			СтрокаОбъект.Объект = ObjectType.Name;
			СтрокаОбъект.Версия = Версия;
			СтрокаОбъект.Отправка = Истина;
			
			Индекс = Получение.Найти(Версия);
			Если Не Индекс = Неопределено Тогда
				СтрокаОбъект.Получение = Истина;
				Получение.Удалить(Индекс);
			КонецЕсли;
			
		КонецЦикла;
		
		Для Каждого Версия Из Получение Цикл
			
			СтрокаОбъект = СтруктураНастроек.ПоддерживаемыеОбъекты.Добавить();
			СтрокаОбъект.Объект = ObjectType.Name;
			СтрокаОбъект.Версия = Версия;
			СтрокаОбъект.Получение = Истина;
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

Функция РазрешенаЗаписьОбъекта(Объект, КомпонентыОбмена)
	
	Если ОбщегоНазначения.РазделениеВключено()
		И ОбщегоНазначения.ДоступноИспользованиеРазделенныхДанных() Тогда
		
		Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
			МодульРаботаВМоделиСервиса = ОбщегоНазначения.ОбщийМодуль("РаботаВМоделиСервиса");
			ЭтоРазделенныйОбъектМетаданных = МодульРаботаВМоделиСервиса.ЭтоРазделенныйОбъектМетаданных(Объект.Метаданные());
		Иначе
			ЭтоРазделенныйОбъектМетаданных = Ложь;
		КонецЕсли;
		
		Если Не ЭтоРазделенныйОбъектМетаданных Тогда
		
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

#КонецОбласти

#Область ПоискПравилОбмена

Функция ПОДПоТипуСсылкиXDTO(КомпонентыОбмена, ТипСсылкиXDTO, ВозвращатьПустоеЗначение = Ложь)
	
	ПравилоОбработки = КомпонентыОбмена.ПравилаОбработкиДанных.Найти(ТипСсылкиXDTO, "ТипСсылкиXDTO");
	Если ПравилоОбработки = Неопределено Тогда
		
		Если ВозвращатьПустоеЗначение Тогда
			Возврат ПравилоОбработки;
		Иначе
			
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Не найдено ПОД для типа ссылки XDTO.
					|Тип ссылки XDTO: %1
					|Описание ошибки: %2'"),
				Строка(ТипСсылкиXDTO),
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				
		КонецЕсли;
		
	Иначе
		Возврат ПравилоОбработки;
	КонецЕсли;
	
КонецФункции

Функция ПОДПоТипуОбъектаXDTO(КомпонентыОбмена, ТипОбъектаXDTO, ВозвращатьПустоеЗначение = Ложь)
	
	ПравилоОбработки = КомпонентыОбмена.ПравилаОбработкиДанных.Найти(ТипОбъектаXDTO, "ОбъектВыборкиФормат");
	Если ПравилоОбработки = Неопределено Тогда
		
		Если ВозвращатьПустоеЗначение Тогда
			Возврат ПравилоОбработки;
		Иначе
			
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Не найдено ПОД для типа объекта XDTO.
					|Тип объекта XDTO: %1
					|Описание ошибки: %2'"),
				Строка(ТипОбъектаXDTO),
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				
		КонецЕсли;
		
	Иначе
		Возврат ПравилоОбработки;
	КонецЕсли;
	
КонецФункции

Функция ПОДПоОбъектуМетаданных(КомпонентыОбмена, ОбъектМетаданных)
	
	ПравилоОбработки = КомпонентыОбмена.ПравилаОбработкиДанных.Найти(ОбъектМетаданных, "ОбъектВыборкиМетаданные");
	
	Если ПравилоОбработки = Неопределено Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не найдено ПОД для объекта метаданных.
			|Объект метаданных: %3.'"),
			Строка(ОбъектМетаданных));
	КонецЕсли;
	
	Возврат ПравилоОбработки;

КонецФункции

Функция ПОДПоИмени(КомпонентыОбмена, Имя)
	
	ПравилоОбработки = КомпонентыОбмена.ПравилаОбработкиДанных.Найти(Имя, "Имя");
	
	Если ПравилоОбработки = Неопределено Тогда
		
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Не найдено ПОД с именем %1'"), Имя);
			
	Иначе
		Возврат ПравилоОбработки;
	КонецЕсли;

КонецФункции

Процедура ПолучитьПравилоОбработкиДляОбъекта(КомпонентыОбмена, Объект, ПравилоОбработки)
	
	Попытка
		ПравилоОбработки = ПОДПоОбъектуМетаданных(КомпонентыОбмена, Объект.Метаданные());
	Исключение
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Событие: %1.
			|Объект: %2.
			|
			|%3.'"),
			КомпонентыОбмена.НаправлениеОбмена,
			ПредставлениеОбъектаДляПротокола(Объект),
			КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиСобытийПравилОбработкиДанных
// Процедура - "обертка" вызова обработчика ПОД ПриОбработке.
//
// Параметры:
//  КомпонентыОбмена - Структура - содержит все правила и параметры обмена.
//  ПравилоОбработки - Строка таблицы правил обработки данных, соответствующая обрабатываемому ПОД
//  ОбъектОбработки  - Ссылка на объект, подлежащий обработке
//                     либо структура, соответствующая объекту XDTO (при загрузке), 
//                     либо ссылка на объект информационной базы (при выгрузке).
//  ИспользованиеПКО - Структура, определяющая по каким ПКО будет выгружен объект
//                     ключи соответствуют именам ПКО, 
//                     значения - признак использования ПКО для конкретного объекта обработки.
//
Процедура ПриОбработкеПОД(КомпонентыОбмена, ПравилоОбработки, Знач ОбъектОбработки, ИспользованиеПКО, Отказ = Ложь)
	
	Если Не ЗначениеЗаполнено(ПравилоОбработки.ПриОбработке) Тогда
		Возврат;
	КонецЕсли;
	
	МенеджерОбмена = КомпонентыОбмена.МенеджерОбмена;
	СтруктураПараметров = Новый Структура();
	СтруктураПараметров.Вставить("ОбъектОбработки",  ОбъектОбработки);
	СтруктураПараметров.Вставить("ИспользованиеПКО", ИспользованиеПКО);
	СтруктураПараметров.Вставить("КомпонентыОбмена", КомпонентыОбмена);

	Попытка
		МенеджерОбмена.ВыполнитьПроцедуруМодуляМенеджера(ПравилоОбработки.ПриОбработке, СтруктураПараметров);
	Исключение
		Отказ = Истина;
		
		ОписаниеОшибки = ОписаниеОшибкиПОД(
			КомпонентыОбмена.НаправлениеОбмена,
			ПравилоОбработки.Имя,
			ПредставлениеОбъектаДляПротокола(ОбъектОбработки, ПравилоОбработки.ОбъектВыборкиМетаданные),
			ИнформацияОбОшибке());
		
		ЗафиксироватьПроблемуПриОбработкеОбъекта(КомпонентыОбмена,
			ОбъектОбработки,
			?(КомпонентыОбмена.НаправлениеОбмена = "Отправка",
				Перечисления.ТипыПроблемОбменаДанными.ОшибкаВыполненияКодаОбработчиковПриОтправкеДанных,
				Перечисления.ТипыПроблемОбменаДанными.ОшибкаВыполненияКодаОбработчиковПриПолученииДанных),
			ОписаниеОшибки.ПодробноеПредставление,
			ОписаниеОшибки.КраткоеПредставление);
	КонецПопытки;
	
	ОбъектОбработки  = СтруктураПараметров.ОбъектОбработки;
	ИспользованиеПКО = СтруктураПараметров.ИспользованиеПКО;
	КомпонентыОбмена = СтруктураПараметров.КомпонентыОбмена;
	
КонецПроцедуры

// Функция - "обертка" вызова обработчика ПОД ВыборкаДанных.
//
// Параметры:
//  КомпонентыОбмена - Структура - содержит все правила и параметры обмена.
//  ПравилоОбработки - СтрокаТаблицыЗначений - строка правил обработки данных, соответствующая обрабатываемому ПОД.
//
// Возвращаемое значение - то что вернет обработчик ВыборкаДанных (например, выборка результата запроса).
//
Функция ВыборкаДанных(КомпонентыОбмена, ПравилоОбработки)
	
	АлгоритмВыборки = ПравилоОбработки.ВыборкаДанных;
	Если ЗначениеЗаполнено(АлгоритмВыборки) Тогда
		
		МенеджерОбмена = КомпонентыОбмена.МенеджерОбмена;
		СтруктураПараметров = Новый Структура();
		СтруктураПараметров.Вставить("КомпонентыОбмена", КомпонентыОбмена);
		
		Попытка
			ВыборкаДанных = МенеджерОбмена.ВыполнитьФункциюМодуляМенеджера(ПравилоОбработки.ВыборкаДанных, СтруктураПараметров);
		Исключение
			ТекстОшибки = Символы.ПС + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Событие: %1.
					|Обработчик: ВыборкаДанных.
					|ПОД: %2.
					|
					|Ошибка выполнения обработчика.
					|%3.'"),
				КомпонентыОбмена.НаправлениеОбмена,
				ПравилоОбработки.Имя,
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ВызватьИсключение ТекстОшибки;
		КонецПопытки;
		
	Иначе
		Запрос = Новый Запрос;
		Запрос.Текст = 
		"ВЫБРАТЬ
		|	Ссылка
		|ИЗ
		|	" + ПравилоОбработки.ИмяТаблицыДляВыборки;
		
		ВыборкаДанных = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	КонецЕсли;
	
	Возврат ВыборкаДанных;
	
КонецФункции

#КонецОбласти

#Область ОбработчикиСобытийПравилКонвертации
// Функция - "обертка" вызова обработчика ПКО ПриОтправкеДанных.
//
// Параметры:
//  ДанныеИБ         - Ссылка на выгружаемый объект информационной базы.
//                     Может быть также структура ключевых свойств, если выгружается не объект, а ссылка.
//  ДанныеXDTO       - Структура, в которую выгружаются данные. По составу идентичная объекту XDTO.
//  ИмяОбработчика   - Строка, имя процедуры-обработчика в модуле менеджера.
//  КомпонентыОбмена - Структура - содержит все правила и параметры обмена.
//  СтекВыгрузки     - Массив, содержит ссылки на выгружаемые объекты с учетом вложенности.
//
Процедура ПриОтправкеДанных(ДанныеИБ, ДанныеXDTO, Знач ИмяОбработчика, КомпонентыОбмена, СтекВыгрузки)
	
	МенеджерОбмена = КомпонентыОбмена.МенеджерОбмена;
	СтруктураПараметров = Новый Структура();
	СтруктураПараметров.Вставить("ДанныеИБ", ДанныеИБ);
	СтруктураПараметров.Вставить("ДанныеXDTO", ДанныеXDTO);
	СтруктураПараметров.Вставить("КомпонентыОбмена", КомпонентыОбмена);
	СтруктураПараметров.Вставить("СтекВыгрузки", СтекВыгрузки);

	Попытка
		МенеджерОбмена.ВыполнитьПроцедуруМодуляМенеджера(ИмяОбработчика, СтруктураПараметров);
	Исключение
		ТекстОшибки = Символы.ПС + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Событие: %1.
				|Обработчик: ПриОтправкеДанных.
				|Объект: %2.
				|
				|Ошибка выполнения обработчика.
				|%3.'"),
			КомпонентыОбмена.НаправлениеОбмена,
			ПредставлениеОбъектаДляПротокола(ДанныеИБ),
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	ДанныеXDTO       = СтруктураПараметров.ДанныеXDTO;
	КомпонентыОбмена = СтруктураПараметров.КомпонентыОбмена;
	СтекВыгрузки     = СтруктураПараметров.СтекВыгрузки;
	
КонецПроцедуры

// Функция - "обертка" вызова обработчика ПКО ПриКонвертацииДанныхXDTO.
//
// Параметры:
//  ПолученныеДанные - Объект информационной базы, в который происходит загрузка данных.
//  ДанныеXDTO       - Структура, из которой загружаются данные. По составу идентичная загружаемому объекту XDTO.
//  КомпонентыОбмена - Структура - содержит все правила и параметры обмена.
//  ИмяОбработчика   - Строка, имя процедуры-обработчика в модуле менеджера.
//
Процедура ПриКонвертацииДанныхXDTO(ДанныеXDTO, ПолученныеДанные, КомпонентыОбмена, Знач ИмяОбработчика)
	
	МенеджерОбмена = КомпонентыОбмена.МенеджерОбмена;
	СтруктураПараметров = Новый Структура();
	СтруктураПараметров.Вставить("ДанныеXDTO", ДанныеXDTO);
	СтруктураПараметров.Вставить("ПолученныеДанные", ПолученныеДанные);
	СтруктураПараметров.Вставить("КомпонентыОбмена", КомпонентыОбмена);
	
	Попытка
		МенеджерОбмена.ВыполнитьПроцедуруМодуляМенеджера(ИмяОбработчика, СтруктураПараметров);
	Исключение
		ТекстОшибки = Символы.ПС + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Событие: %1.
				|Обработчик: ПриКонвертацииДанныхXDTO.
				|Объект: %2.
				|
				|Ошибка выполнения обработчика.
				|%3.'"),
			КомпонентыОбмена.НаправлениеОбмена,
			ПредставлениеОбъектаДляПротокола(ПолученныеДанные),
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	ДанныеXDTO               = СтруктураПараметров.ДанныеXDTO;
	ПолученныеДанные         = СтруктураПараметров.ПолученныеДанные;
	КомпонентыОбмена         = СтруктураПараметров.КомпонентыОбмена;
	
КонецПроцедуры

// Функция - "обертка" вызова обработчика ПКО ПередЗаписьюПолученныхДанных.
//
// Параметры:
//  ПолученныеДанные   - Объект информационной базы, в который происходит загрузка данных.
//  ДанныеИБ           - Объект информационной базы, который найден при идентификации загружаемых данных.
//                       Если объект соответствующий загружаемому не найден, ДанныеИБ = Неопределено.
//  КомпонентыОбмена   - Структура - содержит все правила и параметры обмена.
//  ИмяОбработчика     - Строка - имя процедуры-обработчика в модуле менеджера.
//  КонвертацияСвойств - ТаблицаЗначений - правила конвертации свойств объекта.
//                       Используется для определения состава свойств, подлежащих переносу из ПолученныеДанные в
//                       ДанныеИБ.
//
Процедура ПередЗаписьюПолученныхДанных(ПолученныеДанные, ДанныеИБ, КомпонентыОбмена, ИмяОбработчика, КонвертацияСвойств)
	
	МенеджерОбмена = КомпонентыОбмена.МенеджерОбмена;
	СтруктураПараметров = Новый Структура();
	СтруктураПараметров.Вставить("ДанныеИБ", ДанныеИБ);
	СтруктураПараметров.Вставить("ПолученныеДанные", ПолученныеДанные);
	СтруктураПараметров.Вставить("КомпонентыОбмена", КомпонентыОбмена);
	СтруктураПараметров.Вставить("КонвертацияСвойств", КонвертацияСвойств);

	Попытка
		МенеджерОбмена.ВыполнитьПроцедуруМодуляМенеджера(ИмяОбработчика, СтруктураПараметров);
	Исключение
		ТекстОшибки = Символы.ПС + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Событие: %1.
				|Обработчик: ПередЗаписьюПолученныхДанных.
				|Объект: %2.
				|
				|Ошибка выполнения обработчика.
				|%3.'"),
			КомпонентыОбмена.НаправлениеОбмена,
			ПредставлениеОбъектаДляПротокола(?(ДанныеИБ <> Неопределено, ДанныеИБ, ПолученныеДанные)),
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	ДанныеИБ                 = СтруктураПараметров.ДанныеИБ;
	ПолученныеДанные         = СтруктураПараметров.ПолученныеДанные;
	КомпонентыОбмена         = СтруктураПараметров.КомпонентыОбмена;
	КонвертацияСвойств       = СтруктураПараметров.КонвертацияСвойств;
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область ВедениеПротокола

// Возвращает объект типа структура, содержащий все возможные поля
// записи протокола выполнения (сообщения об ошибках и т.п.).
//
// Параметры:
//  КСообщенияОбОшибках - Строка, содержит код ошибки.
//  СтрокаОшибки        - Строка, содержит строку модуля где возникла ошибка.
//
// Возвращаемое значение:
//  структура - Объект типа структура
//
Функция ЗаписьПротоколаОбмена(КСообщенияОбОшибках = "", Знач СтрокаОшибки = "")

	СтруктураОшибки = Новый Структура(
		"ТипОбъекта,
		|Объект,
		|ОписаниеОшибки,
		|ПозицияМодуля,
		|КСообщенияОбОшибках");
	
	СтрокаМодуля = ОтделитьРазделителем(СтрокаОшибки, "{");
	Если ПустаяСтрока(СтрокаОшибки) Тогда
		ОписаниеОшибки = СокрЛП(ОтделитьРазделителем(СтрокаМодуля, "}:"));
	Иначе
		ОписаниеОшибки = СтрокаОшибки;
		СтрокаМодуля   = "{" + СтрокаМодуля;
	КонецЕсли;
	
	Если ОписаниеОшибки <> "" Тогда
		СтруктураОшибки.ОписаниеОшибки = ОписаниеОшибки;
		СтруктураОшибки.ПозицияМодуля  = СтрокаМодуля;
	КонецЕсли;
	
	Если СтруктураОшибки.КСообщенияОбОшибках <> "" Тогда
		
		СтруктураОшибки.КСообщенияОбОшибках = КСообщенияОбОшибках;
		
	КонецЕсли;
	
	Возврат СтруктураОшибки;
	
КонецФункции

Функция РезультатВыполненияОбменаОшибка(РезультатВыполненияОбмена)
	
	Возврат РезультатВыполненияОбмена = Перечисления.РезультатыВыполненияОбмена.Ошибка
		Или РезультатВыполненияОбмена = Перечисления.РезультатыВыполненияОбмена.Ошибка_ТранспортСообщения;
	
КонецФункции

Функция РезультатВыполненияОбменаПредупреждение(РезультатВыполненияОбмена)
	
	Возврат РезультатВыполненияОбмена = Перечисления.РезультатыВыполненияОбмена.ВыполненоСПредупреждениями
		Или РезультатВыполненияОбмена = Перечисления.РезультатыВыполненияОбмена.Предупреждение_СообщениеОбменаБылоРанееПринято;
	
КонецФункции

// Функция формирует представление объекта, для записи в протокол обмена.
//
// Параметры:
//   Объект - Ссылка - ссылка на любой ОМД;
//          - Объект - ОМД;
//          - ОбъектXDTO - объект XDTO;
//          - Структура.
//   МетаданныеДляПредставленияСтруктуры - ОбъектМетаданных - метаданные объекта, для которого формируется представление.
//
// Возвращаемое значение:
//   Строка - строковое представление объекта.
//
Функция ПредставлениеОбъектаДляПротокола(Объект, МетаданныеДляПредставленияСтруктуры = Неопределено)
	
	ТипОбъекта           = ТипЗнч(Объект);
	МетаданныеОбъекта    = Метаданные.НайтиПоТипу(ТипОбъекта);
	ПредставлениеОбъекта = Строка(Объект);
	НавигационнаяСсылка  = "";
	
	Если МетаданныеОбъекта <> Неопределено
		И ОбщегоНазначения.ЭтоОбъектСсылочногоТипа(МетаданныеОбъекта)
		И ЗначениеЗаполнено(Объект.Ссылка) Тогда
		НавигационнаяСсылка = ПолучитьНавигационнуюСсылку(Объект);
	Иначе
		
		Если ТипОбъекта = Тип("ОбъектXDTO") Тогда
			
			КоллекцияСвойств = Объект.Свойства();
			ПредставлениеОбъекта = "";
			ТипОбъекта = Объект.Тип().Имя;
			
			Если КоллекцияСвойств.Количество() > 0 И КоллекцияСвойств.Получить("КлючевыеСвойства") <> Неопределено Тогда
				КлючевыеСвойства = Объект.Получить("КлючевыеСвойства");
				
				Реквизиты = Новый Структура("Наименование, Код, КодВПрограмме, Номер, Дата");
				ЗаполнитьЗначенияСвойств(Реквизиты, КлючевыеСвойства);
				
				ПредставлениеОбъекта = ПредставлениеКоллекцииСвойствДляПротокола(Реквизиты);
			КонецЕсли;
			
		ИначеЕсли ТипОбъекта = Тип("Структура") Тогда
			
			СформироватьПредставлениеДляСтруктуры = Истина;
			Если Объект.Свойство("Ссылка")
				И ЗначениеЗаполнено(Объект.Ссылка) Тогда
				ТипОбъекта = ТипЗнч(Объект.Ссылка);
				Если ОбщегоНазначения.ЭтоСсылка(ТипОбъекта) Тогда
					ПредставлениеОбъекта = Строка(Объект.Ссылка);
					НавигационнаяСсылка  = ПолучитьНавигационнуюСсылку(Объект.Ссылка);
					
					СформироватьПредставлениеДляСтруктуры = Ложь;
				КонецЕсли;
			КонецЕсли;
			
			Если СформироватьПредставлениеДляСтруктуры Тогда
				ТипОбъекта = Строка(ТипЗнч(Объект));
				Если Не МетаданныеДляПредставленияСтруктуры = Неопределено Тогда
					ТипОбъекта = ТипОбъекта + "<" + МетаданныеДляПредставленияСтруктуры.Представление() + ">";
				КонецЕсли;
				
				ПредставлениеОбъекта = ПредставлениеКоллекцииСвойствДляПротокола(Объект);
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	ПредставлениеОбъекта = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = '%1, %2 (%3)'"),
		ТипОбъекта, ПредставлениеОбъекта, НавигационнаяСсылка);
	
	Возврат ПредставлениеОбъекта;
	
КонецФункции

Функция ПредставлениеКоллекцииСвойствДляПротокола(КоллекцияСвойств)
	
	Представление = Строка(КоллекцияСвойств);
	
	ЭлементыПредставления = Новый Массив;
				
	ЗначениеСвойства = Неопределено;
	
	Если КоллекцияСвойств.Свойство("Наименование", ЗначениеСвойства)
		И ЗначениеЗаполнено(ЗначениеСвойства) Тогда
		ЭлементыПредставления.Добавить(СокрЛП(ЗначениеСвойства));
	КонецЕсли;
	
	Если КоллекцияСвойств.Свойство("Код", ЗначениеСвойства)
		И ЗначениеЗаполнено(ЗначениеСвойства) Тогда
		ЭлементыПредставления.Добавить("(" + СокрЛП(ЗначениеСвойства) + ")");
	ИначеЕсли КоллекцияСвойств.Свойство("КодВПрограмме", ЗначениеСвойства)
		И ЗначениеЗаполнено(ЗначениеСвойства) Тогда
		ЭлементыПредставления.Добавить("(" + СокрЛП(ЗначениеСвойства) + ")");
	КонецЕсли;
	
	Если КоллекцияСвойств.Свойство("Номер", ЗначениеСвойства)
		И ЗначениеЗаполнено(ЗначениеСвойства) Тогда
		
		ЗначениеСвойстваДата = Неопределено;
		Если КоллекцияСвойств.Свойство("Дата", ЗначениеСвойстваДата)
			И ЗначениеЗаполнено(ЗначениеСвойстваДата) Тогда
			ЭлементыПредставления.Добавить(
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = '№%1 от %2'"), ЗначениеСвойства, Формат(ЗначениеСвойстваДата, "ДЛФ=D")));
		Иначе
			ЭлементыПредставления.Добавить(
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = '№%1'"), ЗначениеСвойства));
		КонецЕсли;
		
	ИначеЕсли КоллекцияСвойств.Свойство("Дата", ЗначениеСвойства)
		И ЗначениеЗаполнено(ЗначениеСвойства) Тогда
		
		ЭлементыПредставления.Добавить(
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'от %1'"), ЗначениеСвойства));
		
	КонецЕсли;
	
	Если ЭлементыПредставления.Количество() > 0 Тогда
		Представление = СтрСоединить(ЭлементыПредставления, " ");
	КонецЕсли;
	
	Возврат Представление;
	
КонецФункции

Функция ПредставлениеОбъектаXDTOДляПротокола(ТипОбъектаXDTO)
	
	Возврат ТипОбъектаXDTO.Имя;
	
КонецФункции

#КонецОбласти

#Область РезультатыОбменаДанными

Функция ОписаниеОшибкиПОД(НаправлениеОбмена, ИмяПОД, ПредставлениеОбъекта, Информация)
	
	Результат = Новый Структура("КраткоеПредставление, ПодробноеПредставление");
	
	ШаблонОписанияОшибки = НСтр("ru = 'Событие: %1.
	|Обработчик: ПриОбработкеПОД.
	|ПОД: %2.
	|Объект: %3.
	|
	|Ошибка выполнения обработчика.
	|%4.'");
	
	Результат.КраткоеПредставление = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		ШаблонОписанияОшибки,
		НаправлениеОбмена,
		ИмяПОД,
		ПредставлениеОбъекта,
		КраткоеПредставлениеОшибки(Информация));
	Результат.ПодробноеПредставление = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		ШаблонОписанияОшибки,
		НаправлениеОбмена,
		ИмяПОД,
		ПредставлениеОбъекта,
		ПодробноеПредставлениеОшибки(Информация));
	
	Возврат Результат;
	
КонецФункции

Функция ОписаниеОшибкиПКО(НаправлениеОбмена, ИмяПОД, ИмяПКО, ПредставлениеОбъекта, Информация)
	
	Результат = Новый Структура("КраткоеПредставление, ПодробноеПредставление");
	
	ШаблонОписанияОшибки = НСтр("ru = 'Направление: %1.
	|ПОД: %2.
	|ПКО: %3.
	|Объект: %4.
	|
	|%5'");
	
	Результат.КраткоеПредставление = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		ШаблонОписанияОшибки,
		НаправлениеОбмена,
		ИмяПОД,
		ИмяПКО,
		ПредставлениеОбъекта,
		КраткоеПредставлениеОшибки(Информация));
	Результат.ПодробноеПредставление = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		ШаблонОписанияОшибки,
		НаправлениеОбмена,
		ИмяПОД,
		ИмяПКО,
		ПредставлениеОбъекта,
		ПодробноеПредставлениеОшибки(Информация));
		
	Возврат Результат;
	
КонецФункции

Процедура ЗафиксироватьПроблемуПриОбработкеОбъекта(КомпонентыОбмена,
		ОбъектОбработки, ТипПроблемы, ПодробноеПредставление, КраткоеПредставление = "")
	
	КодОшибки = Новый Структура("Уровень", УровеньОшибкиПоТипуПроблемы(КомпонентыОбмена, ТипПроблемы));
	КодОшибки.Вставить("ПодробноеПредставлениеОшибки", ПодробноеПредставление);
	КодОшибки.Вставить("КраткоеПредставлениеОшибки",
		?(ПустаяСтрока(КраткоеПредставление), ПодробноеПредставление, КраткоеПредставление));
	
	Если КомпонентыОбмена.ЭтоОбменЧерезПланОбмена Тогда
		Если КомпонентыОбмена.НаправлениеОбмена = "Отправка" Тогда
			ЗаписатьВПротоколВыполнения(КомпонентыОбмена, КодОшибки, , Не КомпонентыОбмена.ПропускатьОбъектыСОшибкамиПроверкиПоСхеме);
			ЗаписатьОшибкуОбработкиОбъектаПриОтправке(
				ОбъектОбработки,
				КомпонентыОбмена.УзелКорреспондента,
				КодОшибки.КраткоеПредставлениеОшибки,
				ТипПроблемы);
		Иначе
			ЗаписатьВПротоколВыполнения(КомпонентыОбмена, КодОшибки);
		КонецЕсли;
	Иначе
		ЗаписатьВПротоколВыполнения(КомпонентыОбмена, КодОшибки);
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаписатьОшибкуОбработкиОбъектаПриОтправке(ОбъектОбработки, УзелИнформационнойБазы, Причина, ТипПроблемы)
	
	Если ТипЗнч(ОбъектОбработки) = Тип("Структура") Тогда
		Возврат;
	КонецЕсли;
	
	Если ОбщегоНазначения.ЭтоОбъектСсылочногоТипа(ОбъектОбработки.Метаданные()) Тогда
		РегистрыСведений.РезультатыОбменаДанными.ЗарегистрироватьОшибкуПроверкиОбъекта(
			ОбъектОбработки.Ссылка,
			УзелИнформационнойБазы,
			Причина,
			ТипПроблемы);
	Иначе
		РегистрыСведений.РезультатыОбменаДанными.ЗарегистрироватьОшибкуПроверкиОбъекта(
			ОбъектОбработки,
			УзелИнформационнойБазы,
			Причина,
			ТипПроблемы);
	КонецЕсли;

КонецПроцедуры

Процедура ОчиститьСписокОшибокПриВыгрузкеДанных(УзелИнформационнойБазы)
	
	РегистрыСведений.РезультатыОбменаДанными.ОчиститьПроблемыПриОтправке(УзелИнформационнойБазы);
	
КонецПроцедуры

Процедура ОчиститьСписокОшибокПриЗагрузкеДанных(УзелИнформационнойБазы)
	
	РегистрыСведений.РезультатыОбменаДанными.ОчиститьПроблемыПриПолучении(УзелИнформационнойБазы);
	
КонецПроцедуры

Функция УровеньОшибкиПоТипуПроблемы(КомпонентыОбмена, ТипПроблемы)
	
	Если ТипПроблемы = Перечисления.ТипыПроблемОбменаДанными.ОшибкаПроверкиСконвертированногоОбъекта Тогда
		Возврат ?(КомпонентыОбмена.ЭтоОбменЧерезПланОбмена
				И КомпонентыОбмена.ПропускатьОбъектыСОшибкамиПроверкиПоСхеме,
			УровеньЖурналаРегистрации.Предупреждение, УровеньЖурналаРегистрации.Ошибка);
	ИначеЕсли ТипПроблемы = Перечисления.ТипыПроблемОбменаДанными.ОшибкаВыполненияКодаОбработчиковПриОтправкеДанных
		Или ТипПроблемы = Перечисления.ТипыПроблемОбменаДанными.ОшибкаВыполненияКодаОбработчиковПриПолученииДанных Тогда
		Возврат УровеньЖурналаРегистрации.Ошибка;
	ИначеЕсли ТипПроблемы = Перечисления.ТипыПроблемОбменаДанными.НезаполненныеРеквизиты
		Или ТипПроблемы = Перечисления.ТипыПроблемОбменаДанными.НепроведенныйДокумент Тогда
		Возврат УровеньЖурналаРегистрации.Предупреждение;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииВерсионированияФорматаОбмена

Функция ВерсииФорматаОбмена(Знач УзелИнформационнойБазы)
	
	ВерсииФорматаОбмена = Новый Соответствие;
	ИмяПланаОбмена = "";
	
	Если ЗначениеЗаполнено(УзелИнформационнойБазы) Тогда
		ИмяПланаОбмена = ОбменДаннымиПовтИсп.ПолучитьИмяПланаОбмена(УзелИнформационнойБазы);
		ВерсииФорматаОбмена = ОбменДаннымиСервер.ЗначениеНастройкиПланаОбмена(ИмяПланаОбмена, "ВерсииФорматаОбмена");
	Иначе
		ОбменДаннымиПереопределяемый.ПриПолученииДоступныхВерсийФормата(ВерсииФорматаОбмена);
	КонецЕсли;
	
	Если ВерсииФорматаОбмена.Количество() = 0 Тогда
		Если ЗначениеЗаполнено(УзелИнформационнойБазы) Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Не заданы версии формата обмена.
				|Имя плана обмена: %1
				|Процедура: ПолучитьВерсииФорматаОбмена(<ВерсииФорматаОбмена>)'"),
				ИмяПланаОбмена);
		Иначе
			ВызватьИсключение НСтр("ru = 'Не заданы версии формата обмена.
				|Процедура: ОбменДаннымиПереопределяемый.ПриПолученииДоступныхВерсийФормата(<ВерсииФорматаОбмена>)'");
		КонецЕсли;
	КонецЕсли;
	
	Результат = Новый Соответствие;
	
	Для Каждого Версия Из ВерсииФорматаОбмена Цикл
		
		Результат.Вставить(СокрЛП(Версия.Ключ), Версия.Значение);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция СортироватьВерсииФормата(Знач ВерсииФормата)
	
	Результат = Новый ТаблицаЗначений;
	Результат.Колонки.Добавить("Версия");
	
	Для Каждого Версия Из ВерсииФормата Цикл
		
		Результат.Добавить().Версия = Версия.Ключ;
		
	КонецЦикла;
	
	Результат.Сортировать("Версия Убыв");
	
	Возврат Результат.ВыгрузитьКолонку("Версия");
КонецФункции

Процедура ПроверитьВерсию(Знач Версия)
	
	Версии = СтрРазделить(Версия, ".");
	
	Если Версии.Количество() = 0 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Неканоническое представление версии формата обмена: <%1>.'"), Версия);
	КонецЕсли;
	
КонецПроцедуры

Функция МинимальнаяВерсияФорматаОбмена(Знач УзелИнформационнойБазы)
	
	Результат = Неопределено;
	
	ВерсииФормата = ВерсииФорматаОбмена(УзелИнформационнойБазы);
	
	Для Каждого ВерсияФормата Из ВерсииФормата Цикл
		
		Если Результат = Неопределено Тогда
			Результат = ВерсияФормата.Ключ;
			Продолжить;
		КонецЕсли;
		Если СравнитьВерсии(СокрЛП(Результат), СокрЛП(ВерсияФормата.Ключ)) > 0 Тогда
			Результат = ВерсияФормата.Ключ;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Получает массив версий формата обмена, сортированные по убыванию.
// Параметры:
//  УзелИнформационнойБазы - ссылка на узел-корреспондент.
//
Функция ВерсииФорматаОбменаМассив(Знач УзелИнформационнойБазы) Экспорт
	
	Возврат СортироватьВерсииФормата(ВерсииФорматаОбмена(УзелИнформационнойБазы));
	
КонецФункции

// Сравнить две строки версий.
//
// Параметры:
//  СтрокаВерсии1  - Строка - номер версии в формате 0.0.0 либо 0.0.
//  СтрокаВерсии2  - Строка - второй сравниваемый номер версии.
//
// Возвращаемое значение:
//   Число   - больше 0, если СтрокаВерсии1 > СтрокаВерсии2; 0, если версии равны.
//             Меньше 0 если СтрокаВерсии1 < СтрокаВерсии2.
Функция СравнитьВерсии(Знач СтрокаВерсии1, Знач СтрокаВерсии2)
	
	Строка1 = ?(ПустаяСтрока(СтрокаВерсии1), "0.0", СтрокаВерсии1);
	Строка2 = ?(ПустаяСтрока(СтрокаВерсии2), "0.0", СтрокаВерсии2);
	Версия1 = СтрРазделить(Строка1, ".");
	Если Версия1.Количество() < 2 ИЛИ Версия1.Количество() > 3 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Неправильный формат параметра СтрокаВерсии1: %1'"), СтрокаВерсии1);
	КонецЕсли;
	Версия2 = СтрРазделить(Строка2, ".");
	Если Версия2.Количество() < 2 ИЛИ Версия2.Количество() > 3 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Неправильный формат параметра СтрокаВерсии2: %1'"), СтрокаВерсии2);
	КонецЕсли;
	
	Результат = 0;
	Если СокрЛП(СтрокаВерсии1) = СокрЛП(СтрокаВерсии2) Тогда
		Возврат 0;
	КонецЕсли;
	
	// В последнем разряде может быть beta - это минимальная версия, не совместимая ни с какой другой.
	Если Версия1.Количество() = 3 И СокрЛП(Версия1[2]) = "beta" Тогда
		Возврат -1;
	ИначеЕсли Версия2.Количество() = 3 И СокрЛП(Версия2[2]) = "beta" Тогда
		Возврат 1;
	КонецЕсли;
	// Значимыми при сравнении являются первые 2 разряда (всегда число).
	Для Разряд = 0 По 1 Цикл
		Результат = Число(Версия1[Разряд]) - Число(Версия2[Разряд]);
		Если Результат <> 0 Тогда
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

Функция ВерсияПоддерживается(ПоддерживаемыеВерсии, ПроверяемаяВерсия)
	
	Результат = Ложь;
	
	Для Каждого ПоддерживаемаяВерсия Из ПоддерживаемыеВерсии Цикл
		Если СравнитьВерсии(ПоддерживаемаяВерсия, ПроверяемаяВерсия) >= 0 Тогда
			Результат = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область Прочее

// Разбирает строку на две части: до подстроки разделителя и после.
//
// Параметры:
//  Стр          - разбираемая строка;
//  Разделитель  - подстрока-разделитель:
//  Режим        - 0 - разделитель в возвращаемые подстроки не включается;
//                 1 - разделитель включается в левую подстроку;
//                 2 - разделитель включается в правую подстроку.
//
// Возвращаемое значение:
//  Правая часть строки - до символа-разделителя.
// 
Функция ОтделитьРазделителем(Стр, Знач Разделитель, Режим=0)

	ПраваяЧасть         = "";
	ПозРазделителя      = СтрНайти(Стр, Разделитель);
	ДлинаРазделителя    = СтрДлина(Разделитель);
	Если ПозРазделителя > 0 Тогда
		ПраваяЧасть	 = Сред(Стр, ПозРазделителя + ?(Режим=2, 0, ДлинаРазделителя));
		Стр          = СокрЛП(Лев(Стр, ПозРазделителя - ?(Режим=1, -ДлинаРазделителя + 1, 1)));
	КонецЕсли;

	Возврат(ПраваяЧасть);

КонецФункции // ОтделитьРазделителем()

// Возвращает строковое представление типа, свойственного для данных,
// соответствующих переданному объекту метаданных.
// Может быть использован как значение параметра встроенной функции Тип().
//
// Параметры:
//  ОбъектМетаданных - объект метаданных, по которому необходимо определить имя типа;
//
// Возвращаемое значение:
//  Строка - например, "СправочникСсылка.Номенклатура".
//
Функция ИмяТипаДанныхПоОбъектуМетаданных(Знач ОбъектМетаданных)
	
	ЛитералыТипа = СтрРазделить(ОбъектМетаданных.ПолноеИмя(), ".");
	ТипТаблицы = ЛитералыТипа[0];
	
	Если ТипТаблицы = "Константа" Тогда
		
		ШаблонИмениТипа = "[ТипТаблицы]МенеджерЗначения.[ИмяТаблицы]";
		
	ИначеЕсли ТипТаблицы = "РегистрСведений"
		Или ТипТаблицы = "РегистрНакопления"
		Или ТипТаблицы = "РегистрБухгалтерии"
		Или ТипТаблицы = "РегистрРасчета" Тогда
		
		ШаблонИмениТипа = "[ТипТаблицы]НаборЗаписей.[ИмяТаблицы]";
		
	Иначе
		ШаблонИмениТипа = "[ТипТаблицы]Ссылка.[ИмяТаблицы]";
	КонецЕсли;
	
	ШаблонИмениТипа = СтрЗаменить(ШаблонИмениТипа, "[ТипТаблицы]", ЛитералыТипа[0]);
	Результат = СтрЗаменить(ШаблонИмениТипа, "[ИмяТаблицы]", ЛитералыТипа[1]);
	Возврат Результат;
	
КонецФункции

Процедура ЗаписатьПриНеобходимостиПубличныйИдентификатор(
		ДанныеДляЗаписиВИБ,
		ПолученныеДанныеСсылка,
		УИДСтрокой,
		УзелОбмена,
		ПравилоКонвертации)
	
	ВариантИдентификации = СокрЛП(ПравилоКонвертации.ВариантИдентификации);
	Если Не (ВариантИдентификации = "СначалаПоУникальномуИдентификаторуПотомПоПолямПоиска"
		Или ВариантИдентификации = "ПоУникальномуИдентификатору")
		Или Не ЗначениеЗаполнено(УзелОбмена) Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураЗаписи = Новый Структура;
	СтруктураЗаписи.Вставить("УзелИнформационнойБазы", УзелОбмена);
	СтруктураЗаписи.Вставить("Ссылка", ?(ДанныеДляЗаписиВИБ = Неопределено, ПолученныеДанныеСсылка, ДанныеДляЗаписиВИБ.Ссылка));
	
	Если ДанныеДляЗаписиВИБ <> Неопределено
		И РегистрыСведений.ПубличныеИдентификаторыСинхронизируемыхОбъектов.ЗаписьЕстьВРегистре(СтруктураЗаписи) Тогда
		Возврат;
	КонецЕсли;
	
	ПубличныйИдентификатор = ?(ЗначениеЗаполнено(УИДСтрокой), УИДСтрокой, ПолученныеДанныеСсылка.УникальныйИдентификатор());
	СтруктураЗаписи.Вставить("Идентификатор", ПубличныйИдентификатор);
	
	РегистрыСведений.ПубличныеИдентификаторыСинхронизируемыхОбъектов.ДобавитьЗапись(СтруктураЗаписи, Истина);
	
КонецПроцедуры

Процедура ДобавитьВыгруженныеОбъектыВРегистрПубличныеИдентификаторы(КомпонентыОбмена)
	УзелДляОбмена = КомпонентыОбмена.УзелКорреспондента;
	СоставПланаОбмена = УзелДляОбмена.Метаданные().Состав;
	ТекстЗапроса = "ВЫБРАТЬ 
	|	ТаблицаИзменений.Ссылка
	|ИЗ 
	|	#ПолноеИмя#.Изменения КАК ТаблицаИзменений
	|ЛЕВОЕ СОЕДИНЕНИЕ 
	|	РегистрСведений.ПубличныеИдентификаторыСинхронизируемыхОбъектов КАК ПубличныеИдентификаторы
	|ПО ПубличныеИдентификаторы.УзелИнформационнойБазы = &Узел И ПубличныеИдентификаторы.Ссылка = ТаблицаИзменений.Ссылка
	|ГДЕ ТаблицаИзменений.Узел = &Узел И ТаблицаИзменений.НомерСообщения <= &НомерСообщения
	|	И ПубличныеИдентификаторы.Идентификатор ЕСТЬ NULL";
	Для Каждого ЭлементСостава Из СоставПланаОбмена Цикл
		Если НЕ ОбщегоНазначения.ЭтоОбъектСсылочногоТипа(ЭлементСостава.Метаданные) Тогда
			Продолжить;
		КонецЕсли;
		ПолноеИмяОбъекта = ЭлементСостава.Метаданные.ПолноеИмя();
		Запрос = Новый Запрос;
		Запрос.Текст = СтрЗаменить(ТекстЗапроса, "#ПолноеИмя#", ПолноеИмяОбъекта);
		Запрос.УстановитьПараметр("Узел", УзелДляОбмена);
		Запрос.УстановитьПараметр("НомерСообщения", КомпонентыОбмена.НомерСообщенияПолученногоКорреспондентом);
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			СтруктураЗаписи = Новый Структура;
			СтруктураЗаписи.Вставить("Ссылка", Выборка.Ссылка);
			СтруктураЗаписи.Вставить("УзелИнформационнойБазы", КомпонентыОбмена.УзелКорреспондента);
			СтруктураЗаписи.Вставить("Идентификатор", Выборка.Ссылка.УникальныйИдентификатор());
			РегистрыСведений.ПубличныеИдентификаторыСинхронизируемыхОбъектов.ДобавитьЗапись(СтруктураЗаписи, Истина);
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

Функция XMLБазоваяСхема()
	
	Возврат "http://www.1c.ru/SSL/Exchange/Message";
	
КонецФункции

Функция НомерВерсииСПоддержкойИдентификатораОбменаДанными()
	Возврат "1.5";
КонецФункции

Процедура ИнициализироватьТаблицуПоддерживаемыхОбъектовФормата(ТаблицаОбъекты, Режим)
	
	ТаблицаОбъекты.Колонки.Добавить("Версия", Новый ОписаниеТипов("Строка"));
	ТаблицаОбъекты.Колонки.Добавить("Объект", Новый ОписаниеТипов("Строка"));
	
	Если СтрНайти(Режим, "Отправка") Тогда
		ТаблицаОбъекты.Колонки.Добавить("Отправка", Новый ОписаниеТипов("Булево"));
	КонецЕсли;
	
	Если СтрНайти(Режим, "Получение") Тогда
		ТаблицаОбъекты.Колонки.Добавить("Получение", Новый ОписаниеТипов("Булево"));
	КонецЕсли;
	
	ТаблицаОбъекты.Индексы.Добавить("Версия, Объект");
	
КонецПроцедуры

Процедура ЗаполнитьПоддерживаемыеОбъектыФорматаПоКомпонентамОбмена(ТаблицаОбъекты, КомпонентыОбмена)
	
	Если КомпонентыОбмена.НаправлениеОбмена = "Отправка" Тогда
		
		Для Каждого ПравилоКонвертации Из КомпонентыОбмена.ПравилаКонвертацииОбъектов Цикл
			
			Отбор = Новый Структура;
			Отбор.Вставить("Версия", КомпонентыОбмена.ВерсияФорматаОбмена);
			Отбор.Вставить("Объект", ПравилоКонвертации.ТипXDTO.Имя);
			
			СтрокиОбъекты = ТаблицаОбъекты.НайтиСтроки(Отбор);
			Если СтрокиОбъекты.Количество() = 0 Тогда
				СтрокаОбъекты = ТаблицаОбъекты.Добавить();
				ЗаполнитьЗначенияСвойств(СтрокаОбъекты, Отбор);
			Иначе
				СтрокаОбъекты = СтрокиОбъекты[0];
			КонецЕсли;
			
			СтрокаОбъекты.Отправка = Истина;
			
		КонецЦикла;
		
	ИначеЕсли КомпонентыОбмена.НаправлениеОбмена = "Получение" Тогда
		
		Для Каждого ПравилоОбработки Из КомпонентыОбмена.ПравилаОбработкиДанных Цикл
			
			Отбор = Новый Структура;
			Отбор.Вставить("Версия", КомпонентыОбмена.ВерсияФорматаОбмена);
			Отбор.Вставить("Объект", ПравилоОбработки.ОбъектВыборкиФормат);
			
			СтрокиОбъекты = ТаблицаОбъекты.НайтиСтроки(Отбор);
			Если СтрокиОбъекты.Количество() = 0 Тогда
				СтрокаОбъекты = ТаблицаОбъекты.Добавить();
				ЗаполнитьЗначенияСвойств(СтрокаОбъекты, Отбор);
			Иначе
				СтрокаОбъекты = СтрокиОбъекты[0];
			КонецЕсли;
			
			СтрокаОбъекты.Получение = Истина;
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

Функция ОбъектФорматаПроходитПоФильтруXDTO(КомпонентыОбмена, ОбъектФормата)
	
	Возврат Не КомпонентыОбмена.ЭтоОбменЧерезПланОбмена
		Или КомпонентыОбмена.ПоддерживаемыеОбъектыXDTO.Найти(ОбъектФормата) <> Неопределено;
	
КонецФункции
	
Функция ОбъектПроходитПоФильтруТаблицДляЗагрузки(ТаблицыДляЗагрузки, ТипДанныхПриОтправке, ТипДанныхПриПолучении)
	
	Если ТаблицыДляЗагрузки = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	
	КлючТаблицыДанных = ОбменДаннымиСервер.КлючТаблицыДанных(ТипДанныхПриОтправке, ТипДанныхПриПолучении, Ложь);
	
	Возврат ТаблицыДляЗагрузки.Найти(КлючТаблицыДанных) <> Неопределено;
	
КонецФункции

Функция ПоискПоИдентификатору(Знач ВариантИдентификации)
	
	ВариантИдентификации = СокрЛП(ВариантИдентификации);
	
	Возврат (ВариантИдентификации = "СначалаПоУникальномуИдентификаторуПотомПоПолямПоиска")
		Или (ВариантИдентификации = "ПоУникальномуИдентификатору");
									
КонецФункции
	
Процедура ДополнитьСписокОбъектовКУдалению(КомпонентыОбмена, ТипДанных, УникальныйИдентификатор, МассивОбъектовКУдалению)
	
	СсылкаКУдалению = СсылкаОбъектаПоУИДОбъектаXDTO(УникальныйИдентификатор,
		ТипДанных, КомпонентыОбмена);
	Если МассивОбъектовКУдалению.Найти(СсылкаКУдалению) = Неопределено Тогда
		МассивОбъектовКУдалению.Добавить(СсылкаКУдалению);
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбновитьСчетчикЗагруженныхОбъектов(КомпонентыОбмена)
	
	КомпонентыОбмена.СчетчикЗагруженныхОбъектов = КомпонентыОбмена.СчетчикЗагруженныхОбъектов + 1;
	ОбменДаннымиСервер.РассчитатьПроцентЗагрузки(КомпонентыОбмена.СчетчикЗагруженныхОбъектов,
		КомпонентыОбмена.КоличествоОбъектовКЗагрузке, КомпонентыОбмена.РазмерФайлаСообщенияОбмена);
	
КонецПроцедуры

// Параметры:
//   ТипОбъектаXDTO - ТипОбъектаXDTO -
//   Свойства - Массив из Строка -
// 
Процедура ЗаполнитьСписокСвойствОбъектаXDTO(ТипОбъектаXDTO, Свойства)
	
	Для Каждого ДочернееСвойство Из ТипОбъектаXDTO.Свойства Цикл
		Если ТипЗнч(ДочернееСвойство.Тип) = Тип("ТипОбъектаXDTO")
			И СтрНачинаетсяС(ДочернееСвойство.Тип.Имя, "ОбщиеСвойства") Тогда
			ЗаполнитьСписокСвойствОбъектаXDTO(ДочернееСвойство.Тип, Свойства);
		Иначе
			Свойства.Добавить(ДочернееСвойство.Имя);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти