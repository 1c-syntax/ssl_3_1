///////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2019, ООО 1С-Софт
// Все права защищены. Эта программа и сопроводительные материалы предоставляются 
// в соответствии с условиями лицензии Attribution 4.0 International (CC BY 4.0)
// Текст лицензии доступен по ссылке:
// https://creativecommons.org/licenses/by/4.0/legalcode
///////////////////////////////////////////////////////////////////////////////////////////////////////

#Область СлужебныйПрограммныйИнтерфейс

////////////////////////////////////////////////////////////////////////////////
// Основные процедуры и функции.

// Добавляет пользователя в группу доступа, соответствующую поставляемому профилю.
// Группа доступа определяется по идентификатору ссылки поставляемого профиля.
// Если группа доступа не будет найдена, она будет создана.
//
// Параметры:
//  Пользователь        - СправочникСсылка.Пользователи,
//                        СправочникСсылка.ВнешниеПользователи,
//                        СправочникСсылка.ГруппыПользователей,
//                        СправочникСсылка.ГруппыВнешнихПользователей
//                        - участник, которого нужно включить в группу доступа.
// 
//  ПоставляемыйПрофиль - Строка - строка идентификатора поставляемого профиля.
//                      - СправочникСсылка.ПрофилиГруппДоступа - ссылка на профиль, который
//                        создан по описанию в модуле УправлениеДоступомПереопределяемый
//                        в процедуре ЗаполнитьПоставляемыеПрофилиГруппДоступа.
//                        Профили с непустым списком видов доступа не поддерживаются.
//                        Профиль групп доступа Администратор не поддерживается.
// 
Процедура ВключитьПользователяВГруппуДоступа(Пользователь, ПоставляемыйПрофиль) Экспорт
	
	ОбработатьСвязьПользователяСГруппойДоступа(Пользователь, ПоставляемыйПрофиль, Истина);
	
КонецПроцедуры

// Обновляет состав пользователей указанных групп исполнителей.
// 
// Требуется вызывать при изменении состава пользователей у групп исполнителей,
// например, у групп исполнителей задач.
//
// В качестве значений параметра передается группы исполнителей, состав которых изменился.
//
// Параметры:
//  ГруппыИсполнителей - Например, СправочникСсылка.ГруппыИсполнителейЗадач.
//                     - Массив значений указанных выше типов.
//                     - Неопределено - без отбора.
//
Процедура ОбновитьПользователейГруппИсполнителей(ГруппыИсполнителей = Неопределено) Экспорт
	
	Если ТипЗнч(ГруппыИсполнителей) = Тип("Массив") И ГруппыИсполнителей.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Параметры = Новый Структура;
	Параметры.Вставить("ГруппыИсполнителей", ГруппыИсполнителей);
	
	РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппировкиПользователей(Параметры);
	
КонецПроцедуры

// Проверяет существование вида доступа с указанным именем.
// Применяется для автоматизации условного встраивания подсистем.
// 
Функция ВидДоступаСуществует(ИмяВидаДоступа) Экспорт
	
	Возврат СвойстваВидаДоступа(ИмяВидаДоступа) <> Неопределено;
	
КонецФункции

// Возвращает вид интерфейса пользователя для настройки доступа.
Функция УпрощенныйИнтерфейсНастройкиПравДоступа() Экспорт
	
	УпрощенныйИнтерфейс = Ложь;
	УправлениеДоступомПереопределяемый.ПриОпределенииИнтерфейсаНастройкиДоступа(УпрощенныйИнтерфейс);
	
	Возврат УпрощенныйИнтерфейс = Истина;
	
КонецФункции

// Возвращает массив разрешенных значений указанных типов в рамках всех групп доступа.
// Используется в процедуре НастроитьОтборыДинамическогоСписка для ускорения открытия динамических списков.
// 
// Параметры:
//  Таблица      - Строка - полное имя объекта метаданных, например, "Документ.РасходнаяНакладная".
//  ТипЗначений  - Тип    - тип значений доступа, разрешенные значения которых нужно вернуть.
//               - Массив - массив указанных выше типов.
//
//  Значения     - Неопределено - не учитывать.
//               - Массив - массив значений типов, указанных в параметре ТипЗначений.
//
//  Пользователь - Неопределено - вернуть разрешенные значения для авторизованного пользователя.
//               - СправочникСсылка.Пользователи, СправочникСсылка.ВнешниеПользователи - вернуть
//                   разрешенные значения для указанного пользователя.
//
//  ВернутьВсе   - Булево - если установить Истина, тогда будут возвращены все значение даже тогда,
//                   когда их более 100.
//
// Возвращаемое значение:
//  Неопределено - либо все значения разрешены для типов, указанных в параметре ТипЗначений,
//                 либо (когда ВернутьВсе = Ложь) количество разрешенных значений превышает 100.
//  Массив       - ссылки разрешенных значений указанных типов.
//
Функция РазрешенныеЗначенияДляДинамическогоСписка(Таблица, ТипЗначений, Значения = Неопределено, Пользователь = Неопределено, ВернутьВсе = Ложь) Экспорт
	
	Если ТипЗнч(ТипЗначений) <> Тип("Массив") Тогда
		ТипыЗначений = Новый Массив;
		ТипыЗначений.Добавить(ТипЗначений);
		
	ИначеЕсли ТипЗначений.Количество() = 0 Тогда
		Возврат Неопределено;
	Иначе
		ТипыЗначений = ТипЗначений;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТекстЗапросаЗначенийБезГрупп =
	"ВЫБРАТЬ ПЕРВЫЕ 101
	|	ЗначенияБезГрупп.Ссылка КАК Ссылка
	|ИЗ
	|	(ВЫБРАТЬ
	|		&ЗначениеПустойСсылки КАК Ссылка
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ВЫБРАТЬ
	|		ЗначенияБезПустойСсылки.Ссылка
	|	ИЗ
	|		&ТаблицаЗначенийДоступа КАК ЗначенияБезПустойСсылки) КАК ЗначенияБезГрупп
	|ГДЕ
	|	ИСТИНА В
	|			(ВЫБРАТЬ ПЕРВЫЕ 1
	|				ИСТИНА
	|			ИЗ
	|				ГруппыДоступаПользователя КАК ГруппыДоступа
	|			ГДЕ
	|				ВЫБОР
	|					КОГДА ИСТИНА В
	|							(ВЫБРАТЬ ПЕРВЫЕ 1
	|								ИСТИНА
	|							ИЗ
	|								РегистрСведений.ЗначенияГруппДоступа КАК Значения
	|							ГДЕ
	|								Значения.ГруппаДоступа = ГруппыДоступа.Ссылка
	|								И Значения.ЗначениеДоступа = ЗначенияБезГрупп.Ссылка)
	|						ТОГДА ИСТИНА
	|					ИНАЧЕ ЛОЖЬ
	|				КОНЕЦ = ВЫБОР
	|					КОГДА ИСТИНА В
	|							(ВЫБРАТЬ ПЕРВЫЕ 1
	|								ИСТИНА
	|							ИЗ
	|								РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
	|							ГДЕ
	|								ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
	|								И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(ЗначенияБезГрупп.Ссылка)
	|								И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ)
	|						ТОГДА ИСТИНА
	|					ИНАЧЕ ЛОЖЬ
	|				КОНЕЦ)
	|	И ЗначенияБезГрупп.Ссылка В(&Значения)";
	
	Если ТипЗнч(Значения) = Тип("Массив") Или ВернутьВсе Тогда
		ТекстЗапросаЗначенийБезГрупп = СтрЗаменить(ТекстЗапросаЗначенийБезГрупп, "ПЕРВЫЕ 101", "");
	КонецЕсли;
	Если ТипЗнч(Значения) <> Тип("Массив") Тогда
		ТекстЗапросаЗначенийБезГрупп = СтрЗаменить(ТекстЗапросаЗначенийБезГрупп, "ЗначенияБезГрупп.Ссылка В(&Значения)", "Истина");
	КонецЕсли;
	
	ТекстЗапросаЗначенийСГруппами =
	"ВЫБРАТЬ ПЕРВЫЕ 101
	|	ЗначенияСГруппами.Ссылка КАК Ссылка
	|ИЗ
	|	(ВЫБРАТЬ
	|		&ЗначениеПустойСсылки КАК Ссылка
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ВЫБРАТЬ
	|		ЗначенияБезПустойСсылки.Ссылка
	|	ИЗ
	|		&ТаблицаЗначенийДоступа КАК ЗначенияБезПустойСсылки) КАК ЗначенияСГруппами
	|ГДЕ
	|	ИСТИНА В
	|			(ВЫБРАТЬ ПЕРВЫЕ 1
	|				ИСТИНА
	|			ИЗ
	|				ГруппыДоступаПользователя КАК ГруппыДоступа
	|			ГДЕ
	|				ВЫБОР
	|					КОГДА ИСТИНА В
	|							(ВЫБРАТЬ ПЕРВЫЕ 1
	|								ИСТИНА
	|							ИЗ
	|								РегистрСведений.ЗначенияГруппДоступа КАК Значения
	|									ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
	|									ПО
	|										Значения.ГруппаДоступа = ГруппыДоступа.Ссылка
	|											И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаЗначенийДоступа
	|											И ГруппыЗначений.ЗначениеДоступа = ЗначенияСГруппами.Ссылка)
	|						ТОГДА ИСТИНА
	|					ИНАЧЕ ЛОЖЬ
	|				КОНЕЦ = ВЫБОР
	|					КОГДА ИСТИНА В
	|							(ВЫБРАТЬ ПЕРВЫЕ 1
	|								ИСТИНА
	|							ИЗ
	|								РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
	|							ГДЕ
	|								ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
	|								И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(ЗначенияСГруппами.Ссылка)
	|								И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ)
	|						ТОГДА ИСТИНА
	|					ИНАЧЕ ЛОЖЬ
	|				КОНЕЦ)
	|	И ЗначенияСГруппами.Ссылка В(&Значения)";
	
	Если ТипЗнч(Значения) = Тип("Массив") Или ВернутьВсе Тогда
		ТекстЗапросаЗначенийСГруппами = СтрЗаменить(ТекстЗапросаЗначенийСГруппами, "ПЕРВЫЕ 101", "");
	КонецЕсли;
	Если ТипЗнч(Значения) <> Тип("Массив") Тогда
		ТекстЗапросаЗначенийСГруппами = СтрЗаменить(ТекстЗапросаЗначенийСГруппами, "ЗначенияСГруппами.Ссылка В(&Значения)", "Истина");
	КонецЕсли;
	
	ТекстЗапросаВсеЗначения =
	"ВЫБРАТЬ ПЕРВЫЕ 101
	|	ВсеЗначения.Ссылка КАК Ссылка
	|ИЗ
	|	(ВЫБРАТЬ
	|		&ЗначениеПустойСсылки КАК Ссылка
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ВЫБРАТЬ
	|		ЗначенияБезПустойСсылки.Ссылка
	|	ИЗ
	|		&ТаблицаЗначенийДоступа КАК ЗначенияБезПустойСсылки) КАК ВсеЗначения
	|ГДЕ
	|	ВсеЗначения.Ссылка В(&Значения)";
	
	Если ТипЗнч(Значения) = Тип("Массив") Или ВернутьВсе Тогда
		ТекстЗапросаВсеЗначения = СтрЗаменить(ТекстЗапросаВсеЗначения, "ПЕРВЫЕ 101", "");
	КонецЕсли;
	Если ТипЗнч(Значения) <> Тип("Массив") Тогда
		ТекстЗапросаВсеЗначения = СтрЗаменить(ТекстЗапросаВсеЗначения, "ВсеЗначения.Ссылка В(&Значения)", "Истина");
	КонецЕсли;
	
	СвойстваВидовДоступа = УправлениеДоступомСлужебныйПовтИсп.СвойстваВидовДоступа();
	ТекстЗапроса = "";
	Если Пользователь <> Неопределено Тогда
		АвторизованныйПользователь = Пользователь;
	Иначе
		АвторизованныйПользователь = Пользователи.АвторизованныйПользователь();
	КонецЕсли;
	ДобавитьТекущегоПользователя = Ложь;
	ЕстьИспользуемыеВидыДоступа = Ложь;
	
	Для Каждого ТекущийТип Из ТипыЗначений Цикл
		Свойства = СвойстваВидовДоступа.ПоТипамЗначений.Получить(ТекущийТип);
		Если Свойства = Неопределено Тогда
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Тип ""%1"" не является типом значений доступа'"), Строка(ТекущийТип));
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
		Если Не ВидДоступаИспользуется(Свойства.Имя) Тогда
			ТекущийТекстЗапроса = ТекстЗапросаВсеЗначения;
		Иначе
			Если СвойстваВидовДоступа.ТипыЗначенийДоступаСГруппами.Получить(ТекущийТип) = Неопределено Тогда
				ТекущийТекстЗапроса = ТекстЗапросаЗначенийБезГрупп;
			Иначе
				ТекущийТекстЗапроса = ТекстЗапросаЗначенийСГруппами;
			КонецЕсли;
			ЕстьИспользуемыеВидыДоступа = Истина;
		КонецЕсли;
		ТаблицаЗначенийДоступа = Метаданные.НайтиПоТипу(ТекущийТип).ПолноеИмя();
		ТекущийТекстЗапроса = СтрЗаменить(ТекущийТекстЗапроса, "&ТаблицаЗначенийДоступа", ТаблицаЗначенийДоступа);
		ТекущийТекстЗапроса = СтрЗаменить(ТекущийТекстЗапроса, "&ЗначениеПустойСсылки",
			"ЗНАЧЕНИЕ(" + ТаблицаЗначенийДоступа + ".ПустаяСсылка)");
		Если ЗначениеЗаполнено(ТекстЗапроса) Тогда
			ОбъединитьЗапросСЗапросом(ТекстЗапроса, ТекущийТекстЗапроса);
		Иначе
			ТекстЗапроса = ТекущийТекстЗапроса;
		КонецЕсли;
		Если ТекущийТип = ТипЗнч(АвторизованныйПользователь) Тогда
			ДобавитьТекущегоПользователя = Истина;
		КонецЕсли;
	КонецЦикла;
	
	Если Не ЕстьИспользуемыеВидыДоступа Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ИмяОсновнойТаблицыСписка", Таблица);
	Запрос.УстановитьПараметр("АвторизованныйПользователь", АвторизованныйПользователь);
	Запрос.Текст = ТекстЗапросаГруппДоступа();
	Если ТипЗнч(Значения) = Тип("Массив") Тогда
		Запрос.УстановитьПараметр("Значения", Значения);
	КонецЕсли;
	
	ДобавитьЗапросВПакет(Запрос.Текст, ТекстЗапроса);
	
	Выгрузка = Запрос.Выполнить().Выгрузить();
	
	Если ТипЗнч(Значения) <> Тип("Массив")
	   И Не ВернутьВсе
	   И Выгрузка.Количество() > 100 Тогда
		
		Возврат Неопределено;
	КонецЕсли;
	
	РазрешенныеЗначения = Выгрузка.ВыгрузитьКолонку("Ссылка");
	
	Если ДобавитьТекущегоПользователя Тогда
		РазрешенныеЗначения.Добавить(АвторизованныйПользователь);
	КонецЕсли;
	
	Возврат РазрешенныеЗначения;
	
КонецФункции

// Добавляет администраторов системы в группу доступа,
// связанную с предопределенным профилем ОткрытиеВнешнихОтчетовИОбработок.
//
Процедура УстановитьПравоОткрытияВнешнихОтчетовИОбработок(ОткрытиеРазрешено) Экспорт
	
	СвойстваПрофиля = ОписаниеПрофиляОткрытиеВнешнихОтчетовИОбработок();
	СвойстваПрофиля.Вставить("Ссылка", Справочники.ПрофилиГруппДоступа.ПоставляемыйПрофильПоИдентификатору(
		СвойстваПрофиля.Имя, Истина));
	
	ИдентификаторРоли = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(
		Метаданные.Роли.ИнтерактивноеОткрытиеВнешнихОтчетовИОбработок);
	
	// В упрощенном интерфейсе группу доступа создавать не требуется (только профиль).
	УпрощенныйИнтерфейс = УпрощенныйИнтерфейсНастройкиПравДоступа();
	Если Не УпрощенныйИнтерфейс Тогда
		ГруппаПрофиля = ГруппаДоступаОткрытиеВнешнихОтчетовИОбработок(СвойстваПрофиля);
	КонецЕсли;
	
	Если ОткрытиеРазрешено Тогда
		// Включение администраторов в группы доступа с этим профилем.
		РольАдминистратора = Метаданные.Роли.АдминистраторСистемы;
		ПользователиИБ = ПользователиИнформационнойБазы.ПолучитьПользователей();
		СоставПользователей = Новый Массив;
		Для Каждого ПользовательИБ Из ПользователиИБ Цикл
			Если ПользовательИБ.Роли.Содержит(РольАдминистратора) Тогда
				Пользователь = Справочники.Пользователи.НайтиПоРеквизиту(
					"ИдентификаторПользователяИБ",
					ПользовательИБ.УникальныйИдентификатор);
				Если Пользователь = Неопределено Тогда
					Продолжить;
				КонецЕсли;
				Если УпрощенныйИнтерфейс Тогда
					// В упрощенном интерфейсе каждый администратор включаются в отдельную группу.
					УправлениеДоступом.ВключитьПрофильПользователю(Пользователь, СвойстваПрофиля.Ссылка);
				Иначе
					// В расширенном интерфейсе администраторы включаются в одну группу, связанную с предопределенным профилем.
					СоставПользователей.Добавить(Пользователь);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		Если Не УпрощенныйИнтерфейс Тогда
			Блокировка = Новый БлокировкаДанных;
			ЭлементБлокировки = Блокировка.Добавить("Справочник.ГруппыДоступа");
			ЭлементБлокировки.УстановитьЗначение("Ссылка", ГруппаПрофиля);
			НачатьТранзакцию();
			Попытка
				Блокировка.Заблокировать();
				ГруппаДоступаОбъект = ГруппаПрофиля.ПолучитьОбъект();
				Для Каждого Пользователь Из СоставПользователей Цикл
					Если ГруппаДоступаОбъект.Пользователи.Найти(Пользователь, "Пользователь") = Неопределено Тогда
						ГруппаДоступаОбъект.Пользователи.Добавить().Пользователь = Пользователь;
					КонецЕсли;
				КонецЦикла;
				Если ГруппаДоступаОбъект.Модифицированность() Тогда
					ГруппаДоступаОбъект.Записать();
				КонецЕсли;
				ЗафиксироватьТранзакцию();
			Исключение
				ОтменитьТранзакцию();
				ВызватьИсключение;
			КонецПопытки;
		КонецЕсли;
	Иначе
		// Удаление роли из всех профилей, за исключением предопределенного.
		Запрос = Новый Запрос;
		Запрос.Текст =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ПрофилиГруппДоступаРоли.Ссылка
		|ИЗ
		|	Справочник.ПрофилиГруппДоступа.Роли КАК ПрофилиГруппДоступаРоли
		|ГДЕ
		|	ПрофилиГруппДоступаРоли.Роль = &Роль
		|	И ПрофилиГруппДоступаРоли.Ссылка <> &ИсключаемыйПрофиль";
		Запрос.УстановитьПараметр("Роль", ИдентификаторРоли);
		Запрос.УстановитьПараметр("ИсключаемыйПрофиль", СвойстваПрофиля.Ссылка);
		МассивПрофилей = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
		Для Каждого Профиль Из МассивПрофилей Цикл
			Блокировка = Новый БлокировкаДанных;
			ЭлементБлокировки = Блокировка.Добавить("Справочник.ПрофилиГруппДоступа");
			ЭлементБлокировки.УстановитьЗначение("Ссылка", Профиль);
			НачатьТранзакцию();
			Попытка
				Блокировка.Заблокировать();
				ПрофильОбъект = Профиль.ПолучитьОбъект();
				Найденные = ПрофильОбъект.Роли.НайтиСтроки(Новый Структура("Роль", ИдентификаторРоли));
				Для Каждого СтрокаТаблицы Из Найденные Цикл
					ПрофильОбъект.Роли.Удалить(СтрокаТаблицы);
				КонецЦикла;
				ПрофильОбъект.Записать();
				ЗафиксироватьТранзакцию();
			Исключение
				ОтменитьТранзакцию();
				ВызватьИсключение;
			КонецПопытки;
		КонецЦикла;
		
		// Очистка состава групп доступа, связанных с предопределенным профилем.
		Запрос = Новый Запрос;
		Запрос.Текст =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ГруппыДоступа.Ссылка
		|ИЗ
		|	Справочник.ГруппыДоступа КАК ГруппыДоступа
		|ГДЕ
		|	ГруппыДоступа.Профиль = &Профиль";
		Запрос.УстановитьПараметр("Профиль", СвойстваПрофиля.Ссылка);
		МассивГрупп = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
		Для Каждого ГруппаДоступа Из МассивГрупп Цикл
			Блокировка = Новый БлокировкаДанных;
			ЭлементБлокировки = Блокировка.Добавить("Справочник.ГруппыДоступа");
			ЭлементБлокировки.УстановитьЗначение("Ссылка", ГруппаДоступа);
			НачатьТранзакцию();
			Попытка
				Блокировка.Заблокировать();
				ГруппаДоступаОбъект = ГруппаДоступа.ПолучитьОбъект();
				ГруппаДоступаОбъект.Пользователи.Очистить();
				ГруппаДоступаОбъект.Записать();
				ЗафиксироватьТранзакцию();
			Исключение
				ОтменитьТранзакцию();
				ВызватьИсключение;
			КонецПопытки;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Только для внутреннего использования.
Процедура ПриРегистрацииИспользованияВерсииРасширенийВНеразделенномСеансе() Экспорт
	
	Если ТекущийРежимЗапуска() = Неопределено
	 Или ОбщегоНазначения.ДоступноИспользованиеРазделенныхДанных() Тогда
		Возврат;
	КонецЕсли;
	
	ОтключитьУВсехРасширенийФлажокИспользоватьОсновныеРолиДляВсехПользователей();
	
КонецПроцедуры

#Область УниверсальноеОграничение

Функция ОграничиватьДоступНаУровнеЗаписейУниверсально(СУчетомКонстантыОграничениеДоступаНаУровнеЗаписей = Истина,
			КогдаПервоеОбновлениеДоступаЗавершилось = Ложь, ОбновлятьПараметрыСеансаКогдаТребуется = Истина) Экспорт
	
	Если СУчетомКонстантыОграничениеДоступаНаУровнеЗаписей Тогда
		Значение = Константы.ОграничиватьДоступНаУровнеЗаписейУниверсально.Получить();
		
		Если ОбновлятьПараметрыСеансаКогдаТребуется
		   И (Значение <> УправлениеДоступомСлужебныйПовтИсп.КонстантаОграничиватьДоступНаУровнеЗаписейУниверсально()
		      Или Значение
		        И Не ПараметрыСеанса.ОграничениеДоступаНаУровнеЗаписейУниверсально
		        И Константы.ПервоеОбновлениеДоступаЗавершилось.Получить()) Тогда
			
			ОбновитьПараметрыСеанса();
		КонецЕсли;
		
		Возврат Значение
		      И (Не КогдаПервоеОбновлениеДоступаЗавершилось
		         Или Константы.ПервоеОбновлениеДоступаЗавершилось.Получить());
	КонецЕсли;
	
	Если ОбновлятьПараметрыСеансаКогдаТребуется
	   И Не ПараметрыСеанса.ОтключениеОбновленияКлючейДоступа.Полное
	   И Не ПараметрыСеанса.ОграничениеДоступаНаУровнеЗаписейУниверсально Тогда
		
		ПоследняяПроверка = УправлениеДоступомСлужебныйПовтИсп.ПоследняяПроверкаВерсииРазрешенныхНаборов();
		Если ПоследняяПроверка.Дата + 3 <= ТекущаяДатаСеанса() Тогда
			ПоследняяПроверка.Дата = ТекущаяДатаСеанса();
			
			Если Константы.ПервоеОбновлениеДоступаЗавершилось.Получить()
			 Или УправлениеДоступомСлужебныйПовтИсп.КонстантаОграничиватьДоступНаУровнеЗаписейУниверсально()
					<> Константы.ОграничиватьДоступНаУровнеЗаписейУниверсально.Получить() Тогда
				
				ОбновитьПараметрыСеанса();
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если Не КогдаПервоеОбновлениеДоступаЗавершилось Тогда
		Возврат УправлениеДоступомСлужебныйПовтИсп.КонстантаОграничиватьДоступНаУровнеЗаписейУниверсально();
	КонецЕсли;
	
	Возврат ПараметрыСеанса.ОграничениеДоступаНаУровнеЗаписейУниверсально;
	
КонецФункции

// Устанавливает использование регламентного задания ОбновлениеДоступа.
//
// Параметры:
//   Использование - Булево - Истина, если задание нужно включить, иначе Ложь.
//
Процедура УстановитьОбновлениеДоступа(Использование, БезПроверкиВыполненияОбновленияИБ = Ложь) Экспорт
	
	Если Использование
	   И Не БезПроверкиВыполненияОбновленияИБ
	   И ОбновлениеИнформационнойБазы.ВыполняетсяОбновлениеИнформационнойБазы() Тогда
		
		Возврат; // После обновления ИБ задание включается безусловно.
	КонецЕсли;
	
	Если Использование Тогда
		ПоследнееОбновлениеДоступа = ПоследнееОбновлениеДоступа();
		Если ПоследнееОбновлениеДоступа.ОбновлениеДоступаЗапрещено Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ВключитьЗадание = ?(ОграничиватьДоступНаУровнеЗаписейУниверсально(), Использование, Ложь);
	
	Отбор = Новый Структура("Метаданные", Метаданные.РегламентныеЗадания.ОбновлениеДоступаНаУровнеЗаписей);
	Задания = РегламентныеЗаданияСервер.НайтиЗадания(Отбор);
	
	ТребуетсяИзменение = Истина;
	Для Каждого Задание Из Задания Цикл
		Если ВключитьЗадание <> Задание.Использование Тогда
			ТребуетсяИзменение = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если Не ТребуетсяИзменение Тогда
		Возврат;
	КонецЕсли;
	
	Блокировка = Новый БлокировкаДанных;
	Блокировка.Добавить("Константа.КоличествоПотоковОбновленияДоступа");
	
	ЗаданиеВключено = Ложь;
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		Задания = РегламентныеЗаданияСервер.НайтиЗадания(Отбор);
		Для Каждого Задание Из Задания Цикл
			Если ВключитьЗадание = Задание.Использование Тогда
				Продолжить;
			КонецЕсли;
			Если ВключитьЗадание Тогда
				ЗаданиеВключено = Истина;
			КонецЕсли;
			РегламентныеЗаданияСервер.ИзменитьЗадание(Задание.УникальныйИдентификатор,
				Новый Структура("Использование", ВключитьЗадание));
		КонецЦикла;
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	Если Не ЗаданиеВключено Или ОбщегоНазначения.РазделениеВключено() Тогда
		Возврат;
	КонецЕсли;
	
	// Немедленный запуск регламентного задания.
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		
		ТекущееРасписание = РегламентныеЗаданияСервер.РасписаниеРегламентногоЗадания(
			Метаданные.РегламентныеЗадания.ОбновлениеДоступаНаУровнеЗаписей);
		
		РегламентныеЗаданияСервер.УстановитьРасписаниеРегламентногоЗадания(
			Метаданные.РегламентныеЗадания.ОбновлениеДоступаНаУровнеЗаписей, ТекущееРасписание);
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Возвращает ошибки текстов ограничений доступа объектов без учета зависимостей между объектами.
// Тексты проверяются в режиме максимальных ограничений (как будто включены все виды ограничений).
// Функция должна вызываться перед функцией НастройкиВнедрения, чтобы собрать весь пакет ошибок.
//
// Возвращаемое значение:
//  Массив - со значениями:
//   * Структура - со свойствами:
//      * ПолноеИмя   - Строка - полное имя объекта метаданных.
//      * ТекстОшибки - Строка - текст ошибки в ограничении доступа.
//
Функция ОшибкиОграниченийДоступа() Экспорт
	
	Ошибки = Новый Массив;
	ОбщийКонтекст = ОбщийКонтекстРасчетаПараметровОграничения(Истина, Ложь);
	
	Попытка
		СпискиСОграничением = УправлениеДоступомСлужебныйПовтИсп.СпискиСОграничением();
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Списки с ограничением доступа некорректно указаны
			           |в процедуре ПриЗаполненииСписковСОграничениемДоступа
			           |общего модуля УправлениеДоступомПереопределяемый по причине:
			           |
			           |%1'"), ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
		ОбъектОшибки = "ОбщийМодуль.УправлениеДоступомПереопределяемый";
		Ошибки.Добавить(Новый Структура("ПолноеИмя, ТекстОшибки", ОбъектОшибки, ТекстОшибки));
		Возврат Ошибки;
	КонецПопытки;
	
	ТекстыОшибок = Новый Соответствие;
	ОбщийКонтекст.Вставить("СпискиСОграничением", СпискиСОграничением);
	ОбщийКонтекст.Вставить("ОписанияОграничений", Новый Соответствие);
	
	Для Каждого ОписаниеСписка Из ОбщийКонтекст.СпискиСОграничением Цикл
		ПолноеИмя = ОписаниеСписка.Ключ;
		Попытка
			ТекстОшибки = ОшибкаОграниченияДоступа(ОбщийКонтекст, ПолноеИмя);
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		КонецПопытки;
		Если ЗначениеЗаполнено(ТекстОшибки) И ТекстыОшибок.Получить(ТекстОшибки) = Неопределено Тогда
			ТекстыОшибок.Вставить(ТекстОшибки, Истина);
			Ошибки.Добавить(Новый Структура("ПолноеИмя, ТекстОшибки", ПолноеИмя, ТекстОшибки));
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ошибки;
	
КонецФункции

// Возвращает настройки внедрения для инструментов разработчика.
//
// Параметры:
//  ДействующиеПараметры - Неопределено - значение по умолчанию.
//                       - Структура - только для вызова из функции РезультатПроверкиОграниченияДоступа.
//
// Возвращаемое значение:
//  Структура - со свойствами:
//    * ОграниченияВРолях - Структура - со свойствами:
//       * ДляПользователей        - Соответствие - со свойствами, как для внешних пользователей (ниже).
//       * ДляВнешнихПользователей - Соответствие - со свойствами:
//           * Ключ     - Строка - полное имя объекта метаданных (списка). Имя коллекции на английском.
//                                 В форме объекта должна вставка ПриЧтенииНаСервере.
//           * Значение - Структура - со свойствами:
//               * ШаблонДляОбъекта - Булево - если Истина, тогда используется шаблон #ДляОбъекта,
//                                             если Ложь,   тогда используется шаблон #ДляРегистра.
//               * Параметры - Массив - параметры шаблона (для объекта 1, для регистра 6).
//                   * Значение - Строка - например, имя поля "Владелец" или
//                                      опорного поля регистра "Организация".
//
//    * ПредопределенныеИдентификаторы - Соответствие - со свойствами:
//        * Ключ     - Строка - имя требуемого предопределенного элемента справочника
//                              ИдентификаторыОбъектовМетаданных или ИдентификаторыОбъектовРасширений
//                              в формате "<ИмяСправочника>.<ИмяПредопределенного>".
//        * Значение - Строка - полное имя соответствующего объекта метаданных.
//
//    * ВладельцыЗначенийКлючейДоступа - Структура - для группы определяемых типов:
//        * Ссылки    - Массив - полные имена типов ссылки  (имя коллекции на английском).
//        * Документы - Массив - полные имена типов объекта (имя коллекции на английском).
//        * Объекты                      - Массив - то же, что в предыдущем пункте.
//        * НаборыЗаписей                - Массив - то же, что в предыдущем пункте.
//        * НаборыЗаписейРегистраРасчета - Массив - то же, что в предыдущем пункте.
//
//    * ЗначенияДоступа - Массив - полные имена типов ссылки (имя коллекции на английском).
//                                 Для дополнения определяемого типа ЗначениеДоступа.
//
//    * ТипыИзмеренийРегистровКлючей - Соответствие - для изменений с именем Поле*
//        регистра КлючиДоступаКРегистрам и регистров КлючиДоступаКРегистру*:
//           * Ключ     - Строка - имя регистра.
//           * Значение - Структура - со свойствами:
//               * ИменаТипов - Массив - со значениями:
//                   * Значение - Строка - полное имя типа (на английском).
//               * ПоляРегистров - Соответствие - со свойствами:
//                   * Ключ - полное имя регистра, который ограничивается.
//                   * Значение - Массив - порядок полей соответствуют служебным полям (Поле1, Поле2, ...):
//                       * Значение - Структура - со свойствам:
//                           * Поле - Строка - имя поля регистра.
//                           * Тип  - ОписаниеТипов - типы поля регистра.
//               * ПоляРегистровПоТипам - Соответствие - со свойствами:
//                   * Ключ - полное имя типа (на английском).
//                   * Значение - Массив - со значениями:
//                       * Значение - полное имя поля, например,
//                                      "РегистрСведений.ДополнительныеСведения.Свойство".
//
Функция НастройкиВнедрения(ДействующиеПараметры = Неопределено) Экспорт
	
	ОграниченияВРолях = Новый Структура;
	ОграниченияВРолях.Вставить("ДляПользователей",        Новый Соответствие);
	ОграниченияВРолях.Вставить("ДляВнешнихПользователей", Новый Соответствие);
	
	ВладельцыЗначенийКлючейДоступа = Новый Структура;
	ВладельцыЗначенийКлючейДоступа.Вставить("Ссылки",        Новый Массив);
	ВладельцыЗначенийКлючейДоступа.Вставить("Документы",     Новый Массив);
	ВладельцыЗначенийКлючейДоступа.Вставить("Объекты",       Новый Массив);
	ВладельцыЗначенийКлючейДоступа.Вставить("НаборыЗаписей", Новый Массив);
	ВладельцыЗначенийКлючейДоступа.Вставить("НаборыЗаписейРегистраРасчета", Новый Массив);
	
	ПредопределенныеИдентификаторы = Новый Соответствие;
	ЗначенияДоступа = Новый Массив;
	ТипыИзмеренийРегистровКлючей = Новый Соответствие;
	ТипыИзмеренийРегистраКлючей(ТипыИзмеренийРегистровКлючей, "КлючиДоступаКРегистрам");
	
	ТипыТаблицПоИменам = УправлениеДоступомСлужебныйПовтИсп.СинтаксисЯзыка().ТипыТаблиц.ПоИменам;
	ЗначенияДоступа.Добавить(ИмяТипаСсылкиXML(Метаданные.Справочники.КлючиДоступа.ПолноеИмя(), ТипыТаблицПоИменам));
	
	ВозможныеПрава = УправлениеДоступомСлужебныйПовтИсп.ВозможныеПраваДляНастройкиПравОбъектов();
	Для Каждого ОписаниеВозможныхПрав Из ВозможныеПрава.ПоПолнымИменам Цикл
		ЗначенияДоступа.Добавить(ИмяТипаСсылкиXML(ОписаниеВозможныхПрав.Ключ, ТипыТаблицПоИменам));
	КонецЦикла;
	
	Если ДействующиеПараметры = Неопределено Тогда
		ОбщийКонтекст = ОбщийКонтекстРасчетаПараметровОграничения(Истина);
		НовыеХранимыеПараметры = ХранимыеПараметрыОграниченияДоступа(ОбщийКонтекст);
		ДействующиеПараметры = Новый Структура(НовыеХранимыеПараметры.ДляЗаписиОбъектовИПроверкиПрав.Получить());
	КонецЕсли;
	
	ДобавленныеСписки = Новый Соответствие;
	Для Каждого ОписаниеВерсии Из ДействующиеПараметры.ВерсииОграниченийСписков Цикл
		ПолноеИмя = ОписаниеВерсии.Ключ;
		ПолноеИмяXML = ПолноеИмяXML(ПолноеИмя, ТипыТаблицПоИменам);
		ИмяТипаСсылкиXML  = ИмяТипаСсылкиXML(ПолноеИмя, ТипыТаблицПоИменам);
		ИмяТипаОбъектаXML = ИмяТипаОбъектаИлиНабораЗаписейXML(ПолноеИмя, ТипыТаблицПоИменам);
		
		Если ЗначениеЗаполнено(ИмяТипаСсылкиXML) Тогда
			ВладельцыЗначенийКлючейДоступа.Ссылки.Добавить(ИмяТипаСсылкиXML);
		КонецЕсли;
		
		ДобавитьОбъектКВладельцам(ИмяТипаОбъектаXML, ВладельцыЗначенийКлючейДоступа);
		ДобавленныеСписки.Вставить(ВРег(ПолноеИмя), Истина);
		
		Если ОписаниеВерсии.Значение = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ДобавитьОграниченияВРолях(ПолноеИмяXML,
			ПолноеИмя,
			ОграниченияВРолях.ДляПользователей,
			ДействующиеПараметры.ДополнительныйКонтекст.ДляПользователей.СвойстваОграниченияСписков,
			ТипыИзмеренийРегистровКлючей,
			ТипыТаблицПоИменам,
			ПредопределенныеИдентификаторы);
		
		ДобавитьОграниченияВРолях(ПолноеИмяXML,
			ПолноеИмя,
			ОграниченияВРолях.ДляВнешнихПользователей,
			ДействующиеПараметры.ДополнительныйКонтекст.ДляВнешнихПользователей.СвойстваОграниченияСписков,
			ТипыИзмеренийРегистровКлючей,
			ТипыТаблицПоИменам,
			ПредопределенныеИдентификаторы);
	КонецЦикла;
	
	Для Каждого ВедущийСписок Из ДействующиеПараметры.ВедущиеСписки Цикл
		ПолноеИмя = ВедущийСписок.Ключ;
		Если ДобавленныеСписки.Получить(ВРег(ПолноеИмя)) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ИмяТипаОбъектаXML = ИмяТипаОбъектаИлиНабораЗаписейXML(ПолноеИмя, ТипыТаблицПоИменам);
		ДобавитьОбъектКВладельцам(ИмяТипаОбъектаXML, ВладельцыЗначенийКлючейДоступа);
	КонецЦикла;
	
	Настройки = Новый Структура;
	Настройки.Вставить("ОграниченияВРолях",              ОграниченияВРолях);
	Настройки.Вставить("ПредопределенныеИдентификаторы", ПредопределенныеИдентификаторы);
	Настройки.Вставить("ВладельцыЗначенийКлючейДоступа", ВладельцыЗначенийКлючейДоступа);
	Настройки.Вставить("ЗначенияДоступа",                ЗначенияДоступа);
	Настройки.Вставить("ТипыИзмеренийРегистровКлючей",   ТипыИзмеренийРегистровКлючей);
	
	Возврат Настройки;
	
КонецФункции

// Возвращает результат проверки ограничения доступа для инструмента разработчика.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных.
//  ДополнительныеПараметры
//    - Неопределено - проверить и вернуть текущее ограничение.
//    - Структура - со свойствами:
//        * Текст - Строка - новый текст ограничения для пользователей.
//        * ТекстДляВнешнихПользователей - Строка - новый текст ограничения для внешних пользователей.
//        * УчитыватьЗависимости         - Булево - учитывать зависимости между ограничениями объектов.
//        * ВсеВидыДоступаИспользуются   - Неопределено - вычислить по текущим настройками.
//                                       - Булево - Истина (по умолчанию) - используются все,
//                                                  Ложь - не используется ни одного.
//
// Возвращаемое значение:
//  Структура - со свойствами:
//   * ОшибкаОписанияОграничения - Строка - если не пустая, то описание ограничения не удалось получить.
//       Если при этом УчитыватьЗависимости = Истина, то это текст первой ошибки при получении всех описаний.
//
//   * ТекстВМодулеМенеджера - Неопределено - когда заполнена ОшибкаОписанияОграничения.
//                           - Булево - возвращает место размещения текста ограничения,
//                               когда Истина - в модуле менеджера, иначе в переопределяемом модуле.
//
//   * ДляПользователей - Структура - со свойствами:
//      * ПроверяемоеОграничение - Неопределено, Строка    - проверенный текст ограничения.
//      * ОписаниеОшибок         - Неопределено, см. УправлениеДоступом.СтруктураОграничения.
//      * ОшибкаФормированияПараметровОграничения - Неопределено, Строка - текст ошибки.
//      * ОшибкаФормированияТекстовЗапросов       - Неопределено, Строка - текст ошибки.
//      * ОграничениеПоВладельцуВозможно - Неопределено, Булево - свойство проверенного ограничения.
//      * ОграниченияВРолях - Неопределено, Структура - со свойствами:
//          * ШаблонДляОбъекта - Булево - если Истина, тогда используется шаблон #ДляОбъекта,
//                                        если Ложь,   тогда используется шаблон #ДляРегистра.
//          * Параметры - Массив - параметры шаблона (для объекта 1, для регистра 6).
//              * Значение - Строка - например, имя поля "Владелец" или
//                                    опорного поля регистра "Организация".
//      * ОграничениеВМодуле - Неопределено, Строка - текст ограничения, который установлен в конфигурации.
//      * ПоВладельцуБезЗаписиКлючейДоступа - Неопределено, Булево - настройка ограничения,
//                                    установленная в конфигурации.
//
//   * ДляВнешнихПользователей - Структура - со свойствами, как ДляПользователей.
//
//   * ВладелецЗначенийКлючейДоступа                            - Строка - типы для одноименного определяемого типа.
//   * ВладелецЗначенийКлючейДоступаОбъект                      - Строка - типы для одноименного определяемого типа.
//   * ВладелецЗначенийКлючейДоступаНаборЗаписей                - Строка - типы для одноименного определяемого типа.
//   * ВладелецЗначенийКлючейДоступаНаборЗаписейРегистраРасчета - Строка - типы для одноименного определяемого типа.
//   * ПолеРегистраКлючейДоступаКРегистрам                      - Строка - типы для одноименного определяемого типа.
//   * ЗначениеДоступа                                          - Строка - типы для одноименного определяемого типа.
//
//   * ТипыИзмеренийОтдельногоРегистраКлючей - Неопределено, Структура - со свойствами:
//      * ИмяРегистраСведений - Строка - имя регистра ключей доступа.
//      * ТипыИзмерений       - Строка - типы для соответствующих измерений регистра.
//
//   * ПредопределенныйИдентификатор - Неопределено, Структура - со свойствами
//      * ИмяСправочника       - Строка - имя справочника идентификаторы объектов метаданных (или расширений).
//      * ИмяПредопределенного - Строка - имя предопределенного в справочнике.
//
Функция РезультатПроверкиОграниченияДоступа(ПолноеИмя, ДополнительныеПараметры = Неопределено) Экспорт
	
	Возврат РезультатПроверкиОграниченияДоступаОбъекта(ПолноеИмя, ДополнительныеПараметры);
	
КонецФункции

// Возвращает структуру указанного текста ограничения для объекта метаданных.
//
// Параметры:
//  ПолноеИмя        - Строка - полное имя объекта метаданных.
//  ТекстОграничения - Строка - текст ограничения, который будет разобран.
//
// Возвращаемое значение:
//  Структура - возвращаемое значение см. УправлениеДоступом.СтруктураОграничения.
//
Функция СтруктураОграниченияИзОписания(ПолноеИмя, ТекстОграничения) Экспорт
	
	Возврат РассчитаннаяСтруктураОграничения(ПолноеИмя,
		ТекстОграничения, Неопределено, Неопределено, Истина);
	
КонецФункции

// Добавляет обновление доступа для указанных списков или всех списков.
// 
// Параметры:
//  Списки - Неопределено - запланировать полное обновление доступа.
//         - Строка - полное имя объекта метаданных.
//         - СправочникСсылка.ИдентификаторыОбъектовМетаданных - идентификатор.
//         - Массив, ФиксированныйМассив - значения типов указанные выше, кроме Неопределено.
//
//  ПараметрыПланирования - Неопределено - использовать значения по умолчанию.
//                        - см. ПараметрыПланированияОбновленияДоступа().
//
Процедура ЗапланироватьОбновлениеДоступа(Списки = Неопределено, ПараметрыПланирования = Неопределено) Экспорт
	
	Если ПараметрыПланирования = Неопределено Тогда
		ПараметрыПланирования = ПараметрыПланированияОбновленияДоступа();
	КонецЕсли;
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	Если Не ПараметрыПланирования.КлючиДоступаКДанным
	   И Не ПараметрыПланирования.РазрешенныеКлючиДоступа Тогда
		
		Возврат;
	КонецЕсли;
	
	ИдентификаторыРегистров     = Новый Массив;
	ИдентификаторыСписковКлючей = Новый Массив;
	
	Если Списки = Неопределено Тогда
		ОчиститьКэшЗначенийГруппДоступаДляРасчетаПрав();
		
		Если ПараметрыПланирования.ВерсииОграниченийСписков = Неопределено Тогда
			ДействующиеПараметры = ДействующиеПараметрыОграниченияДоступа(Неопределено, Неопределено, Ложь);
			ВерсииОграниченийСписков = Новый Соответствие(ДействующиеПараметры.ВерсииОграниченийСписков);
		Иначе
			ВерсииОграниченийСписков = ПараметрыПланирования.ВерсииОграниченийСписков;
		КонецЕсли;
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("РазрешенныйКлючДоступа",
			УправлениеДоступомСлужебныйПовтИсп.РазрешенныйКлючДоступа());
		Запрос.Текст =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ТИПЗНАЧЕНИЯ(КлючиДоступаКДанным.Объект) КАК ТипСсылки
		|ИЗ
		|	РегистрСведений.КлючиДоступаКОбъектам КАК КлючиДоступаКДанным
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	КлючиДоступаКДанным.Регистр КАК Регистр
		|ИЗ
		|	РегистрСведений.КлючиДоступаКРегистрам КАК КлючиДоступаКДанным
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	КлючиДоступа.Список КАК Список
		|ИЗ
		|	Справочник.КлючиДоступа КАК КлючиДоступа
		|ГДЕ
		|	КлючиДоступа.Ссылка <> &РазрешенныйКлючДоступа";
		РезультатыЗапроса = Запрос.ВыполнитьПакет();
		ИдентификаторыРегистров     = РезультатыЗапроса[1].Выгрузить().ВыгрузитьКолонку("Регистр");
		ИдентификаторыСписковКлючей = РезультатыЗапроса[2].Выгрузить().ВыгрузитьКолонку("Список");
		
		Выборка = РезультатыЗапроса[0].Выбрать();
		ДопустимыеТипы = УправлениеДоступомСлужебныйПовтИсп.ОписаниеТиповСсылокДопустимыхОбъектов();
		ЕстьНедопустимыйТип = Ложь;
		Пока Выборка.Следующий() Цикл
			Если ТипЗнч(Выборка.ТипСсылки) <> Тип("Тип") Тогда
				Продолжить;
			ИначеЕсли Выборка.ТипСсылки = Тип("Неопределено")
			      Или Не ДопустимыеТипы.СодержитТип(Выборка.ТипСсылки) Тогда
				ЕстьНедопустимыйТип = Истина;
				Продолжить;
			КонецЕсли;
			ОбъектМетаданных = Метаданные.НайтиПоТипу(Выборка.ТипСсылки);
			Если ОбъектМетаданных = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			ВерсииОграниченийСписков.Вставить(ОбъектМетаданных.ПолноеИмя(), Истина);
		КонецЦикла;
		ВерсииОграниченийСписков.Вставить("Справочник.НаборыГруппДоступа", Истина);
		Если ЕстьНедопустимыйТип Тогда
			ИдентификаторыРегистров.Добавить(Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка());
		КонецЕсли;
		
		СпискиДляОбновления = Новый Массив;
		Для Каждого КлючИЗначение Из ВерсииОграниченийСписков Цикл
			СпискиДляОбновления.Добавить(КлючИЗначение.Ключ);
		КонецЦикла;
		
		// При планировании полного обновления добавляются:
		// а) списки с ограничением,
		// б) списки, которые пишут ключи доступа для ограничений по полю-владельцу,
		// в) списки без ограничения, для которых есть записи в регистрах ключей доступа к данным,
		// в) списки, для которых рассчитываются разрешенные ключи доступа,
		// г) списки без расчета разрешенных ключей доступа, для которых есть записи в регистрах
		//    разрешенных ключей доступа.
		
	ИначеЕсли ТипЗнч(Списки) <> Тип("Массив")
	        И ТипЗнч(Списки) <> Тип("ФиксированныйМассив") Тогда
		
		СпискиДляОбновления = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Списки);
	Иначе
		СпискиДляОбновления = Списки;
	КонецЕсли;
	
	Если СпискиДляОбновления.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(СпискиДляОбновления[0]) = Тип("Строка") Тогда
		Идентификаторы = ОбщегоНазначения.ИдентификаторыОбъектовМетаданных(СпискиДляОбновления, Списки <> Неопределено);
		СпискиПоИдентификаторам = Новый Соответствие;
		Для Каждого ОписаниеИдентификатора Из Идентификаторы Цикл
			СпискиПоИдентификаторам.Вставить(ОписаниеИдентификатора.Значение, ОписаниеИдентификатора.Ключ);
		КонецЦикла;
	Иначе
		СпискиПоИдентификаторам = Новый Соответствие;
		Для Каждого Идентификатор Из СпискиДляОбновления Цикл
			СпискиПоИдентификаторам.Вставить(Идентификатор, "");
		КонецЦикла;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ИдентификаторыРегистров)
	 Или ЗначениеЗаполнено(ИдентификаторыСписковКлючей) Тогда
		
		Для Каждого ИдентификаторРегистра Из ИдентификаторыРегистров Цикл
			Если ИдентификаторРегистра = Неопределено Тогда
				СпискиПоИдентификаторам.Вставить(
					Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка(), "");
			КонецЕсли;
			СпискиПоИдентификаторам.Вставить(ИдентификаторРегистра, "");
		КонецЦикла;
		Для Каждого ИдентификаторРазрешенных Из ИдентификаторыСписковКлючей Цикл
			СпискиПоИдентификаторам.Вставить(ИдентификаторРазрешенных, "");
		КонецЦикла;
	КонецЕсли;
	
	ИдентификаторСправочникаНаборыГруппДоступа =
		СлужебныйИдентификатор("Справочник.НаборыГруппДоступа");
	
	ТекущаяДатаСеанса = ТекущаяДатаСеанса();
	КлючУникальностиЗаписей = Новый УникальныйИдентификатор;
	
	ЭтоТочечноеЗадание = Ложь;
	ПараметрыЗадания = Новый Структура;
	РазмерЗадания = 3;
	
	Если ПараметрыПланирования.ЭтоОбработкаУстаревшихЭлементов Тогда
		ПараметрыПланирования.ЭтоПродолжениеОбновления = Истина;
		УстановитьВидКлючаДанных(ПараметрыЗадания, "УстаревшиеЭлементы");
		ДатаПоследнегоОбновленногоЭлемента = '00010101';
		РазмерЗадания = 2;
	Иначе
		ВедущийОбъект = ПараметрыПланирования.ВедущийОбъект;
		Если ВедущийОбъект <> Неопределено
		   И Не (    ВедущийОбъект.Свойство("ПоКлючамДоступа")
		         Или ВедущийОбъект.Свойство("ПоЗначениямСГруппами")
		         Или ВедущийОбъект.Свойство("ПоЗначениямПолей")
		           И ТипЗнч(ВедущийОбъект.ПоЗначениямПолей.СоставИзменений) = Тип("ТаблицаЗначений") ) Тогда
			ВедущийОбъект = Неопределено;
		КонецЕсли;
		Если ВедущийОбъект <> Неопределено Тогда
			ЭтоТочечноеЗадание = Истина;
			ПараметрыПланирования = Новый Структура(Новый ФиксированнаяСтруктура(ПараметрыПланирования));
			ПараметрыПланирования.Вставить("ЭтоТочечноеЗадание");
			РазмерЗадания = 1;
			ПараметрыЗадания.Вставить("ТочечноеЗадание", ВедущийОбъект);
		КонецЕсли;
		ДатаПоследнегоОбновленногоЭлемента = ?(ПараметрыПланирования.ЭтоПродолжениеОбновления,
			МаксимальнаяДатаПриПродолжении(), МаксимальнаяДата());
	КонецЕсли;
	Если ПараметрыЗадания.Количество() = 0 Тогда
		ПараметрыЗадания = Неопределено;
	КонецЕсли;
	ХранилищеПараметровЗадания = Новый ХранилищеЗначения(ПараметрыЗадания);
	
	ОбновлениеКлючейДоступаКДанным       = СлужебныйНаборЗаписей(РегистрыСведений.ОбновлениеКлючейДоступаКДанным);
	ОбновлениеКлючейДоступаПользователей = СлужебныйНаборЗаписей(РегистрыСведений.ОбновлениеКлючейДоступаПользователей);
	
	Для Каждого ОписаниеСписка Из СпискиПоИдентификаторам Цикл
		ИдентификаторСписка = ОписаниеСписка.Ключ;
		
		Если ПараметрыПланирования.КлючиДоступаКДанным Тогда
			Если ПараметрыПланирования.ДляПользователей Тогда
				НоваяЗапись = ОбновлениеКлючейДоступаКДанным.Добавить();
				НоваяЗапись.КлючУникальности                   = КлючУникальностиЗаписей;
				НоваяЗапись.Список                             = ИдентификаторСписка;
				НоваяЗапись.ТочечноеЗадание                    = ЭтоТочечноеЗадание;
				НоваяЗапись.ДатаПоследнегоОбновленногоЭлемента = ДатаПоследнегоОбновленногоЭлемента;
				НоваяЗапись.ПараметрыЗадания                   = ХранилищеПараметровЗадания;
				НоваяЗапись.РазмерЗадания                      = РазмерЗадания;
				НоваяЗапись.ДатаИзмененияЗаписиРегистра        = ТекущаяДатаСеанса;
			КонецЕсли;
			Если ПараметрыПланирования.ДляВнешнихПользователей Тогда
				НоваяЗапись = ОбновлениеКлючейДоступаКДанным.Добавить();
				НоваяЗапись.КлючУникальности                   = КлючУникальностиЗаписей;
				НоваяЗапись.Список                             = ИдентификаторСписка;
				НоваяЗапись.ДляВнешнихПользователей            = Истина;
				НоваяЗапись.ТочечноеЗадание                    = ЭтоТочечноеЗадание;
				НоваяЗапись.ДатаПоследнегоОбновленногоЭлемента = ДатаПоследнегоОбновленногоЭлемента;
				НоваяЗапись.ПараметрыЗадания                   = ХранилищеПараметровЗадания;
				НоваяЗапись.РазмерЗадания                      = РазмерЗадания;
				НоваяЗапись.ДатаИзмененияЗаписиРегистра        = ТекущаяДатаСеанса;
			КонецЕсли;
		КонецЕсли;
		
		Если ИдентификаторСписка = ИдентификаторСправочникаНаборыГруппДоступа Тогда
			Продолжить;
		КонецЕсли;
		
		Если ПараметрыПланирования.РазрешенныеКлючиДоступа Тогда
			Если ПараметрыПланирования.ДляПользователей Тогда
				НоваяЗапись = ОбновлениеКлючейДоступаПользователей.Добавить();
				НоваяЗапись.КлючУникальности            = КлючУникальностиЗаписей;
				НоваяЗапись.Список                      = ИдентификаторСписка;
				НоваяЗапись.ТочечноеЗадание             = ЭтоТочечноеЗадание;
				НоваяЗапись.ПараметрыЗадания            = ХранилищеПараметровЗадания;
				НоваяЗапись.РазмерЗадания               = РазмерЗадания;
				НоваяЗапись.ДатаИзмененияЗаписиРегистра = ТекущаяДатаСеанса;
			КонецЕсли;
			Если ПараметрыПланирования.ДляВнешнихПользователей Тогда
				НоваяЗапись = ОбновлениеКлючейДоступаПользователей.Добавить();
				НоваяЗапись.КлючУникальности            = КлючУникальностиЗаписей;
				НоваяЗапись.Список                      = ИдентификаторСписка;
				НоваяЗапись.ДляВнешнихПользователей     = Истина;
				НоваяЗапись.ТочечноеЗадание             = ЭтоТочечноеЗадание;
				НоваяЗапись.ПараметрыЗадания            = ХранилищеПараметровЗадания;
				НоваяЗапись.РазмерЗадания               = РазмерЗадания;
				НоваяЗапись.ДатаИзмененияЗаписиРегистра = ТекущаяДатаСеанса;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если ТранзакцияАктивна() И ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		Блокировка = Новый БлокировкаДанных;
		Блокировка.Добавить("РегистрСведений.ОбновлениеКлючейДоступаКДанным");
		Блокировка.Добавить("РегистрСведений.ОбновлениеКлючейДоступаПользователей");
		Блокировка.Заблокировать();
	КонецЕсли;
	
	Если ОбновлениеКлючейДоступаКДанным.Количество() > 0 Тогда
		ОбновлениеКлючейДоступаКДанным.Записать(Ложь);
	КонецЕсли;
	
	Если ОбновлениеКлючейДоступаПользователей.Количество() > 0 Тогда
		ОбновлениеКлючейДоступаПользователей.Записать(Ложь);
	КонецЕсли;
	
	ЗарегистрироватьПланированиеОбновленияДоступа(СпискиПоИдентификаторам,
		ПараметрыПланирования, Списки = Неопределено);
	
	Если ОбновлениеКлючейДоступаКДанным.Количество() > 0
	 Или ОбновлениеКлючейДоступаПользователей.Количество() > 0 Тогда
		
		УстановитьОбновлениеДоступа(Истина);
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Ложь);
	УстановитьОтключениеБезопасногоРежима(Ложь);
	
КонецПроцедуры

// Конструктор структуры дополнительных параметров для процедуры ЗапланироватьОбновлениеДоступа.
//
// Возвращаемое значение:
//  Структура - со свойствами:
//    * КлючиДоступаКДанным     - Булево - по умолчанию Истина - запланировать обновление ключей доступа
//                                  к данным.
//    * РазрешенныеКлючиДоступа - Булево - по умолчанию Истина - запланировать обновление ключей доступа
//                                  пользователей и групп доступа.
//    * ДляПользователей        - Булево - по умолчанию Истина - запланировать обновление для пользователей.
//    * ДляВнешнихПользователей - Булево - по умолчанию значение константы ИспользоватьВнешнихПользователей
//                                         запланировать обновление для внешних пользователей.
//
Функция ПараметрыПланированияОбновленияДоступа(ВычислитьДляВнешнихПользователей = Истина) Экспорт
	
	ДляВнешнихПользователей = ?(ВычислитьДляВнешнихПользователей,
		Константы.ИспользоватьВнешнихПользователей.Получить(), Истина);
	
	Результат = Новый Структура;
	Результат.Вставить("КлючиДоступаКДанным", Истина);
	Результат.Вставить("РазрешенныеКлючиДоступа", Истина);
	Результат.Вставить("ДляПользователей", Истина);
	Результат.Вставить("ДляВнешнихПользователей", ДляВнешнихПользователей);
	Результат.Вставить("ВедущийОбъект", Неопределено);
	Результат.Вставить("ВерсииОграниченийСписков", Неопределено);
	Результат.Вставить("Описание", "");
	Результат.Вставить("ЭтоПродолжениеОбновления", Ложь);
	Результат.Вставить("ЭтоОбработкаУстаревшихЭлементов", Ложь);
	
	Возврат Результат;
	
КонецФункции

// Только для внутреннего использования.
Процедура ЗапланироватьОбновлениеПараметровОграниченияДоступа(Описание) Экспорт
	
	Если Не ОграничиватьДоступНаУровнеЗаписейУниверсально() Тогда
		Возврат;
	КонецЕсли;
	
	ПараметрыПланирования = ПараметрыПланированияОбновленияДоступа();
	ПараметрыПланирования.РазрешенныеКлючиДоступа = Ложь;
	ПараметрыПланирования.Описание = Описание;
	
	Идентификатор = СлужебныйИдентификатор("РегистрСведений.ПараметрыОграниченияДоступа");
	Если Идентификатор <> Null Тогда
		ЗапланироватьОбновлениеДоступа(Идентификатор, ПараметрыПланирования);
	КонецЕсли;
	
КонецПроцедуры

// Запускает обновление доступа, если оно запланировано и еще не запущено.
Процедура ЗапуститьОбновлениеДоступа() Экспорт
	
	Если Не ОграничиватьДоступНаУровнеЗаписейУниверсально(Ложь) Тогда
		Возврат;
	КонецЕсли;
	
	ЗапуститьОбновлениеДоступаНаУровнеЗаписей();
	
КонецПроцедуры

// Только для внутреннего использования.
Процедура ОбновитьДоступПослеОбновленияИнформационнойБазы(ВыполнитьОтложенноеОбновлениеСейчас) Экспорт
	
	Если ОбщегоНазначения.РазделениеВключено()
	   И Не ОбщегоНазначения.ДоступноИспользованиеРазделенныхДанных() Тогда
		Возврат;
	КонецЕсли;
	
	Если ВыполнитьОтложенноеОбновлениеСейчас
	   И ОграничиватьДоступНаУровнеЗаписейУниверсально() Тогда
		
		ВыполнитьОбновлениеДоступаНаУровнеЗаписей(Истина, Ложь, 0, Истина);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// Обработчики событий подсистем конфигурации.

// См. ГрупповоеИзменениеОбъектовПереопределяемый.ПриОпределенииОбъектовСРедактируемымиРеквизитами.
Процедура ПриОпределенииОбъектовСРедактируемымиРеквизитами(Объекты) Экспорт
	Объекты.Вставить(Метаданные.Справочники.ГруппыДоступа.ПолноеИмя(), "РеквизитыНеРедактируемыеВГрупповойОбработке");
	Объекты.Вставить(Метаданные.Справочники.ПрофилиГруппДоступа.ПолноеИмя(), "РеквизитыНеРедактируемыеВГрупповойОбработке");
КонецПроцедуры

// См. ОбщегоНазначенияПереопределяемый.ПриДобавленииОбработчиковУстановкиПараметровСеанса.
Процедура ПриДобавленииОбработчиковУстановкиПараметровСеанса(Обработчики) Экспорт
	
	Обработчики.Вставить("ОграничениеДоступаНаУровнеЗаписейИспользуется",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("ВидыДоступа*",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("ВсеВидыДоступаКромеСпециальных",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("ТаблицыСОтдельнымиНастройкамиПрав",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("ТипыЗначенийДоступаСГруппами",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("ТипыВладельцевНастроекПрав",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("ИдентификаторыТаблицСОтдельнымиНастройкамиПрав",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("ТаблицыРасширенийСОграничениемДоступа",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	#Область УниверсальноеОграничение
	
	Обработчики.Вставить("ОграничениеДоступаНаУровнеЗаписейУниверсально",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("ОтключениеОбновленияКлючейДоступа",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("ВерсииШаблоновОграниченияДоступа",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("РазрешенныйНаборГруппДоступа",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("РазрешенныйПустойНаборГруппДоступа",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("РазрешенныйНаборГруппПользователей",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("РазрешенныйПользователь",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("ОбщиеПараметрыШаблоновОграниченияДоступа",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("СпискиСОграничениемПоПолям",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("СпискиСОграничениемЧерезКлючиДоступа*",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("СпискиСОтключеннымОграничениемЧтения",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("ПараметрыОграниченияДоступа",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	#КонецОбласти
	
КонецПроцедуры

// См. РегламентныеЗаданияПереопределяемый.ПриОпределенииНастроекРегламентныхЗаданий.
// 
// Параметры:
//  Настройки - см. РегламентныеЗаданияПереопределяемый.ПриОпределенииНастроекРегламентныхЗаданий.Настройки
//
Процедура ПриОпределенииНастроекРегламентныхЗаданий(Настройки) Экспорт
	
	Настройка = Настройки.Добавить();
	Настройка.РегламентноеЗадание = Метаданные.РегламентныеЗадания.ЗаполнениеДанныхДляОграниченияДоступа;
	Настройка.ФункциональнаяОпция = Метаданные.ФункциональныеОпции.ОграничиватьДоступНаУровнеЗаписей;
	
	Настройка = Настройки.Добавить();
	Настройка.РегламентноеЗадание = Метаданные.РегламентныеЗадания.ОбновлениеДоступаНаУровнеЗаписей;
	Настройка.ФункциональнаяОпция = Метаданные.ФункциональныеОпции.ОграничиватьДоступНаУровнеЗаписейУниверсально;
	
КонецПроцедуры

// Обновляет вспомогательные данные, которые зависят только от конфигурации.
// Записывает изменения этих данных по версиям конфигурации(если изменения есть),
// чтобы использовать эти изменения при обновлении остальных вспомогательных данных,
// например, в обработчике ОбновитьВспомогательныеДанныеПоИзменениямКонфигурации.
//
Процедура ОбновитьПараметрыОграниченияДоступа(ЕстьИзменения = Неопределено) Экспорт
	
	РегистрыСведений.ПраваРолей.ОбновитьДанныеРегистра(ЕстьИзменения);
	
	РегистрыСведений.ЗависимостиПравДоступа.ОбновитьДанныеРегистра(ЕстьИзменения);
	
	ОбновитьОписаниеСвойствВидовДоступа(ЕстьИзменения);
	
	Справочники.ПрофилиГруппДоступа.ОбновитьОписаниеПоставляемыхПрофилей(ЕстьИзменения);
	
	Справочники.ПрофилиГруппДоступа.ОбновитьСоставПредопределенныхПрофилей(ЕстьИзменения);
	
	РегистрыСведений.НастройкиПравОбъектов.ОбновитьВозможныеПраваДляНастройкиПравОбъектов(ЕстьИзменения);
	
	РегистрыСведений.ПараметрыОграниченияДоступа.ОбновитьВерсиюТекстовОграниченияДоступа(ЕстьИзменения);
	
КонецПроцедуры

// Обновляет описание свойств видов доступа в параметрах работы программы.
// 
// Параметры:
//  ЕстьИзменения - Булево - (возвращаемое значение) - если производилась запись,
//                  устанавливается Истина, иначе не изменяется.
//
Процедура ОбновитьОписаниеСвойствВидовДоступа(ЕстьИзменения = Ложь) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	СвойстваВидовДоступа = СвойстваВидовДоступа();
	
	НачатьТранзакцию();
	Попытка
		ЕстьТекущиеИзменения = Ложь;
		СтароеЗначение = Неопределено;
		
		СтандартныеПодсистемыСервер.ОбновитьПараметрРаботыПрограммы(
			"СтандартныеПодсистемы.УправлениеДоступом.СвойстваВидовДоступа",
			СвойстваВидовДоступа, ЕстьТекущиеИзменения, СтароеЗначение);
		
		ЕстьИзмененияТиповГруппИЗначенийДоступа = ЕстьТекущиеИзменения
			И ЕстьИзмененияТиповГруппИЗначенийДоступа(СвойстваВидовДоступа, СтароеЗначение);
		
		СтандартныеПодсистемыСервер.ДобавитьИзмененияПараметраРаботыПрограммы(
			"СтандартныеПодсистемы.УправлениеДоступом.ТипыГруппИЗначенийДоступа",
			?(ЕстьИзмененияТиповГруппИЗначенийДоступа,
			  Новый ФиксированнаяСтруктура("ЕстьИзменения", Истина),
			  Новый ФиксированнаяСтруктура()) );
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	Если ЕстьТекущиеИзменения Тогда
		ЕстьИзменения = Истина;
	КонецЕсли;
	
КонецПроцедуры

// См. ОбновлениеИнформационнойБазыБСП.ПриДобавленииОбработчиковОбновления.
// 
// Параметры:
//  Обработчики - см. ОбновлениеИнформационнойБазы.НоваяТаблицаОбработчиковОбновления
//
Процедура ПриДобавленииОбработчиковОбновления(Обработчики) Экспорт
	
	// Обработчики обновления неразделенных данных.
	Обработчик = Обработчики.Добавить();
	Обработчик.ОбщиеДанные = Истина;
	Обработчик.УправлениеОбработчиками = Истина;
	Обработчик.Приоритет = 1;
	Обработчик.Версия = "*";
	Обработчик.РежимВыполнения = "Оперативно";
	Обработчик.Процедура = "УправлениеДоступомСлужебный.ЗаполнитьОбработчикиРазделенныхДанных";
	
	// Обработчики обновления разделенных данных.
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "*";
	Обработчик.РежимВыполнения = "Оперативно";
	Обработчик.Процедура = "УправлениеДоступомСлужебный.ОбновитьВспомогательныеДанныеПоИзменениямКонфигурации";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.НачальноеЗаполнение = Истина;
	Обработчик.РежимВыполнения = "Оперативно";
	Обработчик.Процедура = "УправлениеДоступомСлужебный.ЗаполнитьНаименованиеПредопределенныхЭлементов";
	
	// Должен выполнятся после обработчика ЗаполнитьИдентификаторыПоставляемыхДанных.
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "1.0.0.1";
	Обработчик.НачальноеЗаполнение = Истина;
	Обработчик.Процедура = "Справочники.ГруппыДоступа.ЗаполнитьПрофильГруппыДоступаАдминистраторы";
	Обработчик.РежимВыполнения = "Монопольно";
	Обработчик.ВыполнятьВГруппеОбязательных = Истина;
	Обработчик.Приоритет = 1;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.4.1.1";
	Обработчик.Процедура = "УправлениеДоступомСлужебный.ОбновитьДанныеПрофиляОткрытиеВнешнихОтчетовИОбработок";
	Обработчик.РежимВыполнения = "Оперативно";
	Обработчик.ВыполнятьВГруппеОбязательных = Истина;
	Обработчик.Приоритет = 1;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "3.0.1.196";
	Обработчик.Процедура = "Справочники.ГруппыДоступа.ОбработатьДанныеДляПереходаНаНовуюВерсию";
	Обработчик.РежимВыполнения = "Отложенно";
	Обработчик.ЗапускатьИВПодчиненномУзлеРИБСФильтрами = Истина;
	Обработчик.Комментарий = НСтр("ru = 'Устраняет некорректное скрытие данных в некоторых списках при включенном ограничении на уровне записей.'");
	Обработчик.Идентификатор = Новый УникальныйИдентификатор("b73c2481-f789-4b2d-b705-8219aea0e75d");
	Обработчик.ПроцедураПроверки = "ОбновлениеИнформационнойБазы.ОбработкаДанныхЗавершена";
	Обработчик.ПроцедураЗаполненияДанныхОбновления = "Справочники.ГруппыДоступа.ЗарегистрироватьДанныеКОбработкеДляПереходаНаНовуюВерсию";
	Обработчик.ОчередьОтложеннойОбработки = 1;
	Обработчик.ЧитаемыеОбъекты = "Справочник.ГруппыДоступа";
	Обработчик.ИзменяемыеОбъекты = "РегистрСведений.ТаблицыГруппДоступа,РегистрСведений.ЗначенияГруппДоступа,РегистрСведений.ЗначенияГруппДоступаПоУмолчанию";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "3.0.2.139";
	Обработчик.Процедура = "РегистрыСведений.ГруппыЗначенийДоступа.ОбработатьДанныеДляПереходаНаНовуюВерсию";
	Обработчик.РежимВыполнения = "Отложенно";
	Обработчик.Комментарий = НСтр("ru = 'Обновление данных по изменениям программы.'");
	Обработчик.Идентификатор = Новый УникальныйИдентификатор("b3cb643e-d5cf-40b7-9db3-6315a88c063d");
	Обработчик.ПроцедураЗаполненияДанныхОбновления = "РегистрыСведений.ГруппыЗначенийДоступа.ЗарегистрироватьДанныеКОбработкеДляПереходаНаНовуюВерсию";
	Обработчик.ОчередьОтложеннойОбработки = 1;
	Обработчик.ЧитаемыеОбъекты = "РегистрСведений.ГруппыЗначенийДоступа";
	Обработчик.ИзменяемыеОбъекты = "РегистрСведений.ГруппыЗначенийДоступа";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "3.0.2.174";
	Обработчик.Процедура = "РегистрыСведений.НастройкиПравОбъектов.ОбработатьДанныеДляПереходаНаНовуюВерсию";
	Обработчик.РежимВыполнения = "Отложенно";
	Обработчик.Комментарий = НСтр("ru = 'Обновление вспомогательных данных настроек прав.'");
	Обработчик.Идентификатор = Новый УникальныйИдентификатор("40d1c62f-c3f1-4608-8985-2dc618c3d758");
	Обработчик.ПроцедураЗаполненияДанныхОбновления = "РегистрыСведений.НастройкиПравОбъектов.ЗарегистрироватьДанныеКОбработкеДляПереходаНаНовуюВерсию";
	Обработчик.ОчередьОтложеннойОбработки = 1;
	Обработчик.ЧитаемыеОбъекты = "РегистрСведений.НастройкиПравОбъектов";
	Обработчик.ИзменяемыеОбъекты = "РегистрСведений.НастройкиПравОбъектов";
	
КонецПроцедуры

// См. ОбновлениеИнформационнойБазыБСП.ПослеОбновленияИнформационнойБазы.
Процедура ПослеОбновленияИнформационнойБазы(Знач ПредыдущаяВерсия, Знач ТекущаяВерсия,
		Знач ВыполненныеОбработчики, ВыводитьОписаниеОбновлений, МонопольныйРежим) Экспорт
	
	ОбновитьВспомогательныеДанныеЭлементовИзмененныхПриЗагрузке();
	
	Если ОбщегоНазначения.ДоступноИспользованиеРазделенныхДанных() Тогда
		УстановитьОбновлениеДоступа(Истина, Истина);
	КонецЕсли;
	
КонецПроцедуры

// Заполняет структуру параметров, необходимых для работы клиентского кода
// конфигурации.
//
// Параметры:
//   Параметры   - Структура - структура параметров.
//
Процедура ПриДобавленииПараметровРаботыКлиента(Параметры) Экспорт
	
	Параметры.Вставить("УпрощенныйИнтерфейсНастройкиПравДоступа",
		УпрощенныйИнтерфейсНастройкиПравДоступа());
	
КонецПроцедуры

// См. ОбщегоНазначенияПереопределяемый.ПриДобавленииИсключенийПоискаСсылок.
//
// Параметры:
//  Массив - см. ОбщегоНазначенияПереопределяемый.ПриДобавленииИсключенийПоискаСсылок.ИсключенияПоискаСсылок
//
Процедура ПриДобавленииИсключенийПоискаСсылок(Массив) Экспорт
	
	Массив.Добавить(Метаданные.РегистрыСведений.ГруппыЗначенийДоступа);
	Массив.Добавить(Метаданные.РегистрыСведений.ЗависимостиПравДоступа);
	Массив.Добавить(Метаданные.РегистрыСведений.ЗначенияГруппДоступа);
	Массив.Добавить(Метаданные.РегистрыСведений.ЗначенияГруппДоступаПоУмолчанию);
	Массив.Добавить(Метаданные.РегистрыСведений.НаборыЗначенийДоступа);
	Массив.Добавить(Метаданные.РегистрыСведений.ПраваРолей);
	Массив.Добавить(Метаданные.РегистрыСведений.НаследованиеНастроекПравОбъектов);
	Массив.Добавить(Метаданные.РегистрыСведений.НастройкиПравОбъектов);
	Массив.Добавить(Метаданные.РегистрыСведений.ТаблицыГруппДоступа);
	
	ПриДобавленииИсключенийПоискаСсылокДопускающихУдаление(Массив);
	
КонецПроцедуры

// Объекты с отложенным удалением.
//
// Параметры:
//  Массив - см. ОбщегоНазначенияПереопределяемый.ПриДобавленииИсключенийПоискаСсылок.ИсключенияПоискаСсылок
//
Процедура ПриДобавленииИсключенийПоискаСсылокДопускающихУдаление(Массив) Экспорт
	
	Массив.Добавить(Метаданные.Справочники.КлючиДоступа);
	Массив.Добавить(Метаданные.Справочники.НаборыГруппДоступа);
	Массив.Добавить(Метаданные.РегистрыСведений.КлючиДоступаВнешнихПользователей);
	Массив.Добавить(Метаданные.РегистрыСведений.КлючиДоступаГруппДоступа);
	Массив.Добавить(Метаданные.РегистрыСведений.КлючиДоступаНаборовГруппДоступа);
	Массив.Добавить(Метаданные.РегистрыСведений.КлючиДоступаКОбъектам);
	Массив.Добавить(Метаданные.РегистрыСведений.КлючиДоступаКРегистрам);
	Массив.Добавить(Метаданные.РегистрыСведений.КлючиДоступаПользователей);
	Массив.Добавить(Метаданные.РегистрыСведений.ОбновлениеКлючейДоступаКДанным);
	Массив.Добавить(Метаданные.РегистрыСведений.ОбновлениеКлючейДоступаПользователей);
	Массив.Добавить(Метаданные.РегистрыСведений.ПараметрыОграниченияДоступа);
	
	Для Каждого РегистрСведений Из Метаданные.РегистрыСведений Цикл 
		Если СтрНачинаетсяС(ВРег(РегистрСведений.Имя), ВРег("КлючиДоступаКРегистру")) Тогда 
			Массив.Добавить(РегистрСведений);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Вызывается при загрузке ссылок предопределенных элементов в процессе загрузки важных данных.
// Позволяет выполнить действия по исправлению или регистрации сведений о не уникальности
// предопределенных элементов, а также позволяет отказаться от продолжения, если это недопустимо.
//
// Параметры:
//   Объект          - СправочникОбъект, ПланВидовХарактеристикОбъект, ПланСчетовОбъект, ПланВидовРасчетаОбъект -
//                     объект предопределенного элемента после записи которого обнаружено наличие не уникальности.
//   ЗаписатьВЖурнал - Булево - возвращаемое значение. Если указать Ложь, тогда сведения о не уникальности не будут
//                     добавлены в журнал регистрации в общем сообщении.
//                     Нужно установить Ложь, если не уникальность была устранена автоматически.
//   Отказ           - Булево - возвращаемое значение. Если указать Истина, будет вызвано общее исключение,
//                     содержащее все причины отказа.
//   ОписаниеОтказа  - Строка - возвращаемое значение. Если Отказ установлен в Истина, то описание будет добавлено
//                     в список причин невозможности продолжения.
//
Процедура ПриОбнаруженииНеУникальностиПредопределенного(Объект, ЗаписатьВЖурнал, Отказ, ОписаниеОтказа) Экспорт
	
	Если ТипЗнч(Объект) = Тип("СправочникОбъект.ПрофилиГруппДоступа")
	   И Объект.ИмяПредопределенныхДанных = "Администратор" Тогда
		
		ЗаписатьВЖурнал = Ложь;
		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка);
		Запрос.УстановитьПараметр("ИмяПредопределенныхДанных", "Администратор");
		Запрос.Текст =
		"ВЫБРАТЬ
		|	ПрофилиГруппДоступа.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.ПрофилиГруппДоступа КАК ПрофилиГруппДоступа
		|ГДЕ
		|	ПрофилиГруппДоступа.Ссылка <> &Ссылка
		|	И ПрофилиГруппДоступа.ИмяПредопределенныхДанных = &ИмяПредопределенныхДанных";
		
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			ТекущийОбъект = Выборка.Ссылка.ПолучитьОбъект();
			ТекущийОбъект.ИмяПредопределенныхДанных = "";
			ТекущийОбъект.ИдентификаторПоставляемыхДанных = "";
			ОбновлениеИнформационнойБазы.ЗаписатьДанные(ТекущийОбъект);
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(Объект) = Тип("СправочникОбъект.ГруппыДоступа")
	        И Объект.ИмяПредопределенныхДанных = "Администраторы" Тогда
		
		ЗаписатьВЖурнал = Ложь;
		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ИмяПредопределенныхДанных", "Администраторы");
		Запрос.Текст =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ГруппыДоступаПользователи.Пользователь
		|ИЗ
		|	Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
		|ГДЕ
		|	ГруппыДоступаПользователи.Ссылка.ИмяПредопределенныхДанных = &ИмяПредопределенныхДанных";
		ВсеПользователи = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Пользователь");
		
		Записать = Ложь;
		Для каждого Пользователь Из ВсеПользователи Цикл
			Если Объект.Пользователи.Найти(Пользователь, "Пользователь") = Неопределено Тогда
				Объект.Пользователи.Добавить().Пользователь = Пользователь;
				Записать = Истина;
			КонецЕсли;
		КонецЦикла;
		
		Если Записать Тогда
			ОбновлениеИнформационнойБазы.ЗаписатьДанные(Объект);
		КонецЕсли;
		
		Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка);
		Запрос.Текст =
		"ВЫБРАТЬ
		|	ГруппыДоступа.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.ГруппыДоступа КАК ГруппыДоступа
		|ГДЕ
		|	ГруппыДоступа.Ссылка <> &Ссылка
		|	И ГруппыДоступа.ИмяПредопределенныхДанных = &ИмяПредопределенныхДанных";
		
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			ТекущийОбъект = Выборка.Ссылка.ПолучитьОбъект();
			ТекущийОбъект.ИмяПредопределенныхДанных = "";
			ОбновлениеИнформационнойБазы.ЗаписатьДанные(ТекущийОбъект);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// См. ОбменДаннымиПереопределяемый.ПриНастройкеПодчиненногоУзлаРИБ.
Процедура ПриНастройкеПодчиненногоУзлаРИБ() Экспорт
	
	// Роли расширений назначаются независимо во всех РИБ-узлах.
	Справочники.ПрофилиГруппДоступа.УдалитьРолиРасширенийВоВсехПрофиляхГруппДоступа();
	
	// Администраторы назначаются независимо во всех РИБ-узлах.
	Справочники.ГруппыДоступа.УдалитьУчастниковГруппыДоступаАдминистраторыБезПользователяИБ();
	
	Если ОбщегоНазначения.ЭтоАвтономноеРабочееМесто() Тогда
		Справочники.ПрофилиГруппДоступа.ОбновитьПоставляемыеПрофилиПоИзменениямКонфигурации();
	КонецЕсли;
	
	Если ОграничиватьДоступНаУровнеЗаписейУниверсально()
	   И ОбщегоНазначения.ЭтоПодчиненныйУзелРИБСФильтром() Тогда
		
		ПараметрыПланирования = ПараметрыПланированияОбновленияДоступа();
		ПараметрыПланирования.Описание = "ПриНастройкеПодчиненногоУзлаРИБ";
		ЗапланироватьОбновлениеДоступа(, ПараметрыПланирования);
	КонецЕсли;
	
КонецПроцедуры

// См. СтандартныеПодсистемыСервер.ПриОтправкеДанныхГлавному.
Процедура ПриОтправкеДанныхГлавному(ЭлементДанных, ОтправкаЭлемента, Получатель) Экспорт
	
	Если ОбъектПодсистемыУправлениеДоступомТолькоДляСозданияНачальногоОбраза(ЭлементДанных) Тогда
		ОтправкаЭлемента = ОтправкаЭлементаДанных.Игнорировать;
		Возврат;
	КонецЕсли;
	
	// Профиль и группа доступа открытия внешних отчетов и обработок
	// недоступны в сервисе, но доступны в автономном рабочем месте.
	Если ОбщегоНазначения.ЭтоАвтономноеРабочееМесто()
	   И (    ТипЗнч(ЭлементДанных) = Тип("СправочникОбъект.ПрофилиГруппДоступа")
	        И ЭтоПрофильОткрытиеВнешнихОтчетовИОбработок(ЭлементДанных)
	      Или ТипЗнч(ЭлементДанных) = Тип("СправочникОбъект.ГруппыДоступа")
	        И Не ЭлементДанных.ЭтоГруппа
	        И ЭтоПрофильОткрытиеВнешнихОтчетовИОбработок(ЭлементДанных.Профиль) ) Тогда
		
		ОтправкаЭлемента = ОтправкаЭлементаДанных.Игнорировать;
	КонецЕсли;
	
	// Роли расширений назначаются независимо во всех РИБ-узлах.
	Если ТипЗнч(ЭлементДанных) = Тип("СправочникОбъект.ПрофилиГруппДоступа") Тогда
		Справочники.ПрофилиГруппДоступа.УдалитьРолиРасширений(ЭлементДанных);
	КонецЕсли;
	
КонецПроцедуры

// См. СтандартныеПодсистемыСервер.ПриОтправкеДанныхПодчиненному.
Процедура ПриОтправкеДанныхПодчиненному(ЭлементДанных, ОтправкаЭлемента, СозданиеНачальногоОбраза, Получатель) Экспорт
	
	// Роли расширений назначаются независимо во всех РИБ-узлах.
	// Частичное изменение объектов при создании начального образа не поддерживается,
	// удаление ролей расширений см. в процедуре ПриНастройкеПодчиненногоУзлаРИБ.
	
	// Администраторы назначаются независимо во всех РИБ-узлах.
	// Частичное изменение объектов при создании начального образа не поддерживается,
	// очистку состава администраторов см. в процедуре ПриНастройкеПодчиненногоУзлаРИБ.
	
	Если СозданиеНачальногоОбраза Тогда
		Возврат;
	КонецЕсли;
	
	Если ОбъектПодсистемыУправлениеДоступомТолькоДляСозданияНачальногоОбраза(ЭлементДанных) Тогда
		ОтправкаЭлемента = ОтправкаЭлементаДанных.Игнорировать;
		Возврат;
	КонецЕсли;
	
КонецПроцедуры

// См. СтандартныеПодсистемыСервер.ПриПолученииДанныхОтГлавного.
Процедура ПриПолученииДанныхОтГлавного(ЭлементДанных, ПолучениеЭлемента, ОтправкаНазад, Отправитель) Экспорт
	
	// Стандартная обработка не переопределяется.
	Если ПолучениеЭлемента = ПолучениеЭлементаДанных.Игнорировать Тогда
		Возврат;
	КонецЕсли;
	
	Если ОбъектПодсистемыУправлениеДоступомТолькоДляСозданияНачальногоОбраза(ЭлементДанных) Тогда
		ПолучениеЭлемента = ПолучениеЭлементаДанных.Игнорировать;
		Возврат;
	КонецЕсли;
	
	ПриПолученииДанныхОтГлавногоИлиОтПодчиненного(ЭлементДанных);
	
КонецПроцедуры

// См. СтандартныеПодсистемыСервер.ПриПолученииДанныхОтПодчиненного.
Процедура ПриПолученииДанныхОтПодчиненного(ЭлементДанных, ПолучениеЭлемента, ОтправкаНазад, Отправитель) Экспорт
	
	// Стандартная обработка не переопределяется.
	Если ПолучениеЭлемента = ПолучениеЭлементаДанных.Игнорировать Тогда
		Возврат;
	КонецЕсли;
	
	Если ОбъектПодсистемыУправлениеДоступомТолькоДляСозданияНачальногоОбраза(ЭлементДанных) Тогда
		ПолучениеЭлемента = ПолучениеЭлементаДанных.Игнорировать;
		Возврат;
	КонецЕсли;
	
	Если Не ОбщегоНазначения.РазделениеВключено() Тогда
		ПриПолученииДанныхОтГлавногоИлиОтПодчиненного(ЭлементДанных);
		
	ИначеЕсли ТипЗнч(ЭлементДанных) = Тип("КонстантаМенеджерЗначения.ОграничиватьДоступНаУровнеЗаписей")
	      Или ТипЗнч(ЭлементДанных) = Тип("КонстантаМенеджерЗначения.ОграничиватьДоступНаУровнеЗаписейУниверсально")
	      Или ТипЗнч(ЭлементДанных) = Тип("СправочникОбъект.ГруппыДоступа")
	      Или ТипЗнч(ЭлементДанных) = Тип("СправочникОбъект.ПрофилиГруппДоступа")
	      Или ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.ГруппыЗначенийДоступа")
	      Или ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.НаборыЗначенийДоступа")
	      Или ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.НаследованиеНастроекПравОбъектов")
	      Или ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.НастройкиПравОбъектов") Тогда
		
		// Получение данных из автономного рабочего места пропускается, а для соответствия
		// данных в узлах, текущие данные отправляются обратно в автономное рабочее место.
		ПолучениеЭлемента = ПолучениеЭлементаДанных.Игнорировать;
		ОтправкаНазад = Истина;
	КонецЕсли;
	
КонецПроцедуры

// См. СтандартныеПодсистемыСервер.ПослеПолученияДанных.
Процедура ПослеПолученияДанных(Отправитель, Отказ, ПолучениеИзГлавногоУзла) Экспорт
	
	Если ОбновлениеИнформационнойБазы.ВыполняетсяОбновлениеИнформационнойБазы() Тогда
		Возврат;
	КонецЕсли;
	
	ОбновитьВспомогательныеДанныеЭлементовИзмененныхПриЗагрузке();
	
КонецПроцедуры

// См. описание в процедуре ЗаполнитьВсеПараметрыРаботыРасширений
// модуля менеджера регистра сведений ПараметрыРаботыВерсийРасширений.
//
Процедура ПриЗаполненииВсехПараметровРаботыРасширений() Экспорт
	
	ОбновитьТаблицыГруппДоступаДляПодключенныхРасширений();
	
КонецПроцедуры

// Обработчики событий подсистемы Пользователи.

// См. ПользователиПереопределяемый.ПриОпределенииНастроек.
Процедура ПриОпределенииНастроек(Настройки) Экспорт
	
	// Роли устанавливаются автоматически по данным групп доступа
	// через связь: ПользователиГруппыДоступа -> Профиль -> РолиПрофиля.
	Настройки.РедактированиеРолей = Ложь;
	
КонецПроцедуры

// См. ПользователиПереопределяемый.ПриОпределенииДействийВФорме.
Процедура ПриОпределенииДействийВФорме(Ссылка, ДействияВФорме) Экспорт
	
	ДействияВФорме.Роли = "";
	
КонецПроцедуры

// См. ИнтеграцияПодсистемБСП.ПослеЗаписиАдминистратораПриАвторизации.
Процедура ПослеЗаписиАдминистратораПриАвторизации(Комментарий) Экспорт
	
	Комментарий =
		НСтр("ru = 'Выполнен запуск от имени пользователя с ролью ""Полные права"",
		           |который не зарегистрирован в списке пользователей.
		           |Выполнена автоматическая регистрация в списке пользователей.
		           |Пользователь добавлен в группу доступа Администраторы.
		           |
		           |Для ведения списка и настройки прав пользователей предназначен список Пользователи,
		           |режим конфигурирования 1С:Предприятия для этого использовать не следует.'");
	
КонецПроцедуры

// См. ИнтеграцияПодсистемБСП.ПослеУстановкиПользователяИБ.
Процедура ПослеУстановкиПользователяИБ(Ссылка, ПарольПользователяСервиса) Экспорт
	
	ОбновитьРолиПользователей(Ссылка, ПарольПользователяСервиса);
	
	Если ОграничиватьДоступНаУровнеЗаписейУниверсально() Тогда
		ЗапланироватьОбновлениеНаборовГруппДоступа(
			"ПослеУстановкиПользователяИБ",
			ТипЗнч(Ссылка) = Тип("СправочникСсылка.Пользователи"),
			ТипЗнч(Ссылка) = Тип("СправочникСсылка.ВнешниеПользователи"));
	КонецЕсли;
	
КонецПроцедуры

// См. ИнтеграцияПодсистемБСП.ПриОпределенииТекстаВопросаПередЗаписьюПервогоАдминистратора.
Процедура ПриОпределенииТекстаВопросаПередЗаписьюПервогоАдминистратора(ТекстВопроса) Экспорт
	
	ТекстВопроса =
		НСтр("ru = 'В список пользователей программы добавляется первый пользователь,
		           |поэтому он будет автоматически включен в группу доступа Администраторы. 
		           |Продолжить?'")
	
КонецПроцедуры

// См. ИнтеграцияПодсистемБСП.ПриСозданииАдминистратора.
Процедура ПриСозданииАдминистратора(Администратор, Уточнение) Экспорт
	
	Если ТипЗнч(Администратор) <> Тип("СправочникСсылка.Пользователи") Тогда
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Пользователь", Администратор);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ИСТИНА КАК ЗначениеИстина
	|ИЗ
	|	Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|ГДЕ
	|	ГруппыДоступаПользователи.Ссылка = ЗНАЧЕНИЕ(Справочник.ГруппыДоступа.Администраторы)
	|	И ГруппыДоступаПользователи.Пользователь = &Пользователь";
	
	Если Не Запрос.Выполнить().Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	КомментарийДляЖурнала = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Пользователь ""%1"" добавлен в группу доступа Администраторы по причине:
		           |%2'"),
		Администратор,
		Уточнение);
	
	Объект = Справочники.ГруппыДоступа.Администраторы.ПолучитьОбъект();
	
	НачатьТранзакцию();
	Попытка
		ЗаблокироватьДанныеДляРедактирования(Объект.Ссылка, Объект.ВерсияДанных);
		Если Объект.Пользователи.Найти(Администратор, "Пользователь") = Неопределено Тогда
			Объект.Пользователи.Добавить().Пользователь = Администратор;
			ОбновлениеИнформационнойБазы.ЗаписатьДанные(Объект);
			ЗаписьЖурналаРегистрации(
				НСтр("ru = 'Управление доступом.Автоматическое изменение группы доступа Администраторы'",
				     ОбщегоНазначения.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Информация,
				Метаданные.Справочники.Пользователи,
				Администратор,
				КомментарийДляЖурнала,
				РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная);
		КонецЕсли;
		РазблокироватьДанныеДляРедактирования(Объект.Ссылка);
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// См. ИнтеграцияПодсистемБСП.ПослеДобавленияИзмененияПользователяИлиГруппы.
Процедура ПослеДобавленияИзмененияПользователяИлиГруппы(Ссылка, ЭтоНовый) Экспорт
	
	Если ЭтоНовый Тогда
		Если ТипЗнч(Ссылка) = Тип("СправочникСсылка.ГруппыПользователей")
		 ИЛИ ТипЗнч(Ссылка) = Тип("СправочникСсылка.ГруппыВнешнихПользователей") Тогда
		
			Параметры = Новый Структура;
			Параметры.Вставить("ГруппыПользователей", Ссылка);
			РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппировкиПользователей(Параметры);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// См. ИнтеграцияПодсистемБСП.ПослеОбновленияСоставовГруппПользователей.
Процедура ПослеОбновленияСоставовГруппПользователей(УчастникиИзменений, ИзмененныеГруппы) Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("Пользователи",        УчастникиИзменений);
	Параметры.Вставить("ГруппыПользователей", ИзмененныеГруппы);
	
	РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппировкиПользователей(Параметры);
	
	ОбновитьРолиПользователей(УчастникиИзменений);
	
	Если ОграничиватьДоступНаУровнеЗаписейУниверсально() Тогда
		ЗапланироватьОбновлениеДоступаПриКосвенномИзмененииУчастниковГруппыДоступа(УчастникиИзменений);
		ЗапланироватьОбновлениеДоступаПриКосвенномИзмененииУчастниковГруппыДоступа(ИзмененныеГруппы);
	КонецЕсли;
	
КонецПроцедуры

// См. ИнтеграцияПодсистемБСП.ПослеИзмененияОбъектаАвторизацииВнешнегоПользователя.
Процедура ПослеИзмененияОбъектаАвторизацииВнешнегоПользователя(ВнешнийПользователь,
                                                               СтарыйОбъектАвторизации,
                                                               НовыйОбъектАвторизации) Экспорт
	
	ОбъектыАвторизации = Новый Массив;
	Если СтарыйОбъектАвторизации <> NULL Тогда
		ОбъектыАвторизации.Добавить(СтарыйОбъектАвторизации);
	КонецЕсли;
	ОбъектыАвторизации.Добавить(НовыйОбъектАвторизации);
	
	Параметры = Новый Структура;
	Параметры.Вставить("ОбъектыАвторизации", ОбъектыАвторизации);
	
	РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппировкиПользователей(Параметры);
	
КонецПроцедуры

// Выполняет копирование прав от одного пользователя другому.
Процедура ПриКопированииПравНовомуПользователю(Источник, Приемник) Экспорт
	
	УпрощенныйИнтерфейс = УпрощенныйИнтерфейсНастройкиПравДоступа();
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Пользователь", Источник);
	
	Если УпрощенныйИнтерфейс Тогда
		Запрос.Текст =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ГруппыДоступаПользователи.Ссылка.Профиль КАК Профиль
		|ИЗ
		|	Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
		|ГДЕ
		|	(ГруппыДоступаПользователи.Пользователь = &Пользователь
		|			ИЛИ ГруппыДоступаПользователи.Пользователь В
		|				(ВЫБРАТЬ
		|					СоставыГруппПользователей.ГруппаПользователей
		|				ИЗ
		|					РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
		|				ГДЕ
		|					СоставыГруппПользователей.Пользователь = &Пользователь))";
	Иначе
		Запрос.Текст =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ГруппыДоступаПользователи.Ссылка КАК ГруппаДоступа
		|ИЗ
		|	Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
		|ГДЕ
		|	(ГруппыДоступаПользователи.Пользователь = &Пользователь
		|			ИЛИ ГруппыДоступаПользователи.Пользователь В
		|				(ВЫБРАТЬ
		|					СоставыГруппПользователей.ГруппаПользователей
		|				ИЗ
		|					РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
		|				ГДЕ
		|					СоставыГруппПользователей.Пользователь = &Пользователь))";
	КонецЕсли;
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	Выборка = РезультатЗапроса.Выбрать();
	
	Если Не УпрощенныйИнтерфейс Тогда
		Блокировка = Новый БлокировкаДанных();
		ЭлементБлокировки = Блокировка.Добавить("Справочник.ГруппыДоступа");
		ЭлементБлокировки.ИсточникДанных = РезультатЗапроса;
	КонецЕсли;
	
	НачатьТранзакцию();
	Попытка
		Если УпрощенныйИнтерфейс Тогда
			Пока Выборка.Следующий() Цикл
				УправлениеДоступом.ВключитьПрофильПользователю(Приемник, Выборка.Профиль);
			КонецЦикла;
		Иначе
			Блокировка.Заблокировать();
			Пока Выборка.Следующий() Цикл
				ГруппаДоступаОбъект = Выборка.ГруппаДоступа.ПолучитьОбъект(); // СправочникОбъект.ГруппыДоступа - 
				Если ГруппаДоступаОбъект.Пользователи.Найти(Приемник, "Пользователь") = Неопределено Тогда
					Строка = ГруппаДоступаОбъект.Пользователи.Добавить();
					Строка.Пользователь = Приемник;
					ГруппаДоступаОбъект.Записать();
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Обработчики событий подсистемы ВариантыОтчетов.

// См. ВариантыОтчетовПереопределяемый.НастроитьВариантыОтчетов.
Процедура ПриНастройкеВариантовОтчетов(Настройки) Экспорт
	МодульВариантыОтчетов = ОбщегоНазначения.ОбщийМодуль("ВариантыОтчетов");
	МодульВариантыОтчетов.НастроитьОтчетВМодулеМенеджера(Настройки, Метаданные.Отчеты.ПраваДоступа);
КонецПроцедуры

// Обработчики событий подсистемы КонтрольВеденияУчета.

// См. ИнтеграцияПодсистемБСП.ПриОпределенииОбъектовИсключаемыхИзПроверки
//
// Параметры:
//  Объекты - см. ИнтеграцияПодсистемБСП.ПриОпределенииОбъектовИсключаемыхИзПроверки
//
Процедура ПриОпределенииОбъектовИсключаемыхИзПроверки(Объекты) Экспорт
	ПриДобавленииИсключенийПоискаСсылокДопускающихУдаление(Объекты);
КонецПроцедуры

// Обработчики событий подсистемы УправлениеДоступом.

// См. УправлениеДоступомПереопределяемый.ПриЗаполненииСписковСОграничениемДоступа.
Процедура ПриЗаполненииСписковСОграничениемДоступа(Списки) Экспорт
	
	Списки.Вставить(Метаданные.Справочники.ПрофилиГруппДоступа, Истина);
	Списки.Вставить(Метаданные.Справочники.ГруппыДоступа, Истина);
	
КонецПроцедуры

// Обработчики событий библиотеки ТехнологияСервиса.

// См. ВыгрузкаЗагрузкаДанныхПереопределяемый.ПриРегистрацииОбработчиковВыгрузкиДанных.
Процедура ПриРегистрацииОбработчиковВыгрузкиДанных(ТаблицаОбработчиков) Экспорт
	
	Обработчик = ТаблицаОбработчиков.Добавить();
	Обработчик.ОбъектМетаданных = Метаданные.Справочники.ПрофилиГруппДоступа;
	Обработчик.Обработчик = Справочники.ПрофилиГруппДоступа;
	Обработчик.ПередВыгрузкойОбъекта = Истина;
	Обработчик.Версия = "1.0.0.1";
	
	Обработчик = ТаблицаОбработчиков.Добавить();
	Обработчик.ОбъектМетаданных = Метаданные.Справочники.ГруппыДоступа;
	Обработчик.Обработчик = Справочники.ГруппыДоступа;
	Обработчик.ПередВыгрузкойОбъекта = Истина;
	Обработчик.Версия = "1.0.0.1";
	
	Обработчик = ТаблицаОбработчиков.Добавить();
	Обработчик.ОбъектМетаданных = Метаданные.РегистрыСведений.ЗначенияГруппДоступа;
	Обработчик.Обработчик = РегистрыСведений.ЗначенияГруппДоступа;
	Обработчик.ПередВыгрузкойОбъекта = Истина;
	Обработчик.Версия = "1.0.0.1";
	
	Обработчик = ТаблицаОбработчиков.Добавить();
	Обработчик.ОбъектМетаданных = Метаданные.РегистрыСведений.ЗначенияГруппДоступаПоУмолчанию;
	Обработчик.Обработчик = РегистрыСведений.ЗначенияГруппДоступаПоУмолчанию;
	Обработчик.ПередВыгрузкойОбъекта = Истина;
	Обработчик.Версия = "1.0.0.1";
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// См. ВыгрузкаЗагрузкаДанныхПереопределяемый.ПриРегистрацииОбработчиковВыгрузкиДанных.
Процедура ПередВыгрузкойОбъекта(Контейнер, МенеджерВыгрузкиОбъекта, Сериализатор, Объект, Артефакты, Отказ) Экспорт
	
	// Роли расширений назначаются независимо в коробке и в сервисе.
	Если ТипЗнч(Объект) = Тип("СправочникОбъект.ПрофилиГруппДоступа") Тогда
		Справочники.ПрофилиГруппДоступа.УдалитьРолиРасширений(Объект);
	КонецЕсли;
	
	// В модели сервиса право открытия внешних отчетов и обработок не используется для пользователей областей данных,
	// поэтому проверка применяется только при переходе Коробка -> Сервис.
	Если ОбщегоНазначения.РазделениеВключено() Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(Объект) = Тип("СправочникОбъект.ПрофилиГруппДоступа") Тогда
		Профиль = Объект;
		
	ИначеЕсли ТипЗнч(Объект) = Тип("СправочникОбъект.ГруппыДоступа") И Не Объект.ЭтоГруппа Тогда
		Профиль = Объект.Профиль;
	Иначе
		Возврат;
	КонецЕсли;
	
	Если ЭтоПрофильОткрытиеВнешнихОтчетовИОбработок(Профиль) Тогда
		Отказ = Истина;
	КонецЕсли;
	
КонецПроцедуры

// См. ВыгрузкаЗагрузкаДанныхПереопределяемый.ПриРегистрацииОбработчиковВыгрузкиДанных.
Процедура ПередВыгрузкойНабораЗаписей(Контейнер, МенеджерВыгрузкиОбъекта, Сериализатор, Объект, Артефакты, Отказ) Экспорт
	
	// В модели сервиса право открытия внешних отчетов и обработок не используется для пользователей областей данных,
	// поэтому проверка применяется только при переходе Коробка -> Сервис.
	Если ОбщегоНазначения.РазделениеВключено() Тогда
		Возврат;
	КонецЕсли;
	
	ГруппыДоступа = ГруппыДоступаПрофиляОткрытиеВнешнихОтчетовИОбработок();
	
	Индекс = Объект.Количество() - 1;
	Пока Индекс >= 0 Цикл
		Если ГруппыДоступа.Найти(Объект[Индекс].ГруппаДоступа) <> Неопределено Тогда
			Объект.Удалить(Индекс);
		КонецЕсли;
		Индекс = Индекс - 1;
	КонецЦикла;
	
КонецПроцедуры

// См. ОбщегоНазначенияПереопределяемый.ПриДобавленииОбработчиковУстановкиПараметровСеанса.
Процедура УстановкаПараметровСеанса(ИмяПараметра, УстановленныеПараметры) Экспорт
	
	#Область УниверсальноеОграничение
	Если ИмяПараметра = "ПараметрыОграниченияДоступа" Тогда
		ПараметрыСеанса.ПараметрыОграниченияДоступа = Новый ФиксированнаяСтруктура(Новый Структура);
		УстановленныеПараметры.Добавить("ПараметрыОграниченияДоступа");
		Возврат;
	КонецЕсли;
	
	Если ИмяПараметра = "ОтключениеОбновленияКлючейДоступа" Тогда
		Свойства = Новый Структура;
		Свойства.Вставить("Стандартное",      Ложь);
		Свойства.Вставить("Полное",           Ложь);
		Свойства.Вставить("ИзмененныеСписки", Новый ХранилищеЗначения(Новый Соответствие));
		ПараметрыСеанса.ОтключениеОбновленияКлючейДоступа = Новый ФиксированнаяСтруктура(Свойства);
		УстановленныеПараметры.Добавить("ОтключениеОбновленияКлючейДоступа");
		Возврат;
	КонецЕсли;
	
	УниверсальноеОграничение = ОграничиватьДоступНаУровнеЗаписейУниверсально(Истина, Истина, Ложь);
	
	ПараметрыСеанса.ОграничениеДоступаНаУровнеЗаписейУниверсально = УниверсальноеОграничение;
	
	УстановленныеПараметры.Добавить("ОграничениеДоступаНаУровнеЗаписейУниверсально");
	Если ИмяПараметра = "ОграничениеДоступаНаУровнеЗаписейУниверсально" Тогда
		Возврат;
	КонецЕсли;
	#КонецОбласти
	
	// Для корректной работы препроцессора в ограничениях доступа, требуется инициализации всех
	// параметров сеанса, которые могут быть востребованы в работе препроцессора.
	ОграничиватьДоступНаУровнеЗаписей = Константы.ОграничиватьДоступНаУровнеЗаписей.Получить();
	ИнформационнаяБазаЗаблокированаДляОбновления = ЗначениеЗаполнено(
		ОбновлениеИнформационнойБазыСлужебный.ИнформационнаяБазаЗаблокированаДляОбновления(Ложь));
	
	#Область УниверсальноеОграничение
	Если Не ОграничиватьДоступНаУровнеЗаписей
	 Или Не УниверсальноеОграничение
	 Или ИнформационнаяБазаЗаблокированаДляОбновления Тогда
		
		ПараметрыСеанса.СпискиСОтключеннымОграничениемЧтения =
			?(ИнформационнаяБазаЗаблокированаДляОбновления
				Или Не УниверсальноеОграничение, "Неопределено", "Все");
		
		ПустойНаборГруппДоступа = Справочники.НаборыГруппДоступа.ПустаяСсылка();
		
		ПараметрыСеанса.ВерсииШаблоновОграниченияДоступа   = ВерсииШаблоновОграниченияДоступа();
		ПараметрыСеанса.РазрешенныйНаборГруппДоступа       = ПустойНаборГруппДоступа;
		ПараметрыСеанса.РазрешенныйПустойНаборГруппДоступа = ПустойНаборГруппДоступа;
		ПараметрыСеанса.РазрешенныйНаборГруппПользователей = ПустойНаборГруппДоступа;
		ПараметрыСеанса.РазрешенныйПользователь            = ПустойНаборГруппДоступа;
		ПараметрыСеанса.ОбщиеПараметрыШаблоновОграниченияДоступа = "";
		ПараметрыСеанса.СпискиСОграничениемЧерезКлючиДоступаГруппДоступа  = "";
		ПараметрыСеанса.СпискиСОграничениемЧерезКлючиДоступаПользователей = "";
		ПараметрыСеанса.СпискиСОграничениемПоПолям = "";
		
		УстановленныеПараметры.Добавить("СпискиСОтключеннымОграничениемЧтения");
		УстановленныеПараметры.Добавить("ВерсииШаблоновОграниченияДоступа");
		УстановленныеПараметры.Добавить("РазрешенныйНаборГруппДоступа");
		УстановленныеПараметры.Добавить("РазрешенныйПустойНаборГруппДоступа");
		УстановленныеПараметры.Добавить("РазрешенныйНаборГруппПользователей");
		УстановленныеПараметры.Добавить("РазрешенныйПользователь");
		УстановленныеПараметры.Добавить("ОбщиеПараметрыШаблоновОграниченияДоступа");
		УстановленныеПараметры.Добавить("СпискиСОграничениемЧерезКлючиДоступаГруппДоступа");
		УстановленныеПараметры.Добавить("СпискиСОграничениемЧерезКлючиДоступаПользователей");
		УстановленныеПараметры.Добавить("СпискиСОграничениемПоПолям");
	КонецЕсли;
	#КонецОбласти
	
	Если Не ОграничиватьДоступНаУровнеЗаписей
	 Или УниверсальноеОграничение
	 Или ИнформационнаяБазаЗаблокированаДляОбновления Тогда
		
		ПараметрыСеанса.ОграничениеДоступаНаУровнеЗаписейИспользуется =
			?(ИнформационнаяБазаЗаблокированаДляОбновления
				Или УниверсальноеОграничение, "", Ложь);
		
		ПараметрыСеанса.ВсеВидыДоступаКромеСпециальных             = "";
		ПараметрыСеанса.ВидыДоступаСОтключеннымИспользованием      = "";
		ПараметрыСеанса.ВидыДоступаБезГруппДляЗначенияДоступа      = "";
		ПараметрыСеанса.ВидыДоступаСОднойГруппойДляЗначенияДоступа = "";
		
		ПараметрыСеанса.ТипыЗначенийДоступаСГруппами
			= Новый ФиксированныйМассив(Новый Массив);
		
		ПараметрыСеанса.ТаблицыСОтдельнымиНастройкамиПрав = "";
		
		ПараметрыСеанса.ИдентификаторыТаблицСОтдельнымиНастройкамиПрав
			= Новый ФиксированныйМассив(Новый Массив);
		
		ПараметрыСеанса.ТипыВладельцевНастроекПрав
			= Новый ФиксированныйМассив(Новый Массив);
		
		ПараметрыСеанса.ТаблицыРасширенийСОграничениемДоступа = "";
		
		УстановленныеПараметры.Добавить("ОграничениеДоступаНаУровнеЗаписейИспользуется");
		УстановленныеПараметры.Добавить("ВсеВидыДоступаКромеСпециальных");
		УстановленныеПараметры.Добавить("ВидыДоступаСОтключеннымИспользованием");
		УстановленныеПараметры.Добавить("ВидыДоступаБезГруппДляЗначенияДоступа");
		УстановленныеПараметры.Добавить("ВидыДоступаСОднойГруппойДляЗначенияДоступа");
		УстановленныеПараметры.Добавить("ТипыЗначенийДоступаСГруппами");
		УстановленныеПараметры.Добавить("ТаблицыСОтдельнымиНастройкамиПрав");
		УстановленныеПараметры.Добавить("ИдентификаторыТаблицСОтдельнымиНастройкамиПрав");
		УстановленныеПараметры.Добавить("ТипыВладельцевНастроекПрав");
		УстановленныеПараметры.Добавить("ТаблицыРасширенийСОграничениемДоступа");
	КонецЕсли;
	
	Если ИнформационнаяБазаЗаблокированаДляОбновления Тогда
		Возврат;
	КонецЕсли;
	
	#Область УниверсальноеОграничение
	Если УниверсальноеОграничение Тогда
		ДействующиеПараметрыОграниченияДоступа(Неопределено, Неопределено, Ложь, Истина);
		Возврат;
	КонецЕсли;
	#КонецОбласти
	
	Если Не ОграничиватьДоступНаУровнеЗаписей Тогда
		Возврат;
	КонецЕсли;
	
	ПараметрыСеанса.ОграничениеДоступаНаУровнеЗаписейИспользуется = Истина;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ТекущийПользователь", Пользователи.АвторизованныйПользователь());
	Запрос.Текст =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ЗначенияПоУмолчанию.ТипЗначенийДоступа КАК ТипЗначений,
	|	ЗначенияПоУмолчанию.ВсеРазрешеныБезИсключений КАК ВсеРазрешеныБезИсключений
	|ПОМЕСТИТЬ ЗначенияПоУмолчаниюДляПользователя
	|ИЗ
	|	РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
	|ГДЕ
	|	ИСТИНА В
	|			(ВЫБРАТЬ ПЕРВЫЕ 1
	|				ИСТИНА
	|			ИЗ
	|				Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|					ПО
	|						ГруппыДоступаПользователи.Ссылка = ЗначенияПоУмолчанию.ГруппаДоступа
	|							И ГруппыДоступаПользователи.Пользователь = СоставыГруппПользователей.ГруппаПользователей
	|							И СоставыГруппПользователей.Пользователь = &ТекущийПользователь)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ЗначенияПоУмолчанию.ТипЗначений
	|ИЗ
	|	ЗначенияПоУмолчаниюДляПользователя КАК ЗначенияПоУмолчанию
	|
	|СГРУППИРОВАТЬ ПО
	|	ЗначенияПоУмолчанию.ТипЗначений
	|
	|ИМЕЮЩИЕ
	|	МИНИМУМ(ЗначенияПоУмолчанию.ВсеРазрешеныБезИсключений) = ИСТИНА";
	
	ТипыЗначенийВсеРазрешеныБезИсключений = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("ТипЗначений");
	
	// Установка параметров ВсеВидыДоступаКромеСпециальных, ВидыДоступаСОтключеннымИспользованием.
	ВсеВидыДоступаКромеСпециальных        = Новый Массив;
	ВидыДоступаСОтключеннымИспользованием = Новый Массив;
	
	СвойстваВидовДоступа = УправлениеДоступомСлужебныйПовтИсп.СвойстваВидовДоступа();
	
	Для каждого СвойстваВидаДоступа Из СвойстваВидовДоступа.Массив Цикл
		ВсеВидыДоступаКромеСпециальных.Добавить(СвойстваВидаДоступа.Имя);
		
		Если НЕ ВидДоступаИспользуется(СвойстваВидаДоступа.Ссылка)
		 ИЛИ ТипыЗначенийВсеРазрешеныБезИсключений.Найти(СвойстваВидаДоступа.Ссылка) <> Неопределено Тогда
			
			ВидыДоступаСОтключеннымИспользованием.Добавить(СвойстваВидаДоступа.Имя);
		КонецЕсли;
	КонецЦикла;
	
	ПараметрыСеанса.ВсеВидыДоступаКромеСпециальных = ВсеКомбинацииВидовДоступа(ВсеВидыДоступаКромеСпециальных);
	
	УстановленныеПараметры.Добавить("ВсеВидыДоступаКромеСпециальных");
	
	ВсеВидыДоступаКромеСпециальныхОтключены = (ВсеВидыДоступаКромеСпециальных.Количество()
		= ВидыДоступаСОтключеннымИспользованием.Количество());
	
	Если ВсеВидыДоступаКромеСпециальныхОтключены Тогда
		ПараметрыСеанса.ВидыДоступаСОтключеннымИспользованием = "Все";
	Иначе
		ПараметрыСеанса.ВидыДоступаСОтключеннымИспользованием
			= ВсеКомбинацииВидовДоступа(ВидыДоступаСОтключеннымИспользованием);
	КонецЕсли;
	
	УстановленныеПараметры.Добавить("ВидыДоступаСОтключеннымИспользованием");
	
	// Установка параметров ВидыДоступаБезГруппДляЗначенияДоступа,
	// ВидыДоступаСОднойГруппойДляЗначенияДоступа, ТипыЗначенийДоступаСГруппами.
	ПараметрыСеанса.ВидыДоступаБезГруппДляЗначенияДоступа =
		ВсеКомбинацииВидовДоступа(СвойстваВидовДоступа.БезГруппДляЗначенияДоступа);
	ПараметрыСеанса.ВидыДоступаСОднойГруппойДляЗначенияДоступа =
		ВсеКомбинацииВидовДоступа(СвойстваВидовДоступа.СОднойГруппойДляЗначенияДоступа);
	
	ТипыЗначенийДоступаСГруппами = Новый Массив;
	Для каждого КлючИЗначение Из СвойстваВидовДоступа.ТипыЗначенийДоступаСГруппами Цикл
		ТипыЗначенийДоступаСГруппами.Добавить(КлючИЗначение.Значение);
	КонецЦикла;
	ПараметрыСеанса.ТипыЗначенийДоступаСГруппами = Новый ФиксированныйМассив(ТипыЗначенийДоступаСГруппами);
	
	УстановленныеПараметры.Добавить("ВидыДоступаБезГруппДляЗначенияДоступа");
	УстановленныеПараметры.Добавить("ВидыДоступаСОднойГруппойДляЗначенияДоступа");
	УстановленныеПараметры.Добавить("ТипыЗначенийДоступаСГруппами");
	
	// Установка параметров ТаблицыСОтдельнымиНастройкамиПрав,
	// ИдентификаторыТаблицСОтдельнымиНастройкамиПрав, ТипыВладельцевНастроекПрав.
	ВозможныеПрава = УправлениеДоступомСлужебныйПовтИсп.ВозможныеПраваДляНастройкиПравОбъектов();
	ОтдельныеТаблицы = ВозможныеПрава.ОтдельныеТаблицы;
	ТаблицыСОтдельнымиНастройкамиПрав = "";
	ИдентификаторыТаблицСОтдельнымиНастройкамиПрав = Новый Массив;
	Для каждого КлючИЗначение Из ОтдельныеТаблицы Цикл
		ТаблицыСОтдельнымиНастройкамиПрав = ТаблицыСОтдельнымиНастройкамиПрав
			+ "|" + КлючИЗначение.Значение + ";" + Символы.ПС;
		ИдентификаторыТаблицСОтдельнымиНастройкамиПрав.Добавить(КлючИЗначение.Ключ);
	КонецЦикла;
	
	ПараметрыСеанса.ТаблицыСОтдельнымиНастройкамиПрав = ТаблицыСОтдельнымиНастройкамиПрав;
	
	ПараметрыСеанса.ИдентификаторыТаблицСОтдельнымиНастройкамиПрав =
		Новый ФиксированныйМассив(ИдентификаторыТаблицСОтдельнымиНастройкамиПрав);
	
	ПараметрыСеанса.ТипыВладельцевНастроекПрав = ВозможныеПрава.ТипыВладельцев;
	
	ПолныеИмена = Справочники.ИдентификаторыОбъектовРасширений.ПолныеИменаТаблицСДанными();
	ТаблицыРасширений = СтрСоединить(ПолныеИмена, ";" + Символы.ПС + "|");
	ТаблицыРасширений = ?(ТаблицыРасширений = "", "", "|" + ТаблицыРасширений + ";" + Символы.ПС);
	
	ПараметрыСеанса.ТаблицыРасширенийСОграничениемДоступа = ТаблицыРасширений;
	
	УстановленныеПараметры.Добавить("ТаблицыСОтдельнымиНастройкамиПрав");
	УстановленныеПараметры.Добавить("ИдентификаторыТаблицСОтдельнымиНастройкамиПрав");
	УстановленныеПараметры.Добавить("ТипыВладельцевНастроекПрав");
	УстановленныеПараметры.Добавить("ТаблицыРасширенийСОграничениемДоступа");
	
КонецПроцедуры

// Только для внутреннего использования.
Процедура ОбновитьПараметрыСеанса() Экспорт
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	УстановленныеПараметры = Новый Массив;
	УстановкаПараметровСеанса("", УстановленныеПараметры);
	
	УстановитьПривилегированныйРежим(Ложь);
	УстановитьОтключениеБезопасногоРежима(Ложь);
	
	ОбновитьПовторноИспользуемыеЗначения();
	
КонецПроцедуры

// Обновляет список ролей пользователей информационной базы
// по их текущим принадлежностям к группам доступа.
//  Пользователи с ролью "ПолныеПрава" игнорируется.
//
// Параметры:
//  Пользователи - СправочникСсылка.Пользователи,
//                 СправочникСсылка.ВнешниеПользователи.
//                 Массив значений указанных выше типов.
//               - Неопределено - обновить роли всех пользователей.
//               - Тип по которому будет найден объект метаданных:
//                 если будет найден Справочник.ВнешниеПользователи,
//                 то будут обновлены роли всех внешних пользователей,
//                 иначе будут обновлены роли всех пользователей.
//
//  ПарольПользователяСервиса - Строка - Пароль для авторизации в менеджере
//                        сервиса.
//  ЕстьИзменения - Булево - (возвращаемое значение) - в этот параметр возвращается
//                  значение Истина, если производилась запись, иначе не изменяется.
//
Процедура ОбновитьРолиПользователей(Знач Пользователи1 = Неопределено,
                                    Знач ПарольПользователяСервиса = Неопределено,
                                    ЕстьИзменения = Ложь) Экспорт
	
	Если НЕ ПользователиСлужебный.ЗапретРедактированияРолей() Тогда
		// Роли устанавливаются механизмами подсистем Пользователи и ВнешниеПользователи.
		Возврат;
	КонецЕсли;
	
	Если Пользователи1 = Неопределено Тогда
		МассивПользователей = Неопределено;
		Пользователи.НайтиНеоднозначныхПользователейИБ(Неопределено);
		
	ИначеЕсли ТипЗнч(Пользователи1) = Тип("Массив") Тогда
		МассивПользователей = Пользователи1;
		Если МассивПользователей.Количество() = 0 Тогда
			Возврат;
		ИначеЕсли МассивПользователей.Количество() = 1 Тогда
			Пользователи.НайтиНеоднозначныхПользователейИБ(МассивПользователей[0]);
		Иначе
			Пользователи.НайтиНеоднозначныхПользователейИБ(Неопределено);
		КонецЕсли;
		
	ИначеЕсли ТипЗнч(Пользователи1) = Тип("Тип") Тогда
		МассивПользователей = Пользователи1;
		Пользователи.НайтиНеоднозначныхПользователейИБ(Неопределено);
	Иначе
		МассивПользователей = Новый Массив;
		МассивПользователей.Добавить(Пользователи1);
		Пользователи.НайтиНеоднозначныхПользователейИБ(Пользователи1);
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТекущиеСвойстваПользователей = ТекущиеСвойстваПользователей(МассивПользователей);
	
	// Параметры проверки в цикле.
	ВсеРоли                       = ПользователиСлужебный.ВсеРоли().Соответствие;
	ИдентификаторыПользователейИБ = ТекущиеСвойстваПользователей.ИдентификаторыПользователейИБ;
	НовыеРолиПользователей        = ТекущиеСвойстваПользователей.РолиПользователей;
	Администраторы                = ТекущиеСвойстваПользователей.Администраторы;
	РазделениеВключено            = ОбщегоНазначения.РазделениеВключено();
	
	ОбязательныеРолиАдминистратора = Новый Соответствие;
	ОбязательныеРолиАдминистратора.Вставить("ПолныеПрава", Истина);
	Если Не РазделениеВключено Тогда
		ОбязательныеРолиАдминистратора.Вставить("АдминистраторСистемы", Истина);
	КонецЕсли;
	ДополнительныеРолиАдминистратора = Новый Соответствие;
	ДополнительныеРолиАдминистратора.Вставить("ИнтерактивноеОткрытиеВнешнихОтчетовИОбработок", Истина);
	
	// Будущий итог после цикла.
	НовыеАдминистраторыИБ     = Новый Соответствие;
	ОбновляемыеПользователиИБ = Новый Соответствие;
	
	Для Каждого ОписаниеПользователя Из ИдентификаторыПользователейИБ Цикл
		
		ТекущийПользователь         = ОписаниеПользователя.Пользователь;
		ИдентификаторПользователяИБ = ОписаниеПользователя.ИдентификаторПользователяИБ;
		НовыйАдминистраторИБ        = Ложь;
		
		Отказ = Ложь;
		ИнтеграцияПодсистемБСП.ПриОбновленииРолейПользователяИБ(ИдентификаторПользователяИБ, Отказ);
		Если Отказ Тогда
			Продолжить;
		КонецЕсли;
		
		// Поиск пользователя ИБ.
		Если ТипЗнч(ИдентификаторПользователяИБ) = Тип("УникальныйИдентификатор") Тогда
			ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(
				ИдентификаторПользователяИБ);
		Иначе
			ПользовательИБ = Неопределено;
		КонецЕсли;
		
		Если ПользовательИБ = Неопределено
		 Или Не ЗначениеЗаполнено(ПользовательИБ.Имя) Тогда
			Продолжить;
		КонецЕсли;
		
		Отбор = Новый Структура("Пользователь", ТекущийПользователь);
		НовыеРоли = НовыеРолиПользователей.Скопировать(
			НовыеРолиПользователей.НайтиСтроки(Отбор), "Роль, РольСсылка");
		
		НовыеРоли.Индексы.Добавить("Роль");
		
		Если Администраторы[ТекущийПользователь] <> Неопределено Тогда
			ТекущиеНовыеРоли = НовыеРоли;
			НовыеРоли = ТекущиеНовыеРоли.Скопировать(Новый Массив);
			Для Каждого КлючИЗначение Из ОбязательныеРолиАдминистратора Цикл
				НовыеРоли.Добавить().Роль = КлючИЗначение.Ключ;
			КонецЦикла;
			Для Каждого КлючИЗначение Из ДополнительныеРолиАдминистратора Цикл
				Если ТекущиеНовыеРоли.Найти(КлючИЗначение.Ключ, "Роль") = Неопределено Тогда
					Продолжить;
				КонецЕсли;
				НовыеРоли.Добавить().Роль = КлючИЗначение.Ключ;
			КонецЦикла;
		КонецЕсли;
		
		// Проверка старых ролей.
		СтарыеРоли        = Новый Соответствие;
		РолиДляДобавления = Новый Соответствие;
		РолиДляУдаления   = Новый Соответствие;
		
		Для Каждого Роль Из ПользовательИБ.Роли Цикл
			ИмяРоли = Роль.Имя;
			СтарыеРоли.Вставить(ИмяРоли, Истина);
			Если НовыеРоли.Найти(ИмяРоли, "Роль") = Неопределено Тогда
				РолиДляУдаления.Вставить(ИмяРоли, Истина);
			КонецЕсли;
		КонецЦикла;
		
		НедоступныеРоли = ПользователиСлужебныйПовтИсп.НедоступныеРолиПоТипуПользователя(
			ТипЗнч(ТекущийПользователь) = Тип("СправочникСсылка.ВнешниеПользователи"));
		
		// Проверка новых ролей.
		Для Каждого Строка Из НовыеРоли Цикл
			
			Если СтарыеРоли[Строка.Роль] <> Неопределено Тогда
				Если РазделениеВключено
				   И НедоступныеРоли.Получить(Строка.Роль) <> Неопределено Тогда
					
					ЗарегистрироватьНедоступнуюРоль(Строка, ТекущийПользователь);
					РолиДляУдаления.Вставить(Строка.Роль, Истина);
				КонецЕсли;
				Продолжить;
			КонецЕсли;
			
			Если ВсеРоли.Получить(Строка.Роль) = Неопределено Тогда
				ЗарегистрироватьНенайденнуюРоль(Строка, ТекущийПользователь);
				Продолжить;
			КонецЕсли;
			
			Если НедоступныеРоли.Получить(Строка.Роль) <> Неопределено Тогда
				ЗарегистрироватьНедоступнуюРоль(Строка, ТекущийПользователь);
				Продолжить;
			КонецЕсли;
			
			РолиДляДобавления.Вставить(Строка.Роль, Истина);
			
			Если Строка.Роль = "АдминистраторСистемы" Тогда
				НовыйАдминистраторИБ = Истина;
			КонецЕсли;
		КонецЦикла;
		
		// Завершение обработки текущего пользователя.
		Если РолиДляДобавления.Количество() = 0
		   И РолиДляУдаления.Количество()   = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		ИзмененияРолей = Новый Структура;
		ИзмененияРолей.Вставить("ПользовательСсылка", ТекущийПользователь);
		ИзмененияРолей.Вставить("ПользовательИБ",     ПользовательИБ);
		ИзмененияРолей.Вставить("РолиДляДобавления",  РолиДляДобавления);
		ИзмененияРолей.Вставить("РолиДляУдаления",    РолиДляУдаления);
		
		Если НовыйАдминистраторИБ Тогда
			НовыеАдминистраторыИБ.Вставить(ТекущийПользователь, ИзмененияРолей);
		Иначе
			ОбновляемыеПользователиИБ.Вставить(ТекущийПользователь, ИзмененияРолей);
		КонецЕсли;
		
		ЕстьИзменения = Истина;
	КонецЦикла;
	
	// Добавление новых администраторов.
	Если НовыеАдминистраторыИБ.Количество() > 0 Тогда
		ОбновитьРолиПользователейИБ(НовыеАдминистраторыИБ, ПарольПользователяСервиса);
	КонецЕсли;
	
	// Удаление старых администраторов и обновление остальных пользователей.
	Если ОбновляемыеПользователиИБ.Количество() > 0 Тогда
		ОбновитьРолиПользователейИБ(ОбновляемыеПользователиИБ, ПарольПользователяСервиса);
	КонецЕсли;
	
	ОтключитьУВсехРасширенийФлажокИспользоватьОсновныеРолиДляВсехПользователей();
	
КонецПроцедуры

// Проверка группы доступа Администраторы перед записью.
Процедура ПроверитьНаличиеПользователяИБВГруппеДоступаАдминистраторы(ПользователиГруппы, ОписаниеОшибки) Экспорт
	
	Пользователи.НайтиНеоднозначныхПользователейИБ(Неопределено);
	
	// Проверка пустого списка пользователей ИБ в группе доступа Администраторы.
	УстановитьПривилегированныйРежим(Истина);
	НайденДействующийАдминистратор = Ложь;
	
	Для Каждого ОписаниеПользователя Из ПользователиГруппы Цикл
		
		Если Не ЗначениеЗаполнено(ОписаниеПользователя.Пользователь)
		 Или ТипЗнч(ОписаниеПользователя.Пользователь) <> Тип("СправочникСсылка.Пользователи")
		   И ТипЗнч(ОписаниеПользователя.Пользователь) <> Тип("СправочникСсылка.Пользователи") Тогда
			Продолжить;
		КонецЕсли;
		
		ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(
			ОписаниеПользователя.Пользователь.ИдентификаторПользователяИБ);
		
		Если ПользовательИБ <> Неопределено
		   И Пользователи.ВходВПрограммуРазрешен(ПользовательИБ) Тогда
			
			НайденДействующийАдминистратор = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если НЕ НайденДействующийАдминистратор Тогда
		ОписаниеОшибки =
			НСтр("ru = 'В группе доступа Администраторы
			           |должен быть хотя бы один пользователь,
			           |которому разрешен вход в программу.'");
	КонецЕсли;
	
КонецПроцедуры

// См. УправлениеДоступом.ЕстьОграничениеТаблицыПоВидуДоступа.
Функция ЕстьОграничениеТаблицыПоВидуДоступа(Таблица, ВидДоступа, ВсеВидыДоступа) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ВидыДоступаСОтключеннымИспользованием = ПараметрыСеанса.ВидыДоступаСОтключеннымИспользованием;
	Если ВидыДоступаСОтключеннымИспользованием = "Все"
	 Или СтрНайти(ВидыДоступаСОтключеннымИспользованием, "," + ВидДоступа + ",") > 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	МассивВидовДоступа = СтрРазделить(ВсеВидыДоступа, ",", Ложь);
	СвойстваВидовДоступа = УправлениеДоступомСлужебныйПовтИсп.СвойстваВидовДоступа();
	
	ЗаголовокОшибки =
		НСтр("ru = 'Ошибка в функции ЕстьОграничениеТаблицыПоВидуДоступа общего модуля УправлениеДоступом.'")
		+ Символы.ПС;
	
	СвойстваВидаДоступа = СвойстваВидовДоступа.ПоИменам.Получить(ВидДоступа);
	Если СвойстваВидаДоступа = Неопределено Тогда
		ТекстОшибки = ЗаголовокОшибки + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не найден вид доступа ""%1"", указанный в параметре ВидДоступа.'"), ВидДоступа);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	ВидДоступаСсылка = СвойстваВидаДоступа.Ссылка;
	
	ВсеВидыДоступаТаблицыСОтключеннымИспользованием = Истина;
	ИспользованиеВидовДоступа = Новый Соответствие;
	ВидДоступаУказанВоВсехВидахДоступа = Ложь;
	
	Для Каждого ТекущийВидДоступа Из МассивВидовДоступа Цикл
		ТекущийВидДоступа = СокрЛП(ТекущийВидДоступа);
		СвойстваВидаДоступа = СвойстваВидовДоступа.ПоИменам.Получить(ТекущийВидДоступа);
		Если СвойстваВидаДоступа = Неопределено Тогда
			ТекстОшибки = ЗаголовокОшибки + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Не найден вид доступа ""%1"", указанный в параметре
				           |ВсеВидыДоступа: ""%2"".'"), ТекущийВидДоступа, ВсеВидыДоступа);
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
		Если СвойстваВидаДоступа.Имя = ВидДоступа Тогда
			ВидДоступаУказанВоВсехВидахДоступа = Истина;
		КонецЕсли;
		Используется = СтрНайти(ВидыДоступаСОтключеннымИспользованием, "," + СвойстваВидаДоступа.Имя + ",") = 0;
		ИспользованиеВидовДоступа.Вставить(СвойстваВидаДоступа.Ссылка, Используется);
		Если Используется Тогда
			ВсеВидыДоступаТаблицыСОтключеннымИспользованием = Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Если Не ВидДоступаУказанВоВсехВидахДоступа Тогда
		ТекстОшибки = ЗаголовокОшибки + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Вид доступа ""%1"", указанный в параметре ВидДоступа не найден в параметре
			           |ВсеВидыДоступа: ""%2"".'"), ВидДоступа, ВсеВидыДоступа);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Если ВсеВидыДоступаТаблицыСОтключеннымИспользованием Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ИмяОсновнойТаблицыСписка", Таблица);
	Запрос.УстановитьПараметр("АвторизованныйПользователь", Пользователи.АвторизованныйПользователь());
	
	Запрос.Текст = ТекстЗапросаГруппДоступа();
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ЗначенияПоУмолчанию.ГруппаДоступа КАК ГруппаДоступа,
	|	ЗначенияПоУмолчанию.ТипЗначенийДоступа КАК ВидДоступа
	|ИЗ
	|	РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ГруппыДоступаПользователя КАК ГруппыДоступаПользователя
	|		ПО ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступаПользователя.Ссылка
	|ГДЕ
	|	НЕ ЗначенияПоУмолчанию.ВсеРазрешеныБезИсключений
	|	И ИСТИНА В
	|			(ВЫБРАТЬ ПЕРВЫЕ 1
	|				ИСТИНА
	|			ИЗ
	|				Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|					ПО
	|						ГруппыДоступаПользователи.Ссылка = ЗначенияПоУмолчанию.ГруппаДоступа
	|							И ГруппыДоступаПользователи.Пользователь = СоставыГруппПользователей.ГруппаПользователей
	|							И СоставыГруппПользователей.Пользователь = &АвторизованныйПользователь)";
	
	ДобавитьЗапросВПакет(Запрос.Текст, ТекстЗапроса);
	Выборка = Запрос.Выполнить().Выбрать();
	
	НастроенныеВидыДоступаГруппДоступа = Новый Соответствие;
	ЕстьГруппаДоступаСОграничениемПоВидуДоступа = Ложь;
	
	Пока Выборка.Следующий() Цикл
		НастроенныеВидыДоступа = НастроенныеВидыДоступаГруппДоступа.Получить(Выборка.ГруппаДоступа);
		Если НастроенныеВидыДоступа = Неопределено Тогда
			НастроенныеВидыДоступа = Новый Соответствие;
			НастроенныеВидыДоступаГруппДоступа.Вставить(Выборка.ГруппаДоступа, НастроенныеВидыДоступа);
		КонецЕсли;
		Если ИспользованиеВидовДоступа.Получить(Выборка.ВидДоступа) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		НастроенныеВидыДоступа.Вставить(Выборка.ВидДоступа, Истина);
		Если Выборка.ВидДоступа = ВидДоступаСсылка Тогда
			ЕстьГруппаДоступаСОграничениемПоВидуДоступа = Истина;
		КонецЕсли;
	КонецЦикла;
	
	ЕстьГруппаДоступаБезОграниченийПоВсемВидамДоступа = Ложь;
	
	Для Каждого ОписаниеГруппыДоступа Из НастроенныеВидыДоступаГруппДоступа Цикл
		НастроенныеВидыДоступа = ОписаниеГруппыДоступа.Значение;
		ВсеВидыДоступаТаблицыБезОграниченийВГруппеДоступа = Истина;
		Для Каждого ОписаниеИспользованияВидаДоступа Из ИспользованиеВидовДоступа Цикл
			Если Не ОписаниеИспользованияВидаДоступа.Значение Тогда
				Продолжить; // Не используется.
			КонецЕсли;
			Если НастроенныеВидыДоступа.Получить(ОписаниеИспользованияВидаДоступа.Ключ) = Неопределено Тогда
				Продолжить; // ВсеРазрешеныБезИсключений или ограничения по виду доступа нет.
			КонецЕсли;
			ВсеВидыДоступаТаблицыБезОграниченийВГруппеДоступа = Ложь;
			Прервать;
		КонецЦикла;
		Если ВсеВидыДоступаТаблицыБезОграниченийВГруппеДоступа Тогда
			ЕстьГруппаДоступаБезОграниченийПоВсемВидамДоступа = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если ЕстьГруппаДоступаБезОграниченийПоВсемВидамДоступа Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат ЕстьГруппаДоступаСОграничениемПоВидуДоступа;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обработчики подписок на события.

// Обработчик подписки ОбновитьГруппыЗначенийДоступа на событие ПередЗаписью:
// - вызывает метод записи групп значений доступа в
//   регистр сведений ГруппыЗначенийДоступа для требуемых объектов метаданных;
//
Процедура ОбновитьГруппыЗначенийДоступа(Знач Объект, Отказ) Экспорт
	
	Если Объект.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	Если СтандартныеПодсистемыСервер.ЭтоИдентификаторОбъектаМетаданных(Объект) Тогда
		Возврат;
	КонецЕсли;
	
	СвойстваВидовДоступа = УправлениеДоступомСлужебныйПовтИсп.СвойстваВидовДоступа();
	ЗначенияДоступаСГруппами = СвойстваВидовДоступа.ЗначенияДоступаСГруппами;
	
	Если ЗначенияДоступаСГруппами.ПоТипамДляОбновления.Получить(ТипЗнч(Объект)) <> Неопределено Тогда
		РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппыЗначенийДоступа(Объект);
	КонецЕсли;
	
	Если СвойстваВидовДоступа.ПоТипамЗначенийСИерархией.Получить(ТипЗнч(Объект)) <> Неопределено Тогда
		Родитель = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Объект.Ссылка, "Родитель");
		Если Объект.Родитель <> Родитель Тогда
			Объект.ДополнительныеСвойства.Вставить("ОбновитьЗначенияГруппДоступа");
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Обработчик подписки ОбновитьЗначенияГруппДоступа на событие ПриЗаписи:
// - обновляет значения групп доступа, выбранные с учетом иерархии.
//
Процедура ОбновитьЗначенияГруппДоступа(Источник) Экспорт
	
	Если Источник.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	Если Источник.ДополнительныеСвойства.Свойство("ОбновитьЗначенияГруппДоступа") Тогда
		ГруппыДоступа = ГруппыДоступаИспользующиеИерархиюЗначенийДоступа(ТипЗнч(Источник.Ссылка));
		РегистрыСведений.ЗначенияГруппДоступа.ОбновитьДанныеРегистра(ГруппыДоступа);
	КонецЕсли;
	
КонецПроцедуры

// Обработчик подписки ОбновитьГруппыВладельцевНастроекПрав на событие ПередЗаписью:
// - вызывает метод записи иерархии владельцев настроек прав объектов в
//   регистр сведений НаследованиеНастроекПравОбъектов для требуемых объектов метаданных.
//
Процедура ОбновитьГруппыВладельцевНастроекПрав(Знач Объект, Отказ) Экспорт
	
	Если Объект.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	Если СтандартныеПодсистемыСервер.ЭтоИдентификаторОбъектаМетаданных(Объект) Тогда
		Возврат;
	КонецЕсли;
	
	ВозможныеПрава = УправлениеДоступомСлужебныйПовтИсп.ВозможныеПраваДляНастройкиПравОбъектов();
	ВозможныеПраваПоТипам = ВозможныеПрава.ПоТипам;
	
	Если ВозможныеПраваПоТипам.Получить(ТипЗнч(Объект)) <> Неопределено Тогда
		РегистрыСведений.НаследованиеНастроекПравОбъектов.ОбновитьДанныеРегистра(Объект);
	КонецЕсли;
	
КонецПроцедуры

// Обработчик подписки ЗаписатьНаборыЗначенийДоступа на событие ПриЗаписи
// вызывает метод записи значений доступа объекта в РегистрСведений.НаборыЗначенийДоступа.
//  Возможен случай использования подсистемы "УправлениеДоступом", когда
// указанной подписки не существует, если наборы значений доступа не применяются.
//
Процедура ЗаписатьНаборыЗначенийДоступаПриЗаписи(Знач Объект, Отказ) Экспорт
	
	// Проверка ОбменДанными.Загрузка пропускается только в тех случаях,
	// когда дополнительно установлено свойство ЗаписатьНаборыЗначенийДоступа.
	// В этом случае при записи ведущего объекта для корректной работы его RLS выполняется программная
	// запись подчиненного объекта для обновления служебной табличной части НаборыЗначенийДоступа.
	Если Объект.ОбменДанными.Загрузка
	   И НЕ Объект.ДополнительныеСвойства.Свойство("ЗаписатьНаборыЗначенийДоступа") Тогда
		
		Возврат;
	КонецЕсли;
	
	Если СтандартныеПодсистемыСервер.ЭтоИдентификаторОбъектаМетаданных(Объект) Тогда
		Возврат;
	КонецЕсли;
	
	ЗаписатьНаборыЗначенийДоступа(Объект, , Объект.ДополнительныеСвойства.Свойство(
		"ЗаписьНаборовЗначенийДоступаПриОбновленииИБ"));
	
КонецПроцедуры

// Обработчик подписки ЗаписатьЗависимыеНаборыЗначенийДоступа события ПриЗаписи
// вызывает перезапись зависимых наборов значений доступа в регистре сведений НаборыЗначенийДоступа.
//
//  Возможен случай использования подсистемы "УправлениеДоступом", когда
// указанной подписки не существует, если зависимые наборы значений доступа не применяются.
//
Процедура ЗаписатьЗависимыеНаборыЗначенийДоступаПриЗаписи(Знач Объект, Отказ) Экспорт
	
	// Проверка ОбменДанными.Загрузка пропускается только в тех случаях,
	// когда дополнительно установлено свойство ЗаписатьНаборыЗначенийДоступа.
	// В этом случае при записи ведущего объекта для корректной работы его RLS выполняется программная
	// запись подчиненного объекта для обновления служебной табличной части НаборыЗначенийДоступа.
	Если Объект.ОбменДанными.Загрузка
	   И НЕ Объект.ДополнительныеСвойства.Свойство("ЗаписатьЗависимыеНаборыЗначенийДоступа") Тогда
		
		Возврат;
	КонецЕсли;
	
	Если СтандартныеПодсистемыСервер.ЭтоИдентификаторОбъектаМетаданных(Объект) Тогда
		Возврат;
	КонецЕсли;
	
	ЗаписатьЗависимыеНаборыЗначенийДоступа(Объект, Объект.ДополнительныеСвойства.Свойство(
		"ЗаписьНаборовЗначенийДоступаПриОбновленииИБ"));
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики регламентных заданий.

// Обработчик регламентного задания ЗаполнениеДанныхДляОграниченияДоступа.
Процедура ЗаполнениеДанныхДляОграниченияДоступаОбработчикЗадания() Экспорт
	
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(
		Метаданные.РегламентныеЗадания.ЗаполнениеДанныхДляОграниченияДоступа);
	
	ЗаполнениеДанныхДляОграниченияДоступа();
	
КонецПроцедуры

// Выполняет последовательное заполнение и обновление данных, необходимых для работы
// подсистемы УправленияДоступом в режиме ограничения доступа на уровне записей.
// 
//  При включенном режиме ограничения доступа на уровне записей заполняет наборы
// значений доступа. Заполнение выполняется частями при каждом запуске, пока все
// наборы значений доступа не будут заполнены.
//  При отключении режима ограничения доступа на уровне записей наборы значений доступа
// (заполненные ранее) удаляются при перезаписи объектов, а не все сразу.
//  Независимо от режима ограничения доступа на уровне записей обновляет кэш-реквизиты.
//  После завершения всех обновлений и заполнений отключает использование регламентного задания.
//
//  Сведения о состоянии работы записываются в журнал регистрации.
//
//  Возможно вызывать программно, например, при обновлении информационной базы.
// Также для целей обновления есть форма Справочник.ГруппыДоступа.ОбновлениеДанныхОграниченияДоступа,
// с помощью которой можно сделать интерактивное обновление данных ограничения доступа
// при обновлении информационной базы.
//
Процедура ЗаполнениеДанныхДляОграниченияДоступа(КоличествоДанных = 0, ТолькоКэшРеквизиты = Ложь, ЕстьИзменения = Неопределено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	СвойстваВидовДоступа = УправлениеДоступомСлужебныйПовтИсп.СвойстваВидовДоступа();
	ЗначенияДоступаСГруппами = СвойстваВидовДоступа.ЗначенияДоступаСГруппами;
	
	Если УправлениеДоступом.ОграничиватьДоступНаУровнеЗаписей() И НЕ ТолькоКэшРеквизиты Тогда
		
		// Заполнение групп значений доступа в регистре сведений ГруппыЗначенийДоступа.
		Для Каждого ИмяТаблицы Из ЗначенияДоступаСГруппами.ИменаТаблицДляОбновления Цикл
			
			Если КоличествоДанных < 10000 Тогда
				
				Запрос = Новый Запрос;
				Запрос.Текст =
				"ВЫБРАТЬ ПЕРВЫЕ 10000
				|	ТекущаяТаблица.Ссылка КАК Ссылка
				|ИЗ
				|	&ТекущаяТаблица КАК ТекущаяТаблица
				|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				|		ПО ТекущаяТаблица.Ссылка = ГруппыЗначенийДоступа.ЗначениеДоступа
				|			И (ГруппыЗначенийДоступа.ГруппаДанных = 0)
				|ГДЕ
				|	ГруппыЗначенийДоступа.ЗначениеДоступа ЕСТЬ NULL ";
				
				Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ТекущаяТаблица", ИмяТаблицы);
				Значения = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
				
				РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппыЗначенийДоступа(Значения, ЕстьИзменения);
				
				КоличествоДанных = КоличествоДанных + Значения.Количество();
			КонецЕсли;
			
		КонецЦикла;
		
		Если КоличествоДанных < 10000 И Не ОграничиватьДоступНаУровнеЗаписейУниверсально(Ложь, Истина) Тогда
			
			// Заполнение регистра сведений НаборыЗначенийДоступа.
			ТипыОбъектов = УправлениеДоступомСлужебныйПовтИсп.ТипыОбъектовВПодпискахНаСобытия(
				"ЗаписатьНаборыЗначенийДоступа");
			
			Для каждого ОписаниеТипа Из ТипыОбъектов Цикл
				Тип = ОписаниеТипа.Ключ;
				
				Если КоличествоДанных < 10000 И Тип <> Тип("Строка") Тогда
				
					Запрос = Новый Запрос;
					Запрос.Текст =
					"ВЫБРАТЬ ПЕРВЫЕ 10000
					|	ТекущаяТаблица.Ссылка КАК Ссылка
					|ИЗ
					|	&ТекущаяТаблица КАК ТекущаяТаблица
					|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.НаборыЗначенийДоступа КАК РегистрСведенийНаборыЗначенийДоступа
					|		ПО ТекущаяТаблица.Ссылка = РегистрСведенийНаборыЗначенийДоступа.Объект
					|ГДЕ
					|	РегистрСведенийНаборыЗначенийДоступа.Объект ЕСТЬ NULL ";
					Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ТекущаяТаблица", Метаданные.НайтиПоТипу(Тип).ПолноеИмя());
					Выборка = Запрос.Выполнить().Выбрать();
					КоличествоДанных = КоличествоДанных + Выборка.Количество();
					
					Пока Выборка.Следующий() Цикл
						ОбновитьНаборыЗначенийДоступа(Выборка.Ссылка, ЕстьИзменения);
					КонецЦикла;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	// Обновление кэш-реквизитов в наборах значений доступа.
	Если КоличествоДанных < 10000 И Не ОграничиватьДоступНаУровнеЗаписейУниверсально(Ложь, Истина) Тогда
		
		ТипыЗначенийДоступа          = СвойстваВидовДоступа.ПоТипамЗначений;
		ТипыЗначенийДоступаСГруппами = СвойстваВидовДоступа.ТипыЗначенийДоступаСГруппами;
		
		ТаблицаТиповЗначений = Новый ТаблицаЗначений;
		ТаблицаТиповЗначений.Колонки.Добавить("ТипЗначений", Метаданные.ОпределяемыеТипы.ЗначениеДоступа.Тип);
		Для каждого КлючИЗначение Из ТипыЗначенийДоступа Цикл
			ТаблицаТиповЗначений.Добавить().ТипЗначений = ПустаяСсылкаОбъектаМетаданных(КлючИЗначение.Ключ);
		КонецЦикла;
		
		ТаблицаТиповЗначенийСГруппами = Новый ТаблицаЗначений;
		ТаблицаТиповЗначенийСГруппами.Колонки.Добавить("ТипЗначений", Метаданные.ОпределяемыеТипы.ЗначениеДоступа.Тип);
		Для каждого КлючИЗначение Из ТипыЗначенийДоступаСГруппами Цикл
			ТаблицаТиповЗначенийСГруппами.Добавить().ТипЗначений = ПустаяСсылкаОбъектаМетаданных(КлючИЗначение.Ключ);
		КонецЦикла;
		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ТаблицаТиповЗначений", ТаблицаТиповЗначений);
		Запрос.УстановитьПараметр("ТаблицаТиповЗначенийСГруппами", ТаблицаТиповЗначенийСГруппами);
		Запрос.Текст =
		"ВЫБРАТЬ
		|	ТаблицаТипов.ТипЗначений
		|ПОМЕСТИТЬ ТаблицаТиповЗначений
		|ИЗ
		|	&ТаблицаТиповЗначений КАК ТаблицаТипов
		|
		|ИНДЕКСИРОВАТЬ ПО
		|	ТаблицаТипов.ТипЗначений
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	ТаблицаТипов.ТипЗначений
		|ПОМЕСТИТЬ ТаблицаТиповЗначенийСГруппами
		|ИЗ
		|	&ТаблицаТиповЗначенийСГруппами КАК ТаблицаТипов
		|
		|ИНДЕКСИРОВАТЬ ПО
		|	ТаблицаТипов.ТипЗначений
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ ПЕРВЫЕ 10000
		|	НаборыЗначенийДоступа.Объект,
		|	НаборыЗначенийДоступа.НомерНабора,
		|	НаборыЗначенийДоступа.ЗначениеДоступа,
		|	НаборыЗначенийДоступа.Уточнение,
		|	НаборыЗначенийДоступа.Чтение,
		|	НаборыЗначенийДоступа.Изменение
		|ИЗ
		|	РегистрСведений.НаборыЗначенийДоступа КАК НаборыЗначенийДоступа
		|ГДЕ
		|	ВЫБОР
		|			КОГДА НаборыЗначенийДоступа.СтандартноеЗначение <> ИСТИНА В
		|					(ВЫБРАТЬ ПЕРВЫЕ 1
		|						ИСТИНА
		|					ИЗ
		|						ТаблицаТиповЗначений КАК ТаблицаТиповЗначений
		|					ГДЕ
		|						ТИПЗНАЧЕНИЯ(ТаблицаТиповЗначений.ТипЗначений) = ТИПЗНАЧЕНИЯ(НаборыЗначенийДоступа.ЗначениеДоступа))
		|				ТОГДА ИСТИНА
		|			КОГДА НаборыЗначенийДоступа.СтандартноеЗначение = ИСТИНА
		|				ТОГДА НаборыЗначенийДоступа.ЗначениеБезГрупп = ИСТИНА В
		|						(ВЫБРАТЬ ПЕРВЫЕ 1
		|							ИСТИНА
		|						ИЗ
		|							ТаблицаТиповЗначенийСГруппами КАК ТаблицаТиповЗначенийСГруппами
		|						ГДЕ
		|							ТИПЗНАЧЕНИЯ(ТаблицаТиповЗначенийСГруппами.ТипЗначений) = ТИПЗНАЧЕНИЯ(НаборыЗначенийДоступа.ЗначениеДоступа))
		|			ИНАЧЕ НаборыЗначенийДоступа.ЗначениеБезГрупп = ИСТИНА
		|		КОНЕЦ";
		Выборка = Запрос.Выполнить().Выбрать();
		КоличествоДанных = КоличествоДанных + Выборка.Количество();
		
		Пока Выборка.Следующий() Цикл
			МенеджерЗаписи = РегистрыСведений.НаборыЗначенийДоступа.СоздатьМенеджерЗаписи();
			ЗаполнитьЗначенияСвойств(МенеджерЗаписи, Выборка);
			
			ТипЗначенияДоступа = ТипЗнч(Выборка.ЗначениеДоступа);
			
			Если ТипыЗначенийДоступа.Получить(ТипЗначенияДоступа) <> Неопределено Тогда
				МенеджерЗаписи.СтандартноеЗначение = Истина;
				Если ТипыЗначенийДоступаСГруппами.Получить(ТипЗначенияДоступа) = Неопределено Тогда
					МенеджерЗаписи.ЗначениеБезГрупп = Истина;
				КонецЕсли;
			КонецЕсли;
			
			МенеджерЗаписи.Записать();
			ЕстьИзменения = Истина;
		КонецЦикла;
	КонецЕсли;
	
	Если КоличествоДанных < 10000 Тогда
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Управление доступом.Заполнение данных для ограничения доступа'",
				 ОбщегоНазначения.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Информация,
			,
			,
			НСтр("ru = 'Завершено заполнение данных для ограничения доступа.'"),
			РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная);
			
		УстановитьЗаполнениеДанныхДляОграниченияДоступа(Ложь);
	Иначе
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Управление доступом.Заполнение данных для ограничения доступа'",
				 ОбщегоНазначения.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Информация,
			,
			,
			НСтр("ru = 'Выполнена запись части данных для ограничения доступа.'"),
			РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная);
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает использование регламентного задания заполнения данных управления доступом.
//
// Параметры:
//   Использование - Булево - Истина, если задание нужно включить, иначе Ложь.
//
Процедура УстановитьЗаполнениеДанныхДляОграниченияДоступа(Знач Использование) Экспорт
	
	РегламентныеЗаданияСервер.УстановитьИспользованиеПредопределенногоРегламентногоЗадания(
		Метаданные.РегламентныеЗадания.ЗаполнениеДанныхДляОграниченияДоступа, Использование);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с видами доступа.

// Возвращает Истина, если вид доступа включен по функциональным опциям для всех сеансов.
//
// Параметры:
//  ВидДоступа - Ссылка - пустая ссылка основного типа.
//             - Строка - имя вида доступа.
//
// Возвращаемое значение:
//  Булево - 
//
Функция ВидДоступаИспользуется(Знач ВидДоступа) Экспорт
	
	Если Не УправлениеДоступом.ОграничиватьДоступНаУровнеЗаписей() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Используется = Ложь;
	
	СвойстваВидаДоступа = СвойстваВидаДоступа(ВидДоступа);
	Если СвойстваВидаДоступа = Неопределено Тогда
		Возврат Используется;
	КонецЕсли;
	
	Если СвойстваВидаДоступа.Имя = "ВнешниеПользователи"
	 Или СвойстваВидаДоступа.Имя = "Пользователи" Тогда
		// Эти виды доступа не могут быть отключены по функциональным опциям.
		Возврат Истина;
	КонецЕсли;
	
	Используется = Истина;
	
	ИнтеграцияПодсистемБСП.ПриЗаполненииИспользованияВидаДоступа(СвойстваВидаДоступа.Имя, Используется);
	УправлениеДоступомПереопределяемый.ПриЗаполненииИспользованияВидаДоступа(СвойстваВидаДоступа.Имя, Используется);
	
	Возврат Используется;
	
КонецФункции

// Возвращает свойства вида доступа или всех видов доступа.
//
// Параметры:
//  ВидДоступа - Ссылка - пустая ссылка основного типа;
//             - Строка - имя вида доступа;
//             - Неопределено - вернуть массив свойств всех видов доступа.
//
// Возвращаемое значение:
//  Неопределено - когда для вида доступа свойств не найдено.
//  Структура    - свойства найденного вида доступа, описание которых см. в
//                 комментарии к функции СвойстваВидовДоступа этого модуля.
//  Массив       - со значениями:
//    * Структура - со свойствами, как у структуры, указанной выше.
//
Функция СвойстваВидаДоступа(Знач ВидДоступа = Неопределено) Экспорт
	
	Свойства = УправлениеДоступомСлужебныйПовтИсп.СвойстваВидовДоступа();
	
	Если ВидДоступа = Неопределено Тогда
		Возврат Свойства.Массив;
	КонецЕсли;
	
	СвойстваВидаДоступа = Свойства.ПоИменам.Получить(ВидДоступа);
	
	Если СвойстваВидаДоступа = Неопределено Тогда
		СвойстваВидаДоступа = Свойства.ПоСсылкам.Получить(ВидДоступа);
	КонецЕсли;
	
	Возврат СвойстваВидаДоступа;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с наборами значений доступа.

// Возвращает новые наборы для заполнения табличной части.
Функция ПолучитьНаборыЗначенийДоступаТабличнойЧасти(Объект) Экспорт
	
	ТипЗначенияОбъект = ТипЗнч(Объект);
	
	Если Объект.Метаданные().ТабличныеЧасти.Найти("НаборыЗначенийДоступа") = Неопределено Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверные параметры.
			           |У объекта типа ""%1""
			           |не найдена табличная часть ""Наборы значений доступа"".'"),
			ТипЗначенияОбъект);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Таблица = УправлениеДоступом.ТаблицаНаборыЗначенийДоступа();
	
	Если НЕ УправлениеДоступом.ОграничиватьДоступНаУровнеЗаписей() Тогда
		Возврат Таблица;
	КонецЕсли;
	
	УправлениеДоступом.ЗаполнитьНаборыЗначенийДоступа(Объект, Таблица);
	
	УправлениеДоступом.ДобавитьНаборыЗначенийДоступа(
		Таблица, УправлениеДоступом.ТаблицаНаборыЗначенийДоступа(), Ложь, Истина);
	
	Возврат Таблица;
	
КонецФункции

// Выполняет обновление наборов значений доступа объекта, если они изменились.
// Наборы обновляются в табличной части (если используется) и
// в регистре сведений НаборыЗначенийДоступа.
//
// Параметры:
//  СсылкаИлиОбъект - СправочникСсылка, ДокументСсылка и другие типы ссылок или объектов - ссылка или объект,
//                    для которого заполняются наборы значений доступа.
//
//  ОбновлениеИБ    - Булево - если Истина, то необходимо выполнять запись данных,
//                            не выполняя лишних, избыточных действий с данными.
//                            См. ОбновлениеИнформационнойБазы.ЗаписатьДанные.
//
Процедура ОбновитьНаборыЗначенийДоступа(СсылкаИлиОбъект, ЕстьИзменения = Неопределено, ОбновлениеИБ = Ложь) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Объект = ?(СсылкаИлиОбъект = СсылкаИлиОбъект.Ссылка, СсылкаИлиОбъект.ПолучитьОбъект(), СсылкаИлиОбъект);
	СсылкаНаОбъект = Объект.Ссылка;
	ТипЗначенияОбъект = ТипЗнч(Объект);
	
	НаборыЗаписываются = УправлениеДоступомСлужебныйПовтИсп.ТипыОбъектовВПодпискахНаСобытия(
		"ЗаписатьНаборыЗначенийДоступа").Получить(ТипЗначенияОбъект) <> Неопределено;
	
	Если НЕ НаборыЗаписываются Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверные параметры.
			           |Тип объекта ""%1""
			           |не найден в подписке на события
			           |""Записать наборы значений доступа"".'"),
			ТипЗначенияОбъект);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Если Метаданные.РегистрыСведений.НаборыЗначенийДоступа.Измерения.Объект.Тип.Типы().Найти(ТипЗнч(СсылкаНаОбъект)) = Неопределено Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка при записи наборов значений доступа:
			           |в регистре сведений НаборыЗначенийДоступа в измерении Объект
			           |не задан тип %1'"),
			СсылкаНаОбъект.Метаданные().ПолноеИмя());
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Если СсылкаНаОбъект.Метаданные().ТабличныеЧасти.Найти("НаборыЗначенийДоступа") <> Неопределено Тогда
		// Обновление объекта требуется.
		Таблица = ПолучитьНаборыЗначенийДоступаТабличнойЧасти(Объект);
		
		Если НаборыЗначенийДоступаТабличнойЧастиИзменены(СсылкаНаОбъект, Таблица) Тогда
			ПодготовитьНаборыЗначенийДоступаКЗаписи(Неопределено, Таблица, Ложь);
			
			Объект.ДополнительныеСвойства.Вставить("ЗаписатьНаборыЗначенийДоступа");
			Объект.ДополнительныеСвойства.Вставить("ЗаписатьЗависимыеНаборыЗначенийДоступа");
			Объект.ДополнительныеСвойства.Вставить("НаборыЗначенийДоступаТабличнойЧастиЗаполнены");
			Объект.НаборыЗначенийДоступа.Загрузить(Таблица);
			Если ОбновлениеИБ Тогда
				Объект.ДополнительныеСвойства.Вставить("ЗаписьНаборовЗначенийДоступаПриОбновленииИБ");
				ОбновлениеИнформационнойБазы.ЗаписатьДанные(Объект);
			Иначе
				Объект.ОбменДанными.Загрузка = Истина;
				// АПК:1327-выкл - №783.1.4.1 Допустимо оставить запись без
				// предварительной управляемой блокировки объекта, так как только
				// для RLS в формате БСП 2.х (устарело) и ни разу не вызывало проблем.
				Объект.Записать();
				// АПК:1327-вкл.
			КонецЕсли;
			ЕстьИзменения = Истина;
		КонецЕсли;
	КонецЕсли;
	
	// Обновление объекта не требуется или объект уже обновлен.
	ЗаписатьНаборыЗначенийДоступа(Объект, ЕстьИзменения, ОбновлениеИБ);
	
КонецПроцедуры

// Заполняет вспомогательные данные, ускоряющие работу шаблонов ограничений доступа.
//  Выполняется перед записью в регистр НаборыЗначенийДоступа.
//
// Параметры:
//  СсылкаНаОбъект - СправочникСсылка.*, ДокументСсылка.*, ...
//  Таблица        - ТаблицаЗначений.
//
Процедура ПодготовитьНаборыЗначенийДоступаКЗаписи(СсылкаНаОбъект, Таблица, ДобавитьКэшРеквизиты = Ложь) Экспорт
	
	Если ДобавитьКэшРеквизиты Тогда
		
		Таблица.Колонки.Добавить("Объект", Метаданные.РегистрыСведений.НаборыЗначенийДоступа.Измерения.Объект.Тип);
		Таблица.Колонки.Добавить("СтандартноеЗначение", Новый ОписаниеТипов("Булево"));
		Таблица.Колонки.Добавить("ЗначениеБезГрупп", Новый ОписаниеТипов("Булево"));
		
		СвойстваВидовДоступа = УправлениеДоступомСлужебныйПовтИсп.СвойстваВидовДоступа();
		
		ТипыЗначенийДоступаСГруппами = СвойстваВидовДоступа.ТипыЗначенийДоступаСГруппами;
		ТипыЗначенийДоступа          = СвойстваВидовДоступа.ПоТипамЗначений;
	КонецЕсли;
	
	// Нормализация ресурсов Чтение, Изменение.
	НомерНабора = -1;
	Для каждого Строка Из Таблица Цикл
		
		Если ДобавитьКэшРеквизиты Тогда
			// Установка значения измерения Объект.
			Строка.Объект = СсылкаНаОбъект;
			
			ТипЗначенияДоступа = ТипЗнч(Строка.ЗначениеДоступа);
			
			Если ТипыЗначенийДоступа.Получить(ТипЗначенияДоступа) <> Неопределено Тогда
				Строка.СтандартноеЗначение = Истина;
				Если ТипыЗначенийДоступаСГруппами.Получить(ТипЗначенияДоступа) = Неопределено Тогда
					Строка.ЗначениеБезГрупп = Истина;
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
		
		// Очистка флажков прав и соответствующих им вторичных данных
		// для всех строк каждого набора, кроме первой строки.
		Если НомерНабора = Строка.НомерНабора Тогда
			Строка.Чтение    = Ложь;
			Строка.Изменение = Ложь;
		Иначе
			НомерНабора = Строка.НомерНабора;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для действий при изменений настроек подсистемы.

// Если необходимо, включает заполнение данных для ограничения доступа и
// обновляет некоторые данные сразу.
//
// Вызывается из обработчика ПриЗаписи константы ОграничиватьДоступаНаУровнеЗаписей.
//
Процедура ПриИзмененииОграниченияДоступаНаУровнеЗаписей(ОграничениеДоступаНаУровнеЗаписейВключено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ОграничениеДоступаНаУровнеЗаписейВключено Тогда
		
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Управление доступом.Заполнение данных для ограничения доступа'",
			     ОбщегоНазначения.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Информация,
			,
			,
			НСтр("ru = 'Начато заполнение данных для ограничения доступа.'"),
			РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная);
		
		УстановитьЗаполнениеДанныхДляОграниченияДоступа(Истина);
	КонецЕсли;
	
	ОбновитьПараметрыСеанса();
	
	УправлениеДоступом.ОбновитьРазрешенныеЗначенияПриИзмененииИспользованияВидовДоступа();
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обслуживание таблиц ВидыДоступа и ЗначенияДоступа в формах редактирования.

// Заполняет вспомогательные данные, требуемые для работы формы,
// которые не зависят от содержания объекта или заполняются для нового объекта.
//
// Форма должна содержать реквизиты, указанные ниже.
// Реквизиты отмеченные символом * заполняются автоматически, но их нужно создать в форме.
// Реквизиты отмеченные символом # должны быть созданы в форме, если
// в форме будет создан реквизит ТекущаяГруппаДоступа (см. ниже).
// Реквизиты отмеченные символом @ будут созданы автоматически.
//
//  ТекущаяГруппаДоступа - необязательный реквизит,
//                         если не создан в форме, тогда не используется.
//
//  ВидыДоступа - Таблица с полями:
//    #ГруппаДоступа              - СправочникСсылка.ГруппыДоступа,
//    ВидДоступа                  - ОпределяемыйТип.ЗначениеДоступа,
//    Предустановленный           - Булево (только для профиля),
//    ВсеРазрешены                - Булево,
//    *ВидДоступаПредставление    - Строка - представление настройки,
//    *ВсеРазрешеныПредставление  - Строка - представление настройки,
//    @Используется               - Булево.
//
//  ЗначенияДоступа - Таблица с полями:
//    #ГруппаДоступа     - СправочникСсылка.ГруппыДоступа,
//    *ВидДоступа        - ОпределяемыйТип.ЗначениеДоступа,
//    ЗначениеДоступа    - ОпределяемыйТип.ЗначениеДоступа,
//    *НомерСтрокиПоВиду - Число.
//
//  *ИспользоватьВнешнихПользователей     - Булево - реквизит будет создан, если нет в форме.
//  *НадписьВидДоступа                    - Строка - представление текущего вида доступа в форме.
//  @ЭтоПрофильГруппДоступа               - Булево.
//  @ТекущийВидДоступа                    - ОпределяемыйТип.ЗначениеДоступа.
//  @ТекущиеТипыВыбираемыхЗначений        - СписокЗначений.
//  @ТекущийТипВыбираемыхЗначений         - ОпределяемыйТип.ЗначениеДоступа.
//  @ИмяРеквизитаХранилищаТаблиц          - Строка.
//  @ВидДоступаПользователи               - ОпределяемыйТип.ЗначениеДоступа.
//  @ВидДоступаВнешниеПользователи        - ОпределяемыйТип.ЗначениеДоступа.
//  
//  @ВсеВидыДоступа - Таблица с полями:
//    @Ссылка        - ОпределяемыйТип.ЗначениеДоступа,
//    @Представление - Строка,
//    @Используется  - Булево.
//
//  @ПредставленияВсеРазрешены - Таблица с полями:
//    @Имя           - Строка,
//    @Представление - Строка.
//
//  @ВсеТипыВыбираемыхЗначений - Таблица с полями:
//    @ВидДоступа        - ОпределяемыйТип.ЗначениеДоступа,
//    @ТипЗначений       - ОпределяемыйТип.ЗначениеДоступа,
//    @ПредставлениеТипа - Строка,
//    @ИмяТаблицы        - Строка,
//    @ИерархияЭлементов - Булево.
//
// Параметры:
//  Форма      - ФормаКлиентскогоПриложения, которую требуется настроить для
//               редактирования разрешенных значений.
//
//  ЭтоПрофиль - Булево - указывает, что возможна настройка видов доступа
//               в том числе представление настройки содержит 4 значения, а не 2.
//
//  ИмяРеквизитаХранилищаТаблиц - Строка, содержащая, например, строку "Объект", которая
//               содержит таблицы ВидыДоступа и ЗначенияДоступа (см. ниже).
//               Если указана пустая строка, тогда считается,
//               что таблицы хранятся в реквизитах формы.
//
Процедура ПриСозданииНаСервереФормыРедактированияРазрешенныхЗначений(Форма, ЭтоПрофиль = Ложь, ИмяРеквизитаХранилищаТаблиц = "Объект") Экспорт
	
	ДобавитьРеквизитыВспомогательныхДанныхВФорму(Форма, ИмяРеквизитаХранилищаТаблиц);
	
	Форма.ИмяРеквизитаХранилищаТаблиц = ИмяРеквизитаХранилищаТаблиц;
	Форма.ЭтоПрофильГруппДоступа = ЭтоПрофиль;
	
	СвойстваВидовДоступа = УправлениеДоступомСлужебныйПовтИсп.СвойстваВидовДоступа();
	
	// Заполнение типов значений доступа всех видов доступа.
	Для каждого СвойстваВидаДоступа Из СвойстваВидаДоступа() Цикл
		Для каждого Тип Из СвойстваВидаДоступа.ТипыВыбираемыхЗначений Цикл
			МассивТипов = Новый Массив;
			МассивТипов.Добавить(Тип);
			ОписаниеТипа = Новый ОписаниеТипов(МассивТипов);
			
			МетаданныеТипа = Метаданные.НайтиПоТипу(Тип);
			Если Метаданные.Перечисления.Найти(МетаданныеТипа.Имя) = МетаданныеТипа Тогда
				ПредставлениеТипа = МетаданныеТипа.Представление();
			Иначе
				ПредставлениеТипа = ?(ЗначениеЗаполнено(МетаданныеТипа.ПредставлениеОбъекта),
					МетаданныеТипа.ПредставлениеОбъекта,
					МетаданныеТипа.Представление());
			КонецЕсли;
			
			НоваяСтрока = Форма.ВсеТипыВыбираемыхЗначений.Добавить();
			НоваяСтрока.ВидДоступа        = СвойстваВидаДоступа.Ссылка;
			НоваяСтрока.ТипЗначений       = ОписаниеТипа.ПривестиЗначение(Неопределено);
			НоваяСтрока.ПредставлениеТипа = ПредставлениеТипа;
			НоваяСтрока.ИмяТаблицы        = МетаданныеТипа.ПолноеИмя();
			НоваяСтрока.ИерархияЭлементов = СвойстваВидовДоступа.ПоТипамЗначенийСИерархией.Получить(Тип) <> Неопределено;
		КонецЦикла;
	КонецЦикла;
	
	Форма.ВидДоступаПользователи           = Справочники.Пользователи.ПустаяСсылка();
	Форма.ВидДоступаВнешниеПользователи    = Справочники.ВнешниеПользователи.ПустаяСсылка();
	Форма.ИспользоватьВнешнихПользователей = ВнешниеПользователи.ИспользоватьВнешнихПользователей();
	
	ЗаполнитьТаблицуВсеВидыДоступаВФорме(Форма);
	
	ЗаполнитьТаблицуПредставленияВсеРазрешеныВФорме(Форма, ЭтоПрофиль);
	
	ОформитьТаблицуВидыДоступаВФорме(Форма);
	
	УдалитьНесуществующиеВидыИЗначенияДоступа(Форма);
	УправлениеДоступомСлужебныйКлиентСервер.ЗаполнитьСвойстваВидовДоступаВФорме(Форма);
	
	ОбновитьОтображениеНеиспользуемыхВидовДоступа(Форма, Истина);
	
	// Настройка параметров выбора значения доступа.
	ПараметрыВыбора = Новый Массив;
	ПараметрыВыбора.Добавить(Новый ПараметрВыбора("ЭтоВыборЗначенияДоступа", Истина));
	Форма.Элементы.ЗначенияДоступаЗначениеДоступа.ПараметрыВыбора = Новый ФиксированныйМассив(ПараметрыВыбора);
	
КонецПроцедуры

// При повторном чтении заполняет или обновляет вспомогательные данные,
// требуемые для работы формы, которые зависят от содержания объекта.
//
Процедура ПриПовторномЧтенииНаСервереФормыРедактированияРазрешенныхЗначений(Форма, ТекущийОбъект) Экспорт
	
	УдалитьНесуществующиеВидыИЗначенияДоступа(Форма, ТекущийОбъект);
	УдалитьНесуществующиеВидыИЗначенияДоступа(Форма);
	
	УправлениеДоступомСлужебныйКлиентСервер.ЗаполнитьСвойстваВидовДоступаВФорме(Форма);
	
	УправлениеДоступомСлужебныйКлиентСервер.ПриИзмененииТекущегоВидаДоступа(Форма, Ложь);
	
КонецПроцедуры

// Удаляет лишние значения доступа перед записью.
// Лишние значения доступа могут появиться, если заменить или удалить вид доступа,
// для которого введены значения доступа.
//
Процедура ПередЗаписьюНаСервереФормыРедактированияРазрешенныхЗначений(Форма, ТекущийОбъект) Экспорт
	
	УдалитьЛишниеЗначенияДоступа(Форма, ТекущийОбъект);
	УдалитьЛишниеЗначенияДоступа(Форма);
	
КонецПроцедуры

// Обновляет свойства видов доступа.
Процедура ПослеЗаписиНаСервереФормыРедактированияРазрешенныхЗначений(Форма, ТекущийОбъект, ПараметрыЗаписи) Экспорт
	
	УправлениеДоступомСлужебныйКлиентСервер.ЗаполнитьСвойстваВидовДоступаВФорме(Форма);
	
КонецПроцедуры

// Скрывает или показывает неиспользуемые виды доступа.
Процедура ОбновитьОтображениеНеиспользуемыхВидовДоступа(Форма, ПриСозданииНаСервере = Ложь) Экспорт
	
	Элементы = Форма.Элементы;
	
	Если Не ПриСозданииНаСервере Тогда
		Элементы.ПоказыватьНеИспользуемыеВидыДоступа.Пометка =
			НЕ Элементы.ПоказыватьНеИспользуемыеВидыДоступа.Пометка;
	КонецЕсли;
	
	Отбор = УправлениеДоступомСлужебныйКлиентСервер.ОтборВТаблицахФормыРедактированияРазрешенныхЗначений(
		Форма);
	
	Если Не Элементы.ПоказыватьНеиспользуемыеВидыДоступа.Пометка Тогда
		Отбор.Вставить("Используется", Истина);
	КонецЕсли;
	
	Элементы.ВидыДоступа.ОтборСтрок = Новый ФиксированнаяСтруктура(Отбор);
	
	Элементы.ВидыДоступаВидДоступаПредставление.СписокВыбора.Очистить();
	
	Для каждого Строка Из Форма.ВсеВидыДоступа Цикл
		
		Если Не Элементы.ПоказыватьНеиспользуемыеВидыДоступа.Пометка
		   И Не Строка.Используется Тогда
			
			Продолжить;
		КонецЕсли;
		
		Элементы.ВидыДоступаВидДоступаПредставление.СписокВыбора.Добавить(Строка.Представление);
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Универсальные процедуры и функции.

// Только для внутреннего использования.
Процедура УстановитьУсловиеОтбораВЗапросе(Знач Запрос, Знач Значения, Знач ИмяПараметраЗначений, Знач ИмяПараметраУсловияОтбораИмяПоля) Экспорт
	
	Если Значения = Неопределено Тогда
		
	ИначеЕсли ТипЗнч(Значения) <> Тип("Массив")
	        И ТипЗнч(Значения) <> Тип("ФиксированныйМассив") Тогда
		
		Запрос.УстановитьПараметр(ИмяПараметраЗначений, Значения);
		
	ИначеЕсли Значения.Количество() = 1 Тогда
		Запрос.УстановитьПараметр(ИмяПараметраЗначений, Значения[0]);
	Иначе
		Запрос.УстановитьПараметр(ИмяПараметраЗначений, Значения);
	КонецЕсли;
	
	Для НомерСтроки = 1 По СтрЧислоСтрок(ИмяПараметраУсловияОтбораИмяПоля) Цикл
		ТекущаяСтрока = СтрПолучитьСтроку(ИмяПараметраУсловияОтбораИмяПоля, НомерСтроки);
		Если НЕ ЗначениеЗаполнено(ТекущаяСтрока) Тогда
			Продолжить;
		КонецЕсли;
		ИндексРазделителя = СтрНайти(ТекущаяСтрока, ":");
		Если ИндексРазделителя = 0 Тогда
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка при выполнении процедуры УправлениеДоступом.УстановитьУсловиеОтбораВЗапросе().
				           |
				           |В параметре ИмяПараметраУсловияОтбораИмяПоля не найден разделитель (двоеточие)
				           |в следующей строке формата ""<Имя параметра условия>:<Имя поля>""
				           |""%1"".'"),
				ТекущаяСтрока);
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
		ИмяПараметраУсловияОтбора = Лев(ТекущаяСтрока, ИндексРазделителя-1);
		ИмяПоля = Сред(ТекущаяСтрока, ИндексРазделителя+1);
		Если Значения = Неопределено Тогда
			УсловиеОтбора = "Истина";
			
		ИначеЕсли ТипЗнч(Значения) <> Тип("Массив")
		        И ТипЗнч(Значения) <> Тип("ФиксированныйМассив") Тогда
			
			УсловиеОтбора = ИмяПоля + " = &" + ИмяПараметраЗначений;
			
		ИначеЕсли Значения.Количество() = 1 Тогда
			УсловиеОтбора = ИмяПоля + " = &" + ИмяПараметраЗначений;
		Иначе
			УсловиеОтбора = ИмяПоля + " В (&" + ИмяПараметраЗначений + ")";
		КонецЕсли;
		Запрос.Текст = СтрЗаменить(Запрос.Текст, ИмяПараметраУсловияОтбора, УсловиеОтбора);
	КонецЦикла;
	
КонецПроцедуры

// Обновляет набор записей в базе данных,
// если записи набора отличаются от записей в базе данных.
//
// Параметры:
//  Данные - Структура - со свойствами:
//    * НаборЗаписей           - НаборЗаписей пустой или прочитанный с заданным отбором или без отбора.
//                              Менеджер регистра для создания набора записей.
//
//    * НовыеЗаписи            - ТаблицаЗначений в формате регистра.
//
//    * ПоляСравнения          - Строка - содержит список полей по значениям которых требуется вычислять
//                               отличие записей набора. Например, "Измерение1, Измерение2, Ресурс1",
//                               а реквизит ДатаИзмерения не входит в список.
//
//    * ПолеОтбора             - Неопределено - записывается весь регистр или
//                                              отбор уже задан в наборе записей.
//                               Строка       - имя поля по которому нужно установить отбор.
//
//    * ЗначениеОтбора         - значение, которое будет установлено в качестве отбора по полю отбора,
//                               если поле отбора задано.
//
//    * НаборЗаписейПрочитан   - Булево, если Истина, тогда не заданный набор записей уже содержит
//                               прочитанные записи блокировка данных этих записей установлена и
//                               транзакция открыта.
//
//    * ТолькоПроверка         - Булево - если Истина, тогда не выполнять запись,
//                               а лишь выявить необходимость записи и установить
//                               свойство ЕстьИзменения.
//
//    * ДополнительныеСвойства - Неопределено, Структура. Если Структура, тогда в
//                               объекты <Регистр*>НаборЗаписей в свойство ДополнительныеСвойства
//                               будут вставлены все параметры структуры.
//
//    * ОбновлениеИБ           - Булево - если Истина, то необходимо выполнять запись данных,
//                               не выполняя лишних, избыточных действий с данными.
//                               См. ОбновлениеИнформационнойБазы.ЗаписатьДанные.
//                               Если свойство не вставлено, то значение вычисляется по "Или" с помощью функций
//                               ВыполняетсяОбновлениеИнформационнойБазы и ЭтоВызовИзОбработчикаОбновления
//                               общего модуля ОбновлениеИнформационнойБазы.
//
//  ЕстьИзменения         - Булево - (возвращаемое значение) - если производилась запись,
//                          устанавливается Истина, иначе не изменяется.
//
//  ИзмененныеЗаписи      - Неопределено - никаких действий, иначе
//                          возвращает таблицу значений в формате регистра с полем ВидИзмененияСтроки
//                          типа Число (-1 запись удалена, 1 запись добавлена).
//
Процедура ОбновитьНаборЗаписей(Знач Данные, ЕстьИзменения = Неопределено, ИзмененныеЗаписи = Неопределено) Экспорт
	
	ВсеПараметры = Новый Структура;
	ВсеПараметры.Вставить("НаборЗаписей");
	ВсеПараметры.Вставить("НовыеЗаписи");
	ВсеПараметры.Вставить("ПоляСравнения");
	ВсеПараметры.Вставить("ПолеОтбора");
	ВсеПараметры.Вставить("ЗначениеОтбора");
	ВсеПараметры.Вставить("НаборЗаписейПрочитан", Ложь);
	ВсеПараметры.Вставить("БезПерезаписи", Ложь);
	ВсеПараметры.Вставить("ТолькоПроверка", Ложь);
	ВсеПараметры.Вставить("ДополнительныеСвойства");
	ВсеПараметры.Вставить("ОбновлениеИБ",
		    ОбновлениеИнформационнойБазы.ВыполняетсяОбновлениеИнформационнойБазы()
		Или ОбновлениеИнформационнойБазы.ЭтоВызовИзОбработчикаОбновления());
	
	ЗаполнитьПараметры(Данные, ВсеПараметры, "НаборЗаписей, НовыеЗаписи");
	
	ПолноеИмяРегистра = Метаданные.НайтиПоТипу(ТипЗнч(Данные.НаборЗаписей)).ПолноеИмя();
	МенеджерРегистра = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмяРегистра);
	Если Данные.НаборЗаписей = МенеджерРегистра Тогда
		Данные.НаборЗаписей = МенеджерРегистра.СоздатьНаборЗаписей();
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Данные.ПолеОтбора) Тогда
		УстановитьОтбор(Данные.НаборЗаписей.Отбор[Данные.ПолеОтбора], Данные.ЗначениеОтбора);
	КонецЕсли;
	
	Если НЕ Данные.НаборЗаписейПрочитан Тогда
		ЗаблокироватьОбластьНабораЗаписей(Данные.НаборЗаписей, ПолноеИмяРегистра);
		Данные.НаборЗаписей.Прочитать();
	КонецЕсли;
	
	Данные.ПоляСравнения = ?(Данные.ПоляСравнения = Неопределено,
		ПоляНабораЗаписей(Данные.НаборЗаписей), Данные.ПоляСравнения);
	
	Если Данные.БезПерезаписи Тогда
		НаборЗаписи = МенеджерРегистра.СоздатьНаборЗаписей();
		ОписаниеКлючаЗаписи = УправлениеДоступомСлужебныйПовтИсп.ОписаниеКлючаЗаписи(ПолноеИмяРегистра);
		ОтборЗаписи = Новый Структура(ОписаниеКлючаЗаписи.СтрокаПолей);
		ПоляОстальныхИзмерений = Новый Массив;
		Для каждого Поле Из ОписаниеКлючаЗаписи.МассивПолей Цикл
			Если Поле <> Данные.ПолеОтбора Тогда
				ПоляОстальныхИзмерений.Добавить(Поле);
			КонецЕсли;
		КонецЦикла;
		УдаляемыеЗаписи = Новый ТаблицаЗначений;
		Для каждого Поле Из ПоляОстальныхИзмерений Цикл
			УдаляемыеЗаписи.Колонки.Добавить(Поле);
		КонецЦикла;
		Данные.НовыеЗаписи = Данные.НовыеЗаписи.Скопировать();
	КонецЕсли;
	
	ЕстьТекущиеИзменения = Ложь;
	Если ИзмененныеЗаписи = Неопределено Тогда
		Если Данные.НаборЗаписей.Количество() = Данные.НовыеЗаписи.Количество() ИЛИ Данные.БезПерезаписи Тогда
			Отбор = Новый Структура(Данные.ПоляСравнения);
			Данные.НовыеЗаписи.Индексы.Добавить(Данные.ПоляСравнения);
			Для каждого Запись Из Данные.НаборЗаписей Цикл
				ЗаполнитьЗначенияСвойств(Отбор, Запись);
				НайденныеСтроки = Данные.НовыеЗаписи.НайтиСтроки(Отбор);
				Если НайденныеСтроки.Количество() = 0 Тогда
					ЕстьТекущиеИзменения = Истина;
					ЕстьИзменения = Истина;
					Если Данные.БезПерезаписи Тогда
						ЗаполнитьЗначенияСвойств(ОтборЗаписи, Запись);
						Если Данные.НовыеЗаписи.НайтиСтроки(ОтборЗаписи).Количество() = 0 Тогда
							ЗаполнитьЗначенияСвойств(УдаляемыеЗаписи.Добавить(), ОтборЗаписи);
						КонецЕсли;
					Иначе
						Прервать;
					КонецЕсли;
				ИначеЕсли Данные.БезПерезаписи Тогда
					Данные.НовыеЗаписи.Удалить(НайденныеСтроки[0]);
				КонецЕсли;
			КонецЦикла;
			Если Данные.БезПерезаписи И Данные.НовыеЗаписи.Количество() > 0 Тогда
				ЕстьТекущиеИзменения = Истина;
				ЕстьИзменения = Истина;
			КонецЕсли;
		Иначе
			ЕстьТекущиеИзменения = Истина;
			ЕстьИзменения = Истина;
		КонецЕсли;
	Иначе
		Если Данные.НаборЗаписей.Количество() <> Данные.НовыеЗаписи.Количество() Тогда
			ЕстьТекущиеИзменения = Истина;
			ЕстьИзменения = Истина;
		КонецЕсли;
		Если Данные.НаборЗаписей.Количество() > Данные.НовыеЗаписи.Количество() Тогда
			ИзмененныеЗаписи = Данные.НаборЗаписей.Выгрузить();
			ИскомыеЗаписи   = Данные.НовыеЗаписи;
			ВидИзмененияСтроки = -1;
		Иначе
			ИзмененныеЗаписи = Данные.НовыеЗаписи.Скопировать();
			ИскомыеЗаписи   = Данные.НаборЗаписей.Выгрузить();
			ВидИзмененияСтроки = 1;
		КонецЕсли;
		ИзмененныеЗаписи.Колонки.Добавить("ВидИзмененияСтроки", Новый ОписаниеТипов("Число"));
		ИзмененныеЗаписи.ЗаполнитьЗначения(ВидИзмененияСтроки, "ВидИзмененияСтроки");
		ВидИзмененияСтроки = ?(ВидИзмененияСтроки = 1, -1, 1);
		Отбор = Новый Структура(Данные.ПоляСравнения);
		
		Для каждого Строка Из ИскомыеЗаписи Цикл
			ЗаполнитьЗначенияСвойств(Отбор, Строка);
			Строки = ИзмененныеЗаписи.НайтиСтроки(Отбор);
			Если Строки.Количество() = 0 Тогда
				НоваяСтрока = ИзмененныеЗаписи.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока, Отбор);
				НоваяСтрока.ВидИзмененияСтроки = ВидИзмененияСтроки;
				ЕстьТекущиеИзменения = Истина;
				ЕстьИзменения = Истина;
			Иначе
				ИзмененныеЗаписи.Удалить(Строки[0]);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если ЕстьТекущиеИзменения Тогда
		Если Данные.ТолькоПроверка Тогда
			Возврат;
		КонецЕсли;
		Если Данные.БезПерезаписи Тогда
			УстановитьДополнительныеСвойства(НаборЗаписи, Данные.ДополнительныеСвойства);
			Для каждого Строка Из УдаляемыеЗаписи Цикл
				Если ЗначениеЗаполнено(Данные.ПолеОтбора) Тогда
					УстановитьОтбор(НаборЗаписи.Отбор[Данные.ПолеОтбора], Данные.ЗначениеОтбора);
				КонецЕсли;
				Для каждого Поле Из ПоляОстальныхИзмерений Цикл
					УстановитьОтбор(НаборЗаписи.Отбор[Поле], Строка[Поле]);
				КонецЦикла;
				ЗаписатьОбъектИлиНаборЗаписей(Данные, НаборЗаписи);
			КонецЦикла;
			НаборЗаписи.Добавить();
			Для каждого Строка Из Данные.НовыеЗаписи Цикл
				Если ЗначениеЗаполнено(Данные.ПолеОтбора) Тогда
					УстановитьОтбор(НаборЗаписи.Отбор[Данные.ПолеОтбора], Данные.ЗначениеОтбора);
				КонецЕсли;
				Для каждого Поле Из ПоляОстальныхИзмерений Цикл
					УстановитьОтбор(НаборЗаписи.Отбор[Поле], Строка[Поле]);
				КонецЦикла;
				ЗаполнитьЗначенияСвойств(НаборЗаписи[0], Строка);
				ЗаписатьОбъектИлиНаборЗаписей(Данные, НаборЗаписи);
			КонецЦикла;
		Иначе
			УстановитьДополнительныеСвойства(Данные.НаборЗаписей, Данные.ДополнительныеСвойства);
			Данные.НаборЗаписей.Загрузить(Данные.НовыеЗаписи);
			ЗаписатьОбъектИлиНаборЗаписей(Данные, Данные.НаборЗаписей);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Обновляет строки регистра с отбором по нескольким значениям для одного или
// для двух измерений регистра, выполняется проверка наличия изменений,
// если изменений нет, перезапись не производится.
//
// Параметры:
//  Данные - Структура - со свойствами:
//    * МенеджерРегистра          - Менеджер регистра для создания типа <Регистр*>НаборЗаписей.
//
//    * НовыеЗаписи               - ТаблицаЗначений в формате регистра.
//
//    * ПоляСравнения             - Строка - содержит список полей по значениям которых требуется
//                                  вычислять отличие записей набора, например, "Измерение1, Измерение2,
//                                  Ресурс1", а реквизит ДатаИзменения не входит в список.
//
//    * ИмяПервогоИзмерения       - Неопределено - нет отбора по измерению.
//                                  Строка       - содержит имя первого измерения, для которого задано
//                                                 несколько значений.
//
//    * ЗначенияПервогоИзмерения  - Неопределено - нет отбора по измерению, аналогично,
//                                                 ИмяПервогоИзмерения = Неопределено.
//                                  ЛюбаяСсылка  - содержит одно значение отбора регистра для
//                                                 обновляемых записей.
//                                  Массив       - содержит массив значений отбора регистра для
//                                                 обновляемых записей, пустой массив - значит
//                                                 действий не требуется.
//
//    * ИмяВторогоИзмерения       - аналогично ИмяПервогоИзмерения.
//    * ЗначенияВторогоИзмерения  - аналогично ЗначенияПервогоИзмерения.
//    * ИмяТретьегоИзмерения      - аналогично ИмяПервогоИзмерения.
//    * ЗначенияТретьегоИзмерения - аналогично ЗначенияПервогоИзмерения.
//
//    * ТолькоПроверка            - Булево - если Истина, тогда не выполнять запись,
//                                  а лишь выявить необходимость записи и установить
//                                  свойство ЕстьИзменения.
//
//    * ДополнительныеСвойства    - Неопределено, Структура. Если Структура, тогда в
//                                  объекты <Регистр*>НаборЗаписей в свойство
//                                  ДополнительныеСвойства будут вставлены все параметры структуры.
//
//    * ОбновлениеИБ              - Булево - если Истина, то необходимо выполнять запись данных,
//                                  не выполняя лишних, избыточных действий с данными.
//                                  См. ОбновлениеИнформационнойБазы.ЗаписатьДанные.
//                                  Если свойство не вставлено, то значение вычисляется по "Или" с помощью функций
//                                  ВыполняетсяОбновлениеИнформационнойБазы и ЭтоВызовИзОбработчикаОбновления
//                                  общего модуля ОбновлениеИнформационнойБазы.
//
//  ЕстьИзменения             - Булево - (возвращаемое значение) - если производилась запись,
//                              устанавливается Истина, иначе не изменяется.
//
Процедура ОбновитьНаборыЗаписей(Знач Данные, ЕстьИзменения) Экспорт
	
	ВсеПараметры = Новый Структура;
	ВсеПараметры.Вставить("МенеджерРегистра");
	ВсеПараметры.Вставить("НовыеЗаписи");
	ВсеПараметры.Вставить("ПоляСравнения");
	ВсеПараметры.Вставить("ИмяПервогоИзмерения");
	ВсеПараметры.Вставить("ЗначенияПервогоИзмерения");
	ВсеПараметры.Вставить("ИмяВторогоИзмерения");
	ВсеПараметры.Вставить("ЗначенияВторогоИзмерения");
	ВсеПараметры.Вставить("ИмяТретьегоИзмерения");
	ВсеПараметры.Вставить("ЗначенияТретьегоИзмерения");
	ВсеПараметры.Вставить("НовыеЗаписиСодержатТолькоРазличия", Ложь);
	ВсеПараметры.Вставить("ФиксированныйОтбор");
	ВсеПараметры.Вставить("ТолькоПроверка", Ложь);
	ВсеПараметры.Вставить("ДополнительныеСвойства");
	ВсеПараметры.Вставить("ОбновлениеИБ",
		    ОбновлениеИнформационнойБазы.ВыполняетсяОбновлениеИнформационнойБазы()
		Или ОбновлениеИнформационнойБазы.ЭтоВызовИзОбработчикаОбновления());
	
	ЗаполнитьПараметры(Данные, ВсеПараметры, "МенеджерРегистра, НовыеЗаписи");
	
	// Предварительная обработка параметров.
	
	Если НЕ ГруппаПараметровИзмеренияОбработана(Данные.ИмяПервогоИзмерения, Данные.ЗначенияПервогоИзмерения) Тогда
		ЕстьИзменения = Истина;
		Возврат;
	КонецЕсли;
	Если НЕ ГруппаПараметровИзмеренияОбработана(Данные.ИмяВторогоИзмерения, Данные.ЗначенияВторогоИзмерения) Тогда
		ЕстьИзменения = Истина;
		Возврат;
	КонецЕсли;
	Если НЕ ГруппаПараметровИзмеренияОбработана(Данные.ИмяТретьегоИзмерения, Данные.ЗначенияТретьегоИзмерения) Тогда
		ЕстьИзменения = Истина;
		Возврат;
	КонецЕсли;
	
	УпорядочитьГруппыПараметровИзмерений(Данные);
	
	// Проверка и обновление данных.
	Данные.Вставить("НаборЗаписей",       Данные.МенеджерРегистра.СоздатьНаборЗаписей());
	Данные.Вставить("МетаданныеРегистра", Метаданные.НайтиПоТипу(ТипЗнч(Данные.НаборЗаписей)));
	Данные.Вставить("ПолноеИмяРегистра",  Данные.МетаданныеРегистра.ПолноеИмя());
	
	Если Данные.НовыеЗаписиСодержатТолькоРазличия Тогда
		Данные.Вставить("НаборДляОднойЗаписи", Данные.МенеджерРегистра.СоздатьНаборЗаписей());
	КонецЕсли;
	
	Если Данные.ФиксированныйОтбор <> Неопределено Тогда
		Для каждого КлючИЗначение Из Данные.ФиксированныйОтбор Цикл
			УстановитьОтбор(Данные.НаборЗаписей.Отбор[КлючИЗначение.Ключ], КлючИЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Если Данные.НовыеЗаписиСодержатТолькоРазличия Тогда
		
		Если Данные.ИмяПервогоИзмерения = Неопределено Тогда
			ТекстОшибки = НСтр("ru = 'Некорректные параметры в процедуре ОбновитьНаборыЗаписей.'");
			ВызватьИсключение ТекстОшибки;
		Иначе
			Если Данные.ИмяВторогоИзмерения = Неопределено Тогда
				ЗаписьНесколькимиНаборами = Ложь;
			Иначе
				ЗаписьНесколькимиНаборами = ЗаписьНесколькимиНаборами(
					Данные, Новый Структура, Данные.ИмяПервогоИзмерения, Данные.ЗначенияПервогоИзмерения);
			КонецЕсли;
			
			Если ЗаписьНесколькимиНаборами Тогда
				СписокПолей = Данные.ИмяПервогоИзмерения + ", " + Данные.ИмяВторогоИзмерения;
				Данные.НовыеЗаписи.Индексы.Добавить(СписокПолей);
				
				КоличествоПоЗначениямПервогоИзмерения = Данные.КоличествоПоЗначениям;
				
				Для каждого ПервоеЗначение Из Данные.ЗначенияПервогоИзмерения Цикл
					Отбор = Новый Структура(Данные.ИмяПервогоИзмерения, ПервоеЗначение);
					УстановитьОтбор(Данные.НаборЗаписей.Отбор[Данные.ИмяПервогоИзмерения], ПервоеЗначение);
					
					Если Данные.ИмяТретьегоИзмерения = Неопределено Тогда
						ЗаписьНесколькимиНаборами = Ложь;
					Иначе
						ЗаписьНесколькимиНаборами = ЗаписьНесколькимиНаборами(
							Данные, Отбор, Данные.ИмяВторогоИзмерения, Данные.ЗначенияВторогоИзмерения);
					КонецЕсли;
					
					Если ЗаписьНесколькимиНаборами Тогда
						Для каждого ВтороеЗначение Из Данные.ЗначенияВторогоИзмерения Цикл
							Отбор.Вставить(Данные.ИмяВторогоИзмерения, ВтороеЗначение);
							УстановитьОтбор(Данные.НаборЗаписей.Отбор[Данные.ИмяВторогоИзмерения], ВтороеЗначение);
							
							// Обновление по трем измерениям.
							ОбновитьНовыеЗаписиНабораПоРазличнымНовымЗаписям(Данные, Отбор, ЕстьИзменения);
						КонецЦикла;
						Данные.НаборЗаписей.Отбор[Данные.ИмяВторогоИзмерения].Использование = Ложь;
					Иначе
						// Обновление по двум измерениям.
						Данные.Вставить("КоличествоПоЗначениям", КоличествоПоЗначениямПервогоИзмерения);
						ОбновитьНовыеЗаписиНабораПоРазличнымНовымЗаписям(Данные, Отбор, ЕстьИзменения);
					КонецЕсли;
				КонецЦикла;
			Иначе
				// Обновление по одному измерению.
				ПрочитатьКоличествоДляЧтения(Данные);
				ОбновитьНовыеЗаписиНабораПоРазличнымНовымЗаписям(Данные, Новый Структура, ЕстьИзменения);
			КонецЕсли;
		КонецЕсли;
	Иначе
		Если Данные.ИмяПервогоИзмерения = Неопределено Тогда
			// Обновление всех записей.
			
			ТекущиеДанные = Новый Структура("НаборЗаписей, НовыеЗаписи, ПоляСравнения,
				|ТолькоПроверка, ДополнительныеСвойства, ОбновлениеИБ");
			ЗаполнитьЗначенияСвойств(ТекущиеДанные, Данные);
			ОбновитьНаборЗаписей(ТекущиеДанные, ЕстьИзменения);
			
		ИначеЕсли Данные.ИмяВторогоИзмерения = Неопределено Тогда
			// Обновление по одному измерению.
			Отбор = Новый Структура(Данные.ИмяПервогоИзмерения);
			Для каждого Значение Из Данные.ЗначенияПервогоИзмерения Цикл
				
				УстановитьОтбор(Данные.НаборЗаписей.Отбор[Данные.ИмяПервогоИзмерения], Значение);
				Отбор[Данные.ИмяПервогоИзмерения] = Значение;
				
				Если Данные.ЗначенияПервогоИзмерения.Количество() <> 1 Тогда
					НовыеЗаписиНабора = Данные.НовыеЗаписи;
				Иначе
					НовыеЗаписиНабора = Данные.НовыеЗаписи.Скопировать(Отбор);
				КонецЕсли;
				
				ТекущиеДанные = Новый Структура("НаборЗаписей, ПоляСравнения,
					|ТолькоПроверка, ДополнительныеСвойства, ОбновлениеИБ");
				ЗаполнитьЗначенияСвойств(ТекущиеДанные, Данные);
				ТекущиеДанные.Вставить("НовыеЗаписи", НовыеЗаписиНабора);
				
				ОбновитьНаборЗаписей(ТекущиеДанные, ЕстьИзменения);
			КонецЦикла;
			
		ИначеЕсли Данные.ИмяТретьегоИзмерения = Неопределено Тогда
			// Обновление по двум измерениям.
			СписокПолей = Данные.ИмяПервогоИзмерения + ", " + Данные.ИмяВторогоИзмерения;
			Данные.НовыеЗаписи.Индексы.Добавить(СписокПолей);
			Отбор = Новый Структура(СписокПолей);
			
			Для каждого ПервоеЗначение Из Данные.ЗначенияПервогоИзмерения Цикл
				УстановитьОтбор(Данные.НаборЗаписей.Отбор[Данные.ИмяПервогоИзмерения], ПервоеЗначение);
				Отбор[Данные.ИмяПервогоИзмерения] = ПервоеЗначение;
				
				ОбновитьНовыеЗаписиНабораПоВсемНовымЗаписям(
					Данные,
					Отбор,
					СписокПолей,
					Данные.ИмяВторогоИзмерения,
					Данные.ЗначенияВторогоИзмерения,
					ЕстьИзменения);
			КонецЦикла;
		Иначе
			// Обновление по трем измерениям.
			СписокПолей = Данные.ИмяПервогоИзмерения + ", " + Данные.ИмяВторогоИзмерения + ", " + Данные.ИмяТретьегоИзмерения;
			Данные.НовыеЗаписи.Индексы.Добавить(СписокПолей);
			Отбор = Новый Структура(СписокПолей);
			
			Для каждого ПервоеЗначение Из Данные.ЗначенияПервогоИзмерения Цикл
				УстановитьОтбор(Данные.НаборЗаписей.Отбор[Данные.ИмяПервогоИзмерения], ПервоеЗначение);
				Отбор[Данные.ИмяПервогоИзмерения] = ПервоеЗначение;
				
				Для каждого ВтороеЗначение Из Данные.ЗначенияВторогоИзмерения Цикл
					УстановитьОтбор(Данные.НаборЗаписей.Отбор[Данные.ИмяВторогоИзмерения], ВтороеЗначение);
					Отбор[Данные.ИмяВторогоИзмерения] = ВтороеЗначение;
					
					ОбновитьНовыеЗаписиНабораПоВсемНовымЗаписям(
						Данные,
						Отбор,
						СписокПолей,
						Данные.ИмяВторогоИзмерения,
						Данные.ЗначенияВторогоИзмерения,
						ЕстьИзменения);
				КонецЦикла;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Обновляет регистр сведений по данным в таблице значений ИзмененияСтрок.
//
// Параметры:
//  Данные - Структура - со свойствами:
//
//  * МенеджерРегистра       - Менеджер регистра для создания типа <Регистр*>НаборЗаписей.
//
//  * ИзмененияСоставаСтрок  - ТаблицаЗначений, содержащей поля регистра и
//                             поле ВидИзмененияСтроки (Число):
//                                1 - значит, что строку нужно добавить,
//                               -1 - значит, что строку нужно удалить.
//
//  * ФиксированныйОтбор     - Структура, содержащая имя измерения в ключе и значение
//                             отбора в значении. Может быть указана, когда измерений
//                             более 3-х и заранее известно, что по измерениям сверх 3-х
//                             будет единственное значение. Измерения указанные в
//                             фиксированном отборе не используются при формировании
//                             наборов записей для выполнения обновления.
//
//  * ИзмеренияОтбора        - Строка измерений перечисленных через запятую, которые
//                             нужно использовать при формировании наборов записей
//                             для выполнения обновления (не более 3-х). Не указанные
//                             измерения будут превращены в фиксированный отбор,
//                             если по ним все значения совпадают.
//
//  * ТолькоПроверка         - Булево - если Истина, тогда не выполнять запись,
//                             а лишь выявить необходимость записи и установить
//                             свойство ЕстьИзменения.
//
//  * ДополнительныеСвойства - Неопределено, Структура. Если Структура, тогда в
//                             объекты <Регистр*>НаборЗаписей в свойство
//                             ДополнительныеСвойства будут вставлены все параметры структуры.
//
//  * ОбновлениеИБ           - Булево - если Истина, то необходимо выполнять запись данных,
//                             не выполняя лишних, избыточных действий с данными.
//                             См. ОбновлениеИнформационнойБазы.ЗаписатьДанные.
//                             Если свойство не вставлено, то значение вычисляется по "Или" с помощью функций
//                             ВыполняетсяОбновлениеИнформационнойБазы и ЭтоВызовИзОбработчикаОбновления
//                             общего модуля ОбновлениеИнформационнойБазы.
//
//  ЕстьИзменения         - Булево - (возвращаемое значение) - если производилась запись,
//                          устанавливается Истина, иначе не изменяется.
//
Процедура ОбновитьРегистрСведений(Знач Данные, ЕстьИзменения = Неопределено) Экспорт
	
	Если Данные.ИзмененияСоставаСтрок.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ВсеПараметры = Новый Структура;
	ВсеПараметры.Вставить("МенеджерРегистра");
	ВсеПараметры.Вставить("ИзмененияСоставаСтрок");
	ВсеПараметры.Вставить("ФиксированныйОтбор", Новый Структура);
	ВсеПараметры.Вставить("ИзмеренияОтбора");
	ВсеПараметры.Вставить("ТолькоПроверка", Ложь);
	ВсеПараметры.Вставить("ДополнительныеСвойства");
	ВсеПараметры.Вставить("ОбновлениеИБ",
		    ОбновлениеИнформационнойБазы.ВыполняетсяОбновлениеИнформационнойБазы()
		Или ОбновлениеИнформационнойБазы.ЭтоВызовИзОбработчикаОбновления());
	
	ЗаполнитьПараметры(Данные, ВсеПараметры, "МенеджерРегистра, ИзмененияСоставаСтрок");
	
	МетаданныеРегистра = Метаданные.НайтиПоТипу(ТипЗнч(Данные.МенеджерРегистра.ПустойКлюч()));
	ОписаниеКлючаЗаписи = УправлениеДоступомСлужебныйПовтИсп.ОписаниеКлючаЗаписи(МетаданныеРегистра.ПолноеИмя());
	
	Если Данные.ИзмеренияОтбора <> Неопределено Тогда
		Данные.ИзмеренияОтбора = Новый Структура(Данные.ИзмеренияОтбора);
	КонецЕсли;
	
	МассивИзмеренийОтбора   = Новый Массив;
	ЗначенияИзмеренийОтбора = Новый Структура;
	ИзмерениеБезФиксированногоОтбора = Новый Структура;
	
	Для Каждого Поле Из ОписаниеКлючаЗаписи.МассивПолей Цикл
		Если Не Данные.ФиксированныйОтбор.Свойство(Поле) Тогда
			Значения = ЗначенияКолонкиТаблицы(Данные.ИзмененияСоставаСтрок, Поле);
			
			Если Значения.Количество() = 1 Тогда
				Данные.ФиксированныйОтбор.Вставить(Поле, Значения[0]);
				Продолжить;
			КонецЕсли;
			
			Если Данные.ИзмеренияОтбора = Неопределено
			 Или Данные.ИзмеренияОтбора.Свойство(Поле) Тогда
				
				МассивИзмеренийОтбора.Добавить(Поле);
				ЗначенияИзмеренийОтбора.Вставить(Поле, Значения);
				
			ИначеЕсли Не ЗначениеЗаполнено(ИзмерениеБезФиксированногоОтбора) Тогда
				ИзмерениеБезФиксированногоОтбора.Вставить("Поле",     Поле);
				ИзмерениеБезФиксированногоОтбора.Вставить("Значения", Значения);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если МассивИзмеренийОтбора.Количество() = 0 Тогда
		Если ЗначениеЗаполнено(ИзмерениеБезФиксированногоОтбора) Тогда
			Поле     = ИзмерениеБезФиксированногоОтбора.Поле;
			Значения = ИзмерениеБезФиксированногоОтбора.Значения;
		КонецЕсли;
		МассивИзмеренийОтбора.Добавить(Поле);
		ЗначенияИзмеренийОтбора.Вставить(Поле, Значения);
	КонецЕсли;
	
	Данные.Вставить("ИмяПервогоИзмерения", МассивИзмеренийОтбора[0]);
	Данные.Вставить("ЗначенияПервогоИзмерения", ЗначенияИзмеренийОтбора[Данные.ИмяПервогоИзмерения]);
	
	Если МассивИзмеренийОтбора.Количество() > 1 Тогда
		Данные.Вставить("ИмяВторогоИзмерения", МассивИзмеренийОтбора[1]);
		Данные.Вставить("ЗначенияВторогоИзмерения", ЗначенияИзмеренийОтбора[Данные.ИмяВторогоИзмерения]);
	Иначе
		Данные.Вставить("ИмяВторогоИзмерения", Неопределено);
		Данные.Вставить("ЗначенияВторогоИзмерения", Неопределено);
	КонецЕсли;
	
	Если МассивИзмеренийОтбора.Количество() > 2 Тогда
		Данные.Вставить("ИмяТретьегоИзмерения", МассивИзмеренийОтбора[2]);
		Данные.Вставить("ЗначенияТретьегоИзмерения", ЗначенияИзмеренийОтбора[Данные.ИмяТретьегоИзмерения]);
	Иначе
		Данные.Вставить("ИмяТретьегоИзмерения", Неопределено);
		Данные.Вставить("ЗначенияТретьегоИзмерения", Неопределено);
	КонецЕсли;
	
	Данные.Вставить("ПоляСравнения", ОписаниеКлючаЗаписи.СтрокаПолей);
	Данные.Вставить("НовыеЗаписиСодержатТолькоРазличия", Истина);
	Данные.Вставить("НовыеЗаписи", Данные.ИзмененияСоставаСтрок);
	Данные.Удалить("ИзмененияСоставаСтрок");
	Данные.Удалить("ИзмеренияОтбора");
	
	ОбновитьНаборыЗаписей(Данные, ЕстьИзменения);
	
КонецПроцедуры

// Возвращает пустую ссылку объекта метаданных ссылочного типа.
//
// Параметры:
//  ОписаниеОбъектаМетаданных - ОбъектМетаданных,
//                            - Тип, по которому можно найти объект метаданных,
//                            - Строка - полное имя объекта метаданных.
// Возвращаемое значение:
//  Ссылка - .
//
Функция ПустаяСсылкаОбъектаМетаданных(ОписаниеОбъектаМетаданных) Экспорт
	
	Если ТипЗнч(ОписаниеОбъектаМетаданных) = Тип("ОбъектМетаданных") Тогда
		ОбъектМетаданных = ОписаниеОбъектаМетаданных;
		
	ИначеЕсли ТипЗнч(ОписаниеОбъектаМетаданных) = Тип("Тип") Тогда
		ОбъектМетаданных = Метаданные.НайтиПоТипу(ОписаниеОбъектаМетаданных);
	Иначе
		ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ОписаниеОбъектаМетаданных);
	КонецЕсли;
	
	Если ОбъектМетаданных = Неопределено Тогда
		ТекстОшибки =
			НСтр("ru = 'Ошибка в функции ПустаяСсылкаОбъектаМетаданных
			           |общего модуля УправлениеДоступомСлужебный.
			           |
			           |Неверный параметр ОписаниеОбъектаМетаданных.'");
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	ПустаяСсылка = Неопределено;
	Попытка
		МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ОбъектМетаданных.ПолноеИмя());
		ПустаяСсылка = МенеджерОбъекта.ПустаяСсылка();
	Исключение
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка в функции ПустаяСсылкаОбъектаМетаданных
			           |общего модуля УправлениеДоступомСлужебный.
			           |
			           |Не удалось получить пустую ссылка для объекта метаданных
			           |""%1"".'"),
			ОбъектМетаданных.ПолноеИмя());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	Возврат ПустаяСсылка;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Прочие процедуры и функции

// Создает запрос выбора различий между строками регистра в заданной области данных
// (на основе отборов в параметре ПоляИОтбор).
//
// Параметры:
//  ТекстЗапросаВыбораНовых - Строка.
//
//  ПоляИОтбор   - Массив элементов типа Структура("ИмяПоля", ИмяПараметраУсловияОтбора).
//
//  ПолноеИмяРегистра
//               - Строка       - запрос старых формируется автоматически.
//                 Неопределено - запрос старых берется из следующего параметра.
//
//  ТекстЗапросаВыбораСтарых
//               - Строка       - запрос старых, с учетом нестандартных отборов.
//               - Неопределено - когда полное имя регистра определено.
//
// Возвращаемое значение:
//  Строка - текст запрос с учетом оптимизации для СУБД PostgreSQL.
//
Функция ТекстЗапросаВыбораИзменений(ТекстЗапросаВыбораНовых,
                                    ПоляИОтбор,
                                    ПолноеИмяРегистра            = Неопределено,
                                    ТекстЗапросовВременныхТаблиц = Неопределено,
                                    ТекстЗапросаВыбораСтарых     = Неопределено) Экспорт
	
	// Подготовка текста запроса старых данных.
	Если ПолноеИмяРегистра <> Неопределено Тогда
		ТекстЗапросаВыбораСтарых =
		"ВЫБРАТЬ
		|	&ВыбираемыеПоля,
		|	&ПодстановкаПоляВидИзмененияСтроки
		|ИЗ
		|	ПолноеИмяРегистра КАК СтарыеДанные
		|ГДЕ
		|	&УсловияОтбора";
	КонецЕсли;
	
	ВыбираемыеПоля = "";
	УсловияОтбора = "Истина";
	Для каждого ОписаниеПоля Из ПоляИОтбор Цикл
		// Сборка выбираемых полей.
		ВыбираемыеПоля = ВыбираемыеПоля + СтрЗаменить(
			"
			|	СтарыеДанные.Поле,",
			"Поле",
			КлючИЗначение(ОписаниеПоля).Ключ);
			
		// Сборка условий отбора.
		Если ЗначениеЗаполнено(КлючИЗначение(ОписаниеПоля).Значение) Тогда
			УсловияОтбора = УсловияОтбора + СтрЗаменить(
				"
				|	И &ИмяПараметраУсловияОтбора", "&ИмяПараметраУсловияОтбора",
				КлючИЗначение(ОписаниеПоля).Значение);
		КонецЕсли;
	КонецЦикла;
	
	ТекстЗапросаВыбораСтарых =
		СтрЗаменить(ТекстЗапросаВыбораСтарых, "&ВыбираемыеПоля,",  ВыбираемыеПоля);
	
	ТекстЗапросаВыбораСтарых =
		СтрЗаменить(ТекстЗапросаВыбораСтарых, "&УсловияОтбора",    УсловияОтбора);
	
	ТекстЗапросаВыбораСтарых =
		СтрЗаменить(ТекстЗапросаВыбораСтарых, "ПолноеИмяРегистра", ПолноеИмяРегистра);
	
	Если СтрНайти(ТекстЗапросаВыбораНовых, "&ПодстановкаПоляВидИзмененияСтроки") = 0 Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка в значении параметра ТекстЗапросаВыбораСтарых
			           |процедуры ТекстЗапросаВыбораИзменений модуля УправлениеДоступомСлужебный.
			           |
			           |В тексте запроса не найдена строка ""%1"".'"),
			"&ПодстановкаПоляВидИзмененияСтроки");
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	ТекстЗапросаВыбораСтарых = СтрЗаменить(
		ТекстЗапросаВыбораСтарых, "&ПодстановкаПоляВидИзмененияСтроки", "-1 КАК ВидИзмененияСтроки");
	
	Если СтрНайти(ТекстЗапросаВыбораНовых, "&ПодстановкаПоляВидИзмененияСтроки") = 0 Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка в значении параметра ТекстЗапросаВыбораНовых
			           |процедуры ТекстЗапросаВыбораИзменений модуля УправлениеДоступомСлужебный.
			           |
			           |В тексте запроса не найдена строка ""%1"".'"),
			"&ПодстановкаПоляВидИзмененияСтроки");
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	ТекстЗапросаВыбораНовых = СтрЗаменить(
		ТекстЗапросаВыбораНовых,  "&ПодстановкаПоляВидИзмененияСтроки", "1 КАК ВидИзмененияСтроки");
	
	// Подготовка текста запроса выбора изменений.
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	&ВыбираемыеПоля,
	|	СУММА(ВсеСтроки.ВидИзмененияСтроки) КАК ВидИзмененияСтроки
	|ИЗ
	|	(&ТекстЗапросаВыбораНовых
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	&ТекстЗапросаВыбораСтарых) КАК ВсеСтроки
	|	
	|СГРУППИРОВАТЬ ПО
	|	&ПоляГруппировки
	|	
	|ИМЕЮЩИЕ
	|	СУММА(ВсеСтроки.ВидИзмененияСтроки) <> 0";
	
	ВыбираемыеПоля = "";
	ПоляГруппировки = "";
	Для каждого ОписаниеПоля Из ПоляИОтбор Цикл
		// Сборка выбираемых полей.
		ВыбираемыеПоля = ВыбираемыеПоля + СтрЗаменить(
			"
			|	ВсеСтроки.Поле,",
			"Поле",
			КлючИЗначение(ОписаниеПоля).Ключ);
		
		// Сборка полей соединения.
		ПоляГруппировки = ПоляГруппировки + СтрЗаменить(
			"
			|	ВсеСтроки.Поле,",
			"Поле",
			КлючИЗначение(ОписаниеПоля).Ключ);
	КонецЦикла;
	ПоляГруппировки = Лев(ПоляГруппировки, СтрДлина(ПоляГруппировки)-1);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ВыбираемыеПоля,",  ВыбираемыеПоля);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляГруппировки", ПоляГруппировки);
	
	ТекстЗапроса = СтрЗаменить(
		ТекстЗапроса, "&ТекстЗапросаВыбораНовых",  ТекстЗапросаВыбораНовых);
	
	ТекстЗапроса = СтрЗаменить(
		ТекстЗапроса, "&ТекстЗапросаВыбораСтарых", ТекстЗапросаВыбораСтарых);
	
	Если ЗначениеЗаполнено(ТекстЗапросовВременныхТаблиц) Тогда
		ТекстЗапроса = ТекстЗапросовВременныхТаблиц
		+ "
		  |;
		  |" + ТекстЗапроса;
	КонецЕсли;
	
	Возврат ТекстЗапроса;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обновление информационной базы.

// Заполняет обработчик разделенных данных, зависимый от изменения неразделенных данных.
//
// Параметры:
//   Обработчики - ТаблицаЗначений, Неопределено - см. описание
//    функции НоваяТаблицаОбработчиковОбновления общего модуля
//    ОбновлениеИнформационнойБазы.
//    В случае прямого вызова (не через механизм обновления
//    версии ИБ) передается Неопределено.
// 
Процедура ЗаполнитьОбработчикиРазделенныхДанных(Параметры = Неопределено) Экспорт
	
	Если Параметры <> Неопределено И ЕстьИзмененияПараметровОграниченияДоступа() Тогда
		Обработчики = Параметры.РазделенныеОбработчики;
		Обработчик = Обработчики.Добавить();
		Обработчик.Версия = "*";
		Обработчик.РежимВыполнения = "Оперативно";
		Обработчик.Процедура = "УправлениеДоступомСлужебный.ОбновитьВспомогательныеДанныеПоИзменениямКонфигурации";
	КонецЕсли;
	
КонецПроцедуры

// Обновляет вспомогательные данные, которые зависят от конфигурации частично.
//
// Обновляется при наличии изменений конфигурации, записанных в параметры
// ограничения доступа при обновлении базы данных на текущую версию конфигурации.
//
Процедура ОбновитьВспомогательныеДанныеПоИзменениямКонфигурации(Параметры = Неопределено) Экспорт
	
	Блокировка = Новый БлокировкаДанных;
	Блокировка.Добавить("РегистрСведений.ТаблицыГруппДоступа");
	Блокировка.Добавить("РегистрСведений.НастройкиПравОбъектов");
	Блокировка.Добавить("Справочник.ПрофилиГруппДоступа");
	Блокировка.Добавить("Справочник.ГруппыДоступа");
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		
		РегистрыСведений.ТаблицыГруппДоступа.ОбновитьДанныеРегистраПоИзменениямКонфигурации();
		РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьВспомогательныеДанныеРегистраПоИзменениямКонфигурации();
		РегистрыСведений.НастройкиПравОбъектов.ОбновитьВспомогательныеДанныеРегистраПоИзменениямКонфигурации();
		Справочники.ПрофилиГруппДоступа.ОбновитьПоставляемыеПрофилиПоИзменениямКонфигурации();
		Справочники.ГруппыДоступа.ПометитьНаУдалениеГруппыДоступаПомеченныхПрофилей();
		РегистрыСведений.НаборыЗначенийДоступа.ОбновитьВспомогательныеДанныеРегистраПоИзменениямКонфигурации();
		РегистрыСведений.ПараметрыОграниченияДоступа.ЗапланироватьОбновлениеДоступаПоИзменениямКонфигурации();
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Обновляет настройки и включает регламентное задание.
Процедура ВключитьЗаполнениеДанныхДляОграниченияДоступа() Экспорт
	
	Использование = Константы.ОграничиватьДоступНаУровнеЗаписей.Получить();
	
	Если ОбщегоНазначения.РазделениеВключено() Тогда
		УстановитьЗаполнениеДанныхДляОграниченияДоступа(Использование);
	Иначе
		Расписание = Новый РасписаниеРегламентногоЗадания;
		Расписание.ПериодНедель = 1;
		Расписание.ПериодПовтораДней = 1;
		Расписание.ПериодПовтораВТечениеДня = 300;
		Расписание.ПаузаПовтора = 90;
		
		ЗаданиеМетаданные = Метаданные.РегламентныеЗадания.ЗаполнениеДанныхДляОграниченияДоступа;
		Задание = РегламентныеЗаданияСервер.ПолучитьРегламентноеЗадание(ЗаданиеМетаданные);
		
		Задание.Использование = Использование;
		Задание.Расписание = Расписание;
		
		Задание.ИнтервалПовтораПриАварийномЗавершении
			= ЗаданиеМетаданные.ИнтервалПовтораПриАварийномЗавершении;
		
		Задание.КоличествоПовторовПриАварийномЗавершении
			= ЗаданиеМетаданные.КоличествоПовторовПриАварийномЗавершении;
		
		Задание.Записать();
	КонецЕсли;
	
КонецПроцедуры

// Обновляет данные профиля "ИнтерактивноеОткрытиеВнешнихОтчетовИОбработок".
Процедура ОбновитьДанныеПрофиляОткрытиеВнешнихОтчетовИОбработок() Экспорт
	
	УникальныйИдентификаторПрофиля = Новый УникальныйИдентификатор(
		ИдентификаторПрофиляОткрытиеВнешнихОтчетовИОбработок());
	
	Ссылка = Справочники.ПрофилиГруппДоступа.ПолучитьСсылку(УникальныйИдентификаторПрофиля);
	Если ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, "Ссылка") = Неопределено Тогда
		Возврат;
	КонецЕсли;
	СсылкаПометитьНаУдаление = Ложь;
	
	Если ОбщегоНазначения.РазделениеВключено() Тогда
		СсылкаПометитьНаУдаление = Истина;
	Иначе
		ОписаниеПрофиля = ОписаниеПрофиляОткрытиеВнешнихОтчетовИОбработок();
		ПоставляемыйПрофильСсылка = Справочники.ПрофилиГруппДоступа.ПоставляемыйПрофильПоИдентификатору(
			ОписаниеПрофиля.Имя);
		
		Если Ссылка <> ПоставляемыйПрофильСсылка Тогда
			Если ПоставляемыйПрофильСсылка <> Неопределено Тогда
				СсылкаПометитьНаУдаление = Истина;
			Иначе
				// Установка идентификатора поставляемых данных.
				ПрофильОбъект = Ссылка.ПолучитьОбъект();
				ПрофильОбъект.ИдентификаторПоставляемыхДанных = УникальныйИдентификаторПрофиля;
				ПрофильОбъект.Комментарий = "";
				ОбновлениеИнформационнойБазы.ЗаписатьОбъект(ПрофильОбъект, Ложь);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если СсылкаПометитьНаУдаление Тогда
		ПрофильОбъект = Ссылка.ПолучитьОбъект();
		ПрофильОбъект.ПометкаУдаления = Истина;
		ОбновлениеИнформационнойБазы.ЗаписатьОбъект(ПрофильОбъект, Ложь);
		
		ГруппыПрофиля = ГруппыПрофиля(Ссылка, Ложь);
		Для Каждого СсылкаГруппы Из ГруппыПрофиля Цикл
			ГруппаОбъект = СсылкаГруппы.ПолучитьОбъект();
			ГруппаОбъект.ПометкаУдаления = Истина;
			ОбновлениеИнформационнойБазы.ЗаписатьОбъект(ГруппаОбъект, Ложь);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Заполняет наименования предопределенного профиля Администратор и группы Администраторы.
Процедура ЗаполнитьНаименованиеПредопределенныхЭлементов() Экспорт
	
	ПрофильАдминистратор = Справочники.ПрофилиГруппДоступа.Администратор.ПолучитьОбъект();
	ПрофильАдминистратор.Наименование = НСтр("ru = 'Администратор'");
	ОбновлениеИнформационнойБазы.ЗаписатьОбъект(ПрофильАдминистратор);
	
	ГруппаАдминистраторы = Справочники.ГруппыДоступа.Администраторы.ПолучитьОбъект();
	ГруппаАдминистраторы.Наименование = НСтр("ru = 'Администраторы'");
	ОбновлениеИнформационнойБазы.ЗаписатьОбъект(ГруппаАдминистраторы);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Вспомогательные процедуры и функции.

Функция ПраваРолейРасширений() Экспорт
	
	ПраваРолейРасширений = Неопределено;
	
	ОбновитьТаблицыГруппДоступаДляПодключенныхРасширений(ПраваРолейРасширений);
	
	Возврат ПраваРолейРасширений;
	
КонецФункции

Процедура ОбновитьТаблицыГруппДоступаДляПодключенныхРасширений(ПраваРолейРасширений = Неопределено)
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	ПустыеПраваРолейРасширений = РегистрыСведений.ПраваРолей.ТаблицаПравРолей(Истина, Истина, Истина);
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ОбменДанными") Тогда
		МодульОбменДаннымиСервер = ОбщегоНазначения.ОбщийМодуль("ОбменДаннымиСервер");
		Если МодульОбменДаннымиСервер.НастройкаПодчиненногоУзлаРИБ() Тогда
			ПраваРолейРасширений = ПустыеПраваРолейРасширений;
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	// Заполнение прав ролей расширений, которые состоят
	// из изменений прав на объекты конфигурации и прав на объекты расширений.
	УстановитьНовыеПраваРолейРасширений = Ложь;
	Если ЗначениеЗаполнено(ПараметрыСеанса.ПодключенныеРасширения) Тогда
		ХранилищеПравРолейРасширений = СтандартныеПодсистемыСервер.ПараметрРаботыРасширения(
			"СтандартныеПодсистемы.УправлениеДоступом.ПраваРолей");
		
		Если ХранилищеПравРолейРасширений = Неопределено Тогда
			ПраваРолейРасширений = Неопределено;
		Иначе
			ПраваРолейРасширений = ХранилищеПравРолейРасширений.Получить();
			Если Не ЭтоПраваРолейРасширений(ПраваРолейРасширений, ПустыеПраваРолейРасширений) Тогда
				ПраваРолейРасширений = Неопределено;
			КонецЕсли;
		КонецЕсли;
		Если ПраваРолейРасширений = Неопределено Тогда
			Запрос = РегистрыСведений.ПраваРолей.ЗапросИзменений(Истина);
			ПраваРолейРасширений = Запрос.Выполнить().Выгрузить();
			УстановитьНовыеПраваРолейРасширений = Истина;
		КонецЕсли;
	Иначе
		ПраваРолейРасширений = ПустыеПраваРолейРасширений;
	КонецЕсли;
	
	// Проверка необходимости обновления регистра ТаблицыГруппДоступа.
	ПараметрыОбновления = СтандартныеПодсистемыСервер.ПараметрРаботыРасширения(
		"СтандартныеПодсистемы.УправлениеДоступом.ПараметрыОбновленияТаблицГруппДоступа", Истина);
	
	Если ТипЗнч(ПараметрыОбновления) <> Тип("Структура")
	 Или Не ПараметрыОбновления.Свойство("ПоследниеПраваРолейРасширений")
	 Или Не ЭтоПраваРолейРасширений(ПараметрыОбновления.ПоследниеПраваРолейРасширений, ПустыеПраваРолейРасширений) Тогда
		
		ТребуетсяОбновление = Истина;
		ПоследниеПраваРолейРасширений = Неопределено;
	Иначе
		ПоследниеПраваРолейРасширений = ПараметрыОбновления.ПоследниеПраваРолейРасширений;
		ТребуетсяОбновление = ПраваРолейРасширенийИзменились(ПраваРолейРасширений, ПоследниеПраваРолейРасширений);
	КонецЕсли;
	
	Если Не ТребуетсяОбновление Тогда
		Если УстановитьНовыеПраваРолейРасширений Тогда;
			СтандартныеПодсистемыСервер.УстановитьПараметрРаботыРасширения(
				"СтандартныеПодсистемы.УправлениеДоступом.ПраваРолей", Новый ХранилищеЗначения(ПраваРолейРасширений));
		КонецЕсли;
		Возврат;
	КонецЕсли;
	
	Если ПоследниеПраваРолейРасширений = Неопределено Тогда
		// Так как последние права ролей расширений недоступны, требуется обновить весь регистр.
		ОбъектыСИзменениемПравДляОбновления = Неопределено;
	Иначе
		ТекущиеОбъектыСИзменениемПрав = РегистрыСведений.ПраваРолей.ИзмененныеОбъектыМетаданных(
			ПраваРолейРасширений.Скопировать());
		
		ПоследниеОбъектыСИзменениемПрав = РегистрыСведений.ПраваРолей.ИзмененныеОбъектыМетаданных(
			ПоследниеПраваРолейРасширений.Скопировать());
		
		ОбъектыСИзменениемПравДляОбновления = Новый Массив(ТекущиеОбъектыСИзменениемПрав);
		Для Каждого Идентификатор Из ПоследниеОбъектыСИзменениемПрав Цикл
			ОбъектыСИзменениемПравДляОбновления.Добавить(Идентификатор);
		КонецЦикла;
	КонецЕсли;
	
	ПараметрыОбновления = Новый Структура;
	ПараметрыОбновления.Вставить("ПоследниеПраваРолейРасширений", ПраваРолейРасширений);
	
	Блокировка = Новый БлокировкаДанных;
	Блокировка.Добавить("РегистрСведений.ТаблицыГруппДоступа");
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		Если Справочники.ВерсииРасширений.РасширенияИзмененыДинамически() Тогда
			ВызватьИсключение НСтр("ru = 'Расширения конфигурации обновлены, требуется перезапустить сеанс.'");
		КонецЕсли;
		Если УстановитьНовыеПраваРолейРасширений Тогда;
			СтандартныеПодсистемыСервер.УстановитьПараметрРаботыРасширения(
				"СтандартныеПодсистемы.УправлениеДоступом.ПраваРолей", Новый ХранилищеЗначения(ПраваРолейРасширений));
		КонецЕсли;
		СтандартныеПодсистемыСервер.УстановитьПараметрРаботыРасширения(
			"СтандартныеПодсистемы.УправлениеДоступом.ПараметрыОбновленияТаблицГруппДоступа", ПараметрыОбновления, Истина);
		РегистрыСведений.ТаблицыГруппДоступа.ОбновитьДанныеРегистра(, ОбъектыСИзменениемПравДляОбновления);
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Для процедуры ОбновитьТаблицыГруппДоступаДляПодключенныхРасширений.
Функция ЭтоПраваРолейРасширений(ПраваРолейРасширений, ПустыеПраваРолейРасширений)
	
	Если ТипЗнч(ПраваРолейРасширений) <> Тип("ТаблицаЗначений") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ПраваРолейРасширений.Колонки.Количество() <> ПустыеПраваРолейРасширений.Колонки.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Каждого Колонка Из ПустыеПраваРолейРасширений.Колонки Цикл
		НайденнаяКолонка = ПраваРолейРасширений.Колонки.Найти(Колонка.Имя);
		Если НайденнаяКолонка = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
		Если Колонка.ТипЗначения <> НайденнаяКолонка.ТипЗначения Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Для процедуры ОбновитьТаблицыГруппДоступаДляПодключенныхРасширений.
Функция ПраваРолейРасширенийИзменились(НовыеПраваРолейРасширений, СтарыеПраваРолейРасширений)
	
	Если НовыеПраваРолейРасширений.Количество() <> СтарыеПраваРолейРасширений.Количество() Тогда
		Возврат Истина;
	КонецЕсли;
	
	Отбор = Новый Структура;
	Поля = Новый Массив;
	Для Каждого Колонка Из НовыеПраваРолейРасширений.Колонки Цикл
		Поля.Добавить(Колонка.Имя);
		Отбор.Вставить(Колонка.Имя);
	КонецЦикла;
	СтарыеПраваРолейРасширений.Индексы.Добавить(СтрСоединить(Поля, ","));
	
	Для Каждого Строка Из НовыеПраваРолейРасширений Цикл
		ЗаполнитьЗначенияСвойств(Отбор, Строка);
		Если СтарыеПраваРолейРасширений.НайтиСтроки(Отбор).Количество() <> 1 Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

Процедура ПриИзмененииНаборовЗначенийДоступа(Знач СсылкаНаОбъект, ОбновлениеИБ = Ложь)
	
	СсылкиНаЗависимыеОбъекты = Новый Массив;
	
	УправлениеДоступомПереопределяемый.ПриИзмененииНаборовЗначенийДоступа(
		СсылкаНаОбъект, СсылкиНаЗависимыеОбъекты);
	
	Для каждого СсылкаНаЗависимыйОбъект Из СсылкиНаЗависимыеОбъекты Цикл
		
		Если СсылкаНаЗависимыйОбъект.Метаданные().ТабличныеЧасти.Найти("НаборыЗначенийДоступа") = Неопределено Тогда
			// Изменение объекта не требуется.
			ЗаписатьНаборыЗначенийДоступа(СсылкаНаЗависимыйОбъект, , ОбновлениеИБ);
		Иначе
			// Изменение объекта требуется.
			Объект = СсылкаНаЗависимыйОбъект.ПолучитьОбъект();
			Таблица = ПолучитьНаборыЗначенийДоступаТабличнойЧасти(Объект);
			Если НЕ НаборыЗначенийДоступаТабличнойЧастиИзменены(СсылкаНаЗависимыйОбъект, Таблица) Тогда
				Продолжить;
			КонецЕсли;
			ПодготовитьНаборыЗначенийДоступаКЗаписи(Неопределено, Таблица, Ложь);
			Попытка
				ЗаблокироватьДанныеДляРедактирования(СсылкаНаЗависимыйОбъект, Объект.ВерсияДанных);
				Объект.ДополнительныеСвойства.Вставить("ЗаписатьНаборыЗначенийДоступа");
				Объект.ДополнительныеСвойства.Вставить("ЗаписатьЗависимыеНаборыЗначенийДоступа");
				Объект.ДополнительныеСвойства.Вставить("НаборыЗначенийДоступаТабличнойЧастиЗаполнены");
				Объект.НаборыЗначенийДоступа.Загрузить(Таблица);
				Если ОбновлениеИБ Тогда
					Объект.ДополнительныеСвойства.Вставить("ЗаписьНаборовЗначенийДоступаПриОбновленииИБ");
					ОбновлениеИнформационнойБазы.ЗаписатьДанные(Объект);
				Иначе
					Объект.ОбменДанными.Загрузка = Истина;
					// АПК:1327-выкл - №783.1.4.1 Допустимо оставить запись без
					// предварительной управляемой блокировки объекта, так как только
					// для RLS в формате БСП 2.х (устарело) и ни разу не вызывало проблем.
					Объект.Записать();
					// АПК:1327-вкл.
				КонецЕсли;
				РазблокироватьДанныеДляРедактирования(СсылкаНаЗависимыйОбъект);
			Исключение
				ИнформацияОбОшибке = ИнформацияОбОшибке();
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'При обновлении зависимого набора значений доступа объекта
					           |""%1"" возникла ошибка:
					           |
					           |%2'"),
					Строка(СсылкаНаЗависимыйОбъект),
					КраткоеПредставлениеОшибки(ИнформацияОбОшибке));
				ВызватьИсключение ТекстОшибки;
			КонецПопытки;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция ИдентификаторПрофиляОткрытиеВнешнихОтчетовИОбработок()
	
	Возврат "1b3472f6-4d87-11e6-8264-5404a6a6895d";
	
КонецФункции

Функция ЭтоПрофильОткрытиеВнешнихОтчетовИОбработок(Профиль) Экспорт
	
	Если ТипЗнч(Профиль) = Тип("СправочникСсылка.ПрофилиГруппДоступа") Тогда
		ИдентификаторПрофиля = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Профиль, "ИдентификаторПоставляемыхДанных");
		
	ИначеЕсли Не Профиль.ЭтоГруппа Тогда
		ИдентификаторПрофиля = Профиль.ИдентификаторПоставляемыхДанных;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
	Возврат ВРег(Строка(ИдентификаторПрофиля)) = ВРег(ИдентификаторПрофиляОткрытиеВнешнихОтчетовИОбработок());
	
КонецФункции

Функция ГруппыДоступаПрофиляОткрытиеВнешнихОтчетовИОбработок()
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ИдентификаторПоставляемыхДанных",
		Новый УникальныйИдентификатор(ИдентификаторПрофиляОткрытиеВнешнихОтчетовИОбработок()));
	
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ГруппыДоступа.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.ГруппыДоступа КАК ГруппыДоступа
	|ГДЕ
	|	ГруппыДоступа.Профиль.ИдентификаторПоставляемыхДанных = &ИдентификаторПоставляемыхДанных";
	
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
КонецФункции

Функция ОписаниеПрофиляОткрытиеВнешнихОтчетовИОбработок() Экспорт
	
	ОписаниеПрофиля = УправлениеДоступом.НовоеОписаниеПрофиляГруппДоступа();
	ОписаниеПрофиля.Имя           = "ОткрытиеВнешнихОтчетовИОбработок";
	ОписаниеПрофиля.Идентификатор = ИдентификаторПрофиляОткрытиеВнешнихОтчетовИОбработок();
	
	ОписаниеПрофиля.Наименование =
		НСтр("ru = 'Открытие внешних отчетов и обработок'", ОбщегоНазначения.КодОсновногоЯзыка());
	
	ОписаниеПрофиля.Описание =
		НСтр("ru = 'Предоставляет право открытия внешних отчетов и обработок из меню ""Файл - Открыть"".
		           |Состав ролей профиля не рекомендуется изменять.'");
	
	ОписаниеПрофиля.Роли.Добавить("ИнтерактивноеОткрытиеВнешнихОтчетовИОбработок");
	
	Возврат ОписаниеПрофиля;
	
КонецФункции

Функция ГруппаДоступаОткрытиеВнешнихОтчетовИОбработок(СвойстваПрофиля)
	
	// Поиск по идентификатору.
	УникальныйИдентификатор = Новый УникальныйИдентификатор("f6929bcb-532f-11e6-a20f-5404a6a6895d");
	Ссылка = Справочники.ГруппыДоступа.ПолучитьСсылку(УникальныйИдентификатор);
	СсылкаСуществует = (ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, "Ссылка") <> Неопределено);
	Если СсылкаСуществует Тогда
		Возврат Ссылка;
	КонецЕсли;
	
	// Поиск по профилю.
	ГруппыПрофиля = ГруппыПрофиля(СвойстваПрофиля.Ссылка, Неопределено);
	Если ГруппыПрофиля.Количество() > 0 Тогда
		Возврат ГруппыПрофиля[0];
	КонецЕсли;
	
	// Создание группы.
	ГруппаДоступаОбъект = Справочники.ГруппыДоступа.СоздатьЭлемент();
	ГруппаДоступаОбъект.УстановитьСсылкуНового(Ссылка);
	ГруппаДоступаОбъект.Наименование = СвойстваПрофиля.Наименование;
	ГруппаДоступаОбъект.Профиль      = СвойстваПрофиля.Ссылка;
	ГруппаДоступаОбъект.Комментарий  =
		НСтр("ru = 'Предоставляет право открытия внешних отчетов и обработок из меню ""Файл - Открыть"".'",
			ОбщегоНазначения.КодОсновногоЯзыка());
	
	ГруппаДоступаОбъект.Записать(); // Важно, чтобы созданная группа "уехала" в подчиненный узел.
	
	Возврат ГруппаДоступаОбъект.Ссылка;
	
КонецФункции

Функция ГруппыПрофиля(СсылкаПрофиля, ПометкаУдаления)
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ГруппыДоступа.Ссылка
	|ИЗ
	|	Справочник.ГруппыДоступа КАК ГруппыДоступа
	|ГДЕ
	|	ГруппыДоступа.Профиль = &Профиль
	|	И ГруппыДоступа.ПометкаУдаления = &ПометкаУдаления
	|
	|УПОРЯДОЧИТЬ ПО
	|	ГруппыДоступа.ПометкаУдаления";
	
	Запрос.УстановитьПараметр("Профиль", СсылкаПрофиля);
	
	Если ПометкаУдаления = Неопределено Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "И ГруппыДоступа.ПометкаУдаления = &ПометкаУдаления", "");
	Иначе
		Запрос.УстановитьПараметр("ПометкаУдаления", ПометкаУдаления);
	КонецЕсли;
	
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
КонецФункции

// Для функция РазрешенныеЗначенияДляДинамическогоСписка, ЕстьОграничениеПоВидуДоступа.
Функция ТекстЗапросаГруппДоступа()
	
	Возврат
	"ВЫБРАТЬ
	|	ГруппыДоступа.Ссылка КАК Ссылка
	|ПОМЕСТИТЬ ГруппыДоступаПользователя
	|ИЗ
	|	Справочник.ИдентификаторыОбъектовМетаданных КАК СвойстваТекущейТаблицы
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ГруппыДоступа КАК ГруппыДоступа
	|		ПО (СвойстваТекущейТаблицы.ПолноеИмя = &ИмяОсновнойТаблицыСписка)
	|			И (ИСТИНА В
	|				(ВЫБРАТЬ ПЕРВЫЕ 1
	|					ИСТИНА
	|				ИЗ
	|					РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступа
	|				ГДЕ
	|					ТаблицыГруппДоступа.Таблица = СвойстваТекущейТаблицы.Ссылка
	|					И ТаблицыГруппДоступа.ГруппаДоступа = ГруппыДоступа.Ссылка))
	|			И (ГруппыДоступа.Ссылка В
	|				(ВЫБРАТЬ
	|					ГруппыДоступаПользователи.Ссылка КАК ГруппаДоступа
	|				ИЗ
	|					Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|						ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|						ПО
	|							СоставыГруппПользователей.Пользователь = &АвторизованныйПользователь
	|								И СоставыГруппПользователей.ГруппаПользователей = ГруппыДоступаПользователи.Пользователь))";
	
КонецФункции

// Для процедур ОбновитьНаборЗаписей, ОбновитьНаборыЗаписей, ОбновитьРегистрСведений.
Процедура ЗаполнитьПараметры(ВходныеПараметры, Знач ВсеПараметры, Знач ОбязательныеПараметры = "")
	
	Если ТипЗнч(ВходныеПараметры) = Тип("Структура") Тогда
		Параметры = ВходныеПараметры;
	ИначеЕсли ВходныеПараметры = Неопределено Тогда
		Параметры = Новый Структура;
	Иначе
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Некорректный тип набора свойств ""%1"".
			           |Допустимые типы: Структура, Неопределено.'"),
			ТипЗнч(ВходныеПараметры));
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Для каждого КлючИЗначение Из Параметры Цикл
		Если Не ВсеПараметры.Свойство(КлючИЗначение.Ключ) Тогда
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Указан несуществующий параметр %1'"),
				КлючИЗначение.Ключ);
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
		ВсеПараметры[КлючИЗначение.Ключ] = Параметры[КлючИЗначение.Ключ];
	КонецЦикла;
	
	Если ЗначениеЗаполнено(ОбязательныеПараметры) Тогда
		ОбязательныеПараметры = Новый Структура(ОбязательныеПараметры);
		
		Для каждого КлючИЗначение Из ОбязательныеПараметры Цикл
			Если Не Параметры.Свойство(КлючИЗначение.Ключ) Тогда
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Не указан обязательный параметр %1'"),
					КлючИЗначение.Ключ);
				ВызватьИсключение ТекстОшибки;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ВходныеПараметры = ВсеПараметры;
	
КонецПроцедуры

// Для процедур ПриОтправкеДанныхГлавному, ПриОтправкеДанныхПодчиненному,
// ПриПолученииДанныхОтГлавного, ПриПолученииДанныхОтПодчиненного.
//
Функция ОбъектПодсистемыУправлениеДоступомТолькоДляСозданияНачальногоОбраза(ЭлементДанных)
	
	Возврат ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.ПраваРолей")
	    Или ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.ЗависимостиПравДоступа")
	    Или ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.ТаблицыГруппДоступа")
	    Или ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.ЗначенияГруппДоступа")
	    Или ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.ЗначенияГруппДоступаПоУмолчанию")
	    Или ТипЗнч(ЭлементДанных) = Тип("СправочникОбъект.КлючиДоступа")
	    Или ТипЗнч(ЭлементДанных) = Тип("СправочникОбъект.НаборыГруппДоступа")
	    Или ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.КлючиДоступаВнешнихПользователей")
	    Или ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.КлючиДоступаГруппДоступа")
	    Или ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.КлючиДоступаНаборовГруппДоступа")
	    Или ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.КлючиДоступаКОбъектам")
	    Или ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.КлючиДоступаКРегистрам")
	    Или ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.КлючиДоступаПользователей")
	    Или ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.ОбновлениеКлючейДоступаКДанным")
	    Или ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.ОбновлениеКлючейДоступаПользователей")
	    Или ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.ПараметрыОграниченияДоступа")
	    Или ТипЗнч(ЭлементДанных) = Тип("КонстантаМенеджерЗначения.ПервоеОбновлениеДоступаЗавершилось");
	
КонецФункции

// Для процедур ПриПолученииДанныхОтГлавного, ПриПолученииДанныхОтПодчиненного
Процедура ПриПолученииДанныхОтГлавногоИлиОтПодчиненного(ЭлементДанных)
	
	Если ТипЗнч(ЭлементДанных) = Тип("СправочникОбъект.ПрофилиГруппДоступа") Тогда
		// Роли расширений назначаются независимо во всех РИБ-узлах.
		Справочники.ПрофилиГруппДоступа.ВосстановитьСоставРолейРасширений(ЭлементДанных);
		// Регистрация измененного профиля для обновления вспомогательных данных.
		Справочники.ПрофилиГруппДоступа.ЗарегистрироватьПрофильИзмененныйПриЗагрузке(ЭлементДанных);
	КонецЕсли;
	
	Если ТипЗнч(ЭлементДанных) = Тип("СправочникОбъект.ГруппыДоступа") Тогда
		// Администраторы назначаются независимо во всех РИБ-узлах.
		Справочники.ГруппыДоступа.ВосстановитьСоставУчастниковГруппыДоступаАдминистраторы(ЭлементДанных);
		// Регистрация измененной группы доступа для обновления вспомогательных данных.
		Справочники.ГруппыДоступа.ЗарегистрироватьГруппуДоступаИзмененнуюПриЗагрузке(ЭлементДанных);
	КонецЕсли;
	
	// Регистрация пользователей, измененных в группе пользователей, для обновления ролей после получения данных.
	Если ТипЗнч(ЭлементДанных) = Тип("СправочникОбъект.ГруппыПользователей")
	 Или ТипЗнч(ЭлементДанных) = Тип("СправочникОбъект.ГруппыВнешнихПользователей") Тогда
		Справочники.ГруппыДоступа.ЗарегистрироватьПользователейГруппыПользователейИзмененнойПриЗагрузке(ЭлементДанных);
	КонецЕсли;
	
	// Регистрация пользователя, измененного при загрузке для обновления ролей после загрузки.
	Если ТипЗнч(ЭлементДанных) = Тип("СправочникОбъект.Пользователи")
	 Или ТипЗнч(ЭлементДанных) = Тип("СправочникОбъект.ВнешниеПользователи") Тогда
		Справочники.ГруппыДоступа.ЗарегистрироватьПользователяИзмененногоПриЗагрузке(ЭлементДанных);
	КонецЕсли;
	
	Если ТипЗнч(ЭлементДанных) <> Тип("УдалениеОбъекта") Тогда
		Возврат;
	КонецЕсли;
	
	// Регистрация измененного профиля для обновления вспомогательных данных после загрузки.
	Если ТипЗнч(ЭлементДанных.Ссылка) = Тип("СправочникСсылка.ПрофилиГруппДоступа") Тогда
		Справочники.ПрофилиГруппДоступа.ЗарегистрироватьПрофильИзмененныйПриЗагрузке(ЭлементДанных);
	КонецЕсли;
	
	// Регистрация измененной группы доступа для обновления вспомогательных данных после загрузки.
	Если ТипЗнч(ЭлементДанных.Ссылка) = Тип("СправочникСсылка.ГруппыДоступа") Тогда
		Справочники.ГруппыДоступа.ЗарегистрироватьГруппуДоступаИзмененнуюПриЗагрузке(ЭлементДанных);
	КонецЕсли;
	
	// Регистрация пользователей, измененных в группе пользователей, для обновления ролей после загрузки.
	Если ТипЗнч(ЭлементДанных.Ссылка) = Тип("СправочникСсылка.ГруппыПользователей")
	 Или ТипЗнч(ЭлементДанных.Ссылка) = Тип("СправочникСсылка.ГруппыВнешнихПользователей") Тогда
		Справочники.ГруппыДоступа.ЗарегистрироватьПользователейГруппыПользователейИзмененнойПриЗагрузке(ЭлементДанных);
	КонецЕсли;
	
	// Регистрация пользователя, измененного при загрузке для обновления ролей после загрузки.
	Если ТипЗнч(ЭлементДанных.Ссылка) = Тип("СправочникСсылка.Пользователи")
	 Или ТипЗнч(ЭлементДанных.Ссылка) = Тип("СправочникСсылка.ВнешниеПользователи") Тогда
		Справочники.ГруппыДоступа.ЗарегистрироватьПользователяИзмененногоПриЗагрузке(ЭлементДанных);
	КонецЕсли;
	
КонецПроцедуры

// Для процедур ПослеПолученияДанных, ПослеОбновленияИнформационнойБазы.
Процедура ОбновитьВспомогательныеДанныеЭлементовИзмененныхПриЗагрузке()
	
	Справочники.ПрофилиГруппДоступа.ОбновитьВспомогательныеДанныеПрофилейИзмененныхПриЗагрузке();
	Справочники.ГруппыДоступа.ОбновитьВспомогательныеДанныеГруппДоступаИзмененныхПриЗагрузке();
	Справочники.ГруппыДоступа.ОбновитьРолиПользователейИзмененныхПриЗагрузке();
	
КонецПроцедуры

// Для процедур ВключитьПользователяВГруппуДоступа, ИсключитьПользователяИзГруппыДоступа
// и функции НайтиПользователяВГруппеДоступа.

Функция ОбработатьСвязьПользователяСГруппойДоступа(Пользователь, ПоставляемыйПрофиль, Включить = Неопределено)
	
	Если ТипЗнч(Пользователь) <> Тип("СправочникСсылка.Пользователи")
	   И ТипЗнч(Пользователь) <> Тип("СправочникСсылка.ГруппыПользователей")
	   И ТипЗнч(Пользователь) <> Тип("СправочникСсылка.ВнешниеПользователи")
	   И ТипЗнч(Пользователь) <> Тип("СправочникСсылка.ГруппыВнешнихПользователей") Тогда
		
		Возврат Ложь;
	КонецЕсли;
	
	ИдентификаторПоставляемогоПрофиля = Неопределено;
	
	Если ТипЗнч(ПоставляемыйПрофиль) = Тип("Строка") Тогда
		Если СтроковыеФункцииКлиентСервер.ЭтоУникальныйИдентификатор(ПоставляемыйПрофиль) Тогда
			
			ИдентификаторПоставляемогоПрофиля = ПоставляемыйПрофиль;
			
			ПоставляемыйПрофиль = Справочники.ПрофилиГруппДоступа.ПоставляемыйПрофильПоИдентификатору(
				ИдентификаторПоставляемогоПрофиля);
		Иначе
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(ПоставляемыйПрофиль) <> Тип("СправочникСсылка.ПрофилиГруппДоступа") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ИдентификаторПоставляемогоПрофиля = Неопределено Тогда
		ИдентификаторПоставляемогоПрофиля =
			Справочники.ПрофилиГруппДоступа.ИдентификаторПоставляемогоПрофиля(ПоставляемыйПрофиль);
	КонецЕсли;
	
	Если ИдентификаторПоставляемогоПрофиля = Справочники.ПрофилиГруппДоступа.ИдентификаторПрофиляАдминистратор() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ПоставляемыеПрофили = УправлениеДоступомСлужебныйПовтИсп.ОписаниеПоставляемыхПрофилей();
	СвойстваПрофиля = ПоставляемыеПрофили.ОписанияПрофилей.Получить(ИдентификаторПоставляемогоПрофиля);
	
	Если СвойстваПрофиля = Неопределено
	 ИЛИ СвойстваПрофиля.ВидыДоступа.Количество() <> 0 Тогда
		
		Возврат Ложь;
	КонецЕсли;
	
	ГруппаДоступа = Неопределено;
	
	Если УпрощенныйИнтерфейсНастройкиПравДоступа() Тогда
		
		Если ТипЗнч(Пользователь) <> Тип("СправочникСсылка.Пользователи")
		   И ТипЗнч(Пользователь) <> Тип("СправочникСсылка.ВнешниеПользователи") Тогда
			
			Возврат Ложь;
		КонецЕсли;
		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("Профиль", ПоставляемыйПрофиль);
		Запрос.УстановитьПараметр("Пользователь", Пользователь);
		Запрос.Текст =
		"ВЫБРАТЬ
		|	ГруппыДоступа.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.ГруппыДоступа КАК ГруппыДоступа
		|ГДЕ
		|	ГруппыДоступа.Профиль = &Профиль
		|	И ГруппыДоступа.Пользователь = &Пользователь";
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			ГруппаДоступа = Выборка.Ссылка;
		КонецЕсли;
		
		Если ГруппаДоступа = Неопределено Тогда
			Если Включить <> Истина Тогда
				Возврат Ложь;
			Иначе
				ГруппаДоступа = Справочники.ГруппыДоступа.СоздатьЭлемент();
				ГруппаДоступа.Наименование = СвойстваПрофиля.Наименование;
				ГруппаДоступа.Профиль      = ПоставляемыйПрофиль;
				ГруппаДоступа.Пользователь = Пользователь;
				ГруппаДоступа.Пользователи.Добавить().Пользователь = Пользователь;
				ГруппаДоступа.Записать();
				Возврат Истина;
			КонецЕсли;
		КонецЕсли;
	Иначе
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ПоставляемыйПрофиль", ПоставляемыйПрофиль);
		Запрос.Текст =
		"ВЫБРАТЬ
		|	ГруппыДоступа.Ссылка КАК Ссылка,
		|	ГруппыДоступа.ОсновнаяГруппаДоступаПоставляемогоПрофиля
		|ИЗ
		|	Справочник.ГруппыДоступа КАК ГруппыДоступа
		|ГДЕ
		|	ГруппыДоступа.Профиль = &ПоставляемыйПрофиль
		|
		|УПОРЯДОЧИТЬ ПО
		|	ГруппыДоступа.ОсновнаяГруппаДоступаПоставляемогоПрофиля УБЫВ";
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			ГруппаДоступа = Выборка.Ссылка; // СправочникСсылка.ГруппыДоступа - 
		КонецЕсли;
		
		Если ГруппаДоступа = Неопределено Тогда
			Если Включить <> Истина Тогда
				Возврат Ложь;
			Иначе
				ГруппаДоступа = Справочники.ГруппыДоступа.СоздатьЭлемент();
				ГруппаДоступа.ОсновнаяГруппаДоступаПоставляемогоПрофиля = Истина;
				ГруппаДоступа.Наименование = СвойстваПрофиля.Наименование;
				ГруппаДоступа.Профиль = ПоставляемыйПрофиль;
				ГруппаДоступа.Пользователи.Добавить().Пользователь = Пользователь;
				ГруппаДоступа.Записать();
				Возврат Истина;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", ГруппаДоступа);
	Запрос.УстановитьПараметр("Пользователь", Пользователь);
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА КАК ЗначениеИстина
	|ИЗ
	|	Справочник.ГруппыДоступа.Пользователи КАК УчастникиГруппы
	|ГДЕ
	|	УчастникиГруппы.Ссылка = &Ссылка
	|	И УчастникиГруппы.Пользователь = &Пользователь";
	ПользовательНайден = НЕ Запрос.Выполнить().Пустой();
	
	Если Включить = Неопределено Тогда
		Возврат ПользовательНайден;
	КонецЕсли;
	
	Если Включить И ПользовательНайден Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если НЕ Включить И НЕ ПользовательНайден Тогда
		Возврат Истина;
	КонецЕсли;
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить("Справочник.ГруппыДоступа");
	ЭлементБлокировки.УстановитьЗначение("Ссылка", ГруппаДоступа);
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		
		ГруппаДоступа = ГруппаДоступа.ПолучитьОбъект();
		
		Если НЕ УпрощенныйИнтерфейсНастройкиПравДоступа()
		   И НЕ ГруппаДоступа.ОсновнаяГруппаДоступаПоставляемогоПрофиля Тогда
			
			ГруппаДоступа.ОсновнаяГруппаДоступаПоставляемогоПрофиля = Истина;
		КонецЕсли;
		
		Если Включить Тогда
			ГруппаДоступа.Пользователи.Добавить().Пользователь = Пользователь;
		Иначе
			Отбор = Новый Структура("Пользователь", Пользователь);
			Строки = ГруппаДоступа.Пользователи.НайтиСтроки(Отбор);
			Для каждого Строка Из Строки Цикл
				ГруппаДоступа.Пользователи.Удалить(Строка);
			КонецЦикла;
		КонецЕсли;
		
		ГруппаДоступа.Записать();
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат Истина;
	
КонецФункции

// Для процедуры ЗаписатьНаборыЗначенийДоступаПриЗаписи.

// Перезаписывает наборы значений доступа проверяемого объекта
// в РегистрСведений.НаборыЗначенийДоступа, используя процедуру
// УправлениеДоступом.ЗаполнитьНаборыЗначенийДоступа().
//
// Процедура вызывается из УправлениеДоступомСлужебный.ЗаписатьНаборыЗначенийДоступа(),
// но может быть вызвана из любого места, например,
// при включении ограничения доступа на уровне записей.
//
// Вызывает процедуру прикладного разработчика
// УправлениеДоступомПереопределяемый.ПриИзмененииНаборовЗначенийДоступа(),
// которая используется для перезаписи зависимых наборов значений доступа.
//
// Параметры:
//  Объект       - СправочникОбъект, ДокументОбъект, ..., или СправочникСсылка, ДокументСсылка, ...
//                 В случае вызова с клиента можно передать только ссылку, а нужен объект.
//                 Если получена ссылка, то по ней будет получен объект.
//  ОбновлениеИБ - Булево - если Истина, то необходимо выполнять запись данных, 
//                 не выполняя лишних, избыточных действий с данными.
//                 См. ОбновлениеИнформационнойБазы.ЗаписатьДанные.
//
Процедура ЗаписатьНаборыЗначенийДоступа(Знач Объект, ЕстьИзменения = Неопределено, ОбновлениеИБ = Ложь)
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Если передача параметра Объект производилась с клиента на сервер,
	// то передавалась ссылка, и объект требуется получить.
	Объект = ?(Объект = Объект.Ссылка, Объект.ПолучитьОбъект(), Объект);
	СсылкаНаОбъект = Объект.Ссылка;
	ТипЗначенияОбъект = ТипЗнч(Объект);
	
	НаборыЗаписываются = УправлениеДоступомСлужебныйПовтИсп.ТипыОбъектовВПодпискахНаСобытия(
		"ЗаписатьНаборыЗначенийДоступа").Получить(ТипЗначенияОбъект) <> Неопределено;
	
	Если НЕ НаборыЗаписываются Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверные параметры.
			           |Тип объекта ""%1""
			           |не найден в подписках на события
			           |""Записать наборы значений доступа"".'"),
			ТипЗначенияОбъект);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	ВозможныеТипыОбъектов = УправлениеДоступомСлужебныйПовтИсп.ТипыПоляТаблицы(
		"РегистрСведений.НаборыЗначенийДоступа.Измерение.Объект");
	
	Если ВозможныеТипыОбъектов.Получить(ТипЗнч(СсылкаНаОбъект)) = Неопределено Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка при записи наборов значений доступа:
			           |в регистре сведений НаборыЗначенийДоступа в измерении Объект
			           |не задан тип ""%1"".'"),
			СсылкаНаОбъект.Метаданные().ПолноеИмя());
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Если УправлениеДоступом.ОграничиватьДоступНаУровнеЗаписей()
	   И Не ОграничиватьДоступНаУровнеЗаписейУниверсально(Ложь, Истина) Тогда
		
		Если Метаданные.НайтиПоТипу(ТипЗначенияОбъект).ТабличныеЧасти.Найти("НаборыЗначенийДоступа") = Неопределено Тогда
			
			Таблица = УправлениеДоступом.ТаблицаНаборыЗначенийДоступа();
			УправлениеДоступом.ЗаполнитьНаборыЗначенийДоступа(Объект, Таблица);
			
			УправлениеДоступом.ДобавитьНаборыЗначенийДоступа(
				Таблица, УправлениеДоступом.ТаблицаНаборыЗначенийДоступа(), Ложь, Истина);
		Иначе
			ТабличнаяЧастьЗаполняется = УправлениеДоступомСлужебныйПовтИсп.ТипыОбъектовВПодпискахНаСобытия(
				"ЗаполнитьНаборыЗначенийДоступаТабличныхЧастей").Получить(ТипЗначенияОбъект) <> Неопределено;
			
			Если НЕ ТабличнаяЧастьЗаполняется Тогда
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Неверные параметры.
					           |Тип объекта ""%1""
					           |не найден в подписках на события
					           |""Заполнить наборы значений доступа табличных частей"".'"),
					ТипЗначенияОбъект);
				ВызватьИсключение ТекстОшибки;
			КонецЕсли;
			// Записан объект с уже заполненной табличной частью НаборыЗначенийДоступа.
			Таблица = Объект.НаборыЗначенийДоступа.Выгрузить();
		КонецЕсли;
		
		ПодготовитьНаборыЗначенийДоступаКЗаписи(СсылкаНаОбъект, Таблица, Истина);
		
		Данные = Новый Структура;
		Данные.Вставить("МенеджерРегистра",   РегистрыСведений.НаборыЗначенийДоступа);
		Данные.Вставить("ФиксированныйОтбор", Новый Структура("Объект", СсылкаНаОбъект));
		Данные.Вставить("НовыеЗаписи",        Таблица);
		Данные.Вставить("ОбновлениеИБ",       ОбновлениеИБ);
		
		НачатьТранзакцию();
		Попытка
			ОбновитьНаборыЗаписей(Данные, ЕстьИзменения);
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
		
		Если ЕстьИзменения = Истина Тогда
			ПриИзмененииНаборовЗначенийДоступа(СсылкаНаОбъект, ОбновлениеИБ);
		КонецЕсли;
	Иначе
		Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	ИСТИНА КАК ЗначениеИстина
		|ИЗ
		|	РегистрСведений.НаборыЗначенийДоступа КАК НаборыЗначенийДоступа
		|ГДЕ
		|	НаборыЗначенийДоступа.Объект = &СсылкаНаОбъект");
		
		Запрос.УстановитьПараметр("СсылкаНаОбъект", СсылкаНаОбъект);
		
		// АПК:1328-выкл - №648.1.1 Допустимо чтение без предварительной
		// управляемой разделяемой блокировки объекта, так как только
		// для RLS в формате БСП 2.х (устарело) и ни разу не вызывало проблем.
		Если НЕ Запрос.Выполнить().Пустой() Тогда
		// АПК:1328-вкл.
			
			// Очистка устаревшего набора.
			// Запись нового набора будет выполнена регламентным заданием,
			// после включения ограничения на уровне записей.
			НаборЗаписей = РегистрыСведений.НаборыЗначенийДоступа.СоздатьНаборЗаписей();
			НаборЗаписей.Отбор.Объект.Установить(СсылкаНаОбъект);
			НаборЗаписей.Записать();
			ЕстьИзменения = Истина;
			
			// Очистка устаревших зависимых наборов.
			ПриИзмененииНаборовЗначенийДоступа(СсылкаНаОбъект, ОбновлениеИБ);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ЗаписатьЗависимыеНаборыЗначенийДоступаПриЗаписи.

// Перезаписывает наборы значений доступа зависимых объектов.
//
//  Процедура вызывается из УправлениеДоступомСлужебный.ЗаписатьЗависимыеНаборыЗначенийДоступа(),
// состав типов подписки дополняет (без пересечения) состав типов подписки ЗаписатьНаборыЗначенийДоступа,
// теми типами, для которых выполнять запись наборов в регистр сведений НаборыЗначенийДоступа
// не требуется, но сами наборы входят в состав других наборов, например, наборы некоторых файлов
// из справочника "Файлы" могут входить в состав некоторых бизнес-процессов "Задание", созданных
// на основании файлов, при этом наборы файлов записывать в регистр не требуется.
//
// Вызывает процедуру прикладного разработчика
// УправлениеДоступомПереопределяемый.ПриИзмененииНаборовЗначенийДоступа(),
// которая используется для перезаписи зависимых наборов значений доступа,
// то есть организуется рекурсия.
//
// Параметры:
//  Объект       - СправочникОбъект, ДокументОбъект, ..., или СправочникСсылка, ДокументСсылка, ...
//                 В случае вызова с клиента можно передать только ссылку, а нужен объект.
//                 Если получена ссылка, то по ней будет получен объект.
//
//  ОбновлениеИБ - Булево - если Истина, то необходимо выполнять запись данных, 
//                 не выполняя лишних, избыточных действий с данными.
//                 См. ОбновлениеИнформационнойБазы.ЗаписатьДанные.
//
Процедура ЗаписатьЗависимыеНаборыЗначенийДоступа(Знач Объект, ОбновлениеИБ = Ложь)
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Если передача параметра Объект производилась с клиента на сервер,
	// то передавалась ссылка, и объект требуется получить.
	Объект = ?(Объект = Объект.Ссылка, Объект.ПолучитьОбъект(), Объект);
	СсылкаНаОбъект = Объект.Ссылка;
	ТипЗначенияОбъект = ТипЗнч(Объект);
	
	ЭтоВедущийОбъект = УправлениеДоступомСлужебныйПовтИсп.ТипыОбъектовВПодпискахНаСобытия(
		"ЗаписатьЗависимыеНаборыЗначенийДоступа").Получить(ТипЗначенияОбъект) <> Неопределено;
	
	Если НЕ ЭтоВедущийОбъект Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверные параметры.
			           |Тип объекта ""%1""
			           |не найден в подписке на события
			           |""Записать зависимые наборы значений доступа"".'"),
			ТипЗначенияОбъект);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	ПриИзмененииНаборовЗначенийДоступа(СсылкаНаОбъект, ОбновлениеИБ);
	
КонецПроцедуры

// Для процедур ОбновитьВспомогательныеДанныеПоИзменениямКонфигурации и
// ЗаполнитьОбработчикиРазделенныхДанных.

// Проверяет были ли изменения неразделенных данных для какой-нибудь области данных.
Функция ЕстьИзмененияПараметровОграниченияДоступа()
	
	УстановитьПривилегированныйРежим(Истина);
	
	Параметры = Новый Массив;
	Параметры.Добавить("СтандартныеПодсистемы.УправлениеДоступом.ОбъектыМетаданныхПравРолей");
	Параметры.Добавить("СтандартныеПодсистемы.УправлениеДоступом.ВозможныеПраваДляНастройкиПравОбъектов");
	Параметры.Добавить("СтандартныеПодсистемы.УправлениеДоступом.ОписаниеПоставляемыхПрофилей");
	Параметры.Добавить("СтандартныеПодсистемы.УправлениеДоступом.ПредопределенныеПрофилиГруппДоступа");
	Параметры.Добавить("СтандартныеПодсистемы.УправлениеДоступом.ТипыГруппИЗначенийДоступа");
	Параметры.Добавить("СтандартныеПодсистемы.УправлениеДоступом.ВерсияТекстовОграниченияДоступа");
	
	Для Каждого Параметр Из Параметры Цикл
		
		ПоследниеИзменения = СтандартныеПодсистемыСервер.ИзмененияПараметраРаботыПрограммы(Параметр);
		
		Если ПоследниеИзменения = Неопределено
		 ИЛИ ПоследниеИзменения.Количество() > 0 Тогда
			
			Возврат Истина;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Для процедуры ОбновитьРолиПользователей.

Функция ТекущиеСвойстваПользователей(МассивПользователей)
	
	Запрос = Новый Запрос;
	
	Запрос.УстановитьПараметр("ПустойИдентификатор",
		ОбщегоНазначенияКлиентСервер.ПустойУникальныйИдентификатор());
	
	Если МассивПользователей = Неопределено Тогда
		Запрос.Текст =
		"ВЫБРАТЬ
		|	Пользователи.Ссылка КАК Пользователь,
		|	Пользователи.ИдентификаторПользователяИБ
		|ПОМЕСТИТЬ ПроверяемыеПользователи
		|ИЗ
		|	Справочник.Пользователи КАК Пользователи
		|ГДЕ
		|	Пользователи.Служебный = ЛОЖЬ
		|	И Пользователи.ИдентификаторПользователяИБ <> &ПустойИдентификатор
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	ВнешниеПользователи.Ссылка,
		|	ВнешниеПользователи.ИдентификаторПользователяИБ
		|ИЗ
		|	Справочник.ВнешниеПользователи КАК ВнешниеПользователи
		|ГДЕ
		|	ВнешниеПользователи.ИдентификаторПользователяИБ <> &ПустойИдентификатор";
		
	ИначеЕсли ТипЗнч(МассивПользователей) = Тип("Тип") Тогда
		Если Метаданные.НайтиПоТипу(МассивПользователей) = Метаданные.Справочники.ВнешниеПользователи Тогда
			Запрос.Текст =
			"ВЫБРАТЬ
			|	ВнешниеПользователи.Ссылка КАК Пользователь,
			|	ВнешниеПользователи.ИдентификаторПользователяИБ
			|ПОМЕСТИТЬ ПроверяемыеПользователи
			|ИЗ
			|	Справочник.ВнешниеПользователи КАК ВнешниеПользователи
			|ГДЕ
			|	ВнешниеПользователи.ИдентификаторПользователяИБ <> &ПустойИдентификатор";
		Иначе
			Запрос.Текст =
			"ВЫБРАТЬ
			|	Пользователи.Ссылка КАК Пользователь,
			|	Пользователи.ИдентификаторПользователяИБ
			|ПОМЕСТИТЬ ПроверяемыеПользователи
			|ИЗ
			|	Справочник.Пользователи КАК Пользователи
			|ГДЕ
			|	Пользователи.Служебный = ЛОЖЬ
			|	И Пользователи.ИдентификаторПользователяИБ <> &ПустойИдентификатор";
		КонецЕсли;
	Иначе
		ИсходныеПользователи = Новый ТаблицаЗначений;
		ИсходныеПользователи.Колонки.Добавить("Пользователь", Новый ОписаниеТипов(
			"СправочникСсылка.Пользователи, СправочникСсылка.ВнешниеПользователи"));
		
		Для каждого Пользователь Из МассивПользователей Цикл
			ИсходныеПользователи.Добавить().Пользователь = Пользователь;
		КонецЦикла;
		
		Запрос.УстановитьПараметр("ИсходныеПользователи", ИсходныеПользователи);
		Запрос.Текст =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ИсходныеПользователи.Пользователь
		|ПОМЕСТИТЬ ИсходныеПользователи
		|ИЗ
		|	&ИсходныеПользователи КАК ИсходныеПользователи
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	Пользователи.Ссылка КАК Пользователь,
		|	Пользователи.ИдентификаторПользователяИБ
		|ПОМЕСТИТЬ ПроверяемыеПользователи
		|ИЗ
		|	Справочник.Пользователи КАК Пользователи
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ИсходныеПользователи КАК ИсходныеПользователи
		|		ПО Пользователи.Ссылка = ИсходныеПользователи.Пользователь
		|			И (Пользователи.Служебный = ЛОЖЬ)
		|			И (Пользователи.ИдентификаторПользователяИБ <> &ПустойИдентификатор)
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	ВнешниеПользователи.Ссылка,
		|	ВнешниеПользователи.ИдентификаторПользователяИБ
		|ИЗ
		|	Справочник.ВнешниеПользователи КАК ВнешниеПользователи
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ИсходныеПользователи КАК ИсходныеПользователи
		|		ПО ВнешниеПользователи.Ссылка = ИсходныеПользователи.Пользователь
		|			И (ВнешниеПользователи.ИдентификаторПользователяИБ <> &ПустойИдентификатор)";
	КонецЕсли;
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	Пользователи.Ссылка КАК Ссылка,
	|	Пользователи.ИдентификаторПользователяИБ
	|ИЗ
	|	Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Пользователи КАК Пользователи
	|		ПО (ГруппыДоступаПользователи.Ссылка = ЗНАЧЕНИЕ(Справочник.ГруппыДоступа.Администраторы))
	|			И ГруппыДоступаПользователи.Пользователь = Пользователи.Ссылка
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ПроверяемыеПользователи.Пользователь,
	|	ПроверяемыеПользователи.ИдентификаторПользователяИБ
	|ИЗ
	|	ПроверяемыеПользователи КАК ПроверяемыеПользователи
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ПроверяемыеПользователи.Пользователь КАК Пользователь,
	|	ГруппыДоступаПользователи.Ссылка.Профиль КАК Профиль
	|ПОМЕСТИТЬ ПрофилиПользователей
	|ИЗ
	|	ПроверяемыеПользователи КАК ПроверяемыеПользователи
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|		ПО ПроверяемыеПользователи.Пользователь = СоставыГруппПользователей.Пользователь
	|			И (СоставыГруппПользователей.Используется)
	|			И (&ИсключитьВнешнихПользователей)
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|		ПО (СоставыГруппПользователей.ГруппаПользователей = ГруппыДоступаПользователи.Пользователь)
	|			И (НЕ ГруппыДоступаПользователи.Ссылка.ПометкаУдаления)
	|			И (НЕ ГруппыДоступаПользователи.Ссылка.Профиль.ПометкаУдаления)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ПрофилиПользователей.Пользователь,
	|	Роли.Роль КАК РольСсылка,
	|	Роли.Роль.Имя КАК Роль
	|ИЗ
	|	ПрофилиПользователей КАК ПрофилиПользователей
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ПрофилиГруппДоступа.Роли КАК Роли
	|		ПО (Роли.Ссылка = ПрофилиПользователей.Профиль)
	|ГДЕ
	|	Роли.Роль <> НЕОПРЕДЕЛЕНО";
	
	Запрос.Текст = Запрос.Текст + "
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|" + ТекстЗапроса;
	
	Если Константы.ИспользоватьВнешнихПользователей.Получить() Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИсключитьВнешнихПользователей", "Истина");
	Иначе
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИсключитьВнешнихПользователей",
			"ТИПЗНАЧЕНИЯ(ПроверяемыеПользователи.Пользователь) = ТИП(Справочник.Пользователи)");
	КонецЕсли;
	
	РезультатыЗапросов = Запрос.ВыполнитьПакет();
	ПоследнийРезультат = РезультатыЗапросов.Количество()-1;
	Итог = Новый Структура;
	
	Итог.Вставить("Администраторы", Новый Соответствие);
	
	Для каждого Строка Из РезультатыЗапросов[ПоследнийРезультат-3].Выгрузить() Цикл
		Итог.Администраторы.Вставить(Строка.Ссылка, Истина);
	КонецЦикла;
	
	Итог.Вставить("ИдентификаторыПользователейИБ", РезультатыЗапросов[ПоследнийРезультат-2].Выгрузить());
	Итог.ИдентификаторыПользователейИБ.Индексы.Добавить("Пользователь");
	
	Итог.Вставить("РолиПользователей", РезультатыЗапросов[ПоследнийРезультат].Выгрузить());
	Итог.РолиПользователей.Индексы.Добавить("Пользователь");
	
	РолиВсехПользователей = Итог.РолиПользователей.Скопировать(, "РольСсылка");
	РолиВсехПользователей.Свернуть("РольСсылка");
	ИдентификаторыРолей = РолиВсехПользователей.ВыгрузитьКолонку("РольСсылка");
	МетаданныеРолей = ОбщегоНазначения.ОбъектыМетаданныхПоИдентификаторам(ИдентификаторыРолей, Ложь);
	
	Для Каждого Строка Из Итог.РолиПользователей Цикл
		МетаданныеРоли = МетаданныеРолей.Получить(Строка.РольСсылка);
		Если ТипЗнч(МетаданныеРоли) = Тип("ОбъектМетаданных") Тогда
			Строка.Роль = МетаданныеРоли.Имя;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Итог;
	
КонецФункции

Процедура ЗарегистрироватьНедоступнуюРоль(ОписаниеРоли, Пользователь)
	
	// Недоступные роли в профилях.
	Профили = ПрофилиПользователяСРолью(Пользователь, ОписаниеРоли.РольСсылка);
	
	Для Каждого Профиль Из Профили Цикл
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Управление доступом.Роль не доступна пользователю'",
			     ОбщегоНазначения.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка,
			Метаданные.Справочники.ПрофилиГруппДоступа,
			Профиль,
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'При обновлении ролей пользователя ""%1""
				          |роль ""%2""
				          |профиля групп доступа ""%3""
				          |недоступна пользователю.'"),
				Строка(Пользователь),
				ОписаниеРоли.Роль,
				Строка(Профиль)),
			РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная);
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗарегистрироватьНенайденнуюРоль(ОписаниеРоли, Пользователь)
	
	// Новые роли не найденные в метаданных.
	Профили = ПрофилиПользователяСРолью(Пользователь, ОписаниеРоли.РольСсылка);
	
	Для Каждого Профиль Из Профили Цикл
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Управление доступом.Роль не найдена в метаданных'",
			     ОбщегоНазначения.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка,
			Метаданные.Справочники.ПрофилиГруппДоступа,
			Профиль,
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'При обновлении ролей пользователя ""%1""
				          |роль ""%2""
				          |профиля групп доступа ""%3""
				          |не найдена в метаданных.'"),
				Строка(Пользователь),
				ОписаниеРоли.Роль,
				Строка(Профиль)),
			РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная);
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбновитьРолиПользователейИБ(ОбновляемыеПользователиИБ, ПарольПользователяСервиса)
	
	СтандартныеПодсистемыСервер.ПроверитьДинамическоеОбновлениеВерсииПрограммы();
	
	Для Каждого КлючИЗначение Из ОбновляемыеПользователиИБ Цикл
		РолиДляДобавления  = КлючИЗначение.Значение.РолиДляДобавления;
		РолиДляУдаления    = КлючИЗначение.Значение.РолиДляУдаления;
		ПользовательИБ     = КлючИЗначение.Значение.ПользовательИБ;
		ПользовательСсылка = КлючИЗначение.Значение.ПользовательСсылка;
		
		БылиПолныеПрава = ПользовательИБ.Роли.Содержит(Метаданные.Роли.ПолныеПрава);
		
		Для каждого КлючИЗначение Из РолиДляДобавления Цикл
			ПользовательИБ.Роли.Добавить(Метаданные.Роли[КлючИЗначение.Ключ]);
		КонецЦикла;
		
		Для каждого КлючИЗначение Из РолиДляУдаления Цикл
			ПользовательИБ.Роли.Удалить(Метаданные.Роли[КлючИЗначение.Ключ]);
		КонецЦикла;
		
		НачатьТранзакцию();
		Попытка
			ЗаписатьПользователяПриОбновленииРолей(ПользовательСсылка,
				ПользовательИБ, БылиПолныеПрава, ПарольПользователяСервиса);
			
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
	КонецЦикла;
	
КонецПроцедуры

Процедура ОтключитьУВсехРасширенийФлажокИспользоватьОсновныеРолиДляВсехПользователей()
	
	Отбор = Новый Структура("ИспользоватьОсновныеРолиДляВсехПользователей", Истина);
	Расширения = РасширенияКонфигурации.Получить(Отбор);
	РазделениеВключено = ОбщегоНазначения.РазделениеВключено();
	ТекущаяОбластьДействия = ?(ОбщегоНазначения.ДоступноИспользованиеРазделенныхДанных(),
		ОбластьДействияРасширенияКонфигурации.РазделениеДанных,
		ОбластьДействияРасширенияКонфигурации.ИнформационнаяБаза);
	
	Для Каждого Расширение Из Расширения Цикл
		Если Не Расширение.ИспользоватьОсновныеРолиДляВсехПользователей
		 Или РазделениеВключено
		   И Расширение.ОбластьДействия <> ТекущаяОбластьДействия Тогда
			Продолжить;
		КонецЕсли;
		Справочники.ВерсииРасширений.ОтключитьИспользованиеОсновныхРолейДляВсехПользователей(Расширение);
		// АПК:280-выкл - №499.3.4 Допустимо пропустить обработку исключения, так как
		// это не останавливающая операция и будет выполнена успешно при очередном обновлении ролей.
		// Запись расширения не является транзакционной операцией, поэтому не создает ошибок в транзакции.
		Попытка
			Расширение.Записать();
		Исключение
			// Обработка не требуется.
		КонецПопытки;
		// АПК:280-вкл.
	КонецЦикла;
	
КонецПроцедуры

// Для процедур ЗарегистрироватьНедоступнуюРоль, ЗарегистрироватьНенайденнуюРоль.
Функция ПрофилиПользователяСРолью(Пользователь, Роль)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ТекущийПользователь", Пользователь);
	Запрос.УстановитьПараметр("Роль", Роль);
	
	Запрос.УстановитьПараметр("ПустойИдентификатор",
		ОбщегоНазначенияКлиентСервер.ПустойУникальныйИдентификатор());
	
	Запрос.Текст =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	Роли.Ссылка КАК Профиль
	|ИЗ
	|	РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|		ПО (СоставыГруппПользователей.Пользователь = &ТекущийПользователь)
	|			И СоставыГруппПользователей.ГруппаПользователей = ГруппыДоступаПользователи.Пользователь
	|			И (СоставыГруппПользователей.Используется)
	|			И (НЕ ГруппыДоступаПользователи.Ссылка.ПометкаУдаления)
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ПрофилиГруппДоступа.Роли КАК Роли
	|		ПО (Роли.Ссылка = ГруппыДоступаПользователи.Ссылка.Профиль)
	|			И (НЕ Роли.Ссылка.ПометкаУдаления)
	|			И (Роли.Роль = &Роль)";
	
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Профиль");
	
КонецФункции

// Для процедуры ОбновитьРолиПользователейИБ.
Процедура ЗаписатьПользователяПриОбновленииРолей(ПользовательСсылка, ПользовательИБ, БылиПолныеПрава, ПарольПользователяСервиса)
	
	ПользователиСлужебный.ЗаписатьПользователяИнформационнойБазы(ПользовательИБ, 
		ТипЗнч(ПользовательСсылка) = Тип("СправочникСсылка.ВнешниеПользователи"));
	
	Если Не ОбщегоНазначения.РазделениеВключено() Тогда
		Возврат;
	КонецЕсли;
	
	ЕстьПолныеПрава = ПользовательИБ.Роли.Содержит(Метаданные.Роли.ПолныеПрава);
	Если ЕстьПолныеПрава = БылиПолныеПрава Тогда
		Возврат;
	КонецЕсли;
	
	Если ПарольПользователяСервиса = Неопределено Тогда
		Если ОбщегоНазначения.ПодсистемаСуществует("ТехнологияСервиса.БазоваяФункциональность") Тогда
			МодульРаботаВМоделиСервиса = ОбщегоНазначения.ОбщийМодуль("РаботаВМоделиСервиса");
			СеансЗапущенБезРазделителей = МодульРаботаВМоделиСервиса.СеансЗапущенБезРазделителей();
		Иначе
			СеансЗапущенБезРазделителей = Истина;
		КонецЕсли;
		Если СеансЗапущенБезРазделителей Тогда
			Возврат;
		КонецЕсли;
		
		ТекстОшибки =
			НСтр("ru = 'Для изменения административного доступа
			           |требуется пароль пользователя сервиса.
			           |
			           |Операция может быть выполнена только интерактивно.'");
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса.ПользователиВМоделиСервиса") Тогда
		МодульПользователиСлужебныйВМоделиСервиса = ОбщегоНазначения.ОбщийМодуль("ПользователиСлужебныйВМоделиСервиса");
		МодульПользователиСлужебныйВМоделиСервиса.ЗаписатьПользователяСервиса(ПользовательСсылка, Ложь, ПарольПользователяСервиса);
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ТекстЗапросаВыбораИзменений.

Функция КлючИЗначение(Структура)
	
	Для каждого КлючИЗначение Из Структура Цикл
		Возврат КлючИЗначение;
	КонецЦикла;
	
КонецФункции

// Для процедур ОбновитьНаборЗаписей, ОбновитьНовыеЗаписиНабораПоРазличнымНовымЗаписям.

Процедура ЗаписатьОбъектИлиНаборЗаписей(Данные, ОбъектИлиНаборЗаписей)
	
	Если Данные.ОбновлениеИБ Тогда
		ОбновлениеИнформационнойБазы.ЗаписатьДанные(ОбъектИлиНаборЗаписей);
	Иначе
		ОбъектИлиНаборЗаписей.Записать();
	КонецЕсли;
	
КонецПроцедуры

// Для процедур ОбновитьНаборЗаписей и ОбновитьНаборыЗаписей.

Функция ГруппаПараметровИзмеренияОбработана(ИмяИзмерения, ЗначенияИзмерения)
	
	Если ИмяИзмерения = Неопределено Тогда
		ЗначенияИзмерения = Неопределено;
		
	ИначеЕсли ЗначенияИзмерения = Неопределено Тогда
		ИмяИзмерения = Неопределено;
		
	ИначеЕсли ТипЗнч(ЗначенияИзмерения) <> Тип("Массив")
	        И ТипЗнч(ЗначенияИзмерения) <> Тип("ФиксированныйМассив") Тогда
		
		ЗначениеИзмерения = ЗначенияИзмерения;
		ЗначенияИзмерения = Новый Массив;
		ЗначенияИзмерения.Добавить(ЗначениеИзмерения);
		
	ИначеЕсли ЗначенияИзмерения.Количество() = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Процедура УпорядочитьГруппыПараметровИзмерений(Данные)
	
	Если Данные.ИмяВторогоИзмерения = Неопределено Тогда
		Данные.ИмяВторогоИзмерения       = Данные.ИмяТретьегоИзмерения;
		Данные.ЗначенияВторогоИзмерения  = Данные.ЗначенияТретьегоИзмерения;
		Данные.ИмяТретьегоИзмерения      = Неопределено;
		Данные.ЗначенияТретьегоИзмерения = Неопределено;
	КонецЕсли;
	
	Если Данные.ИмяПервогоИзмерения = Неопределено Тогда
		Данные.ИмяПервогоИзмерения       = Данные.ИмяВторогоИзмерения;
		Данные.ЗначенияПервогоИзмерения  = Данные.ЗначенияВторогоИзмерения;
		Данные.ИмяВторогоИзмерения       = Данные.ИмяТретьегоИзмерения;
		Данные.ЗначенияВторогоИзмерения  = Данные.ЗначенияТретьегоИзмерения;
		Данные.ИмяТретьегоИзмерения      = Неопределено;
		Данные.ЗначенияТретьегоИзмерения = Неопределено;
	КонецЕсли;
	
	Если Данные.ЗначенияВторогоИзмерения  <> Неопределено
	   И Данные.ЗначенияТретьегоИзмерения <> Неопределено
	   И Данные.ЗначенияВторогоИзмерения.Количество()
	   > Данные.ЗначенияТретьегоИзмерения.Количество() Тогда
		
		ИмяИзмерения      = Данные.ИмяВторогоИзмерения;
		ЗначенияИзмерения = Данные.ЗначенияВторогоИзмерения;
		
		Данные.ИмяВторогоИзмерения       = Данные.ИмяТретьегоИзмерения;
		Данные.ЗначенияВторогоИзмерения  = Данные.ЗначенияТретьегоИзмерения;
		Данные.ИмяТретьегоИзмерения      = ИмяИзмерения;
		Данные.ЗначенияТретьегоИзмерения = ЗначенияИзмерения;
	КонецЕсли;
	
	Если Данные.ЗначенияПервогоИзмерения <> Неопределено
	   И Данные.ЗначенияВторогоИзмерения <> Неопределено
	   И Данные.ЗначенияПервогоИзмерения.Количество()
	   > Данные.ЗначенияВторогоИзмерения.Количество() Тогда
		
		ИмяИзмерения      = Данные.ИмяПервогоИзмерения;
		ЗначенияИзмерения = Данные.ЗначенияПервогоИзмерения;
		
		Данные.ИмяПервогоИзмерения      = Данные.ИмяВторогоИзмерения;
		Данные.ЗначенияПервогоИзмерения = Данные.ЗначенияВторогоИзмерения;
		Данные.ИмяВторогоИзмерения      = ИмяИзмерения;
		Данные.ЗначенияВторогоИзмерения = ЗначенияИзмерения;
	КонецЕсли;
	
КонецПроцедуры

Функция ПоляНабораЗаписей(НаборЗаписей)
	
	ПоляСравнения = "";
	Таблица = НаборЗаписей.Выгрузить(Новый Массив);
	Для каждого Колонка Из Таблица.Колонки Цикл
		ПоляСравнения = ПоляСравнения + "," + Колонка.Имя;
	КонецЦикла;
	ПоляСравнения = Сред(ПоляСравнения, 2);
	
	Возврат ПоляСравнения;
	
КонецФункции

Процедура ОбновитьНовыеЗаписиНабораПоВсемНовымЗаписям(Знач Данные, Знач Отбор, Знач СписокПолей,
				Знач ИмяИзмерения, Знач ЗначенияИзмерения, ЕстьИзменения)
	
	ЗаблокироватьОбластьНабораЗаписей(Данные.НаборЗаписей, Данные.ПолноеИмяРегистра);
	
	Данные.НаборЗаписей.Прочитать();
	НовыеЗаписиНабора = Данные.НаборЗаписей.Выгрузить();
	НовыеЗаписиНабора.Индексы.Добавить(СписокПолей);
	
	Для каждого Значение Из ЗначенияИзмерения Цикл
		Отбор[ИмяИзмерения] = Значение;
		Для каждого НайденнаяЗапись Из НовыеЗаписиНабора.НайтиСтроки(Отбор) Цикл
			НовыеЗаписиНабора.Удалить(НайденнаяЗапись);
		КонецЦикла;
		Для каждого НайденнаяЗапись Из Данные.НовыеЗаписи.НайтиСтроки(Отбор) Цикл
			ЗаполнитьЗначенияСвойств(НовыеЗаписиНабора.Добавить(), НайденнаяЗапись);
		КонецЦикла;
	КонецЦикла;
	
	ТекущиеДанные = Новый Структура("НаборЗаписей, ПоляСравнения,
		|ТолькоПроверка, ДополнительныеСвойства, ОбновлениеИБ");
	ЗаполнитьЗначенияСвойств(ТекущиеДанные, Данные);
	ТекущиеДанные.Вставить("НовыеЗаписи", НовыеЗаписиНабора);
	ТекущиеДанные.Вставить("НаборЗаписейПрочитан", Истина);
	
	ОбновитьНаборЗаписей(ТекущиеДанные, ЕстьИзменения);
	
КонецПроцедуры

Процедура ОбновитьНовыеЗаписиНабораПоРазличнымНовымЗаписям(Знач Данные, Знач Отбор, ЕстьИзменения)
	
	// Получение количества записей для чтения.
	
	Если Отбор.Количество() = 0 Тогда
		ТекущиеНовыеЗаписи = Данные.НовыеЗаписи.Скопировать();
		КоличествоДляЧтения = Данные.КоличествоДляЧтения;
	Иначе
		ТекущиеНовыеЗаписи = Данные.НовыеЗаписи.Скопировать(Отбор);
		
		ИмяПоля = Данные.КоличествоПоЗначениям.Колонки[0].Имя;
		СтрокаКоличества = Данные.КоличествоПоЗначениям.Найти(Отбор[ИмяПоля], ИмяПоля);
		КоличествоДляЧтения = ?(СтрокаКоличества = Неопределено, 0, СтрокаКоличества.Количество);
	КонецЕсли;
	
	ОтборНовойЗаписи = Новый Структура("ВидИзмененияСтроки, " + Данные.ПоляСравнения, 1);
	ТекущиеНовыеЗаписи.Индексы.Добавить("ВидИзмененияСтроки, " + Данные.ПоляСравнения);

	КлючиЗаписей = ТекущиеНовыеЗаписи.Скопировать(, "ВидИзмененияСтроки, " + Данные.ПоляСравнения);
	КлючиЗаписей.Свернуть("ВидИзмененияСтроки, " + Данные.ПоляСравнения);
	КлючиЗаписей.Свернуть(Данные.ПоляСравнения, "ВидИзмененияСтроки");
	
	ОтборПоКлючуЗаписи = Новый Структура(Данные.ПоляСравнения);
	
	Если ОбновлятьНаборЗаписейЦеликом(КоличествоДляЧтения, КлючиЗаписей) Тогда
		
		ЗаблокироватьОбластьНабораЗаписей(Данные.НаборЗаписей, Данные.ПолноеИмяРегистра);
		Данные.НаборЗаписей.Прочитать();
		НовыеЗаписиНабора = Данные.НаборЗаписей.Выгрузить();
		НовыеЗаписиНабора.Индексы.Добавить(Данные.ПоляСравнения);
		
		Для каждого Строка Из КлючиЗаписей Цикл
			ЗаполнитьЗначенияСвойств(ОтборПоКлючуЗаписи, Строка);
			НайденныеСтроки = НовыеЗаписиНабора.НайтиСтроки(ОтборПоКлючуЗаписи);
			Если Строка.ВидИзмененияСтроки = -1 Тогда
				Если НайденныеСтроки.Количество() > 0 Тогда
					// Удаление старой строки.
					НовыеЗаписиНабора.Удалить(НайденныеСтроки[0]);
				КонецЕсли;
			Иначе
				// Добавление новой или обновление старой строки.
				Если НайденныеСтроки.Количество() = 0 Тогда
					ЗаполняемаяСтрока = НовыеЗаписиНабора.Добавить();
				Иначе
					ЗаполняемаяСтрока = НайденныеСтроки[0];
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(ОтборНовойЗаписи, ОтборПоКлючуЗаписи);
				НайденныеЗаписи = ТекущиеНовыеЗаписи.НайтиСтроки(ОтборНовойЗаписи);
				Если НайденныеЗаписи.Количество() = 1 Тогда
					НоваяЗапись = НайденныеЗаписи[0];
				Иначе // Ошибка в параметре НовыеЗаписи.
					ИсключениеПриОшибкеПоискаЗаписи(Данные);
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(ЗаполняемаяСтрока, НоваяЗапись);
			КонецЕсли;
		КонецЦикла;
		// Изменение набора записей, чтобы он отличался от новых записей набора.
		Если Данные.НаборЗаписей.Количество() = НовыеЗаписиНабора.Количество() Тогда
			Данные.НаборЗаписей.Добавить();
		КонецЕсли;
		
		ТекущиеДанные = Новый Структура("НаборЗаписей, ПоляСравнения,
			|ТолькоПроверка, ДополнительныеСвойства, ОбновлениеИБ");
		ЗаполнитьЗначенияСвойств(ТекущиеДанные, Данные);
		ТекущиеДанные.Вставить("НовыеЗаписи", НовыеЗаписиНабора);
		ТекущиеДанные.Вставить("НаборЗаписейПрочитан", Истина);
		
		ОбновитьНаборЗаписей(ТекущиеДанные, ЕстьИзменения);
	Иначе
		// Построчное обновление.
		УстановитьДополнительныеСвойства(Данные.НаборДляОднойЗаписи, Данные.ДополнительныеСвойства);
		Для каждого Строка Из КлючиЗаписей Цикл
			Данные.НаборДляОднойЗаписи.Очистить();
			ЗаполнитьЗначенияСвойств(ОтборПоКлючуЗаписи, Строка);
			Для каждого КлючИЗначение Из ОтборПоКлючуЗаписи Цикл
				УстановитьОтбор(
					Данные.НаборДляОднойЗаписи.Отбор[КлючИЗначение.Ключ], КлючИЗначение.Значение);
			КонецЦикла;
			ЗаблокироватьОбластьНабораЗаписей(Данные.НаборДляОднойЗаписи, Данные.ПолноеИмяРегистра);
			Если Строка.ВидИзмененияСтроки > -1 Тогда
				// Добавление новой или обновление существующей строки.
				ЗаполнитьЗначенияСвойств(ОтборНовойЗаписи, ОтборПоКлючуЗаписи);
				НайденныеЗаписи = ТекущиеНовыеЗаписи.НайтиСтроки(ОтборНовойЗаписи);
				Если НайденныеЗаписи.Количество() = 1 Тогда
					НоваяЗапись = НайденныеЗаписи[0];
				Иначе // Ошибка в параметре НовыеЗаписи.
					ИсключениеПриОшибкеПоискаЗаписи(Данные);
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(Данные.НаборДляОднойЗаписи.Добавить(), НоваяЗапись);
			КонецЕсли;
			ЕстьИзменения = Истина;
			Если Данные.ТолькоПроверка Тогда
				Возврат;
			КонецЕсли;
			ЗаписатьОбъектИлиНаборЗаписей(Данные, Данные.НаборДляОднойЗаписи);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ОбновитьНовыеЗаписиНабораПоРазличнымНовымЗаписям.
Функция ОбновлятьНаборЗаписейЦеликом(КоличествоДляЧтения, КлючиЗаписей)
	
	Если КоличествоДляЧтения > 10000 Тогда
		Возврат Ложь; // Слишком большой набор записей.
	КонецЕсли;
	
	КоличествоУдаляемых = КлючиЗаписей.НайтиСтроки(
		Новый Структура("ВидИзмененияСтроки", -1)).Количество();
	
	КоличествоДобавляемых = КлючиЗаписей.НайтиСтроки(
		Новый Структура("ВидИзмененияСтроки", 1)).Количество();
	
	КоличествоДляЗаписи = КоличествоДляЧтения - КоличествоУдаляемых
		+ КоличествоДобавляемых;
	
	Если КоличествоДляЗаписи > 10000 Тогда
		Возврат Ложь; // Слишком большой набор записей.
	КонецЕсли;
	
	КоличествоИзменяемых = КлючиЗаписей.Количество()
		- (КоличествоУдаляемых + КоличествоДобавляемых);
	
	КоличествоНеизменных = КоличествоДляЧтения
		- (КоличествоУдаляемых + КоличествоИзменяемых);
	
	ЗатратыНаПерезаписьЦеликом =
	//                Операции:   |Чтение|Удаление|Вставка|
	      КоличествоУдаляемых   * ( 0.05  +  0.1          )
	    + КоличествоИзменяемых  * ( 0.05  +  0.1   +  1   )
	    + КоличествоДобавляемых * (                   1   )
	    + КоличествоНеизменных  * ( 0.05  +  0.1   +  1   );
	
	ЗатратыНаПерезаписьПоОднойЗаписи =
	//                Операции:   |Удаление|Вставка|
	      КоличествоУдаляемых   * (   0.5          )
	    + КоличествоИзменяемых  * (   0.5  +  1.2  )
	    + КоличествоДобавляемых * (   0.5  +  1.2  );
	
	Возврат ЗатратыНаПерезаписьЦеликом < ЗатратыНаПерезаписьПоОднойЗаписи;
	
КонецФункции

Процедура ИсключениеПриОшибкеПоискаЗаписи(Параметры)
	
	Для каждого СтрокаИзменений Из Параметры.НовыеЗаписи Цикл
		Если СтрокаИзменений.ВидИзмененияСтроки <>  1
		   И СтрокаИзменений.ВидИзмененияСтроки <> -1 Тогда
			
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка в процедуре ОбновитьНаборыЗаписей
				           |общего модуля УправлениеДоступомСлужебный.
				           |
				           |Неверное значение параметра НовыеЗаписи - колонка
				           |ВидИзмененияСтроки содержит недопустимое значение ""%1"".
				           |
				           |Допустимо только 2 значения: ""1"" и ""-1"".'"),
				Строка(СтрокаИзменений.ВидИзмененияСтроки));
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
	КонецЦикла;
	
	ТекстОшибки =
		НСтр("ru = 'Ошибка в процедуре ОбновитьНаборыЗаписей
		           |общего модуля УправлениеДоступомСлужебный.
		           |
		           |Не удалось найти требуемую в строку
		           |в значении параметра НовыеЗаписи.'");
	
	ВызватьИсключение ТекстОшибки;
	
КонецПроцедуры

Процедура ЗаблокироватьОбластьНабораЗаписей(НаборЗаписей, ПолноеИмяРегистра = Неопределено)
	
	Если НЕ ТранзакцияАктивна() Тогда
		Возврат;
	КонецЕсли;
	
	Если ПолноеИмяРегистра = Неопределено Тогда
		ПолноеИмяРегистра = Метаданные.НайтиПоТипу(ТипЗнч(НаборЗаписей)).ПолноеИмя();
	КонецЕсли;
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить(ПолноеИмяРегистра);
	Для каждого ЭлементОтбора Из НаборЗаписей.Отбор Цикл
		Если ЭлементОтбора.Использование Тогда
			ЭлементБлокировки.УстановитьЗначение(ЭлементОтбора.ПутьКДанным, ЭлементОтбора.Значение);
		КонецЕсли;
	КонецЦикла;
	Блокировка.Заблокировать();
	
КонецПроцедуры

Процедура УстановитьОтбор(ЭлементОтбора, ЗначениеОтбора)
	
	ЭлементОтбора.Значение = ЗначениеОтбора;
	ЭлементОтбора.Использование = Истина;
	
КонецПроцедуры

Функция ЗаписьНесколькимиНаборами(Данные, Отбор, ИмяПоля, ЗначенияПоля)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ЗначенияПоля", ЗначенияПоля);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	КОЛИЧЕСТВО(*) КАК Количество
	|ИЗ
	|	&ТекущаяТаблица КАК ТекущаяТаблица
	|ГДЕ
	|	&УсловиеОтбора
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	КОЛИЧЕСТВО(*) КАК Количество
	|ИЗ
	|	&ТекущаяТаблица КАК ТекущаяТаблица
	|ГДЕ
	|	ТекущаяТаблица.ИмяПоля В(&ЗначенияПоля)
	|	И &УсловиеОтбора
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТекущаяТаблица.ИмяПоля КАК ИмяПоля,
	|	КОЛИЧЕСТВО(*) КАК Количество
	|ИЗ
	|	&ТекущаяТаблица КАК ТекущаяТаблица
	|ГДЕ
	|	ТекущаяТаблица.ИмяПоля В(&ЗначенияПоля)
	|	И &УсловиеОтбора
	|
	|СГРУППИРОВАТЬ ПО
	|	ТекущаяТаблица.ИмяПоля";
	
	УсловиеОтбора = "Истина";
	Если Данные.ФиксированныйОтбор <> Неопределено Тогда
		Для каждого КлючИЗначение Из Данные.ФиксированныйОтбор Цикл
			УсловиеОтбора = УсловиеОтбора + "
			|	И ТекущаяТаблица." + КлючИЗначение.Ключ + " = &" + КлючИЗначение.Ключ;
			Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	
	ОтборДобавляемых = Новый Структура;
	ОтборДобавляемых.Вставить("ВидИзмененияСтроки", 1);
	ОтборУдаляемых = Новый Структура;
	ОтборУдаляемых.Вставить("ВидИзмененияСтроки", -1);
	
	Для каждого КлючИЗначение Из Отбор Цикл
		УсловиеОтбора = УсловиеОтбора + "
		|	И ТекущаяТаблица." + КлючИЗначение.Ключ + " = &" + КлючИЗначение.Ключ;
		Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		ОтборДобавляемых.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		ОтборУдаляемых.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ИмяПоля", ИмяПоля);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ТекущаяТаблица", Данные.ПолноеИмяРегистра);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеОтбора", УсловиеОтбора);
	
	РезультатыЗапросов = Запрос.ВыполнитьПакет();
	
	// Количество всех без отбора.
	КоличествоВсех = РезультатыЗапросов[0].Выгрузить()[0].Количество;
	Данные.Вставить("КоличествоДляЧтения", КоличествоВсех);
	
	// Количество обновляемых с отбором.
	КоличествоОбновляемых = РезультатыЗапросов[1].Выгрузить()[0].Количество;
	
	КоличествоДобавляемых = Данные.НовыеЗаписи.НайтиСтроки(ОтборДобавляемых).Количество();
	Если КоличествоДобавляемых > КоличествоОбновляемых Тогда
		КоличествоОбновляемых = КоличествоДобавляемых;
	КонецЕсли;
	
	КоличествоУдаляемых = Данные.НовыеЗаписи.НайтиСтроки(ОтборУдаляемых).Количество();
	Если КоличествоУдаляемых > КоличествоОбновляемых Тогда
		КоличествоОбновляемых = КоличествоУдаляемых;
	КонецЕсли;
	
	// Количество для чтения по значениям отбора.
	КоличествоПоЗначениям = РезультатыЗапросов[2].Выгрузить();
	КоличествоПоЗначениям.Индексы.Добавить(ИмяПоля);
	Данные.Вставить("КоличествоПоЗначениям", КоличествоПоЗначениям);
	
	Возврат КоличествоВсех * 0.7 > КоличествоОбновляемых;
	
КонецФункции

Процедура ПрочитатьКоличествоДляЧтения(Данные)
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	КОЛИЧЕСТВО(*) КАК Количество
	|ИЗ
	|	&ТекущаяТаблица КАК ТекущаяТаблица
	|ГДЕ
	|	&УсловиеОтбора";
	
	УсловиеОтбора = "Истина";
	Если Данные.ФиксированныйОтбор <> Неопределено Тогда
		Для каждого КлючИЗначение Из Данные.ФиксированныйОтбор Цикл
			УсловиеОтбора = УсловиеОтбора + "
			|	И ТекущаяТаблица." + КлючИЗначение.Ключ + " = &" + КлючИЗначение.Ключ;
			Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ТекущаяТаблица", Данные.ПолноеИмяРегистра);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеОтбора", УсловиеОтбора);
	
	Данные.Вставить("КоличествоДляЧтения", Запрос.Выполнить().Выгрузить()[0].Количество);
	
КонецПроцедуры

Процедура УстановитьДополнительныеСвойства(НаборЗаписей, ДополнительныеСвойства)
	
	Если ТипЗнч(ДополнительныеСвойства) = Тип("Структура") Тогда
		Для каждого КлючИЗначение Из ДополнительныеСвойства Цикл
			НаборЗаписей.ДополнительныеСвойства.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ОбновитьРегистрСведений.

Функция ЗначенияКолонкиТаблицы(Таблица, ИмяКолонки)
	
	НоваяТаблица = Таблица.Скопировать(, ИмяКолонки);
	
	НоваяТаблица.Свернуть(ИмяКолонки);
	
	Возврат НоваяТаблица.ВыгрузитьКолонку(ИмяКолонки);
	
КонецФункции

// Обслуживание таблиц ВидыДоступа и ЗначенияДоступа в формах редактирования.

Процедура ДобавитьРеквизитыВспомогательныхДанныхВФорму(Форма, ИмяРеквизитаХранилищаТаблиц)
	
	ДобавляемыеРеквизиты = Новый Массив;
	ОписаниеТиповЗначенийДоступа = Метаданные.ОпределяемыеТипы.ЗначениеДоступа.Тип;
	
	ПутьКОбъекту = ?(ЗначениеЗаполнено(ИмяРеквизитаХранилищаТаблиц), ИмяРеквизитаХранилищаТаблиц + ".", "");
	
	// Добавление реквизитов в таблицу ВидыДоступа.
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"Используется", Новый ОписаниеТипов("Булево"), ПутьКОбъекту + "ВидыДоступа"));
	
	// Добавление отдельных реквизитов.
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ТекущийВидДоступа", ОписаниеТиповЗначенийДоступа));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ТекущиеТипыВыбираемыхЗначений", Новый ОписаниеТипов("СписокЗначений")));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ТекущийТипВыбираемыхЗначений", ОписаниеТиповЗначенийДоступа));
	
	Если НЕ РеквизитФормыСуществует(Форма, "ИспользоватьВнешнихПользователей") Тогда
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
			"ИспользоватьВнешнихПользователей", Новый ОписаниеТипов("Булево")));
	КонецЕсли;
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ИмяРеквизитаХранилищаТаблиц", Новый ОписаниеТипов("Строка")));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ЭтоПрофильГруппДоступа", Новый ОписаниеТипов("Булево")));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ВидДоступаПользователи", ОписаниеТиповЗначенийДоступа));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ВидДоступаВнешниеПользователи", ОписаниеТиповЗначенийДоступа));
	
	// Добавление таблицы ВсеВидыДоступа.
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ВсеВидыДоступа", Новый ОписаниеТипов("ТаблицаЗначений")));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"Ссылка", ОписаниеТиповЗначенийДоступа, "ВсеВидыДоступа"));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"Представление", Новый ОписаниеТипов("Строка"), "ВсеВидыДоступа"));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"Используется", Новый ОписаниеТипов("Булево"), "ВсеВидыДоступа"));
	
	// Добавление таблицы ПредставленияВсеРазрешены.
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ПредставленияВсеРазрешены", Новый ОписаниеТипов("ТаблицаЗначений")));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"Имя", Новый ОписаниеТипов("Строка"), "ПредставленияВсеРазрешены"));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"Представление", Новый ОписаниеТипов("Строка"), "ПредставленияВсеРазрешены"));
	
	// Добавление таблицы ВсеТипыВыбираемыхЗначений.
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ВсеТипыВыбираемыхЗначений", Новый ОписаниеТипов("ТаблицаЗначений")));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ВидДоступа", ОписаниеТиповЗначенийДоступа, "ВсеТипыВыбираемыхЗначений"));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ТипЗначений", ОписаниеТиповЗначенийДоступа, "ВсеТипыВыбираемыхЗначений"));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ПредставлениеТипа", Новый ОписаниеТипов("Строка"), "ВсеТипыВыбираемыхЗначений"));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ИмяТаблицы", Новый ОписаниеТипов("Строка"), "ВсеТипыВыбираемыхЗначений"));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ИерархияЭлементов", Новый ОписаниеТипов("Булево"), "ВсеТипыВыбираемыхЗначений"));
	
	Форма.ИзменитьРеквизиты(ДобавляемыеРеквизиты);
	
КонецПроцедуры

Процедура ЗаполнитьТаблицуВсеВидыДоступаВФорме(Форма)
	
	Для Каждого СвойстваВидаДоступа Из СвойстваВидаДоступа() Цикл
		Строка = Форма.ВсеВидыДоступа.Добавить();
		Строка.Ссылка        = СвойстваВидаДоступа.Ссылка;
		Строка.Используется  = ВидДоступаИспользуется(Строка.Ссылка);
		// Обеспечение уникальности представлений.
		Представление = ПредставлениеВидаДоступа(СвойстваВидаДоступа);
		Если Не ЗначениеЗаполнено(Представление) Тогда
			Представление = Строка.Имя;
		КонецЕсли;
		Отбор = Новый Структура("Представление", Представление);
		Пока Форма.ВсеВидыДоступа.НайтиСтроки(Отбор).Количество() > 0 Цикл
			Отбор.Представление = Отбор.Представление + " ";
		КонецЦикла;
		Строка.Представление = Представление;
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьТаблицуПредставленияВсеРазрешеныВФорме(Форма, ЭтоПрофиль)
	
	Если ЭтоПрофиль Тогда
		Строка = Форма.ПредставленияВсеРазрешены.Добавить();
		Строка.Имя = "ВначалеВсеЗапрещены";
		Строка.Представление = НСтр("ru = 'Все запрещены, исключения назначаются в группах доступа'");
		
		Строка = Форма.ПредставленияВсеРазрешены.Добавить();
		Строка.Имя = "ВначалеВсеРазрешены";
		Строка.Представление = НСтр("ru = 'Все разрешены, исключения назначаются в группах доступа'");
		
		Строка = Форма.ПредставленияВсеРазрешены.Добавить();
		Строка.Имя = "ВсеЗапрещены";
		Строка.Представление = НСтр("ru = 'Все запрещены, исключения назначаются в профиле'");
		
		Строка = Форма.ПредставленияВсеРазрешены.Добавить();
		Строка.Имя = "ВсеРазрешены";
		Строка.Представление = НСтр("ru = 'Все разрешены, исключения назначаются в профиле'");
	Иначе
		Строка = Форма.ПредставленияВсеРазрешены.Добавить();
		Строка.Имя = "ВсеЗапрещены";
		Строка.Представление = НСтр("ru = 'Все запрещены'");
		
		Строка = Форма.ПредставленияВсеРазрешены.Добавить();
		Строка.Имя = "ВсеРазрешены";
		Строка.Представление = НСтр("ru = 'Все разрешены'");
	КонецЕсли;
	
	СписокВыбора = Форма.Элементы.ВидыДоступаВсеРазрешеныПредставление.СписокВыбора;
	
	Для каждого Строка Из Форма.ПредставленияВсеРазрешены Цикл
		СписокВыбора.Добавить(Строка.Представление);
	КонецЦикла;
	
КонецПроцедуры

Процедура ОформитьТаблицуВидыДоступаВФорме(Форма)
	
	Параметры = ПараметрыФормыРедактированияРазрешенныхЗначений(Форма);
	
	// Оформление отображения неиспользуемых видов доступа.
	ЭлементУсловногоОформления = Форма.УсловноеОформление.Элементы.Добавить();
	
	ЭлементЦветаОформления = ЭлементУсловногоОформления.Оформление.Элементы.Найти("TextColor");
	ЭлементЦветаОформления.Значение = WebЦвета.Серый;
	ЭлементЦветаОформления.Использование = Истина;
	
	ГруппаЭлементовОтбораДанных = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
	ГруппаЭлементовОтбораДанных.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
	ГруппаЭлементовОтбораДанных.Использование = Истина;
	
	ЭлементОтбораДанных = ГруппаЭлементовОтбораДанных.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ЭлементОтбораДанных.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных(Параметры.ПутьКТаблицам + "ВидыДоступа.ВидДоступа");
	ЭлементОтбораДанных.ВидСравнения   = ВидСравненияКомпоновкиДанных.НеРавно;
	ЭлементОтбораДанных.ПравоеЗначение = Неопределено;
	ЭлементОтбораДанных.Использование  = Истина;
	
	ЭлементОтбораДанных = ГруппаЭлементовОтбораДанных.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ЭлементОтбораДанных.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных(Параметры.ПутьКТаблицам + "ВидыДоступа.Используется");
	ЭлементОтбораДанных.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
	ЭлементОтбораДанных.ПравоеЗначение = Ложь;
	ЭлементОтбораДанных.Использование  = Истина;
	
	ЭлементОформляемогоПоля = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ЭлементОформляемогоПоля.Поле = Новый ПолеКомпоновкиДанных("ВидыДоступа");
	ЭлементОформляемогоПоля.Использование = Истина;
	
КонецПроцедуры

Процедура УдалитьЛишниеЗначенияДоступа(Форма, ТекущийОбъект = Неопределено)
	
	Параметры = ПараметрыФормыРедактированияРазрешенныхЗначений(Форма, ТекущийОбъект);
	
	СвойстваВидовДоступа = УправлениеДоступомСлужебныйПовтИсп.СвойстваВидовДоступа();
	ПоТипамГруппИЗначений = СвойстваВидовДоступа.ПоТипамГруппИЗначений;
	
	Отбор = УправлениеДоступомСлужебныйКлиентСервер.ОтборВТаблицахФормыРедактированияРазрешенныхЗначений(
		Форма, "");
	
	Индекс = Параметры.ЗначенияДоступа.Количество()-1;
	Пока Индекс >= 0 Цикл
		ЗначениеДоступа = Параметры.ЗначенияДоступа[Индекс].ЗначениеДоступа;
		
		СвойстваВидаДоступа = ПоТипамГруппИЗначений.Получить(ТипЗнч(ЗначениеДоступа));
		Если СвойстваВидаДоступа <> Неопределено Тогда
			ЗаполнитьЗначенияСвойств(Отбор, Параметры.ЗначенияДоступа[Индекс]);
			Отбор.Вставить("ВидДоступа", СвойстваВидаДоступа.Ссылка);
		КонецЕсли;
		
		Если СвойстваВидаДоступа = Неопределено
		 ИЛИ Параметры.ЗначенияДоступа[Индекс].ВидДоступа <> Отбор.ВидДоступа
		 ИЛИ Параметры.ВидыДоступа.НайтиСтроки(Отбор).Количество() = 0 Тогда
			
			Параметры.ЗначенияДоступа.Удалить(Индекс);
		КонецЕсли;
		Индекс = Индекс - 1;
	КонецЦикла;
	
КонецПроцедуры

Процедура УдалитьНесуществующиеВидыИЗначенияДоступа(Форма, ТекущийОбъект = Неопределено)
	
	Параметры = ПараметрыФормыРедактированияРазрешенныхЗначений(Форма, ТекущийОбъект);
	
	Индекс = Параметры.ВидыДоступа.Количество()-1;
	Пока Индекс >= 0 Цикл
		ВидДоступа = Параметры.ВидыДоступа[Индекс].ВидДоступа;
		Если СвойстваВидаДоступа(ВидДоступа) = Неопределено Тогда
			Параметры.ВидыДоступа.Удалить(Индекс);
		КонецЕсли;
		Индекс = Индекс - 1;
	КонецЦикла;
	
	УдалитьЛишниеЗначенияДоступа(Форма, ТекущийОбъект);
	
КонецПроцедуры

Функция ПараметрыФормыРедактированияРазрешенныхЗначений(Форма, ТекущийОбъект = Неопределено)
	
	Возврат УправлениеДоступомСлужебныйКлиентСервер.ПараметрыФормыРедактированияРазрешенныхЗначений(
		Форма, ТекущийОбъект);
	
КонецФункции

Функция РеквизитФормыСуществует(Форма, ИмяРеквизита)
	
	Структура = Новый Структура(ИмяРеквизита, Null);
	
	ЗаполнитьЗначенияСвойств(Структура, Форма);
	
	Возврат Структура[ИмяРеквизита] <> Null;
	
КонецФункции

// Для процедуры УстановкаПараметровСеанса.

Функция ВсеКомбинацииВидовДоступа(НеупорядоченныйМассивИмен)
	
	// Ограничение на максимальную длину комбинации, чтобы не допустить
	// перегрузку параметров сеанса и препроцессора шаблонов ОДД.
	МаксимальнаяДлинаКомбинации = 4;
	
	Список = Новый СписокЗначений;
	Если ТипЗнч(НеупорядоченныйМассивИмен) = Тип("ФиксированныйМассив") Тогда
		Список.ЗагрузитьЗначения(Новый Массив(НеупорядоченныйМассивИмен));
	Иначе
		Список.ЗагрузитьЗначения(НеупорядоченныйМассивИмен);
	КонецЕсли;
	Список.СортироватьПоЗначению();
	МассивИмен = Список.ВыгрузитьЗначения();
	
	ИтогСтроки = Новый Массив;
	ИтогСтрока = Новый Массив;
	
	// Полный список поддерживается всегда.
	Для каждого Имя Из МассивИмен Цикл
		ИтогСтрока.Добавить(Имя);
	КонецЦикла;
	
	ИтогСтроки.Добавить(ИтогСтрока);
	
	Если МассивИмен.Количество() < 3 Тогда
		Возврат ГруппыСтрокВСтроку(ИтогСтроки);
	КонецЕсли;
	
	ПервоеИмя = МассивИмен[0];
	МассивИмен.Удалить(0);
	
	ПоследнееИмя = МассивИмен[МассивИмен.Количество()-1];
	МассивИмен.Удалить(МассивИмен.Количество()-1);
	
	КоличествоИменВКомбинации = МассивИмен.Количество();
	
	Если КоличествоИменВКомбинации > 1 Тогда
		
		Если (КоличествоИменВКомбинации-1) <= МаксимальнаяДлинаКомбинации Тогда
			ДлинаКомбинации = КоличествоИменВКомбинации-1;
		Иначе
			ДлинаКомбинации = МаксимальнаяДлинаКомбинации;
		КонецЕсли;
		
		ПозицииИменВКомбинации = Новый Массив;
		Для Счетчик = 1 По ДлинаКомбинации Цикл
			ПозицииИменВКомбинации.Добавить(Счетчик);
		КонецЦикла;
		
		Пока ДлинаКомбинации > 0 Цикл
			Пока Истина Цикл
				// Добавление комбинации из текущих позиций.
				ИтогСтрока = Новый Массив;
				ИтогСтрока.Добавить(ПервоеИмя);
				Для Индекс = 0 По ДлинаКомбинации-1 Цикл
					ИтогСтрока.Добавить(МассивИмен[ПозицииИменВКомбинации[Индекс]-1]);
				КонецЦикла;
				ИтогСтрока.Добавить(ПоследнееИмя);
				ИтогСтроки.Добавить(ИтогСтрока);
				// Продвижение позиции в комбинации.
				Индекс = ДлинаКомбинации-1;
				Пока Индекс >= 0 Цикл
					Если ПозицииИменВКомбинации[Индекс] < КоличествоИменВКомбинации - (ДлинаКомбинации - (Индекс+1)) Тогда
						ПозицииИменВКомбинации[Индекс] = ПозицииИменВКомбинации[Индекс] + 1;
						// Заполнение старших позиций начальными значениями.
						Для ИндексСтаршейПозиции = Индекс+1 По ДлинаКомбинации-1 Цикл
							ПозицииИменВКомбинации[ИндексСтаршейПозиции] =
								ПозицииИменВКомбинации[Индекс] + ИндексСтаршейПозиции - Индекс;
						КонецЦикла;
						Прервать;
					Иначе
						Индекс = Индекс - 1;
					КонецЕсли;
				КонецЦикла;
				Если Индекс < 0 Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла;
			ДлинаКомбинации = ДлинаКомбинации - 1;
			Для Индекс = 0 По ДлинаКомбинации - 1 Цикл
				ПозицииИменВКомбинации[Индекс] = Индекс + 1;
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	
	ИтогСтрока = Новый Массив;
	ИтогСтрока.Добавить(ПервоеИмя);
	ИтогСтрока.Добавить(ПоследнееИмя);
	ИтогСтроки.Добавить(ИтогСтрока);
	
	Возврат ГруппыСтрокВСтроку(ИтогСтроки);
	
КонецФункции

Функция ГруппыСтрокВСтроку(ГруппыСтрок)
	
	ИтогСтроки = Новый Массив;
	
	Для Каждого ИтогСтрока Из ГруппыСтрок Цикл
		ИтогСтроки.Добавить(СтрСоединить(ИтогСтрока, ","));
	КонецЦикла;
	
	Строки = СтрСоединить(
		ИтогСтроки,
		",
		|,");
	
	Шаблон =
		"%2%1%2
		|";
	
	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(Шаблон, Строки, ",");
	
КонецФункции

// Для процедур ОбновитьНаборыЗначенийДоступа, ПриИзмененииНаборовЗначенийДоступа.

// Проверяет, что наборы в табличной части отличаются от новых наборов.
Функция НаборыЗначенийДоступаТабличнойЧастиИзменены(СсылкаНаОбъект, НовыеНаборы)
	
	СтарыеНаборы = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(
		СсылкаНаОбъект, "НаборыЗначенийДоступа").Выгрузить();
	
	Если СтарыеНаборы.Количество() <> НовыеНаборы.Количество() Тогда
		Возврат Истина;
	КонецЕсли;
	
	СтарыеНаборы.Колонки.Добавить("ВидДоступа", Новый ОписаниеТипов("Строка"));
	УправлениеДоступом.ДобавитьНаборыЗначенийДоступа(
		СтарыеНаборы, УправлениеДоступом.ТаблицаНаборыЗначенийДоступа(), Ложь, Истина);
	
	ПоляПоиска = "НомерНабора, ЗначениеДоступа, Уточнение, Чтение, Изменение";
	
	НовыеНаборы.Индексы.Добавить(ПоляПоиска);
	Отбор = Новый Структура(ПоляПоиска);
	
	Для каждого Строка Из СтарыеНаборы Цикл
		ЗаполнитьЗначенияСвойств(Отбор, Строка);
		Если НовыеНаборы.НайтиСтроки(Отбор).Количество() <> 1 Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Для функции РазрешенныеЗначенияДляДинамическогоСписка.
Процедура ДобавитьЗапросВПакет(ТекстПакета, ТекстЗапроса)
	
	Разделитель =
	"
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|";
	
	ТекстПакета = ТекстПакета + Разделитель + ТекстЗапроса;
	
КонецПроцедуры

// Для функции РазрешенныеЗначенияДляДинамическогоСписка.
Процедура ОбъединитьЗапросСЗапросом(ТекстЗапроса, ДобавляемыйТекстЗапроса)
	
	Объединитель =
	"
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|";
	
	ТекстЗапроса = ТекстЗапроса + Объединитель + ДобавляемыйТекстЗапроса;
	
КонецПроцедуры

// Обновление свойств видов доступа.

// Для функций СвойстваВидовДоступаДляХранения, ПредставлениеВидовДоступа.
Функция ЗаполненныеВидыДоступа()
	
	// 1. Заполнение данных, указанных при внедрении.
	
	ВидыДоступа = Новый ТаблицаЗначений;
	ВидыДоступа.Колонки.Добавить("Имя",                    Новый ОписаниеТипов("Строка"));
	ВидыДоступа.Колонки.Добавить("Представление",          Новый ОписаниеТипов("Строка"));
	ВидыДоступа.Колонки.Добавить("ТипЗначений",            Новый ОписаниеТипов("Тип"));
	ВидыДоступа.Колонки.Добавить("ТипГруппЗначений",       Новый ОписаниеТипов("Тип"));
	ВидыДоступа.Колонки.Добавить("НесколькоГруппЗначений", Новый ОписаниеТипов("Булево"));
	ВидыДоступа.Колонки.Добавить("ДополнительныеТипы",     Новый ОписаниеТипов("ТаблицаЗначений"));
	
	ИнтеграцияПодсистемБСП.ПриЗаполненииВидовДоступа(ВидыДоступа);
	УправлениеДоступомПереопределяемый.ПриЗаполненииВидовДоступа(ВидыДоступа);
	
	Возврат ВидыДоступа;
	
КонецФункции

// Для процедуры ОбновитьОписаниеСвойствВидовДоступа.
// Возвращает свойства видов доступа, заполняемых при внедрении
// в процедуре ПриЗаполненииВидовДоступа
// общего модуля УправлениеДоступомПереопределяемый
// и одноименных обработчиках этого события.
//
Функция СвойстваВидовДоступа()
	
	ВидыДоступа = ЗаполненныеВидыДоступа();
	
	// Проверки:
	// - тип значений доступа не указан для 2-х видов доступа
	// - тип значений доступа Пользователи, ГруппыПользователей используется только для вида доступа Пользователи.
	// Т тип значений доступа ВнешниеПользователи, ГруппыВнешнихПользователей используется только для вида доступа
	// ВнешниеПользователи.
	// И имена видов доступа Объект, Условие, НастройкиПрав, ПравоЧтения, ПравоИзменения не указаны.
	// Т тип групп значений не совпадает с типом значений.
	
	// 2. Подготовка различных коллекций свойств видов доступа, используемых при работе программы.
	МассивСвойств         = Новый Массив;
	ПоСсылкам             = Новый Соответствие;
	ПоИменам              = Новый Соответствие;
	ПоТипамЗначений       = Новый Соответствие;
	ПоТипамГруппИЗначений = Новый Соответствие;
	
	ЗначенияДоступаСГруппами = Новый Структура;
	ЗначенияДоступаСГруппами.Вставить("ПоТипам",                        Новый Соответствие);
	ЗначенияДоступаСГруппами.Вставить("ПоТипамСсылок",                  Новый Соответствие);
	ЗначенияДоступаСГруппами.Вставить("ИменаТаблицДляОбновления",       Новый Массив);
	ЗначенияДоступаСГруппами.Вставить("ТипыГруппЗначенийДляОбновления", Новый Соответствие);
	ЗначенияДоступаСГруппами.Вставить("ПоТипамДляОбновления",           Новый Соответствие);
	ЗначенияДоступаСГруппами.Вставить("ПоТипамСсылокДляОбновления",     Новый Соответствие);
	
	Параметры = Новый Структура;
	Параметры.Вставить("ОпределяемыеТипыЗначенийДоступа",
		УправлениеДоступомСлужебныйПовтИсп.ТипыПоляТаблицы("ОпределяемыйТип.ЗначениеДоступа"));
	
	ЗаголовокОшибки =
		НСтр("ru = 'Ошибка в процедуре ПриЗаполненииВидовДоступа общего модуля УправлениеДоступомПереопределяемый.'")
		+ Символы.ПС
		+ Символы.ПС;
	
	Параметры.Вставить("ЗаголовокОшибки", ЗаголовокОшибки);
	
	ВсеИменаВидовДоступа = Новый Соответствие;
	ВсеИменаВидовДоступа.Вставить(ВРег("Объект"),         Истина);
	ВсеИменаВидовДоступа.Вставить(ВРег("Условие"),        Истина);
	ВсеИменаВидовДоступа.Вставить(ВРег("НастройкиПрав"),  Истина);
	ВсеИменаВидовДоступа.Вставить(ВРег("ПравоЧтения"),    Истина);
	ВсеИменаВидовДоступа.Вставить(ВРег("ПравоИзменения"), Истина);
	
	ВсеТипыЗначений      = Новый Соответствие;
	ВсеТипыГруппЗначений = Новый Соответствие;
	
	Для каждого ВидДоступа Из ВидыДоступа Цикл
		
		Если ВсеИменаВидовДоступа[ВРег(ВидДоступа.Имя)] <> Неопределено Тогда
			ТекстОшибки = ЗаголовокОшибки + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Имя вида доступа ""%1"" уже определено.'"),
				ВидДоступа.Имя);
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
		
		// Проверка повторения типов значений и групп.
		ПроверитьТип(ВидДоступа, ВидДоступа.ТипЗначений,      ВсеТипыЗначений,      Параметры);
		ПроверитьТип(ВидДоступа, ВидДоступа.ТипГруппЗначений, ВсеТипыГруппЗначений, Параметры, Истина);
		// Проверка пересечения типов значений и групп.
		ПроверитьТип(ВидДоступа, ВидДоступа.ТипЗначений,      ВсеТипыГруппЗначений, Параметры,       , Истина);
		ПроверитьТип(ВидДоступа, ВидДоступа.ТипГруппЗначений, ВсеТипыЗначений,      Параметры, Истина, Истина);
		
		Для каждого Строка Из ВидДоступа.ДополнительныеТипы Цикл
			// Проверка повторения типов значений и групп.
			ПроверитьТип(ВидДоступа, Строка.ТипЗначений,      ВсеТипыЗначений,      Параметры);
			ПроверитьТип(ВидДоступа, Строка.ТипГруппЗначений, ВсеТипыГруппЗначений, Параметры, Истина);
			// Проверка пересечения типов значений и групп.
			ПроверитьТип(ВидДоступа, Строка.ТипЗначений,      ВсеТипыГруппЗначений, Параметры,       , Истина);
			ПроверитьТип(ВидДоступа, Строка.ТипГруппЗначений, ВсеТипыЗначений,      Параметры, Истина, Истина);
		КонецЦикла;
		
		ПустаяСсылкаТипаЗначений = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(
			Метаданные.НайтиПоТипу(ВидДоступа.ТипЗначений).ПолноеИмя()).ПустаяСсылка();
		
		Свойства = Новый Структура;
		Свойства.Вставить("Имя",                      ВидДоступа.Имя);
		Свойства.Вставить("Ссылка",                   ПустаяСсылкаТипаЗначений);
		Свойства.Вставить("ТипЗначений",              ВидДоступа.ТипЗначений);
		Свойства.Вставить("ТипГруппЗначений",         ВидДоступа.ТипГруппЗначений);
		Свойства.Вставить("НесколькоГруппЗначений",   ВидДоступа.НесколькоГруппЗначений);
		Свойства.Вставить("ДополнительныеТипы",       Новый Массив);
		Свойства.Вставить("ТипыВыбираемыхЗначений",   Новый Массив);
		
		МассивСвойств.Добавить(Свойства);
		ПоИменам.Вставить(Свойства.Имя, Свойства);
		ПоСсылкам.Вставить(ПустаяСсылкаТипаЗначений, Свойства);
		ПоТипамЗначений.Вставить(Свойства.ТипЗначений, Свойства);
		ПоТипамГруппИЗначений.Вставить(Свойства.ТипЗначений, Свойства);
		Если Свойства.ТипГруппЗначений <> Тип("Неопределено") Тогда
			ПоТипамГруппИЗначений.Вставить(Свойства.ТипГруппЗначений, Свойства);
		КонецЕсли;
		ЗаполнитьЗначенияДоступаСГруппами(Свойства, ЗначенияДоступаСГруппами, Свойства, Параметры);
		
		Для каждого Строка Из ВидДоступа.ДополнительныеТипы Цикл
			Элемент = Новый Структура;
			Элемент.Вставить("ТипЗначений",            Строка.ТипЗначений);
			Элемент.Вставить("ТипГруппЗначений",       Строка.ТипГруппЗначений);
			Элемент.Вставить("НесколькоГруппЗначений", Строка.НесколькоГруппЗначений);
			Свойства.ДополнительныеТипы.Добавить(Элемент);
			ПоТипамЗначений.Вставить(Строка.ТипЗначений, Свойства);
			ПоТипамГруппИЗначений.Вставить(Строка.ТипЗначений, Свойства);
			Если Строка.ТипГруппЗначений <> Тип("Неопределено") Тогда
				ПоТипамГруппИЗначений.Вставить(Строка.ТипГруппЗначений, Свойства);
			КонецЕсли;
			ЗаполнитьЗначенияДоступаСГруппами(Строка, ЗначенияДоступаСГруппами, Свойства, Параметры);
		КонецЦикла;
		
	КонецЦикла;
	
	БезГруппДляЗначенияДоступа      = Новый Массив;
	СОднойГруппойДляЗначенияДоступа = Новый Массив;
	ТипыЗначенийДоступаСГруппами    = Новый Соответствие;
	
	ВидыДоступаСГруппами = Новый Соответствие;
	
	Для каждого КлючИЗначение Из ЗначенияДоступаСГруппами.ПоТипамСсылок Цикл
		ИмяВидаДоступа = КлючИЗначение.Значение.Имя;
		ВидыДоступаСГруппами.Вставить(ИмяВидаДоступа, Истина);
		
		ПустаяСсылка = ПустаяСсылкаОбъектаМетаданных(КлючИЗначение.Ключ);
		ТипыЗначенийДоступаСГруппами.Вставить(ТипЗнч(ПустаяСсылка), ПустаяСсылка);
		
		Если НЕ КлючИЗначение.Значение.НесколькоГруппЗначений
		   И СОднойГруппойДляЗначенияДоступа.Найти(ИмяВидаДоступа) = Неопределено Тогда
		   
			СОднойГруппойДляЗначенияДоступа.Добавить(ИмяВидаДоступа);
		КонецЕсли;
	КонецЦикла;
	
	ТипыЗначенийДоступаСГруппами.Вставить(Тип("СправочникСсылка.Пользователи"),
		Справочники.Пользователи.ПустаяСсылка());
	
	ТипыЗначенийДоступаСГруппами.Вставить(Тип("СправочникСсылка.ГруппыПользователей"),
		Справочники.ГруппыПользователей.ПустаяСсылка());
	
	ТипыЗначенийДоступаСГруппами.Вставить(Тип("СправочникСсылка.ВнешниеПользователи"),
		Справочники.ВнешниеПользователи.ПустаяСсылка());
	
	ТипыЗначенийДоступаСГруппами.Вставить(Тип("СправочникСсылка.ГруппыВнешнихПользователей"),
		Справочники.ГруппыВнешнихПользователей.ПустаяСсылка());
		
	ПоТипамЗначенийСИерархией = Новый Соответствие;
	Для Каждого КлючИЗначение Из ПоТипамЗначений Цикл
		ТипСсылка = КлючИЗначение.Ключ;
		Если ТипыЗначенийДоступаСГруппами[ТипСсылка] <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипСсылка);
		Если ОбъектМетаданных <> Неопределено 
			И (ОбщегоНазначения.ЭтоСправочник(ОбъектМетаданных) Или ОбщегоНазначения.ЭтоПланВидовХарактеристик(ОбъектМетаданных))
			И ОбъектМетаданных.Иерархический Тогда
			
			ТипОбъект = СтандартныеПодсистемыСервер.ТипОбъектаИлиНабораЗаписейОбъектаМетаданных(ОбъектМетаданных);
			ПоТипамЗначенийСИерархией.Вставить(ТипСсылка, КлючИЗначение.Значение);
			ПоТипамЗначенийСИерархией.Вставить(ТипОбъект, КлючИЗначение.Значение);
		КонецЕсли;
	КонецЦикла;
	
	Для каждого СвойстваВидаДоступа Из МассивСвойств Цикл
		Если ВидыДоступаСГруппами.Получить(СвойстваВидаДоступа.Имя) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если СвойстваВидаДоступа.Имя = "Пользователи"
		 ИЛИ СвойстваВидаДоступа.Имя = "ВнешниеПользователи" Тогда
			Продолжить;
		КонецЕсли;
		БезГруппДляЗначенияДоступа.Добавить(СвойстваВидаДоступа.Имя);
	КонецЦикла;
	
	СвойстваВидовДоступа = Новый Структура;
	СвойстваВидовДоступа.Вставить("Массив",                          МассивСвойств);
	СвойстваВидовДоступа.Вставить("ПоИменам",                        ПоИменам);
	СвойстваВидовДоступа.Вставить("ПоСсылкам",                       ПоСсылкам);
	СвойстваВидовДоступа.Вставить("ПоТипамЗначений",                 ПоТипамЗначений);
	СвойстваВидовДоступа.Вставить("ПоТипамЗначенийСИерархией",       ПоТипамЗначенийСИерархией);
	СвойстваВидовДоступа.Вставить("ПоТипамГруппИЗначений",           ПоТипамГруппИЗначений);
	СвойстваВидовДоступа.Вставить("ЗначенияДоступаСГруппами",        ЗначенияДоступаСГруппами);
	СвойстваВидовДоступа.Вставить("БезГруппДляЗначенияДоступа",      БезГруппДляЗначенияДоступа);
	СвойстваВидовДоступа.Вставить("СОднойГруппойДляЗначенияДоступа", СОднойГруппойДляЗначенияДоступа);
	СвойстваВидовДоступа.Вставить("ТипыЗначенийДоступаСГруппами",    ТипыЗначенийДоступаСГруппами);
	СвойстваВидовДоступа.Вставить("ВладелецНаборовЗначенийДоступа",
		СтрокаДанныхДляХеширования(Метаданные.ОпределяемыеТипы.ВладелецНаборовЗначенийДоступаОбъект.Тип));
	
	ПроверитьТипыПодпискиОбновитьГруппыЗначенийДоступа(ЗначенияДоступаСГруппами);
	
	Возврат ОбщегоНазначения.ФиксированныеДанные(СвойстваВидовДоступа);
	
КонецФункции

// Для функции СвойстваВидовДоступа.
Процедура ЗаполнитьЗначенияДоступаСГруппами(Строка, ЗначенияДоступаСГруппами, Свойства, Параметры)
	
	Если Свойства.Имя = "Пользователи" Тогда
		ДобавитьВМассив(Свойства.ТипыВыбираемыхЗначений, Тип("СправочникСсылка.Пользователи"));
		ДобавитьВМассив(Свойства.ТипыВыбираемыхЗначений, Тип("СправочникСсылка.ГруппыПользователей"));
		Возврат;
	КонецЕсли;
	
	Если Свойства.Имя = "ВнешниеПользователи" Тогда
		ДобавитьВМассив(Свойства.ТипыВыбираемыхЗначений, Тип("СправочникСсылка.ВнешниеПользователи"));
		ДобавитьВМассив(Свойства.ТипыВыбираемыхЗначений, Тип("СправочникСсылка.ГруппыВнешнихПользователей"));
		Возврат;
	КонецЕсли;
	
	ТипСсылки = Строка.ТипЗначений;
	
	МетаданныеТипаЗначений = Метаданные.НайтиПоТипу(Строка.ТипЗначений);
	Если ОбщегоНазначения.ЭтоПеречисление(МетаданныеТипаЗначений) Тогда
		ТипОбъекта = ТипСсылки;
	Иначе
		ТипОбъекта = СтандартныеПодсистемыСервер.ТипОбъектаИлиНабораЗаписейОбъектаМетаданных(
			МетаданныеТипаЗначений);
	КонецЕсли;
	
	Если Строка.ТипГруппЗначений = Тип("Неопределено") Тогда
		ДобавитьТипыПодпискиОбновитьГруппыЗначенийДоступа(ТипСсылки,
			ТипОбъекта, МетаданныеТипаЗначений, ЗначенияДоступаСГруппами, Свойства, Неопределено);
		ДобавитьВМассив(Свойства.ТипыВыбираемыхЗначений, Строка.ТипЗначений);
		Возврат;
	КонецЕсли;
	
	Если Строка.ТипГруппЗначений <> Тип("Неопределено") Тогда
		ДобавитьВМассив(Свойства.ТипыВыбираемыхЗначений, Строка.ТипГруппЗначений);
	КонецЕсли;
	
	ЗначенияДоступаСГруппами.ПоТипам.Вставить(ТипСсылки,  Свойства);
	ЗначенияДоступаСГруппами.ПоТипам.Вставить(ТипОбъекта, Свойства);
	ЗначенияДоступаСГруппами.ПоТипамСсылок.Вставить(ТипСсылки, Свойства);
	
	МетаданныеТипаГруппЗначений = Метаданные.НайтиПоТипу(Строка.ТипГруппЗначений);
	
	ДобавитьТипыПодпискиОбновитьГруппыЗначенийДоступа(ТипСсылки,
		ТипОбъекта, МетаданныеТипаЗначений, ЗначенияДоступаСГруппами, Свойства, МетаданныеТипаГруппЗначений);
	
КонецПроцедуры

// Для функции СвойстваВидовДоступа и процедуры ЗаполнитьЗначенияДоступаСГруппами.
Процедура ДобавитьТипыПодпискиОбновитьГруппыЗначенийДоступа(ТипСсылки, ТипОбъекта,
			МетаданныеТипаЗначений, ЗначенияДоступаСГруппами, Свойства, МетаданныеТипаГруппЗначений)
	
	ПустаяСсылкаТипаЗначений = ПредопределенноеЗначение(МетаданныеТипаЗначений.ПолноеИмя() + ".ПустаяСсылка");
	
	Если МетаданныеТипаГруппЗначений = Неопределено Тогда
		ПустаяСсылкаТипаГруппЗначений = ПустаяСсылкаТипаЗначений;
	Иначе
		ПустаяСсылкаТипаГруппЗначений = ПустаяСсылкаОбъектаМетаданных(МетаданныеТипаГруппЗначений);
	КонецЕсли;
	
	ЗначенияДоступаСГруппами.ИменаТаблицДляОбновления.Добавить(МетаданныеТипаЗначений.ПолноеИмя());
	
	ЗначенияДоступаСГруппами.ТипыГруппЗначенийДляОбновления.Вставить(ТипСсылки,
		ПустаяСсылкаТипаГруппЗначений);
	
	ЗначенияДоступаСГруппами.ТипыГруппЗначенийДляОбновления.Вставить(ПустаяСсылкаТипаЗначений,
		ПустаяСсылкаТипаГруппЗначений);
	
	ЗначенияДоступаСГруппами.ПоТипамСсылокДляОбновления.Вставить(ТипСсылки, Свойства);
	ЗначенияДоступаСГруппами.ПоТипамДляОбновления.Вставить(ТипСсылки, Свойства);
	ЗначенияДоступаСГруппами.ПоТипамДляОбновления.Вставить(ТипОбъекта, Свойства);
	
КонецПроцедуры

// Для функции СвойстваВидовДоступа.
Процедура ПроверитьТипыПодпискиОбновитьГруппыЗначенийДоступа(ЗначенияДоступаСГруппами)
	
	ТекущиеТипыПодписки = УправлениеДоступомСлужебныйПовтИсп.ТипыПоляТаблицы(
		"ОпределяемыйТип.ЗначениеДоступаОбъект");
	
	ТребуемыеТипыПодписки = Новый Соответствие;
	Для Каждого КлючИЗначение Из ЗначенияДоступаСГруппами.ПоТипамДляОбновления Цикл
		Если ЗначенияДоступаСГруппами.ПоТипамСсылокДляОбновления.Получить(КлючИЗначение.Ключ) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ТребуемыеТипыПодписки.Вставить(КлючИЗначение.Ключ, Истина);
	КонецЦикла;
	
	НедостающиеТипы = Новый Массив;
	ЛишниеТипы = Новый Массив;
	
	Для Каждого КлючИЗначение Из ТекущиеТипыПодписки Цикл
		Если ТребуемыеТипыПодписки.Получить(КлючИЗначение.Ключ) = Неопределено Тогда
			ЛишниеТипы.Добавить(КлючИЗначение.Ключ);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого КлючИЗначение Из ТребуемыеТипыПодписки Цикл
		Если ТекущиеТипыПодписки.Получить(КлючИЗначение.Ключ) = Неопределено Тогда
			НедостающиеТипы.Добавить(КлючИЗначение.Ключ);
		КонецЕсли;
	КонецЦикла;
	
	Если НедостающиеТипы.Количество() = 0 И ЛишниеТипы.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если НедостающиеТипы.Количество() = 0 Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'По данным, полученным из процедуры ПриЗаполненииВидовДоступа
			           |общего модуля УправлениеДоступомПереопределяемый,
			           |в определяемом типе ""Значение доступа объект"" указаны лишние типы:
			           |- %1'"),
			СтрСоединить(ЛишниеТипы, "," + Символы.ПС + "- "));
	ИначеЕсли ЛишниеТипы.Количество() = 0 Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'По данным, полученным из процедуры ПриЗаполненииВидовДоступа
			           |общего модуля УправлениеДоступомПереопределяемый,
			           |в определяемом типе ""Значение доступа объект"" не указаны требуемые типы:
			           |- %1'"),
			СтрСоединить(НедостающиеТипы, "," + Символы.ПС + "- "));
	Иначе
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'По данным, полученным из процедуры ПриЗаполненииВидовДоступа
			           |общего модуля УправлениеДоступомПереопределяемый,
			           |в определяемом типе ""Значение доступа объект""
			           |а) указаны лишние типы:
			           |- %1
			           |б) не указаны требуемые типы:
			           |- %2'"),
			СтрСоединить(ЛишниеТипы, "," + Символы.ПС + "- "),
			СтрСоединить(НедостающиеТипы, "," + Символы.ПС + "- "));
	КонецЕсли;
	
	ВызватьИсключение ТекстОшибки;
	
КонецПроцедуры

// Для функции СвойстваВидовДоступа.
Процедура ПроверитьТип(ВидДоступа, Тип, ВсеТипы, Параметры, ПроверкаТиповГрупп = Ложь, ПроверкаПересечения = Ложь)
	
	Если Тип = Тип("Неопределено") Тогда
		Если ПроверкаТиповГрупп Тогда
			Возврат;
		КонецЕсли;
		ТекстОшибки = Параметры.ЗаголовокОшибки + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Для вида доступа ""%1"" не указан тип значений доступа.'"),
			ВидДоступа.Имя);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	// Проверка, что указан тип ссылки.
	Если НЕ ОбщегоНазначения.ЭтоСсылка(Тип) Тогда
		Если ПроверкаТиповГрупп Тогда
			ОписаниеОшибки =
				НСтр("ru = 'Тип ""%1"" указан, как тип групп значений, для вида доступа ""%2"".
				           |Однако это не тип ссылки.'");
		Иначе
			ОписаниеОшибки =
				НСтр("ru = 'Тип ""%1"" указан, как тип значений, для вида доступа ""%2"".
				           |Однако это не тип ссылки.'");
		КонецЕсли;
		ТекстОшибки = Параметры.ЗаголовокОшибки + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			ОписаниеОшибки, Тип, ВидДоступа.Имя);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	// Проверка повторения и пересечения типов значений и групп значений.
	ДляТогоЖеВидаДоступаОшибкиНет = Ложь;
	
	Если ПроверкаТиповГрупп Тогда
		Если ПроверкаПересечения Тогда
			ОписаниеОшибки =
				НСтр("ru = 'Тип ""%1"" указан, как тип значений, для вида доступа ""%2"".
				           |Для вида доступа ""%3"" его нельзя указать, как тип групп значений.'");
		Иначе
			ДляТогоЖеВидаДоступаОшибкиНет = Истина;
			ОписаниеОшибки =
				НСтр("ru = 'Тип групп значений ""%1"" уже указан для вида доступа ""%2"".
				           |Для вида доступа ""%3"" его нельзя указать.'");
		КонецЕсли;
	Иначе
		Если ПроверкаПересечения Тогда
			ОписаниеОшибки =
				НСтр("ru = 'Тип ""%1"" указан, как тип групп значений, для вида доступа ""%2"".
				           |Для вида доступа ""%3"" его нельзя указать, как тип значений.'");
		Иначе
			ОписаниеОшибки =
				НСтр("ru = 'Тип значений ""%1"" уже указан для вида доступа ""%2"".
				           |Для вида доступа ""%3"" его нельзя указать.'");
		КонецЕсли;
	КонецЕсли;
	
	Если ВсеТипы.Получить(Тип) <> Неопределено Тогда
		Если НЕ (ДляТогоЖеВидаДоступаОшибкиНет И ВидДоступа.Имя = ВсеТипы.Получить(Тип)) Тогда
			ТекстОшибки = Параметры.ЗаголовокОшибки + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				ОписаниеОшибки, Тип, ВсеТипы.Получить(Тип), ВидДоступа.Имя);
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
	ИначеЕсли НЕ ПроверкаПересечения Тогда
		ВсеТипы.Вставить(Тип, ВидДоступа.Имя);
	КонецЕсли;
	
	// Проверка состава определяемых типов.
	ОписаниеОшибки = "";
	Если Параметры.ОпределяемыеТипыЗначенийДоступа.Получить(Тип) = Неопределено Тогда
		Если ПроверкаТиповГрупп Тогда
			ОписаниеОшибки =
				НСтр("ru = 'Тип групп значений доступа ""%1"" вида доступа ""%2""
				           |не указан в определяемом типе ""Значение доступа"".'");
		Иначе
			ОписаниеОшибки =
				НСтр("ru = 'Тип значений доступа ""%1"" вида доступа ""%2""
				           |не указан в определяемом типе ""Значение доступа"".'");
		КонецЕсли;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ОписаниеОшибки) Тогда
		ТекстОшибки = Параметры.ЗаголовокОшибки + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			ОписаниеОшибки, Тип, ВидДоступа.Имя);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
КонецПроцедуры

Функция ПредставлениеВидовДоступа() Экспорт
	
	ВидыДоступа = ЗаполненныеВидыДоступа();
	
	ПредставлениеВидовДоступа = Новый Соответствие;
	
	Для Каждого ВидДоступа Из ВидыДоступа Цикл
		ПредставлениеВидовДоступа.Вставить(ВидДоступа.ТипЗначений, ВидДоступа.Представление);
	КонецЦикла;
	
	Возврат Новый ФиксированноеСоответствие(ПредставлениеВидовДоступа);
	
КонецФункции

Функция ПредставлениеВидаДоступа(СвойстваВидаДоступа) Экспорт
	
	ПредставлениеВидовДоступа = УправлениеДоступомСлужебныйПовтИсп.ПредставлениеВидовДоступа();
	
	Представление = ПредставлениеВидовДоступа.Получить(СвойстваВидаДоступа.ТипЗначений);
	
	Если Не ЗначениеЗаполнено(Представление) Тогда
		Представление = СвойстваВидаДоступа.Имя;
	КонецЕсли;
	
	Возврат Представление;
	
КонецФункции

// Для процедуры ЗаполнитьЗначенияДоступаСГруппами.
Процедура ДобавитьВМассив(Массив, Значение)
	
	Если Массив.Найти(Значение) = Неопределено Тогда
		Массив.Добавить(Значение);
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ОбновитьОписаниеСвойствВидовДоступа.
Функция ЕстьИзмененияТиповГруппИЗначенийДоступа(СвойстваВидовДоступа, Сохраненные)
	
	Если НЕ ТипЗнч(Сохраненные) = Тип("ФиксированнаяСтруктура")
	 ИЛИ НЕ Сохраненные.Свойство("ПоТипамЗначений")
	 ИЛИ НЕ Сохраненные.Свойство("ТипыЗначенийДоступаСГруппами")
	 ИЛИ НЕ Сохраненные.Свойство("ЗначенияДоступаСГруппами")
	 ИЛИ НЕ Сохраненные.Свойство("ВладелецНаборовЗначенийДоступа")
	 ИЛИ НЕ ТипЗнч(Сохраненные.ПоТипамЗначений)                = Тип("ФиксированноеСоответствие")
	 ИЛИ НЕ ТипЗнч(Сохраненные.ТипыЗначенийДоступаСГруппами)   = Тип("ФиксированноеСоответствие")
	 ИЛИ НЕ ТипЗнч(Сохраненные.ЗначенияДоступаСГруппами)       = Тип("ФиксированнаяСтруктура")
	 ИЛИ НЕ ТипЗнч(Сохраненные.ВладелецНаборовЗначенийДоступа) = Тип("Строка")
	 ИЛИ НЕ Сохраненные.ЗначенияДоступаСГруппами.Свойство("ИменаТаблицДляОбновления")
	 ИЛИ НЕ ТипЗнч(Сохраненные.ЗначенияДоступаСГруппами.ИменаТаблицДляОбновления) = Тип("ФиксированныйМассив")
	 ИЛИ НЕ СвойстваВидовДоступа.Свойство("ПоТипамЗначений")
	 ИЛИ НЕ СвойстваВидовДоступа.Свойство("ТипыЗначенийДоступаСГруппами")
	 ИЛИ НЕ СвойстваВидовДоступа.Свойство("ЗначенияДоступаСГруппами")
	 ИЛИ НЕ СвойстваВидовДоступа.Свойство("ВладелецНаборовЗначенийДоступа")
	 ИЛИ НЕ ТипЗнч(СвойстваВидовДоступа.ПоТипамЗначений)                = Тип("ФиксированноеСоответствие")
	 ИЛИ НЕ ТипЗнч(СвойстваВидовДоступа.ТипыЗначенийДоступаСГруппами)   = Тип("ФиксированноеСоответствие")
	 ИЛИ НЕ ТипЗнч(СвойстваВидовДоступа.ЗначенияДоступаСГруппами)       = Тип("ФиксированнаяСтруктура")
	 ИЛИ НЕ ТипЗнч(СвойстваВидовДоступа.ВладелецНаборовЗначенийДоступа) = Тип("Строка")
	 ИЛИ НЕ СвойстваВидовДоступа.ЗначенияДоступаСГруппами.Свойство("ИменаТаблицДляОбновления")
	 ИЛИ НЕ ТипЗнч(СвойстваВидовДоступа.ЗначенияДоступаСГруппами.ИменаТаблицДляОбновления) = Тип("ФиксированныйМассив") Тогда
		
		Возврат Истина;
	КонецЕсли;
	
	Если КлючиСоответствийОтличаются(СвойстваВидовДоступа.ПоТипамЗначений, Сохраненные.ПоТипамЗначений) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если КлючиСоответствийОтличаются(СвойстваВидовДоступа.ТипыЗначенийДоступаСГруппами,
			Сохраненные.ТипыЗначенийДоступаСГруппами) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Не ОбщегоНазначения.ДанныеСовпадают(СвойстваВидовДоступа.ЗначенияДоступаСГруппами.ИменаТаблицДляОбновления,
				Сохраненные.ЗначенияДоступаСГруппами.ИменаТаблицДляОбновления) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если СвойстваВидовДоступа.ВладелецНаборовЗначенийДоступа
			<> Сохраненные.ВладелецНаборовЗначенийДоступа Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Для функции ЕстьИзмененияТиповГруппИЗначенийДоступа.
Функция КлючиСоответствийОтличаются(Новое, Старое)
	
	Если Новое.Количество() <> Старое.Количество() Тогда
		Возврат Истина;
	КонецЕсли;
	
	Для каждого КлючИЗначение Из Новое Цикл
		Если Старое.Получить(КлючИЗначение.Ключ) = Неопределено Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

Функция ГруппыДоступаИспользующиеИерархиюЗначенийДоступа(ТипЗначенияВидаДоступа)
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ГруппыДоступа.Ссылка КАК Ссылка,
	|	ГруппыДоступа.Профиль КАК Профиль
	|ПОМЕСТИТЬ ГруппыДоступа
	|ИЗ
	|	Справочник.ГруппыДоступа КАК ГруппыДоступа
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ПрофилиГруппДоступа КАК ПрофилиГруппДоступа
	|		ПО ГруппыДоступа.Профиль = ПрофилиГруппДоступа.Ссылка
	|			И (ГруппыДоступа.Профиль <> ЗНАЧЕНИЕ(Справочник.ПрофилиГруппДоступа.Администратор))
	|			И (НЕ ГруппыДоступа.ПометкаУдаления)
	|			И (НЕ ПрофилиГруппДоступа.ПометкаУдаления)
	|			И (ИСТИНА В
	|				(ВЫБРАТЬ ПЕРВЫЕ 1
	|					ИСТИНА КАК ЗначениеИстина
	|				ИЗ
	|					Справочник.ГруппыДоступа.Пользователи КАК УчастникиГруппДоступа
	|				ГДЕ
	|					УчастникиГруппДоступа.Ссылка = ГруппыДоступа.Ссылка))
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	Ссылка,
	|	ГруппыДоступа.Профиль
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ГруппыДоступа.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.ГруппыДоступа.ЗначенияДоступа КАК ГруппыДоступаЗначенияДоступа
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ГруппыДоступа КАК ГруппыДоступа
	|		ПО ГруппыДоступаЗначенияДоступа.Ссылка = ГруппыДоступа.Ссылка
	|ГДЕ
	|	ГруппыДоступаЗначенияДоступа.ВключаяНижестоящие
	|	И ТИПЗНАЧЕНИЯ(ГруппыДоступаЗначенияДоступа.ЗначениеДоступа) = &ТипЗначенияВидаДоступа
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ГруппыДоступа.Ссылка
	|ИЗ
	|	Справочник.ПрофилиГруппДоступа.ЗначенияДоступа КАК ПрофилиГруппДоступаЗначенияДоступа
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ГруппыДоступа КАК ГруппыДоступа
	|		ПО ПрофилиГруппДоступаЗначенияДоступа.Ссылка = ГруппыДоступа.Профиль
	|ГДЕ
	|	ПрофилиГруппДоступаЗначенияДоступа.ВключаяНижестоящие
	|	И ТИПЗНАЧЕНИЯ(ПрофилиГруппДоступаЗначенияДоступа.ЗначениеДоступа) = &ТипЗначенияВидаДоступа";
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("ТипЗначенияВидаДоступа", ТипЗначенияВидаДоступа);
	
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
КонецФункции

#Область УниверсальноеОграничение

////////////////////////////////////////////////////////////////////////////////
// Обработчики подписок на события.

// Обработчик подписок ПроверитьДоступПередЗаписью* проверяет доступ к старой версии объекта, проверяет
// изменение полей объектов дополнительных таблиц, присоединенных в ограничениях доступа списков.
// Если изменения найдены, тогда регистрируется необходимость обновления ключей доступа
// для списков, у которых в ограничениях доступа присоединены дополнительные таблицы.
//
// Параметры:
//  Источник        - КонстантаМенеджер,
//                    СправочникОбъект,
//                    ДокументОбъект,
//                    ПланВидовХарактеристикОбъект,
//                    ПланСчетовОбъект,
//                    ПланВидовРасчетаОбъект,
//                    БизнесПроцессОбъект,
//                    ЗадачаОбъект,
//                    ПланОбменаОбъект - объект данных, передаваемый в подписку на событие ПередЗаписью.
//
//  Отказ           - Булево - параметр, передаваемый в подписку на событие ПередЗаписью.
//
//  РежимЗаписи     - РежимЗаписиДокумента - параметр, передаваемый в подписку на событие ПередЗаписью,
//                    когда Источник это ДокументОбъект.
//
//  РежимПроведения - РежимПроведенияДокумента - параметр, передаваемый в подписку на событие ПередЗаписью,
//                    когда Источник это ДокументОбъект.
//
Процедура ПроверитьДоступПередЗаписью(Источник, Отказ, РежимЗаписи = Неопределено, РежимПроведения = Неопределено) Экспорт
	
	// ОбменДанными.Загрузка обрабатывается внутри процедуры нестандартно (с учетом проверки прав).
	ПроверитьДоступПередЗаписьюИсточника(Источник, Отказ, Ложь, Ложь);
	
КонецПроцедуры

// Обработчик подписок ПроверитьДоступПередЗаписьюНабораЗаписей* проверяет доступ к старой версии набора записей,
// проверяет изменение полей наборов записей дополнительных таблиц, присоединенных в ограничениях доступа списков.
// Если изменения найдены, тогда регистрируется необходимость обновления ключей доступа
// для списков, у которых в ограничениях доступа присоединены дополнительные таблицы.
//
// Параметры:
//  Источник        - РегистрСведенийНаборЗаписей,
//                    РегистрНакопленияНаборЗаписей,
//                    РегистрБухгалтерииНаборЗаписей,
//                    РегистрРасчетаНаборЗаписей,
//                    ПерерасчетНаборЗаписей - набор записей, передаваемый в подписку
//                                             на событие ПередЗаписью.
//
//  Отказ           - Булево - параметр, передаваемый в подписку на событие ПередЗаписью.
//  Замещение       - Булево - параметр, передаваемый в подписку на событие ПередЗаписью.
//
//  ТолькоЗапись    - Булево - параметр, передаваемый в подписку на событие ПередЗаписью,
//                    когда Источник это РегистрРасчетаНаборЗаписей.
//
//  ЗаписьФактическогоПериодаДействия - Булево - параметр, передаваемый в подписку на событие ПередЗаписью,
//                    когда Источник это РегистрРасчетаНаборЗаписей.
//
//  ЗаписьПерерасчетов - Булево - параметр, передаваемый в подписку на событие ПередЗаписью,
//                    когда Источник это РегистрРасчетаНаборЗаписей.
//
Процедура ПроверитьДоступПередЗаписьюНабораЗаписей(Источник, Отказ, Замещение,
				ТолькоЗапись = Неопределено,
				ЗаписьФактическогоПериодаДействия = Неопределено,
				ЗаписьПерерасчетов = Неопределено) Экспорт
	
	// ОбменДанными.Загрузка обрабатывается внутри процедуры нестандартно (с учетом проверки прав).
	ПроверитьДоступПередЗаписьюИсточника(Источник, Отказ, Истина, Замещение);
	
КонецПроцедуры

// Обработчик подписок ПроверитьДоступПриЗаписи* проверяет устаревание ключа доступа
// новой версии объекта. Обновляет устаревший ключ доступа и, в этом случае,
// выполняет проверку прав Чтение и Изменение новой версии объекта.
//
// Параметры:
//  Источник        - КонстантаМенеджер,
//                    СправочникОбъект,
//                    ДокументОбъект,
//                    ПланВидовХарактеристикОбъект,
//                    ПланСчетовОбъект,
//                    ПланВидовРасчетаОбъект,
//                    БизнесПроцессОбъект,
//                    ЗадачаОбъект,
//                    ПланОбменаОбъект - объект данных, передаваемый в подписку на событие ПриЗаписи.
//
//  Отказ           - Булево - параметр, передаваемый в подписку на событие ПриЗаписи.
//
Процедура ПроверитьДоступПриЗаписи(Источник, Отказ) Экспорт
	
	// ОбменДанными.Загрузка обрабатывается внутри процедуры нестандартно (с учетом проверки прав).
	ПроверитьДоступПриЗаписиИсточника(Источник, Отказ, Ложь, Ложь);
	
КонецПроцедуры

// Обработчик подписок ПроверитьДоступПриЗаписиНабораЗаписей* проверяет устаревание ключей доступа
// новой версии набора записей. Обновляет устаревшие ключи доступа и, в этом случае,
// выполняет проверку прав Чтение и Изменение новой версии набора записей.
//
// Параметры:
//  Источник        - РегистрСведенийНаборЗаписей,
//                    РегистрНакопленияНаборЗаписей,
//                    РегистрБухгалтерииНаборЗаписей,
//                    РегистрРасчетаНаборЗаписей,
//                    ПерерасчетНаборЗаписей - набор записей, передаваемый в подписку
//                                             на событие ПриЗаписи.
//
//  Отказ           - Булево - параметр, передаваемый в подписку на событие ПриЗаписи.
//  Замещение       - Булево - параметр, передаваемый в подписку на событие ПриЗаписи.
//
//  ТолькоЗапись    - Булево - параметр, передаваемый в подписку на событие ПриЗаписи,
//                    когда Источник это РегистрРасчетаНаборЗаписей.
//
//  ЗаписьФактическогоПериодаДействия - Булево - параметр, передаваемый в подписку на событие ПриЗаписи,
//                    когда Источник это РегистрРасчетаНаборЗаписей.
//
//  ЗаписьПерерасчетов - Булево - параметр, передаваемый в подписку на событие ПриЗаписи,
//                    когда Источник это РегистрРасчетаНаборЗаписей.
//
Процедура ПроверитьДоступПриЗаписиНабораЗаписей(Источник, Отказ, Замещение,
				ТолькоЗапись = Неопределено,
				ЗаписьФактическогоПериодаДействия = Неопределено,
				ЗаписьПерерасчетов = Неопределено) Экспорт
	
	// ОбменДанными.Загрузка обрабатывается внутри процедуры нестандартно (с учетом проверки прав).
	ПроверитьДоступПриЗаписиИсточника(Источник, Отказ, Истина, Замещение);
	
КонецПроцедуры

// Обработчик подписок ПроверитьДоступПередУдалением* проверяет
// изменение полей объектов дополнительных таблиц, присоединенных в ограничениях доступа списков.
// Если изменения найдены, тогда регистрируется необходимость обновления ключей доступа
// для списков, у которых в ограничениях доступа присоединены дополнительные таблицы.
//
// Параметры:
//  Источник - СправочникОбъект,
//             ДокументОбъект,
//             ПланВидовХарактеристикОбъект,
//             ПланСчетовОбъект,
//             ПланВидовРасчетаОбъект,
//             БизнесПроцессОбъект,
//             ЗадачаОбъект,
//             ПланОбменаОбъект - объект данных, передаваемый в подписку на событие ПередУдалением.
//
//  Отказ    - Булево - параметр, передаваемый в подписку на событие ПередУдалением.
//
Процедура ПроверитьДоступПередУдалением(Источник, Отказ) Экспорт
	
	// ОбменДанными.Загрузка обрабатывается внутри процедуры нестандартно (с учетом проверки прав).
	ПроверитьДоступПередУдалениемИсточника(Источник, Отказ);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Универсальное ограничение доступа.

Функция ДоступРазрешен(ОписаниеДанных, Изменение, ВызыватьИсключение = Ложь) Экспорт
	
	Если Пользователи.ЭтоПолноправныйПользователь() Тогда
		Возврат Истина;
	КонецЕсли;
	
	ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗнч(ОписаниеДанных));
	Если ОбъектМетаданных = Неопределено Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Недопустимое значение параметра %1 в %2.
			           |Ожидалась ссылка или ключ записи.
			           |Передано значение: %3 (тип %4).'"),
			"ОписаниеДанных",
			?(Изменение, "УправлениеДоступом.ИзменениеРазрешено",
				"УправлениеДоступом.ЧтениеРазрешено"),
			Строка(ОписаниеДанных),
			Строка(ТипЗнч(ОписаниеДанных)));
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	ИмяПраваДоступа = ?(Изменение, "Изменение", "Чтение");
	
	Если ВызыватьИсключение Тогда
		ВыполнитьПроверкуПравДоступа(ИмяПраваДоступа, ОбъектМетаданных);
		
	ИначеЕсли Не ПравоДоступа(ИмяПраваДоступа, ОбъектМетаданных) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
	
	Если Не ОграничиватьДоступНаУровнеЗаписейУниверсально(Ложь, Истина) Тогда
		Возврат ЧтениеДоступно(ПолноеИмя, ОбъектМетаданных, ОписаниеДанных, ВызыватьИсключение);
	КонецЕсли;
	
	ИдентификаторТранзакции = Новый УникальныйИдентификатор;
	ПараметрыОграничения = ПараметрыОграничения(ПолноеИмя, ИдентификаторТранзакции);
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	ОбновитьРазрешенныеНаборыВПараметрахСеанса();
	
	Если ПараметрыОграничения.ОграничениеОтключено Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПараметрыОграничения.ДоступЗапрещен Тогда
		ДоступРазрешен = Ложь;
	Иначе
		Запрос = Новый Запрос;
		УстановитьРазрешенныеНаборыВПараметрыЗапроса(Запрос);
		
		Запрос.Текст = ?(Изменение, ПараметрыОграничения.ТекстЗапросаПроверкиПравЧтениеИзменение,
			ПараметрыОграничения.ТекстЗапросаПроверкиПраваЧтение);
		
		Если ПараметрыОграничения.ЭтоСсылочныйТип Тогда
			СсылкаНаОбъект = ?(ОбщегоНазначения.ЭтоСсылка(ТипЗнч(ОписаниеДанных)),
				ОписаниеДанных, ОписаниеДанных.Ссылка);
			
			Запрос.УстановитьПараметр("Объект", СсылкаНаОбъект);
			
			Если ПараметрыОграничения.ПолеВладельца <> Неопределено Тогда
				Запрос.УстановитьПараметр("ИдентификаторТаблицыНастроекПрав",
					ПараметрыОграничения.ИдентификаторТаблицыНастроекПрав);
			КонецЕсли;
			
			ДоступРазрешен = Не Запрос.Выполнить().Пустой();
			ДанныеДляПредставления = СсылкаНаОбъект;
		Иначе
			НаборЗаписей = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмя).СоздатьНаборЗаписей();
			
			Если ТипЗнч(ОписаниеДанных) = ТипЗнч(НаборЗаписей) Тогда
				Возврат Истина;
			КонецЕсли;
			
			Для Каждого ЭлементОтбора Из НаборЗаписей.Отбор Цикл
				ЭлементОтбора.Значение = ОписаниеДанных[ЭлементОтбора.Имя];
				ЭлементОтбора.Использование = Истина;
			КонецЦикла;
			ОтборПоИзмерениям = ОтборПоИзмерениямНабораЗаписей(НаборЗаписей, Запрос);
			ТекстЗапроса =
			"ВЫБРАТЬ ПЕРВЫЕ 1
			|	ИСТИНА КАК ЗначениеИстина
			|ИЗ
			|	&ТекущаяТаблица КАК ТекущаяТаблица
			|ГДЕ
			|	&ОтборПоИзмерениям";
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ТекущаяТаблица", ПолноеИмя);
			Запрос.Текст = Запрос.Текст + ОбщегоНазначения.РазделительПакетаЗапросов() + ТекстЗапроса;
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ОтборПоИзмерениям", ОтборПоИзмерениям);
			
			РезультатыЗапроса = Запрос.ВыполнитьПакет();
			ДоступРазрешен = РезультатыЗапроса[0].Пустой() И Не РезультатыЗапроса[1].Пустой();
			ДанныеДляПредставления = НаборЗаписей;
		КонецЕсли;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Ложь);
	УстановитьОтключениеБезопасногоРежима(Ложь);
	
	Если ДоступРазрешен Или Не ВызыватьИсключение Тогда
		Возврат ДоступРазрешен;
	КонецЕсли;
	
	Если Изменение Тогда
		ПравоЧтения = ДоступРазрешен(ОписаниеДанных, Ложь);
	Иначе
		ПравоЧтения = Ложь;
	КонецЕсли;
	
	СообщитьОбОшибкеДоступа(ДанныеДляПредставления, Истина, ПравоЧтения, Ложь, Ложь);
	
КонецФункции

// Для функции ДоступРазрешен.
Функция ЧтениеДоступно(ПолноеИмя, ОбъектМетаданных, ОписаниеДанных, ВызыватьИсключение)
	
	Запрос = Новый Запрос;
	
	Если ЭтоСсылочныйТипТаблицы(ПолноеИмя) Тогда
		СсылкаНаОбъект = ?(ОбщегоНазначения.ЭтоСсылка(ТипЗнч(ОписаниеДанных)),
			ОписаниеДанных, ОписаниеДанных.Ссылка);
		
		Запрос.УстановитьПараметр("Ссылка", СсылкаНаОбъект);
		ТекстЗапроса =
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
		|	ИСТИНА КАК ЗначениеИстина
		|ИЗ
		|	&ТекущаяТаблица КАК ТекущаяТаблица
		|ГДЕ
		|	ТекущаяТаблица.Ссылка = &Ссылка";
		ДанныеДляПредставления = СсылкаНаОбъект;
	Иначе
		НаборЗаписей = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмя).СоздатьНаборЗаписей();
		
		Если ТипЗнч(ОписаниеДанных) = ТипЗнч(НаборЗаписей) Тогда
			Возврат Истина;
		КонецЕсли;
		
		Для Каждого ЭлементОтбора Из НаборЗаписей.Отбор Цикл
			ЭлементОтбора.Значение = ОписаниеДанных[ЭлементОтбора.Имя];
			ЭлементОтбора.Использование = Истина;
		КонецЦикла;
		ОтборПоИзмерениям = ОтборПоИзмерениямНабораЗаписей(НаборЗаписей, Запрос);
		ТекстЗапроса =
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	ИСТИНА КАК ЗначениеИстина
		|ИЗ
		|	&ТекущаяТаблица КАК ТекущаяТаблица
		|ГДЕ
		|	&ОтборПоИзмерениям";
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОтборПоИзмерениям", ОтборПоИзмерениям);
		ДанныеДляПредставления = НаборЗаписей;
	КонецЕсли;
	
	Запрос.Текст = СтрЗаменить(ТекстЗапроса, "&ТекущаяТаблица", ПолноеИмя);
	
	Если Не Запрос.Выполнить().Пустой() Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Не ВызыватьИсключение Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СообщитьОбОшибкеДоступа(ДанныеДляПредставления, Ложь, Ложь, Ложь, Ложь);
	
КонецФункции

// Требуется, как начальная максимальная дата при планировании начального обновления доступа.
Функция МаксимальнаяДата() Экспорт
	
	Возврат '39991231235959';
	
КонецФункции

// Требуется, как начальная максимальная дата при планировании продолжения обновления доступа.
Функция МаксимальнаяДатаПриПродолжении()
	
	Возврат '39990101000000';
	
КонецФункции

// Для функции НастройкиВнедрения.
Функция ПолноеИмяXML(ПолноеИмя, ТипыТаблицПоИменам)
	
	СоставИмени = СтрРазделить(ПолноеИмя, ".", Ложь);
	Свойства = ТипыТаблицПоИменам.Получить(ВРег(СоставИмени[0]));
	
	Возврат Свойства.ЯзыкАнглийский + "." + СоставИмени[1];
	
КонецФункции

// Для процедуры ДобавитьТипыТребуемыеВОпределяемомТипе.
Функция ИмяТипаСсылки(ПолноеИмя, ТипыТаблицПоИменам)
	
	СоставИмени = СтрРазделить(ПолноеИмя, ".", Ложь);
	Свойства = ТипыТаблицПоИменам.Получить(ВРег(СоставИмени[0]));
	
	Если Не Свойства.ЭтоСсылочныйТип Тогда
		Возврат "";
	КонецЕсли;
	
	Если ВРег(Свойства.ЯзыкРусский) = ВРег(СоставИмени[0]) Тогда
		ИмяТипа = Свойства.ЯзыкРусский + "Ссылка." + СоставИмени[1];
	Иначе
		ИмяТипа = Свойства.ЯзыкАнглийский + "Ref." + СоставИмени[1];
	КонецЕсли;
	
	Возврат ИмяТипа;
	
КонецФункции

// Для функции НастройкиВнедрения.
Функция ИмяТипаСсылкиXML(ПолноеИмя, ТипыТаблицПоИменам)
	
	СоставИмени = СтрРазделить(ПолноеИмя, ".", Ложь);
	Свойства = ТипыТаблицПоИменам.Получить(ВРег(СоставИмени[0]));
	
	Если Свойства.ЭтоСсылочныйТип Тогда
		Возврат Свойства.ЯзыкАнглийский + "Ref." + СоставИмени[1];
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

// Для функции ДобавитьТипыТребуемыеВОпределяемомТипе.
Функция ИмяТипаОбъектаИлиНабораЗаписей(ПолноеИмя, ТипыТаблицПоИменам)
	
	СоставИмени = СтрРазделить(ПолноеИмя, ".", Ложь);
	Свойства = ТипыТаблицПоИменам.Получить(ВРег(СоставИмени[0]));
	ИмяТипа = "";
	
	Если Свойства.ЭтоСсылочныйТип Тогда
		Если ВРег(Свойства.ЯзыкРусский) = ВРег(СоставИмени[0]) Тогда
			ИмяТипа = Свойства.ЯзыкРусский + "Объект." + СоставИмени[1];
		Иначе
			ИмяТипа = Свойства.ЯзыкАнглийский + "Object." + СоставИмени[1];
		КонецЕсли;
	КонецЕсли;
	
	Если СтрНачинаетсяС(Свойства.ИмяКоллекции, "Регистры") Тогда
		Если ВРег(Свойства.ЯзыкРусский) = ВРег(СоставИмени[0]) Тогда
			ИмяТипа = Свойства.ЯзыкРусский + "НаборЗаписей." + СоставИмени[1];
		Иначе
			ИмяТипа = Свойства.ЯзыкАнглийский + "RecordSet." + СоставИмени[1];
		КонецЕсли;
	КонецЕсли;
	
	Возврат ИмяТипа;
	
КонецФункции

// Для функции НастройкиВнедрения.
Функция ИмяТипаОбъектаИлиНабораЗаписейXML(ПолноеИмя, ТипыТаблицПоИменам)
	
	СоставИмени = СтрРазделить(ПолноеИмя, ".", Ложь);
	Свойства = ТипыТаблицПоИменам.Получить(ВРег(СоставИмени[0]));
	
	Если Свойства.ЭтоСсылочныйТип Тогда
		Возврат Свойства.ЯзыкАнглийский + "Object." + СоставИмени[1];
	КонецЕсли;
	
	Если СтрНачинаетсяС(Свойства.ИмяКоллекции, "Регистры") Тогда
		Возврат Свойства.ЯзыкАнглийский + "RecordSet." + СоставИмени[1];
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

// Для функции НастройкиВнедрения.
Процедура ДобавитьОбъектКВладельцам(ИмяТипаОбъектаXML, ВладельцыЗначенийКлючейДоступа)
	
	Если СтрНачинаетсяС(ИмяТипаОбъектаXML, "DocumentObject.") Тогда
		ВладельцыЗначенийКлючейДоступа.Документы.Добавить(ИмяТипаОбъектаXML);
		
	ИначеЕсли СтрНачинаетсяС(ИмяТипаОбъектаXML, "CalculationRegisterRecordSet.") Тогда
		ВладельцыЗначенийКлючейДоступа.НаборыЗаписейРегистраРасчета.Добавить(ИмяТипаОбъектаXML);
		
	ИначеЕсли СтрНайти(ИмяТипаОбъектаXML, "RecordSet.") > 0 Тогда
		ВладельцыЗначенийКлючейДоступа.НаборыЗаписей.Добавить(ИмяТипаОбъектаXML);
		
	ИначеЕсли СтрНайти(ИмяТипаОбъектаXML, "Object.") > 0 Тогда
		ВладельцыЗначенийКлючейДоступа.Объекты.Добавить(ИмяТипаОбъектаXML);
	КонецЕсли;
	
КонецПроцедуры

// Для функции НастройкиВнедрения.
Процедура ДобавитьОграниченияВРолях(ПолноеИмяXML, ПолноеИмя, ОграниченияВРолях,
			СвойстваОграничений, ТипыИзмеренийРегистровКлючей, ТипыТаблицПоИменам, ПредопределенныеИдентификаторы)
	
	Свойства = СвойстваОграничений.Получить(ПолноеИмя);
	Если Свойства <> Неопределено И Свойства.ДоступЗапрещен Тогда
		Возврат;
	КонецЕсли;
	
	ОграничениеВРоли = Новый Структура("ШаблонДляОбъекта, Параметры", Истина, Новый Массив);
	ОграниченияВРолях.Вставить(ПолноеИмяXML, ОграничениеВРоли);
	
	Если Свойства = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если Свойства.ПолеВладельца <> Неопределено Тогда
		ОграничениеВРоли.Параметры.Добавить(Свойства.ПолеВладельца.Имя);
		Возврат;
	КонецЕсли;
	
	Если Свойства.ОпорныеПоля = Неопределено
	 Или Не ЗначениеЗаполнено(Свойства.ОпорныеПоля) Тогда
		Возврат;
	КонецЕсли;
	
	ОграничениеВРоли.ШаблонДляОбъекта = Ложь;
	
	Если ЗначениеЗаполнено(Свойства.ИмяОтдельногоРегистраКлючей) Тогда
		ПервыйПараметр = Свойства.ИмяОтдельногоРегистраКлючей;
		
		ДобавитьТипыИзмерения(Свойства.ИмяОтдельногоРегистраКлючей,
			Свойства.ОпорныеПоля, ТипыИзмеренийРегистровКлючей, ТипыТаблицПоИменам, ПолноеИмя);
	Иначе
		ПервыйПараметр =
			УправлениеДоступомСлужебныйПовтИсп.ОписаниеПредопределенногоИдентификатораОбъектаМетаданных(ПолноеИмя);
		
		ДобавитьТипыИзмерения("КлючиДоступаКРегистрам",
			Свойства.ОпорныеПоля, ТипыИзмеренийРегистровКлючей, ТипыТаблицПоИменам, ПолноеИмя);
		
		ПредопределенныеИдентификаторы.Вставить(ПервыйПараметр, ПолноеИмя);
	КонецЕсли;
	
	ОграничениеВРоли.Параметры.Добавить(ПервыйПараметр);
	
	Для Каждого ОпорноеПоле Из Свойства.ОпорныеПоля.Все Цикл
		ОграничениеВРоли.Параметры.Добавить(ОпорноеПоле);
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ДобавитьОграниченияВРолях.
Процедура ДобавитьТипыИзмерения(ИмяРегистраКлючей, ОпорныеПоля, ТипыИзмеренийРегистровКлючей,
			ТипыТаблицПоИменам, ИмяИсходногоРегистра)
	
	Если ОпорныеПоля.Все.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ТипыИзмерений = ТипыИзмеренийРегистраКлючей(ТипыИзмеренийРегистровКлючей, ИмяРегистраКлючей);
	
	ИменаТипов           = ТипыИзмерений.ИменаТипов;
	ПоляРегистровПоТипам = ТипыИзмерений.ПоляРегистровПоТипам;
	
	ПоляРегистра = Новый Массив;
	ТипыИзмерений.ПоляРегистров.Вставить(ИмяИсходногоРегистра, ПоляРегистра);
	
	Для Каждого ИмяПоля Из ОпорныеПоля.Все Цикл
		ХранилищеТиповПоля = ОпорныеПоля.ТипыВсех[ОпорныеПоля.Все.Найти(ИмяПоля)];
		ТипыПоля = ХранилищеТиповПоля.Получить();
		ПоляРегистра.Добавить(Новый Структура("Поле, Тип", ИмяПоля, ТипыПоля));
		Для Каждого Тип Из ТипыПоля.Типы() Цикл
			ОбъектМетаданных = Метаданные.НайтиПоТипу(Тип);
			Если ОбъектМетаданных = Неопределено Тогда
				ИмяТипа = XMLТип(Тип).ИмяТипа;
			Иначе
				ИмяТипа = ИмяТипаСсылкиXML(Метаданные.НайтиПоТипу(Тип).ПолноеИмя(), ТипыТаблицПоИменам);
			КонецЕсли;
			Если ИменаТипов.Найти(ИмяТипа) = Неопределено Тогда
				ИменаТипов.Добавить(ИмяТипа);
			КонецЕсли;
			ПоляРегистровПоТипу = ПоляРегистровПоТипам.Получить(ИмяТипа);
			Если ПоляРегистровПоТипу = Неопределено Тогда
				ПоляРегистровПоТипу = Новый Массив;
				ПоляРегистровПоТипам.Вставить(ИмяТипа, ПоляРегистровПоТипу);
			КонецЕсли;
			ПолноеИмяПоля = ИмяИсходногоРегистра + "." + ИмяПоля;
			Если ПоляРегистровПоТипу.Найти(ПолноеИмяПоля) = Неопределено Тогда
				ПоляРегистровПоТипу.Добавить(ПолноеИмяПоля);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	// Для обратной совместимости отчета ПроверкаВнедренияБСП.epf.
	Если ИмяРегистраКлючей <> "КлючиДоступаКРегистрам" Тогда
		Возврат;
	КонецЕсли;
	
	ИмяРегистраXML = "InformationRegister." + ИмяРегистраКлючей;
	ИменаТипов = ТипыИзмеренийРегистровКлючей.Получить(ИмяРегистраXML);
	
	Если ИменаТипов = Неопределено Тогда
		ТипыИзмеренийРегистровКлючей.Вставить(ИмяРегистраXML, ТипыИзмерений.ИменаТипов);
	КонецЕсли;
	
КонецПроцедуры

// Для функции НастройкиВнедрения и процедуры ДобавитьТипыИзмерения.
Функция ТипыИзмеренийРегистраКлючей(ТипыИзмеренийРегистровКлючей, ИмяРегистраКлючей)
	
	ТипыИзмерений = ТипыИзмеренийРегистровКлючей.Получить(ИмяРегистраКлючей);
	Если ТипыИзмерений = Неопределено Тогда
		ТипыИзмерений = Новый Структура;
		ТипыИзмерений.Вставить("ИменаТипов", Новый Массив);
		ТипыИзмерений.Вставить("ПоляРегистров", Новый Соответствие);
		ТипыИзмерений.Вставить("ПоляРегистровПоТипам", Новый Соответствие);
		ТипыИзмеренийРегистровКлючей.Вставить(ИмяРегистраКлючей, ТипыИзмерений);
		ТипыИзмерений.ИменаТипов.Добавить("EnumRef.ДополнительныеЗначенияДоступа");
	КонецЕсли;
	
	Возврат ТипыИзмерений;
	
КонецФункции

#Область ПроверкаДоступаПриИзменении

// Для обработчиков подписок на событие ПередЗаписью.
Процедура ПроверитьДоступПередЗаписьюИсточника(Источник, Отказ, ЭтоНаборЗаписей, Замещение)
	
	Если ПропуститьПроверкуДоступа(Отказ, Источник) Тогда
		Возврат;
	КонецЕсли;
	
	Если Не ЭтоНаборЗаписей И Источник.ЭтоНовый() И ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		Блокировка = Новый БлокировкаДанных;
		Блокировка.Добавить("РегистрСведений.КлючиДоступаКОбъектам");
		Блокировка.Добавить("РегистрСведений.КлючиДоступаГруппДоступа");
		Блокировка.Добавить("РегистрСведений.КлючиДоступаНаборовГруппДоступа");
		Блокировка.Добавить("РегистрСведений.КлючиДоступаПользователей");
		Блокировка.Добавить("РегистрСведений.КлючиДоступаВнешнихПользователей");
		Блокировка.Добавить("Справочник.КлючиДоступа");
		ЭлементБлокировки = Блокировка.Добавить("Справочник.НаборыГруппДоступа");
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		ЭлементБлокировки = Блокировка.Добавить("Справочник.ПрофилиГруппДоступа");
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		ЭлементБлокировки = Блокировка.Добавить("Справочник.ГруппыДоступа");
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ТаблицыГруппДоступа");
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ГруппыЗначенийДоступа");
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ЗначенияГруппДоступа");
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ЗначенияГруппДоступаПоУмолчанию");
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.НастройкиПравОбъектов");
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.НаследованиеНастроекПравОбъектов");
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ПараметрыРаботыВерсийРасширений");
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		Блокировка.Заблокировать();
	КонецЕсли;
	
	ЭтоПолноправныйПользователь = Пользователи.ЭтоПолноправныйПользователь()
		Или Не ОграничиватьДоступНаУровнеЗаписейУниверсально(Ложь, Истина);
	
	Источник.ДополнительныеСвойства.Вставить("УправлениеДоступомИдентификаторТранзакции",
		Новый УникальныйИдентификатор);
	
	ЕстьСтараяВерсия =  ЭтоНаборЗаписей И Замещение
	             Или Не ЭтоНаборЗаписей И Не Источник.ЭтоНовый();
	
	Если ЕстьСтараяВерсия Тогда
		ЗапомнитьДанныеВлияющиеНаЗависимыеКлючиДоступа(Источник, ЭтоНаборЗаписей, Замещение);
		ПроверитьДоступКИсточнику(Источник, Истина, ЭтоНаборЗаписей, Замещение, ЭтоПолноправныйПользователь);
		
	ИначеЕсли Не ЭтоНаборЗаписей Тогда
		УстановитьРазрешенныйКлючДоступаДляНовогоОбъекта(Источник, ЭтоПолноправныйПользователь);
	КонецЕсли;
	
	Если ЭтоНаборЗаписей Тогда
		ЗаписатьКлючиДоступаНовыхКомбинацийЗначенийОпорныхПолейПередЗаписью(Источник, ЭтоПолноправныйПользователь);
	КонецЕсли;
	
КонецПроцедуры

// Для обработчиков подписок на событие ПриЗаписи.
Процедура ПроверитьДоступПриЗаписиИсточника(Источник, Отказ, ЭтоНаборЗаписей, Замещение)
	
	Если ПропуститьПроверкуДоступа(Отказ, Источник) Тогда
		Возврат;
	КонецЕсли;
	
	ЭтоПолноправныйПользователь = Пользователи.ЭтоПолноправныйПользователь()
		Или Не ОграничиватьДоступНаУровнеЗаписейУниверсально(Ложь, Истина);
	
	// Проверка доступа к новой версии.
	ПроверитьДоступКИсточнику(Источник, Ложь, ЭтоНаборЗаписей, Замещение, ЭтоПолноправныйПользователь);
	
	ЗапланироватьОбновлениеЗависимыхУстаревшихКлючейДоступа(Источник, ЭтоНаборЗаписей, Ложь);
	
КонецПроцедуры

// Для обработчиков подписок на событие ПередУдалением.
Процедура ПроверитьДоступПередУдалениемИсточника(Источник, Отказ)
	
	Если ПропуститьПроверкуДоступа(Отказ, Источник) Тогда
		Возврат;
	КонецЕсли;
	
	Источник.ДополнительныеСвойства.Вставить("УправлениеДоступомИдентификаторТранзакции",
		Новый УникальныйИдентификатор);
	
	ЗапомнитьДанныеВлияющиеНаЗависимыеКлючиДоступа(Источник, Ложь, Ложь);
	ЗапланироватьОбновлениеЗависимыхУстаревшихКлючейДоступа(Источник, Ложь, Истина);
	
КонецПроцедуры


// Для процедур ПроверитьДоступПередЗаписьюИсточника, ПроверитьДоступПриЗаписиИсточника.
Функция ПропуститьПроверкуДоступа(Отказ, Источник)
	
	Если СтандартныеПодсистемыСервер.ЭтоИдентификаторОбъектаМетаданных(Источник) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если УправлениеДоступомСлужебныйПовтИсп.РазделенныеДанныеНедоступны() Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Не ОграничиватьДоступНаУровнеЗаписейУниверсально(Ложь) Тогда
		Возврат Истина;
	КонецЕсли;
	
	ОтключениеОбновления = ПараметрыСеанса.ОтключениеОбновленияКлючейДоступа;
	Если ОтключениеОбновления.Полное Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ОтключениеОбновления.Стандартное Тогда
		Кэш = УправлениеДоступомСлужебныйПовтИсп.КэшИзмененныхСписковПриОтключенномОбновленииКлючейДоступа();
		ТипИсточника = ТипЗнч(Источник);
		Если Кэш.Получить(ТипИсточника) <> Неопределено Тогда
			Возврат Истина;
		КонецЕсли;
		ОтключениеОбновления = Новый Структура(ОтключениеОбновления);
		ИзмененныеСписки = ОтключениеОбновления.ИзмененныеСписки.Получить();
		ИзмененныеСписки.Вставить(ТипИсточника, Истина);
		ОтключениеОбновления.ИзмененныеСписки = Новый ХранилищеЗначения(ИзмененныеСписки);
		
		УстановитьОтключениеБезопасногоРежима(Истина);
		УстановитьПривилегированныйРежим(Истина);
		ПараметрыСеанса.ОтключениеОбновленияКлючейДоступа = Новый ФиксированнаяСтруктура(ОтключениеОбновления);
		УстановитьПривилегированныйРежим(Истина);
		УстановитьОтключениеБезопасногоРежима(Истина);
		
		Кэш.Вставить(ТипИсточника, Истина);
		Возврат Истина;
	КонецЕсли;
	
	Если Отказ Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Для процедуры ПроверитьДоступПередЗаписьюИсточника.
Процедура ЗапомнитьДанныеВлияющиеНаЗависимыеКлючиДоступа(Источник, ЭтоНаборЗаписей, Замещение)
	
	ПолноеИмя = Источник.Метаданные().ПолноеИмя();
	СвойстваСпискаКакВедущего = СвойстваСпискаКакВедущего(ПолноеИмя,
		Источник.ДополнительныеСвойства.УправлениеДоступомИдентификаторТранзакции);
	
	Если СвойстваСпискаКакВедущего = Неопределено
	 Или СвойстваСпискаКакВедущего.ПоЗначениямПолей = Неопределено Тогда
		
		Источник.ДополнительныеСвойства.Вставить(
			"УправлениеДоступомЗначенияПолейДляПроверкиИзмененияПриЗаписи");
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	
	Если ЭтоНаборЗаписей Тогда
		ОтборПоИзмерениям = ОтборПоИзмерениямНабораЗаписей(Источник, Запрос);
		Запрос.Текст = СтрЗаменить(СвойстваСпискаКакВедущего.ПоЗначениямПолей.ТекстЗапроса,
			"&ОтборПоИзмерениям", ОтборПоИзмерениям);
	Иначе
		Запрос.Текст = СвойстваСпискаКакВедущего.ПоЗначениямПолей.ТекстЗапроса;
		Запрос.УстановитьПараметр("СсылкаНаОбъект", Источник.Ссылка);
	КонецЕсли;
	
	Источник.ДополнительныеСвойства.Вставить(
		"УправлениеДоступомЗначенияПолейДляПроверкиИзмененияПриЗаписи",
		Запрос.ВыполнитьПакет());
	
КонецПроцедуры

// Для процедур ЗапомнитьДанныеВлияющиеНаЗависимыеКлючиДоступа, ПроверитьДоступКНаборуЗаписей.
Функция ОтборПоИзмерениямНабораЗаписей(НаборЗаписей, Запрос, ЗапросНовыхКомбинаций = Неопределено)
	
	ОтборПоИзмерениям = "";
	
	Для Каждого ЭлементОтбора Из НаборЗаписей.Отбор Цикл
		Если Не ЭлементОтбора.Использование Тогда
			Продолжить;
		КонецЕсли;
		ОтборПоИзмерениям = ОтборПоИзмерениям + ?(ОтборПоИзмерениям = "", "", "
		|	И ") + "ТекущаяТаблица." + ЭлементОтбора.Имя + " = &ЗначениеПоля" + ЭлементОтбора.Имя;
		
		Если Запрос <> Неопределено Тогда
			Запрос.УстановитьПараметр("ЗначениеПоля" + ЭлементОтбора.Имя, ЭлементОтбора.Значение);
		КонецЕсли;
		Если ЗапросНовыхКомбинаций <> Неопределено Тогда
			ЗапросНовыхКомбинаций.УстановитьПараметр("ЗначениеПоля" + ЭлементОтбора.Имя, ЭлементОтбора.Значение);
		КонецЕсли;
	КонецЦикла;
	
	Если ОтборПоИзмерениям = "" Тогда
		ОтборПоИзмерениям = "ИСТИНА";
	КонецЕсли;
	
	Возврат ОтборПоИзмерениям;
	
КонецФункции

// Для процедуры ПроверитьДоступПередЗаписьюИсточника.
Процедура УстановитьРазрешенныйКлючДоступаДляНовогоОбъекта(Источник, ЭтоПолноправныйПользователь)
	
	Если ЭтоПолноправныйПользователь Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	СсылкаНового = ПользователиСлужебный.СсылкаОбъекта(Источник);
	РазрешенныйКлючДоступа = УправлениеДоступомСлужебныйПовтИсп.РазрешенныйКлючДоступа();
	
	НаборЗаписей = РегистрыСведений.КлючиДоступаКОбъектам.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Объект.Установить(СсылкаНового);
	
	Запись = НаборЗаписей.Добавить();
	Запись.Объект = СсылкаНового;
	Запись.КлючДоступаПользователей        = РазрешенныйКлючДоступа;
	Запись.КлючДоступаВнешнихПользователей = РазрешенныйКлючДоступа;
	
	НаборЗаписей.Записать();
	
	УстановитьПривилегированныйРежим(Ложь);
	УстановитьОтключениеБезопасногоРежима(Ложь);
	
КонецПроцедуры

// Для процедур ПроверитьДоступПередЗаписьюИсточника, ПроверитьДоступПриЗаписиИсточника.
Процедура ПроверитьДоступКИсточнику(Источник, ПередЗаписью, ЭтоНаборЗаписей, Замещение, ЭтоПолноправныйПользователь)
	
	Если ПередЗаписью И ЭтоПолноправныйПользователь Тогда
		Возврат;
	КонецЕсли;
	
	ПолноеИмя = Источник.Метаданные().ПолноеИмя();
	ИдентификаторТранзакции = Источник.ДополнительныеСвойства.УправлениеДоступомИдентификаторТранзакции;
	ВсеПараметрыОграничения = ПараметрыОграниченияПриПроверкеДоступа(Источник, ПолноеИмя, ИдентификаторТранзакции);
	
	Если Пользователи.ЭтоСеансВнешнегоПользователя() Тогда
		ПараметрыОграничения               = ВсеПараметрыОграничения.ДляВнешнихПользователей;
		ПараметрыОграниченияДополнительные = ВсеПараметрыОграничения.ДляПользователей
	Иначе
		ПараметрыОграничения               = ВсеПараметрыОграничения.ДляПользователей;
		ПараметрыОграниченияДополнительные = ВсеПараметрыОграничения.ДляВнешнихПользователей
	КонецЕсли;
	
	Если ПараметрыОграничения.ДоступЗапрещен И Не ЭтоПолноправныйПользователь Тогда
		Если ПараметрыОграничения.ДляВнешнихПользователей Тогда
			ШаблонОшибки =
				НСтр("ru = 'Внешним пользователям запрещен доступ к данным списка
				           |""%1"".'");
		Иначе
			ШаблонОшибки =
				НСтр("ru = 'Пользователям запрещен доступ к данным списка
				           |""%1"".'");
		КонецЕсли;
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонОшибки,
			Источник.Метаданные().Представление());
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Если ЭтоНаборЗаписей Тогда
		ПроверитьДоступКНаборуЗаписей(Источник, ПередЗаписью, Замещение, ЭтоПолноправныйПользователь,
			ИдентификаторТранзакции, ПараметрыОграничения, ПараметрыОграниченияДополнительные);
	Иначе
		ПроверитьДоступКОбъекту(Источник, ПередЗаписью, ЭтоПолноправныйПользователь,
			ИдентификаторТранзакции, ПараметрыОграничения, ПараметрыОграниченияДополнительные);
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ПроверитьДоступКИсточнику.
Функция ПараметрыОграниченияПриПроверкеДоступа(Источник, ПолноеИмя, ИдентификаторТранзакции)
	
	Возврат ПараметрыОграничения(ПолноеИмя, ИдентификаторТранзакции, Null);
	
КонецФункции

// Для процедуры ПроверитьДоступКИсточнику.
Процедура ПроверитьДоступКОбъекту(Источник, ПередЗаписью, ЭтоПолноправныйПользователь,
			ИдентификаторТранзакции, ПараметрыОграничения, ПараметрыОграниченияДополнительные)
	
	ЭтоНовый = Не Источник.ДополнительныеСвойства.Свойство(
		"УправлениеДоступомЗначенияПолейДляПроверкиИзмененияПриЗаписи");
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	Если Не ПередЗаписью Тогда
		КлючДоступаОбновлен = Ложь;
		
		ОбновитьКлючДоступаОбъектаПриЗаписи(Источник, ЭтоНовый, ИдентификаторТранзакции,
			ПараметрыОграничения, КлючДоступаОбновлен);
		
		ОбновитьКлючДоступаОбъектаПриЗаписи(Источник, ЭтоНовый, ИдентификаторТранзакции,
			ПараметрыОграниченияДополнительные);
		
		Если Не КлючДоступаОбновлен Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	Если ПараметрыОграничения.ОграничениеОтключено Или ЭтоПолноправныйПользователь Тогда
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	ПроверкаДобавления = ЭтоНовый И Не ПередЗаписью И ПараметрыОграничения.ПолеВладельца = Неопределено;
	
	Если ПроверкаДобавления Тогда
		Запрос.Текст = СтрЗаменить(ПараметрыОграничения.ТекстЗапросаПроверкиПравЧтениеИзменение,
			"РазрешенныеКлючиДоступа.Изменение", "РазрешенныеКлючиДоступа.Добавление");
	Иначе
		Запрос.Текст = ПараметрыОграничения.ТекстЗапросаПроверкиПравЧтениеИзменение;
	КонецЕсли;
	
	ОбновитьРазрешенныеНаборыВПараметрахСеанса();
	
	Запрос.УстановитьПараметр("Объект", Источник.Ссылка);
	УстановитьРазрешенныеНаборыВПараметрыЗапроса(Запрос);
	
	Если ПараметрыОграничения.ПолеВладельца <> Неопределено Тогда
		Запрос.УстановитьПараметр("ИдентификаторТаблицыНастроекПрав",
			ПараметрыОграничения.ИдентификаторТаблицыНастроекПрав);
	КонецЕсли;
	
	Если Не РезультатЗапросаПроверкиДоступа(Запрос, Источник).Пустой() Тогда
		Возврат; // Доступ разрешен.
	КонецЕсли;
	
	Если ПроверкаДобавления Тогда
		Запрос.Текст = ПараметрыОграничения.ТекстЗапросаПроверкиПравЧтениеИзменение;
		ПравоИзменения = Не Запрос.Выполнить().Пустой();
	Иначе
		ПравоИзменения = Ложь;
	КонецЕсли;
	
	Если ПараметрыОграничения.ОграничениеЧтенияОтключено Тогда
		ПравоЧтения = Истина;
	Иначе
		Запрос.Текст = ПараметрыОграничения.ТекстЗапросаПроверкиПраваЧтение;
		ПравоЧтения = Не Запрос.Выполнить().Пустой();
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Ложь);
	УстановитьОтключениеБезопасногоРежима(Ложь);
	
	Данные = ?(ПередЗаписью, Источник.Ссылка, Источник);
	СообщитьОбОшибкеДоступа(Данные, ПередЗаписью, ПравоЧтения, ПравоИзменения, ЭтоНовый);
	
КонецПроцедуры

// Для процедуры ПроверитьДоступКОбъекту.
Процедура ОбновитьКлючДоступаОбъектаПриЗаписи(Источник, ЭтоНовый, ИдентификаторТранзакции,
			ПараметрыОграничения, КлючДоступаОбновлен = Ложь)
	
	Если ПараметрыОграничения.ДоступЗапрещен
	 Или (ПараметрыОграничения.ОграничениеОтключено
	      И Не ПараметрыОграничения.СЗаписьюВсегдаРазрешенногоКлючаДоступа) Тогда
		Возврат;
	КонецЕсли;
	
	Если Не ЭтоНовый И Не КлючДоступаИсточникаУстарел(Источник.Ссылка, ПараметрыОграничения, Источник) Тогда
		Возврат;
	КонецЕсли;
	
	ОбновитьКлючиДоступаЭлементовДанныхПриЗаписи(Источник.Ссылка,
		ПараметрыОграничения, ИдентификаторТранзакции,,, Источник);
	
	КлючДоступаОбновлен = Истина;
	
КонецПроцедуры

// Для процедур ПроверитьДоступКОбъекту, ПроверитьДоступКНаборуЗаписей.
Функция РезультатЗапросаПроверкиДоступа(Запрос, Источник)
	
	Возврат Запрос.Выполнить();
	
КонецФункции

// Для процедуры ПроверитьДоступКИсточнику.
Процедура ПроверитьДоступКНаборуЗаписей(Источник, ПередЗаписью, Замещение, ЭтоПолноправныйПользователь,
			ИдентификаторТранзакции, ПараметрыОграничения, ПараметрыОграниченияДополнительные)
	
	Если    ПередЗаписью И (Не Замещение Или ЭтоПолноправныйПользователь)
	 Или Не ПередЗаписью И Источник.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ОтборПоИзмерениям = "";
	Запрос = ?(ПараметрыОграничения.ОграничениеОтключено Или ЭтоПолноправныйПользователь,
		Неопределено, Новый Запрос);
	
	ОбновитьКлючиДоступаКНаборуЗаписей(Источник, ПередЗаписью, Замещение,
		ИдентификаторТранзакции, ПараметрыОграничения, ОтборПоИзмерениям, Запрос);
	
	ОбновитьКлючиДоступаКНаборуЗаписей(Источник, ПередЗаписью, Замещение,
		ИдентификаторТранзакции, ПараметрыОграниченияДополнительные, "", Неопределено);
	
	Если Запрос = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос.Текст = СтрЗаменить(ПараметрыОграничения.ТекстЗапросаПроверкиПравЧтениеИзменение,
		"&ОтборПоИзмерениям", ОтборПоИзмерениям);
	
	ОбновитьРазрешенныеНаборыВПараметрахСеанса();
	УстановитьРазрешенныеНаборыВПараметрыЗапроса(Запрос);
	
	Если РезультатЗапросаПроверкиДоступа(Запрос, Источник).Пустой() Тогда
		Возврат; // Доступ разрешен.
	КонецЕсли;
	
	Если ПараметрыОграничения.ОграничениеЧтенияОтключено Тогда
		ПравоЧтения = Истина;
	Иначе
		Запрос.Текст = СтрЗаменить(ПараметрыОграничения.ТекстЗапросаПроверкиПраваЧтение,
			"&ОтборПоИзмерениям", ОтборПоИзмерениям);
		ПравоЧтения = Запрос.Выполнить().Пустой();
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Ложь);
	УстановитьОтключениеБезопасногоРежима(Ложь);
	
	СообщитьОбОшибкеДоступа(Источник, ПередЗаписью, ПравоЧтения, Ложь, Ложь);
	
КонецПроцедуры

// Для процедуры ПроверитьДоступКНаборуЗаписей.
Процедура ОбновитьКлючиДоступаКНаборуЗаписей(Источник, ПередЗаписью, Замещение,
			ИдентификаторТранзакции, ПараметрыОграничения, ОтборПоИзмерениям, Запрос)
	
	Если ПараметрыОграничения.ДоступЗапрещен
	 Или ПараметрыОграничения.ОграничениеОтключено
	 Или ПараметрыОграничения.ИспользуетсяОграничениеПоВладельцу
	   И Запрос = Неопределено Тогда
		
		Возврат;
	КонецЕсли;
	
	Если Не ПередЗаписью Тогда
		ЗапросНовыхКомбинаций = Новый Запрос;
	КонецЕсли;
	
	Если Замещение Тогда
		ОтборПоИзмерениям = ОтборПоИзмерениямНабораЗаписей(Источник, Запрос, ЗапросНовыхКомбинаций);
	Иначе
		КомбинацииЗначенийОпорныхПолей = КомбинацииЗначенийОпорныхПолей(Источник,
			ОтборПоИзмерениям, ПараметрыОграничения);
		
		Если Запрос <> Неопределено Тогда
			Запрос.УстановитьПараметр("КомбинацииЗначенийОпорныхПолей", КомбинацииЗначенийОпорныхПолей);
		КонецЕсли;
		ЗапросНовыхКомбинаций.УстановитьПараметр("КомбинацииЗначенийОпорныхПолей", КомбинацииЗначенийОпорныхПолей);
	КонецЕсли;
	
	Если ПередЗаписью Или ПараметрыОграничения.ИспользуетсяОграничениеПоВладельцу Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	ОбновитьКлючиДоступаНовыхКомбинацийЗначенийОпорныхПолей(ЗапросНовыхКомбинаций,
		ОтборПоИзмерениям, Источник, ПараметрыОграничения);
	
	УстановитьПривилегированныйРежим(Ложь);
	УстановитьОтключениеБезопасногоРежима(Ложь);
	
КонецПроцедуры

// Для процедуры ПроверитьДоступПередЗаписьюИсточника.
Процедура ЗаписатьКлючиДоступаНовыхКомбинацийЗначенийОпорныхПолейПередЗаписью(Источник, ЭтоПолноправныйПользователь)
	
	Если ЭтоПолноправныйПользователь Или Источник.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ПолноеИмя = Источник.Метаданные().ПолноеИмя();
	ИдентификаторТранзакции = Источник.ДополнительныеСвойства.УправлениеДоступомИдентификаторТранзакции;
	ПараметрыОграничения = ПараметрыОграничения(ПолноеИмя, ИдентификаторТранзакции);
	
	Если ПараметрыОграничения.ОграничениеОтключено
	 Или ПараметрыОграничения.ИспользуетсяОграничениеПоВладельцу Тогда
		Возврат;
	КонецЕсли;
	
	ЗапросНовыхКомбинаций = Новый Запрос;
	ОтборПоИзмерениям = "";
	
	ЗапросНовыхКомбинаций.УстановитьПараметр("КомбинацииЗначенийОпорныхПолей",
		КомбинацииЗначенийОпорныхПолей(Источник, ОтборПоИзмерениям, ПараметрыОграничения));
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	ОбновитьКлючиДоступаНовыхКомбинацийЗначенийОпорныхПолей(ЗапросНовыхКомбинаций,
			ОтборПоИзмерениям, Источник, ПараметрыОграничения);
	
	УстановитьПривилегированныйРежим(Ложь);
	УстановитьОтключениеБезопасногоРежима(Ложь);
	
КонецПроцедуры

// Для процедур ПроверитьДоступКНаборуЗаписей,
// ЗаписатьКлючиДоступаНовыхКомбинацийЗначенийОпорныхПолейПередЗаписью.
//
Функция КомбинацииЗначенийОпорныхПолей(Источник, ОтборПоИзмерениям, ПараметрыОграничения)
	
	Поля = СтрСоединить(ПараметрыОграничения.ОпорныеПоля.Используемые, ",");
	Поля = УправлениеДоступомСлужебныйПовтИсп.ПоляВРегистреСимволовМетаданных(ПараметрыОграничения.Список, Поля);
	КомбинацииЗначенийОпорныхПолей = Источник.Выгрузить(, Поля);
	КомбинацииЗначенийОпорныхПолей.Свернуть(Поля);
	
	ПоляОтбора = "";
	Для Каждого Поле Из ПараметрыОграничения.ОпорныеПоля.Используемые Цикл
		ПоляОтбора = ПоляОтбора + ?(ПоляОтбора = "", "", ", ") + "ТекущаяТаблица." + Поле;
	КонецЦикла;
	ОтборПоИзмерениям = "(" + ПоляОтбора + ") В (&КомбинацииЗначенийОпорныхПолей)";
	
	Возврат КомбинацииЗначенийОпорныхПолей;
	
КонецФункции

// Для процедур ПроверитьДоступКНаборуЗаписей,
// ЗаписатьКлючиДоступаНовыхКомбинацийЗначенийОпорныхПолейПередЗаписью.
//
Процедура ОбновитьКлючиДоступаНовыхКомбинацийЗначенийОпорныхПолей(ЗапросНовыхКомбинаций,
			ОтборПоИзмерениям, Источник, ПараметрыОграничения)
	
	ЭлементыДанных = ЭлементыДанныхНовыхКомбинацийЗначенийОпорныхПолей(ЗапросНовыхКомбинаций,
		ОтборПоИзмерениям, Источник, ПараметрыОграничения);
	
	Если ЭлементыДанных.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ОбновитьКлючиДоступаЭлементовДанныхПриЗаписи(ЭлементыДанных, ПараметрыОграничения,
		Источник.ДополнительныеСвойства.УправлениеДоступомИдентификаторТранзакции,,, Источник);
	
КонецПроцедуры

// Для процедуры ОбновитьКлючиДоступаНовыхКомбинацийЗначенийОпорныхПолей.
Функция ЭлементыДанныхНовыхКомбинацийЗначенийОпорныхПолей(ЗапросНовыхКомбинаций,
			ОтборПоИзмерениям, Источник, ПараметрыОграничения)
	
	Если ЗапросНовыхКомбинаций.Параметры.Свойство("КомбинацииЗначенийОпорныхПолей") Тогда
		ЗапросНовыхКомбинаций.Текст =
			ПараметрыОграничения.ТекстЗапросаНовыхКомбинацийЗначенийОпорныхПолейНовыхЗаписей;
	Иначе
		ЗапросНовыхКомбинаций.Текст = СтрЗаменить(
			ПараметрыОграничения.ТекстЗапросаНовыхКомбинацийЗначенийОпорныхПолейСуществующихЗаписей,
			"&ОтборПоИзмерениям",
			ОтборПоИзмерениям);
	КонецЕсли;
	
	РезультатЗапросаНовыхКомбинаций = ЗапросНовыхКомбинаций.Выполнить();
	Если РезультатЗапросаНовыхКомбинаций.Пустой() Тогда
		Возврат Новый Массив;
	КонецЕсли;
	
	ЭлементыДанных = РезультатЗапросаНовыхКомбинаций.Выгрузить();
	ЭлементыДанных.Колонки.Добавить("ТекущаяСсылка", Новый ОписаниеТипов("Число"));
	Индекс = 0;
	Для Каждого ЭлементДанных Из ЭлементыДанных Цикл
		ЭлементДанных.ТекущаяСсылка = Индекс;
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Возврат ЭлементыДанных;
	
КонецФункции

// Для процедур ПроверитьДоступКОбъекту, ПроверитьДоступКНаборуЗаписей.
Процедура СообщитьОбОшибкеДоступа(Данные, ПередЗаписью, ПравоЧтения, ПравоИзменения, ЭтоНовый)
	
	Если ПередЗаписью Тогда
		Если ПравоЧтения Тогда
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Недостаточно прав для изменения данных:
				           |%1'"), ПредставлениеДанных(Данные));
		Иначе
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Недостаточно прав для чтения данных:
				           |%1'"), ПредставлениеДанных(Данные));
		КонецЕсли;
	Иначе
		Если ПравоЧтения И ПравоИзменения Тогда
			Если ЭтоНовый Тогда
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Недостаточно прав для добавления данных (нет права добавления):
					           |%1'"), ПредставлениеДанных(Данные));
			Иначе
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Недостаточно прав для добавления данных (нет права добавления для сделанных изменений):
					           |%1'"), ПредставлениеДанных(Данные));
			КонецЕсли;
		ИначеЕсли ПравоЧтения Тогда
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Недостаточно прав для добавления данных (невозможно будет изменить):
				           |%1'"), ПредставлениеДанных(Данные));
		Иначе
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Недостаточно прав для добавления данных (невозможно будет прочитать):
				           |%1.'"), ПредставлениеДанных(Данные));
		КонецЕсли;
	КонецЕсли;
	
	ВызватьИсключение ТекстОшибки;
	
КонецПроцедуры

// Для процедуры СообщитьОбОшибкеДоступа.
Функция ПредставлениеДанных(Данные)
	
	Если ТипЗнч(Данные) = Тип("Строка") Тогда
		Возврат СокрЛП(Данные);
	КонецЕсли;
	
	Если ТипЗнч(Данные) = Тип("Структура") Тогда
		ЭтоРегистр = Истина;
		Если ТипЗнч(Данные.Регистр) = Тип("Строка") Тогда
			ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(Данные.Регистр);
		Иначе
			ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗнч(Данные.Регистр));
		КонецЕсли;
	Иначе
		ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗнч(Данные));
		ЭтоРегистр = ОбщегоНазначения.ЭтоРегистр(ОбъектМетаданных);
	КонецЕсли;
	
	Если ОбъектМетаданных = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	Если ЭтоРегистр Тогда
		ПредставлениеДанных = ОбъектМетаданных.Представление();
		
		КоличествоПолей = 0;
		Для каждого ЭлементОтбора Из Данные.Отбор Цикл
			Если ЭлементОтбора.Использование Тогда
				КоличествоПолей = КоличествоПолей + 1;
			КонецЕсли;
		КонецЦикла;
		
		Если КоличествоПолей = 1 Тогда
			ПредставлениеДанных = ПредставлениеДанных
				+ " " + НСтр("ru = 'с полем'")  + " " + Строка(Данные.Отбор);
			
		ИначеЕсли КоличествоПолей > 1 Тогда
			ПредставлениеДанных = ПредставлениеДанных
				+ " " + НСтр("ru = 'с полями'") + " " + Строка(Данные.Отбор);
		КонецЕсли;
	Иначе
		ПредставлениеДанных = Строка(Данные);
		ПредставлениеМетаданных = ОбщегоНазначения.ПредставлениеОбъекта(ОбъектМетаданных);
		
		Если Не СтрЗаканчиваетсяНа(ПредставлениеДанных, "(" + ПредставлениеМетаданных + ")")
		   И Не СтрНачинаетсяС(ПредставлениеДанных, ПредставлениеМетаданных) Тогда
			
			ПредставлениеДанных = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку("%1 (%2)",
				ПредставлениеДанных, ПредставлениеМетаданных);
		КонецЕсли;
	КонецЕсли;
		
	Возврат ПредставлениеДанных;
	
КонецФункции

// Для процедуры ПроверитьДоступКОбъекту и формы ОбновлениеДоступаРучноеУправление.
Функция КлючДоступаИсточникаУстарел(СсылкаНаОбъект, ПараметрыОграничения, Источник = Неопределено) Экспорт
	
	Если ПараметрыОграничения.БезЗаписиКлючейДоступа Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", СсылкаНаОбъект);
	
	Если ПараметрыОграничения.СЗаписьюВсегдаРазрешенногоКлючаДоступа Тогда
		Запрос.Текст = ПараметрыОграничения.ТекстЗапросаЭлементовДанныхСУстаревшимРазрешеннымКлючом;
		Запрос.УстановитьПараметр("РазрешенныйКлючДоступа", УправлениеДоступомСлужебныйПовтИсп.РазрешенныйКлючДоступа());
	Иначе
		Запрос.Текст = ПараметрыОграничения.ТекстЗапросаЭлементовДанныхСУстаревшимиКлючами;
	КонецЕсли;
	
	Если ПараметрыОграничения.СписокСДатой Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст,
			"ТекущийСписок.Дата МЕЖДУ &ДатаНачала И &ДатаОкончания", "ТекущийСписок.Ссылка = &Ссылка");
	Иначе
		Запрос.Текст = СтрЗаменить(Запрос.Текст,
			"ТекущийСписок.Ссылка >= &ПоследняяОбработаннаяСсылка", "ТекущийСписок.Ссылка = &Ссылка");
	КонецЕсли;
	УстановитьУточнениеПланаЗапроса(Запрос.Текст);
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	Если Запрос.Выполнить().Пустой() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Ложь);
	УстановитьОтключениеБезопасногоРежима(Ложь);
	
	Возврат Истина;
	
КонецФункции

// Для процедур ПроверитьДоступКОбъекту, ПроверитьДоступКНаборуЗаписей и формы ОбновлениеДоступаРучноеУправление.
Процедура ОбновитьКлючиДоступаЭлементовДанныхПриЗаписи(ОписаниеЭлементовДанных, ПараметрыОграничения,
			ИдентификаторТранзакции, ОбновитьПраваНаКлючи = Ложь, ЕстьИзмененияПрав = Ложь, Источник = Неопределено) Экспорт
	
	Если ПараметрыОграничения.БезЗаписиКлючейДоступа Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(ОписаниеЭлементовДанных) = Тип("ТаблицаЗначений") Тогда
		ЭлементыДанных = ОписаниеЭлементовДанных;
	Иначе
		ЭлементыДанных = Новый ТаблицаЗначений;
		ЭлементыДанных.Колонки.Добавить("ТекущаяСсылка");
		ЭлементыДанных.Добавить().ТекущаяСсылка = ОписаниеЭлементовДанных;
	КонецЕсли;
	
	СвойстваСпискаКакВедущего = СвойстваСпискаКакВедущего(ПараметрыОграничения.Список,
		ИдентификаторТранзакции);
	ИмяСвойстваВидаПользователей = ?(ПараметрыОграничения.ДляВнешнихПользователей,
		"ДляВнешнихПользователей", "ДляПользователей");
	
	ПараметрыОбновления = Новый Структура(ПараметрыОграничения);
	ПараметрыОбновления.Вставить("ЕстьИзмененияПрав",       ЕстьИзмененияПрав);
	ПараметрыОбновления.Вставить("ОбновитьПраваНаКлючи",    ОбновитьПраваНаКлючи);
	ПараметрыОбновления.Вставить("ИдентификаторТранзакции", ИдентификаторТранзакции);
	ПараметрыОбновления.Вставить("ИдентификаторСписка",
		ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ПараметрыОграничения.Список));
	
	Если СвойстваСпискаКакВедущего = Неопределено
	 Или СвойстваСпискаКакВедущего.ПоКлючамДоступа = Неопределено
	 Или СвойстваСпискаКакВедущего.ПоКлючамДоступа[ИмяСвойстваВидаПользователей] = Неопределено Тогда
		
		ПараметрыОбновления.Вставить("ЗависимыеСпискиПоКлючамДоступа", Новый Массив);
	Иначе
		ПараметрыОбновления.Вставить("ЗависимыеСпискиПоКлючамДоступа",
			СвойстваСпискаКакВедущего.ПоКлючамДоступа[ИмяСвойстваВидаПользователей]);
	КонецЕсли;
	
	Если ПараметрыОграничения.СЗаписьюВсегдаРазрешенногоКлючаДоступа Тогда
		ОбновитьЭлементыДанныхСпискаСУстаревшимРазрешеннымКлючом(ЭлементыДанных, ПараметрыОбновления);
	Иначе
		ОбновитьКлючиДоступаПорцииЭлементовДанныхСписка(ЭлементыДанных, ПараметрыОбновления);
	КонецЕсли;
	
	ЕстьИзмененияПрав = ПараметрыОбновления.ЕстьИзмененияПрав;
	
КонецПроцедуры

// Для регистра сведений ГруппыЗначенийДоступа.
Процедура ЗапланироватьОбновлениеЗависимыхСписковПоЗначениямСГруппами(ЗначенияСИзменениямиПоТипам) Экспорт
	
	Если Не ОграничиватьДоступНаУровнеЗаписейУниверсально() Тогда
		Возврат;
	КонецЕсли;
	
	ИдентификаторТранзакции = Новый УникальныйИдентификатор;
	
	СпискиДляОбновления = Новый Соответствие;
	Для Каждого ОписаниеЗначений Из ЗначенияСИзменениямиПоТипам Цикл
		ПолноеИмяВедущего = Метаданные.НайтиПоТипу(ОписаниеЗначений.Ключ).ПолноеИмя();
		СвойстваСпискаКакВедущего = СвойстваСпискаКакВедущего(ПолноеИмяВедущего, ИдентификаторТранзакции);
		Если СвойстваСпискаКакВедущего = Неопределено
		 Или СвойстваСпискаКакВедущего.ПоЗначениямСГруппами = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ДобавитьСпискиДляОбновленияДляВидаПользователей(СпискиДляОбновления,
			СвойстваСпискаКакВедущего.ПоЗначениямСГруппами, "ДляПользователей");
		
		ДобавитьСпискиДляОбновленияДляВидаПользователей(СпискиДляОбновления,
			СвойстваСпискаКакВедущего.ПоЗначениямСГруппами, "ДляВнешнихПользователей");
	КонецЦикла;
	
	ЗапланироватьОбновлениеУстаревшихКлючейДоступа(СпискиДляОбновления,
		ИдентификаторТранзакции,
		"ЗапланироватьОбновлениеЗависимыхСписковПоЗначениямСГруппами",
		?(ЗначенияСИзменениямиПоТипам.Количество() <> 1 Или ОписаниеЗначений.Значение = Истина,
			Неопределено, Новый Структура("ПоЗначениямСГруппами", ОписаниеЗначений.Значение)));
	
КонецПроцедуры

// Для процедуры ЗапланироватьОбновлениеЗависимыхСписковПоЗначениямСГруппами.
Процедура ДобавитьСпискиДляОбновленияДляВидаПользователей(СпискиДляОбновления, ПоЗначениямСГруппами, ИмяВидаПользователей)
	
	ПолныеИмена = ПоЗначениямСГруппами[ИмяВидаПользователей];
	Если ПолныеИмена = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого ПолноеИмя Из ПолныеИмена Цикл
		СписокДляОбновления = СпискиДляОбновления.Получить(ПолноеИмя);
		Если СписокДляОбновления = Неопределено Тогда
			СписокДляОбновления = Новый Структура("ДляПользователей, ДляВнешнихПользователей", Ложь, Ложь);
			СпискиДляОбновления.Вставить(ПолноеИмя, СписокДляОбновления);
		КонецЕсли;
		СписокДляОбновления[ИмяВидаПользователей] = Истина;
	КонецЦикла;
	
КонецПроцедуры

// Для процедур ЗапланироватьОбновлениеЗависимыхУстаревшихКлючейДоступа, ЗаписатьКлючиДоступаОбъектов,
// ЗапланироватьОбновлениеЗависимыхСписковПоЗначениямСГруппами.
//
Процедура ЗапланироватьОбновлениеУстаревшихКлючейДоступа(СпискиДляОбновления, ИдентификаторТранзакции,
			Описание, ВедущийОбъект = Неопределено, ЭтоПродолжениеОбновления = Ложь)
	
	Если ТипЗнч(СпискиДляОбновления) = Тип("Соответствие")
	   И СпискиДляОбновления.Количество() = 0
	 Или ТипЗнч(СпискиДляОбновления) = Тип("Структура")
	   И СпискиДляОбновления.ИменаСписков.Количество() = 0 Тогда
		
		Возврат;
	КонецЕсли;
	
	Списки = Новый Массив;
	СпискиДляПользователей = Новый Массив;
	СпискиДляВнешнихПользователей = Новый Массив;
	
	Если ТипЗнч(СпискиДляОбновления) = Тип("Соответствие") Тогда
		Для Каждого ОписаниеСписка Из СпискиДляОбновления Цикл
			ПолноеИмя = ОписаниеСписка.Ключ;
			Свойства  = ОписаниеСписка.Значение;
			
			Если Свойства.ДляПользователей Тогда
				ПараметрыОграничения = ПараметрыОграничения(ПолноеИмя, ИдентификаторТранзакции, Ложь);
				
				Если ПараметрыОграничения.ОграничениеОтключено
				 Или ПараметрыОграничения.ДоступЗапрещен
				 Или ПараметрыОграничения.ИспользуетсяОграничениеПоВладельцу Тогда
					
					Свойства.ДляПользователей = Ложь;
				КонецЕсли;
			КонецЕсли;
			
			Если Свойства.ДляВнешнихПользователей Тогда
				ПараметрыОграничения = ПараметрыОграничения(ПолноеИмя, ИдентификаторТранзакции, Истина);
				
				Если ПараметрыОграничения.ОграничениеОтключено
				 Или ПараметрыОграничения.ДоступЗапрещен
				 Или ПараметрыОграничения.ИспользуетсяОграничениеПоВладельцу Тогда
					
					Свойства.ДляВнешнихПользователей = Ложь;
				КонецЕсли;
			КонецЕсли;
			
			Если Свойства.ДляПользователей И Свойства.ДляВнешнихПользователей Тогда
				Списки.Добавить(ПолноеИмя);
			
			ИначеЕсли Свойства.ДляПользователей Тогда
				СпискиДляПользователей.Добавить(ПолноеИмя);
				
			ИначеЕсли Свойства.ДляВнешнихПользователей Тогда
				СпискиДляВнешнихПользователей.Добавить(ПолноеИмя);
			КонецЕсли;
		КонецЦикла;
	Иначе
		Для Каждого ПолноеИмя Из СпискиДляОбновления.ИменаСписков Цикл
			ПараметрыОграничения = ПараметрыОграничения(ПолноеИмя,
				ИдентификаторТранзакции, СпискиДляОбновления.ДляВнешнихПользователей);
			
			Если ПараметрыОграничения.ОграничениеОтключено
			 Или ПараметрыОграничения.ДоступЗапрещен
			 Или ПараметрыОграничения.ИспользуетсяОграничениеПоВладельцу Тогда
				
				Продолжить;
			КонецЕсли;
			
			Если СпискиДляОбновления.ДляВнешнихПользователей Тогда
				СпискиДляВнешнихПользователей.Добавить(ПолноеИмя);
			Иначе
				СпискиДляПользователей.Добавить(ПолноеИмя);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ПараметрыПланирования = ПараметрыПланированияОбновленияДоступа(Ложь);
	ПараметрыПланирования.РазрешенныеКлючиДоступа = Ложь;
	ПараметрыПланирования.Описание = Описание;
	ПараметрыПланирования.ВедущийОбъект = ВедущийОбъект;
	ПараметрыПланирования.ЭтоПродолжениеОбновления = ЭтоПродолжениеОбновления;
	ЗапланироватьОбновлениеДоступа(Списки, ПараметрыПланирования);
	
	ПараметрыПланирования.ДляВнешнихПользователей = Ложь;
	ЗапланироватьОбновлениеДоступа(СпискиДляПользователей, ПараметрыПланирования);
	
	ПараметрыПланирования.ДляПользователей = Ложь;
	ПараметрыПланирования.ДляВнешнихПользователей = Истина;
	ЗапланироватьОбновлениеДоступа(СпискиДляВнешнихПользователей, ПараметрыПланирования);
	
КонецПроцедуры

// Для процедуры ПроверитьДоступПриЗаписиИсточника, ПроверитьДоступПередУдалениемИсточника.
Процедура ЗапланироватьОбновлениеЗависимыхУстаревшихКлючейДоступа(Источник, ЭтоНаборЗаписей, Удаление)
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	ПолноеИмя = Источник.Метаданные().ПолноеИмя();
	СвойстваСпискаКакВедущего = СвойстваСпискаКакВедущего(ПолноеИмя,
		Источник.ДополнительныеСвойства.УправлениеДоступомИдентификаторТранзакции);
	
	Если СвойстваСпискаКакВедущего = Неопределено
	 Или СвойстваСпискаКакВедущего.ПоЗначениямПолей = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если Источник.ДополнительныеСвойства.Свойство("УправлениеДоступомЗначенияПолейДляПроверкиИзмененияПриЗаписи") Тогда
		РезультатыЗапроса = Источник.ДополнительныеСвойства.УправлениеДоступомЗначенияПолейДляПроверкиИзмененияПриЗаписи;
	Иначе
		РезультатыЗапроса = Неопределено;
	КонецЕсли;
	
	ИзмененияПоЗначениямПолей = Новый Структура;
	ИзмененияПоЗначениямПолей.Вставить("Описание", ?(ЭтоНаборЗаписей, Источник.Отбор, Источник.Ссылка));
	ИзмененияПоЗначениямПолей.Вставить("ИзмененнаяТаблица", ПолноеИмя);
	ИзмененияПоЗначениямПолей.Вставить("СоставИзменений");
	
	ВедущийОбъект = Новый Структура("ПоЗначениямПолей", ИзмененияПоЗначениямПолей);
	
	СпискиДляОбновления = Новый Соответствие;
	ПоЗначениямПолей = СвойстваСпискаКакВедущего.ПоЗначениямПолей;
	ПоляШапки = ПоЗначениямПолей.ПоляШапки;
	
	ПараметрыПланирования = ПараметрыПланированияОбновленияДоступа(Ложь);
	ПараметрыПланирования.РазрешенныеКлючиДоступа = Ложь;
	ПараметрыПланирования.Описание = "ЗапланироватьОбновлениеЗависимыхУстаревшихКлючейДоступа";
	ПараметрыПланирования.ВедущийОбъект = ВедущийОбъект;
	
	Если ЭтоНаборЗаписей Тогда
		Если ЗначениеЗаполнено(ПоляШапки.ВсеПоля) Тогда
			РезультатЗапроса = ?(РезультатыЗапроса = Неопределено, Неопределено, РезультатыЗапроса[0]);
			ЗапланироватьОбновлениеЗависимыхУстаревшихКлючейДоступаПоЗначениямПолей(РезультатЗапроса,
				Источник, ПоляШапки.НаборыПолей, ПараметрыПланирования);
		КонецЕсли;
	Иначе
		Если ЗначениеЗаполнено(ПоляШапки.ВсеПоля) Тогда
			РезультатЗапроса = ?(РезультатыЗапроса = Неопределено, Неопределено, РезультатыЗапроса[0]);
			НовыеЗначения = Новый ТаблицаЗначений;
			Для Каждого ИмяПоля Из ПоляШапки.ВсеПоля Цикл
				НовыеЗначения.Колонки.Добавить(ИмяПоля, ПоляШапки.ТипыВсехПолей.Получить(ИмяПоля).Получить());
			КонецЦикла;
			Если Не Удаление Тогда
				ЗаполнитьЗначенияСвойств(НовыеЗначения.Добавить(), Источник);
			КонецЕсли;
			ЗапланироватьОбновлениеЗависимыхУстаревшихКлючейДоступаПоЗначениямПолей(РезультатЗапроса,
				НовыеЗначения, ПоляШапки.НаборыПолей, ПараметрыПланирования);
			Индекс = 1;
		Иначе
			Индекс = 0;
		КонецЕсли;
		Для Каждого ОписаниеТабличнойЧасти Из ПоЗначениямПолей.ТабличныеЧасти Цикл
			РезультатЗапроса = ?(РезультатыЗапроса = Неопределено, Неопределено, РезультатыЗапроса[Индекс]);
			ИзмененияПоЗначениямПолей.ИзмененнаяТаблица = ПолноеИмя + "." + ОписаниеТабличнойЧасти.Имя;
			НовыеЗначения = НовыеЗначенияТабличнойЧасти(Источник, ОписаниеТабличнойЧасти, Удаление);
			ЗапланироватьОбновлениеЗависимыхУстаревшихКлючейДоступаПоЗначениямПолей(РезультатЗапроса,
				НовыеЗначения, ОписаниеТабличнойЧасти.НаборыПолей, ПараметрыПланирования);
			Индекс = Индекс + 1;
		КонецЦикла;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Ложь);
	УстановитьОтключениеБезопасногоРежима(Ложь);
	
КонецПроцедуры

// Для процедуры ЗапланироватьОбновлениеЗависимыхУстаревшихКлючейДоступа.
Функция НовыеЗначенияТабличнойЧасти(Источник, ОписаниеТабличнойЧасти, Удаление)
	
	Поля = Новый Массив(ОписаниеТабличнойЧасти.ВсеПоля);
	
	ИмяПоляСсылка = "Ссылка";
	Индекс = Поля.Найти(ИмяПоляСсылка);
	Если Индекс <> Неопределено Тогда
		Поля.Удалить(Индекс);
	Иначе
		ИмяПоляСсылка = "Ref";
		Индекс = Поля.Найти(ИмяПоляСсылка);
		Если Индекс <> Неопределено Тогда
			Поля.Удалить(Индекс);
		КонецЕсли;
	КонецЕсли;
	
	НовыеЗначения = Источник[ОписаниеТабличнойЧасти.Имя].Выгрузить(
		?(Удаление, Новый Массив, Неопределено), СтрСоединить(Поля, ", "));
	
	Если Индекс <> Неопределено Тогда
		Типы = Новый Массив;
		Типы.Добавить(ТипЗнч(Источник.Ссылка));
		НовыеЗначения.Колонки.Добавить(ИмяПоляСсылка, Новый ОписаниеТипов(Типы));
		НовыеЗначения.ЗаполнитьЗначения(Источник.Ссылка, ИмяПоляСсылка);
	КонецЕсли;
	
	Возврат НовыеЗначения;
	
КонецФункции

// Для процедуры ЗапланироватьОбновлениеЗависимыхУстаревшихКлючейДоступа.
Процедура ЗапланироватьОбновлениеЗависимыхУстаревшихКлючейДоступаПоЗначениямПолей(РезультатЗапроса,
			Источник, НаборыПолейПоВидамПользователей, ПараметрыПланирования)
	
	ВидыПользователей = Новый Массив;
	ВидыПользователей.Добавить("ДляПользователей");
	ВидыПользователей.Добавить("ДляВнешнихПользователей");
	
	Для Каждого ВидПользователей Из ВидыПользователей Цикл
		НаборыПолей = НаборыПолейПоВидамПользователей[ВидПользователей];
		Если НаборыПолей = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если ВидПользователей = "ДляПользователей" Тогда
			ПараметрыПланирования.ДляВнешнихПользователей = Ложь;
			ПараметрыПланирования.ДляПользователей = Истина;
		Иначе
			ПараметрыПланирования.ДляВнешнихПользователей = Истина;
			ПараметрыПланирования.ДляПользователей = Ложь;
		КонецЕсли;
		Для Каждого ОписаниеНабораПолей Из НаборыПолей Цикл
			СоставИзменений = СоставИзмененийТаблицы(РезультатЗапроса, Источник, ОписаниеНабораПолей.Ключ);
			Если СоставИзменений = Null Тогда
				Продолжить;
			КонецЕсли;
			Для Каждого ОписаниеЗависимыхТаблиц Из ОписаниеНабораПолей.Значение Цикл
				Если ОписаниеЗависимыхТаблиц.Ключ = ОписаниеНабораПолей.Ключ Тогда
					ТекущийСоставИзменений = СоставИзменений;
				Иначе
					ТекущийСоставИзменений = СоставИзменений.Скопировать(, ОписаниеЗависимыхТаблиц.Ключ);
					ТекущийСоставИзменений.Свернуть(ОписаниеЗависимыхТаблиц.Ключ);
				КонецЕсли;
				ПараметрыПланирования.ВедущийОбъект.ПоЗначениямПолей.СоставИзменений = ТекущийСоставИзменений;
				ЗапланироватьОбновлениеДоступа(ОписаниеЗависимыхТаблиц.Значение, ПараметрыПланирования);
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ЗапланироватьОбновлениеЗависимыхУстаревшихКлючейДоступаПоЗначениямПолей.
Функция СоставИзмененийТаблицы(РезультатЗапроса, Источник, Поля)
	
	МаксимумКомбинаций = МаксимальноеКоличествоКомбинацийЗначенийВедущихПолейПриВычисленииСоставаИзмененных();
	Если РезультатЗапроса = Неопределено Тогда
		СтарыеКомбинации = Новый ТаблицаЗначений;
	Иначе
		СтарыеКомбинации = РезультатЗапроса.Выгрузить();
		Если СтрРазделить(Поля, ",").Количество() < СтарыеКомбинации.Количество() Тогда
			СтарыеКомбинации = СтарыеКомбинации.Скопировать(, Поля);
			СтарыеКомбинации.Свернуть(Поля);
		КонецЕсли;
	КонецЕсли;
	
	Если СтарыеКомбинации.Количество() >= МаксимумКомбинаций Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипЗнч(Источник) = Тип("ТаблицаЗначений") Тогда
		НовыеКомбинации = Источник.Скопировать(, Поля);
	Иначе
		НовыеКомбинации = Источник.Выгрузить(, Поля);
	КонецЕсли;
	НовыеКомбинации.Свернуть(Поля);
	
	Если НовыеКомбинации.Количество() >= МаксимумКомбинаций Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СоставИзменений = НовыеКомбинации.Скопировать(Новый Массив);
	
	НовыеКомбинации.Колонки.Добавить("ВидИзменения", Новый ОписаниеТипов("Число"));
	НовыеКомбинации.ЗаполнитьЗначения(1, "ВидИзменения");
	Для Каждого Строка Из СтарыеКомбинации Цикл
		НоваяСтрока = НовыеКомбинации.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		НоваяСтрока.ВидИзменения = -1;
	КонецЦикла;
	НовыеКомбинации.Свернуть(Поля, "ВидИзменения");
	
	Для Каждого Строка Из НовыеКомбинации Цикл
		Если Строка.ВидИзменения <> 0 Тогда
			ЗаполнитьЗначенияСвойств(СоставИзменений.Добавить(), Строка);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ?(СоставИзменений.Количество() > 0, СоставИзменений, Null);
	
КонецФункции

// Для вызова и модуля менеджера справочника ГруппыДоступа.
Процедура ЗапланироватьОбновлениеДоступаПриИзмененииУчастниковГруппыДоступа(ГруппаДоступа,
			ТипыИзмененныхУчастников, ПриЗагрузке = Ложь) Экспорт
	
	Если Не ТипыИзмененныхУчастников.Пользователи
	   И Не ТипыИзмененныхУчастников.ВнешниеПользователи Тогда
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ГруппаДоступа", ГруппаДоступа);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ТаблицыГруппДоступа.Таблица КАК Таблица
	|ИЗ
	|	РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступа
	|ГДЕ
	|	ТаблицыГруппДоступа.ГруппаДоступа = &ГруппаДоступа";
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	Таблицы = Запрос.Выполнить().Выгрузить();
	Описание = ?(ПриЗагрузке,
		"ЗапланироватьОбновлениеДоступаПриИзмененииУчастниковГруппыДоступаПриЗагрузке",
		"ЗапланироватьОбновлениеДоступаПриИзмененииУчастниковГруппыДоступа");
	
	ЗапланироватьОбновлениеПользователейКлючейДоступа(Таблицы, Описание,
		ТипыИзмененныхУчастников.Пользователи, ТипыИзмененныхУчастников.ВнешниеПользователи, Истина);
	
	УстановитьПривилегированныйРежим(Ложь);
	УстановитьОтключениеБезопасногоРежима(Ложь);
	
КонецПроцедуры

// Для процедуры ПослеОбновленияСоставовГруппПользователей и
// модуля менеджера справочника ГруппыДоступа.
//
Процедура ЗапланироватьОбновлениеДоступаПриКосвенномИзмененииУчастниковГруппыДоступа(ИзмененныеУчастники,
			ПриЗагрузке = Ложь) Экспорт
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	Если ИзмененныеУчастники = Неопределено Тогда
		ДляПользователей        = Истина;
		ДляВнешнихПользователей = Истина;
		
		Запрос = Новый Запрос;
		Запрос.Текст =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ТаблицыГруппДоступа.Таблица КАК Таблица
		|ИЗ
		|	РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступа";
	Иначе
		ДляПользователей        = Ложь;
		ДляВнешнихПользователей = Ложь;
		
		Для Каждого Участник Из ИзмененныеУчастники Цикл
			Если ТипЗнч(Участник) = Тип("СправочникСсылка.Пользователи")
			 Или ТипЗнч(Участник) = Тип("СправочникСсылка.ГруппыПользователей") Тогда
				
				ДляПользователей = Истина;
			
			ИначеЕсли ТипЗнч(Участник) = Тип("СправочникСсылка.ВнешниеПользователи")
			      Или ТипЗнч(Участник) = Тип("СправочникСсылка.ГруппыВнешнихПользователей") Тогда
				
				ДляВнешнихПользователей = Истина;
			КонецЕсли;
		КонецЦикла;
		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ИзмененныеУчастники", ИзмененныеУчастники);
		Запрос.Текст =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ТаблицыГруппДоступа.Таблица КАК Таблица
		|ИЗ
		|	РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступа
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ГруппыДоступа.Пользователи КАК УчастникиГруппДоступа
		|		ПО ТаблицыГруппДоступа.ГруппаДоступа = УчастникиГруппДоступа.Ссылка
		|			И (УчастникиГруппДоступа.Пользователь В (&ИзмененныеУчастники))";
	КонецЕсли;
	
	Таблицы = Запрос.Выполнить().Выгрузить();
	Описание = ?(ПриЗагрузке,
		"ЗапланироватьОбновлениеДоступаПриКосвенномИзмененииУчастниковГруппыДоступаПриЗагрузке",
		"ЗапланироватьОбновлениеДоступаПриКосвенномИзмененииУчастниковГруппыДоступа");
	
	ЗапланироватьОбновлениеПользователейКлючейДоступа(Таблицы,
		Описание, ДляПользователей, ДляВнешнихПользователей, Истина);
	
	ЗапланироватьОбновлениеНаборовГруппДоступа(Описание, ДляПользователей, ДляВнешнихПользователей);
	
	УстановитьПривилегированныйРежим(Ложь);
	УстановитьОтключениеБезопасногоРежима(Ложь);
	
КонецПроцедуры

// Для вызова из модуля менеджера регистра ТаблицыГруппДоступа.
Процедура ЗапланироватьОбновлениеДоступаПриИзмененииТаблицГруппДоступа(Таблицы) Экспорт
	
	ЗапланироватьОбновлениеПользователейКлючейДоступа(Таблицы,
		"ЗапланироватьОбновлениеДоступаПриИзмененииТаблицГруппДоступа", Истина, Истина);
	
КонецПроцедуры

// Для вызова из модуля менеджера регистра ЗначенияГруппДоступа.
Процедура ЗапланироватьОбновлениеДоступаПриИзмененииРазрешенныхЗначений(ГруппыДоступаИТипыЗначений) Экспорт
	
	ОчиститьКэшЗначенийГруппДоступаДляРасчетаПрав();
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ГруппыДоступаИТипыЗначений", ГруппыДоступаИТипыЗначений);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ГруппыДоступаИТипыЗначений.ГруппаДоступа КАК ГруппаДоступа,
	|	ГруппыДоступаИТипыЗначений.ТипЗначенийДоступа КАК ТипЗначенийДоступа
	|ПОМЕСТИТЬ ГруппыДоступаИТипыЗначений
	|ИЗ
	|	&ГруппыДоступаИТипыЗначений КАК ГруппыДоступаИТипыЗначений
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ТаблицыГруппДоступа.Таблица КАК Таблица,
	|	ТИПЗНАЧЕНИЯ(ГруппыДоступаИТипыЗначений.ТипЗначенийДоступа) КАК ТипЗначенийДоступа
	|ИЗ
	|	РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступа
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ГруппыДоступаИТипыЗначений КАК ГруппыДоступаИТипыЗначений
	|		ПО ТаблицыГруппДоступа.ГруппаДоступа = ГруппыДоступаИТипыЗначений.ГруппаДоступа
	|ИТОГИ ПО
	|	Таблица";
	
	ТаблицыИТипыЗначенийДоступа = Запрос.Выполнить().Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкам);
	
	ЗапланироватьОбновлениеПользователейКлючейДоступа(ТаблицыИТипыЗначенийДоступа.Строки,
		"ЗапланироватьОбновлениеДоступаПриИзмененииРазрешенныхЗначений", Истина, Истина);
	
КонецПроцедуры

// Для процедур ЗапланироватьОбновлениеДоступаПриИзмененииРазрешенныхЗначений,
// ЗапланироватьОбновлениеДоступа и вызова из модуля формы ОбновлениеДоступаРучноеУправление.
//
Процедура ОчиститьКэшЗначенийГруппДоступаДляРасчетаПрав() Экспорт
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	ИмяПараметраВерсии = "СтандартныеПодсистемы.УправлениеДоступом.ЗначенияГруппДоступаВерсия";
	СтандартныеПодсистемыСервер.УстановитьПараметрРаботыРасширения(ИмяПараметраВерсии, Новый УникальныйИдентификатор, Истина);
	
	ИмяПараметра = "СтандартныеПодсистемы.УправлениеДоступом.ЗначенияГруппДоступа";
	СтандартныеПодсистемыСервер.УстановитьПараметрРаботыРасширения(ИмяПараметра, Неопределено, Истина);
	
	УстановитьПривилегированныйРежим(Ложь);
	УстановитьОтключениеБезопасногоРежима(Ложь);
	
КонецПроцедуры

// Для процедуры ЗапланироватьОбновлениеДоступа, ЗапланироватьОбновлениеПараметровОграниченияДоступа.
Функция СлужебныйИдентификатор(ПолноеИмя)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ПолноеИмя", ПолноеИмя);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ИдентификаторыОбъектовМетаданных.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.ИдентификаторыОбъектовМетаданных КАК ИдентификаторыОбъектовМетаданных
	|ГДЕ
	|	ИдентификаторыОбъектовМетаданных.ПолноеИмя = &ПолноеИмя
	|
	|УПОРЯДОЧИТЬ ПО
	|	ИдентификаторыОбъектовМетаданных.ПометкаУдаления";
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат Выборка.Ссылка;
	КонецЕсли;
	
	Возврат Null;
	
КонецФункции

// Для процедур ЗапланироватьОбновлениеДоступаПриИзмененииУчастниковГруппыДоступа,
// ЗапланироватьОбновлениеДоступаПослеОбновленияСоставовГруппПользователей,
// ЗапланироватьОбновлениеДоступаПриИзмененииТаблицГруппДоступа,
// ЗапланироватьОбновлениеДоступаПриИзмененииРазрешенныхЗначений.
//
Процедура ЗапланироватьОбновлениеПользователейКлючейДоступа(ОписаниеСписков, Описание, ДляПользователей,
				ДляВнешнихПользователей, ПриИзмененииУчастниковГруппыДоступа = Ложь, ВедущийОбъект = Неопределено)
	
	Если ОписаниеСписков.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Контекст = Новый Структура;
	Контекст.Вставить("ПриИзмененииУчастниковГруппыДоступа", ПриИзмененииУчастниковГруппыДоступа);
	Контекст.Вставить("ИдентификаторТранзакции",             Новый УникальныйИдентификатор);
	Контекст.Вставить("Список",                              Неопределено);
	Контекст.Вставить("ПолноеИмя",                           Неопределено);
	Контекст.Вставить("ТипыЗначенийДоступа",                 Неопределено);
	
	Если ТипЗнч(ОписаниеСписков) = Тип("ФиксированныйМассив") Тогда
		ИдентификаторыСписковПоПолнымИменам = ОбщегоНазначения.ИдентификаторыОбъектовМетаданных(ОписаниеСписков);
	Иначе
		ПолныеИмена = ОписаниеСписков.ВыгрузитьКолонку("Таблица");
		ОбъектыМетаданныхСписков = ОбщегоНазначения.ОбъектыМетаданныхПоИдентификаторам(ПолныеИмена, Ложь);
	КонецЕсли;
	
	Списки = Новый Массив;
	СпискиДляПользователей = Новый Массив;
	СпискиДляВнешнихПользователей = Новый Массив;
	
	Для Каждого ОписаниеСписка Из ОписаниеСписков Цикл
		Если ИдентификаторыСписковПоПолнымИменам <> Неопределено Тогда
			Контекст.ПолноеИмя = ОписаниеСписка;
			Контекст.Список = ИдентификаторыСписковПоПолнымИменам.Получить(Контекст.ПолноеИмя);
		Иначе
			ОбъектМетаданных = ОбъектыМетаданныхСписков.Получить(ОписаниеСписка.Таблица);
			Контекст.ПолноеИмя = ?(ТипЗнч(ОбъектМетаданных) = Тип("ОбъектМетаданных"), ОбъектМетаданных.ПолноеИмя(), "");
			Контекст.Список    = ОписаниеСписка.Таблица;
			Если ТипЗнч(ОписаниеСписка) = Тип("СтрокаДереваЗначений") Тогда
				Контекст.ТипыЗначенийДоступа = ОписаниеСписка.Строки;
			КонецЕсли;
		КонецЕсли;
		Если Не ЗначениеЗаполнено(Контекст.ПолноеИмя) Тогда
			Продолжить;
		КонецЕсли;
		ЗапланироватьДляПользователей = ДляПользователей
			И ТребуетсяОбновлениеПользователейКлючейДоступа(Контекст, Ложь);
		
		ЗапланироватьДляВнешнихПользователей = ДляВнешнихПользователей
			И ТребуетсяОбновлениеПользователейКлючейДоступа(Контекст, Истина);
		
		Если ЗапланироватьДляПользователей И ЗапланироватьДляВнешнихПользователей Тогда
			Списки.Добавить(Контекст.ПолноеИмя);
			
		ИначеЕсли ЗапланироватьДляПользователей Тогда
			СпискиДляПользователей.Добавить(Контекст.ПолноеИмя);
			
		ИначеЕсли ЗапланироватьДляВнешнихПользователей Тогда
			СпискиДляВнешнихПользователей.Добавить(Контекст.ПолноеИмя);
		КонецЕсли;
	КонецЦикла;
	
	ПараметрыПланирования = ПараметрыПланированияОбновленияДоступа(Ложь);
	ПараметрыПланирования.КлючиДоступаКДанным = Ложь;
	ПараметрыПланирования.ВедущийОбъект = ВедущийОбъект;
	ПараметрыПланирования.Описание = Описание;
	ЗапланироватьОбновлениеДоступа(Списки, ПараметрыПланирования);
	
	ПараметрыПланирования.ДляВнешнихПользователей = Ложь;
	ЗапланироватьОбновлениеДоступа(СпискиДляПользователей, ПараметрыПланирования);
	
	ПараметрыПланирования.ДляПользователей = Ложь;
	ПараметрыПланирования.ДляВнешнихПользователей = Истина;
	ЗапланироватьОбновлениеДоступа(СпискиДляВнешнихПользователей, ПараметрыПланирования);
	
КонецПроцедуры

// Для процедуры ЗапланироватьОбновлениеПользователейКлючейДоступа.
Функция ТребуетсяОбновлениеПользователейКлючейДоступа(Контекст, ДляВнешнихПользователей)
	
	ДействующиеПараметры = ДействующиеПараметрыОграниченияДоступа(Контекст.ИдентификаторТранзакции, Неопределено, Ложь);
	Если ДляВнешнихПользователей Тогда
		ДополнительныйКонтекст = ДействующиеПараметры.ДополнительныйКонтекст.ДляВнешнихПользователей;
	Иначе
		ДополнительныйКонтекст = ДействующиеПараметры.ДополнительныйКонтекст.ДляПользователей;
	КонецЕсли;
	СвойстваОграничения = ДополнительныйКонтекст.СвойстваОграниченияСписков.Получить(Контекст.ПолноеИмя);
	
	Если ДополнительныйКонтекст.СпискиСОтключеннымОграничением.Получить(Контекст.ПолноеИмя) <> Неопределено
	 Или СвойстваОграничения = Неопределено
	 Или СвойстваОграничения.ДоступЗапрещен
	 Или СвойстваОграничения.ПолеВладельца <> Неопределено
	 Или Контекст.ПриИзмененииУчастниковГруппыДоступа
	   И Не СвойстваОграничения.РассчитыватьПраваПользователей Тогда
		
		Возврат Ложь;
	КонецЕсли;
	
	Если СвойстваОграничения <> Неопределено
	   И Контекст.ТипыЗначенийДоступа <> Неопределено
	   И Не Контекст.ПриИзмененииУчастниковГруппыДоступа Тогда
		
		СредиИзмененныхТиповЗначенийДоступаНетИспользуемых = Истина;
		ИспользуемыеТипыЗначенийДоступа = СвойстваОграничения.ИспользуемыеТипыЗначенийДоступа.Получить();
		Для Каждого Строка Из Контекст.ТипыЗначенийДоступа Цикл
			Если ИспользуемыеТипыЗначенийДоступа.Найти(Строка.ТипЗначенийДоступа) <> Неопределено Тогда
				СредиИзмененныхТиповЗначенийДоступаНетИспользуемых = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если СредиИзмененныхТиповЗначенийДоступаНетИспользуемых Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Для процедуры ЗапланироватьОбновлениеДоступаПриКосвенномИзмененииУчастниковГруппыДоступа и
// модулей менеджера и объекта справочника ГруппыДоступа.
//
Процедура ЗапланироватьОбновлениеНаборовГруппДоступа(Описание, ДляПользователей = Истина, ДляВнешнихПользователей = Истина) Экспорт
	
	Если Не ДляПользователей И Не ДляВнешнихПользователей Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	НаборЗаписей = СлужебныйНаборЗаписей(РегистрыСведений.ОбновлениеКлючейДоступаКДанным);
	
	Список = "Справочник.НаборыГруппДоступа";
	КлючУникальности = Новый УникальныйИдентификатор;
	ИдентификаторСписка = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(Список);
	ТекущаяДата = ТекущаяДатаСеанса();
	МаксимальнаяДата = МаксимальнаяДата();
	
	// Обновление только по изменениям (не полное).
	ПараметрыЗадания = Новый Структура;
	УстановитьВидКлючаДанных(ПараметрыЗадания, "НовыеНаборыИзОдногоПользователя");
	ХранилищеПараметровЗадания = Новый ХранилищеЗначения(ПараметрыЗадания);
	
	Если ДляПользователей Тогда
		НоваяЗапись = НаборЗаписей.Добавить();
		НоваяЗапись.КлючУникальности                   = КлючУникальности;
		НоваяЗапись.Список                             = ИдентификаторСписка;
		НоваяЗапись.ДляВнешнихПользователей            = Ложь;
		НоваяЗапись.ДатаПоследнегоОбновленногоЭлемента = МаксимальнаяДата;
		НоваяЗапись.ПараметрыЗадания                   = ХранилищеПараметровЗадания;
		НоваяЗапись.РазмерЗадания                      = 3;
		НоваяЗапись.ДатаИзмененияЗаписиРегистра        = ТекущаяДата;
	КонецЕсли;
	
	Если ДляВнешнихПользователей Тогда
		НоваяЗапись = НаборЗаписей.Добавить();
		НоваяЗапись.КлючУникальности                   = КлючУникальности;
		НоваяЗапись.Список                             = ИдентификаторСписка;
		НоваяЗапись.ДляВнешнихПользователей            = Истина;
		НоваяЗапись.ДатаПоследнегоОбновленногоЭлемента = МаксимальнаяДата;
		НоваяЗапись.ПараметрыЗадания                   = ХранилищеПараметровЗадания;
		НоваяЗапись.РазмерЗадания                      = 3;
		НоваяЗапись.ДатаИзмененияЗаписиРегистра        = ТекущаяДата;
	КонецЕсли;
	
	НаборЗаписей.Записать(Ложь);
	
	ПараметрыПланирования = ПараметрыПланированияОбновленияДоступа(Ложь);
	ПараметрыПланирования.РазрешенныеКлючиДоступа = Ложь;
	ПараметрыПланирования.ДляПользователей        = ДляПользователей;
	ПараметрыПланирования.ДляВнешнихПользователей = ДляВнешнихПользователей;
	ПараметрыПланирования.Описание = Описание;
	
	СпискиПоИдентификаторам = Новый Соответствие;
	СпискиПоИдентификаторам.Вставить(ИдентификаторСписка, Список);
	
	ЗарегистрироватьПланированиеОбновленияДоступа(СпискиПоИдентификаторам, ПараметрыПланирования);
	
	УстановитьПривилегированныйРежим(Ложь);
	УстановитьОтключениеБезопасногоРежима(Ложь);
	
КонецПроцедуры

#КонецОбласти

#Область ОбновлениеДоступа

// Запускает фоновое задание обновления доступа вместо регламентного задания.
//
// Параметры:
//  ЭтоЗапускВручную - Булево - если передать Ложь, то наименование будет начинаться с "Автозапуск",
//                              в противном случае, наименование будет начинаться с "Запуск вручную",
//                              блокировка обновления доступа будет снята, если была установлена,
//                              выполнение будет продолжаться до полного завершения.
//
// Возвращаемое значение:
//  Неопределено - обновление доступа не требуется или запрещено.
//  Структура - со свойствами:
//   * УжеВыполняется - Булево - если обновление уже выполняется.
//
//   * ИдентификаторФоновогоЗадания - Неопределено - если обновление не выполняется или
//                                      выполняется не в фоновом задании.
//                                  - УникальныйИдентификатор - идентификатор фонового задания.
//
//   * СвойстваСеанса - Неопределено - если запуска не было или фоновое задание только добавлено в очередь.
//                    - Структура - со свойствами сеанса, если обновление уже выполняется:
//                        * ИмяКомпьютера - Строка - одноименное свойства объекта СеансИнформационнойБазы.
//                        * НомерСеанса   - Число  - одноименное свойства объекта СеансИнформационнойБазы.
//                        * НачалоСеанса  - Строка - одноименное свойства объекта СеансИнформационнойБазы.
//
//   * ТекстПредупреждения - Неопределено - если запуска не было или запущено новое фоновое задание.
//                         - Строка - описание, что обновление доступа уже запущено.
//
Функция ЗапуститьОбновлениеДоступаНаУровнеЗаписей(ЭтоЗапускВручную = Ложь) Экспорт
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	Если Не ОграничиватьДоступНаУровнеЗаписейУниверсально(Истина) Тогда
		ТекстОшибки =
			НСтр("ru = 'Невозможно запустить обновление доступа на уровне записей, так как
			           |константа ОграничиватьДоступНаУровнеЗаписейУниверсально выключена.'");
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Если ТранзакцияАктивна() Тогда
		ТекстОшибки =
			НСтр("ru = 'Невозможно запустить обновление доступа на уровне записей в открытой транзакции.'");
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Если Не ЭтоЗапускВручную И Не ЗапланированоОбновлениеДоступа() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПоследнееОбновлениеДоступа = ПоследнееОбновлениеДоступа();
	Если Не ЭтоЗапускВручную И ПоследнееОбновлениеДоступа.ОбновлениеДоступаЗапрещено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Новый Структура("УжеВыполняется, ИдентификаторФоновогоЗадания, СвойстваСеанса, ТекстПредупреждения", Истина);
	Исполнитель = ИсполнительОбновленияДоступа(ПоследнееОбновлениеДоступа);
	
	Если Исполнитель = Неопределено Тогда
		Результат.УжеВыполняется = Ложь;
		Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
			СтандартныеПодсистемыСервер.ПроверитьДинамическоеОбновлениеВерсииПрограммы();
		КонецЕсли;
		Если ЭтоЗапускВручную Тогда
			УстановитьЗапретОбновленияДоступа(Ложь);
			ПараметрыЗадания = Новый Массив;
			ПараметрыЗадания.Добавить(Истина);
		Иначе
			ПараметрыЗадания = Неопределено;
		КонецЕсли;
		ФоновоеЗадание = РасширенияКонфигурации.ВыполнитьФоновоеЗаданиеСРасширениямиБазыДанных(
			Метаданные.РегламентныеЗадания.ОбновлениеДоступаНаУровнеЗаписей.ИмяМетода, ПараметрыЗадания,,
			?(ЭтоЗапускВручную, НСтр("ru = 'Запуск вручную'"), НСтр("ru = 'Автозапуск'")) + ": "
				+ Метаданные.РегламентныеЗадания.ОбновлениеДоступаНаУровнеЗаписей.Синоним);
			
		Результат.ИдентификаторФоновогоЗадания = ФоновоеЗадание.УникальныйИдентификатор;
		
	ИначеЕсли ТипЗнч(Исполнитель) = Тип("ФоновоеЗадание")
	        И Исполнитель.УникальныйИдентификатор <> ПоследнееОбновлениеДоступа.ИдентификаторФоновогоЗадания Тогда
		
		Результат.ТекстПредупреждения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось начать обновление доступа, так как оно уже запущено %3 в %4'"),
			Формат(Исполнитель.Начало, "ДЛФ=D"),
			Формат(Исполнитель.Начало, "ДЛФ=T"));
	Иначе
		СвойстваСеанса = Новый Структура("ИмяКомпьютера, НомерСеанса, НачалоСеанса");
		Если ТипЗнч(Исполнитель) = Тип("ФоновоеЗадание") Тогда
			ЗаполнитьЗначенияСвойств(СвойстваСеанса, ПоследнееОбновлениеДоступа);
		Иначе
			ЗаполнитьЗначенияСвойств(СвойстваСеанса, Исполнитель);
		КонецЕсли;
		Результат.СвойстваСеанса = СвойстваСеанса;
		Результат.ТекстПредупреждения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Обновление доступа уже выполняется
			           |(компьютер: %1, сеанс: %2, начат: %3 в %4)'"),
			СвойстваСеанса.ИмяКомпьютера,
			СвойстваСеанса.НомерСеанса,
			Формат(СвойстваСеанса.НачалоСеанса, "ДЛФ=D"),
			Формат(СвойстваСеанса.НачалоСеанса, "ДЛФ=T"));
	КонецЕсли;
	
	Если ТипЗнч(Исполнитель) = Тип("ФоновоеЗадание") Тогда
		Результат.ИдентификаторФоновогоЗадания = Исполнитель.УникальныйИдентификатор;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Отменить обновление доступа, которое выполняется в фоновом задании.
Процедура ОтменитьОбновлениеДоступаНаУровнеЗаписей() Экспорт
	
	Исполнитель = ИсполнительОбновленияДоступа(ПоследнееОбновлениеДоступа());
	
	Если ТипЗнч(Исполнитель) = Тип("СеансИнформационнойБазы") Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Невозможно отменить полное обновление доступа
			           |(компьютер: %1, сеанс: %2, начат: %3 в %4)'"),
			Исполнитель.ИмяКомпьютера,
			Исполнитель.НомерСеанса,
			Формат(Исполнитель.НачалоСеанса, "ДЛФ=D"),
			Формат(Исполнитель.НачалоСеанса, "ДЛФ=T"));
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Выполняется = ТипЗнч(Исполнитель) = Тип("ФоновоеЗадание");
	
	ЗавершитьПотокиОбновленияДоступа(Истина);
	УстановитьЗапретОбновленияДоступа(Истина, Выполняется);
	
	Если Выполняется Тогда
		Исполнитель = Исполнитель.ОжидатьЗавершенияВыполнения(СекундОжиданияЗавершенияФоновогоЗадания());
		Если Исполнитель.Состояние = СостояниеФоновогоЗадания.Активно Тогда
			Исполнитель.Отменить();
		КонецЕсли;
	КонецЕсли;
	
	Отбор = Новый Структура;
	Отбор.Вставить("Состояние", СостояниеФоновогоЗадания.Активно);
	Отбор.Вставить("ИмяМетода", Метаданные.РегламентныеЗадания.ОбновлениеДоступаНаУровнеЗаписей.ИмяМетода);
	ОсновныеЗадания = ФоновыеЗадания.ПолучитьФоновыеЗадания(Отбор);
	
	Для Каждого ОсновноеЗадание Из ОсновныеЗадания Цикл
		ОсновноеЗадание = ОсновноеЗадание.ОжидатьЗавершенияВыполнения(1);
		Если ОсновноеЗадание.Состояние = СостояниеФоновогоЗадания.Активно Тогда
			ОсновноеЗадание.Отменить();
		КонецЕсли;
	КонецЦикла;
	
	ОтменитьФоновыеЗаданияПотоковОбновленияДоступа();
	
КонецПроцедуры

// Включает или отключает запрет обновления доступа при запуске
// с помощью регламентного задания или при программном запуске.
//
// При вызове процедуры ОбновлениеДоступаНаУровнеЗаписей
// с признаком ОбновитьВсе запрет игнорируется.
// 
// При вызове процедуры ЗапуститьОбновлениеДоступаНаУровнеЗаписей
// с признаком ЭтоЗапускВручную запрет снимается автоматически.
//
Процедура УстановитьЗапретОбновленияДоступа(Использование, ОтменитьОбновление = Ложь) Экспорт
	
	БлокировкаДанных = Новый БлокировкаДанных;
	БлокировкаДанных.Добавить("Константа.ПоследнееОбновлениеДоступа");
	
	НачатьТранзакцию();
	Попытка
		БлокировкаДанных.Заблокировать();
		ЗначениеКонстанты = Константы.ПоследнееОбновлениеДоступа.Получить();
		ПоследнееОбновлениеДоступа = ПоследнееОбновлениеДоступа(ЗначениеКонстанты);
		
		Записать = Ложь;
		Если ПоследнееОбновлениеДоступа.ОбновлениеДоступаЗапрещено <> Использование Тогда
			ПоследнееОбновлениеДоступа.ОбновлениеДоступаЗапрещено = Использование;
			Записать = Истина;
		КонецЕсли;
		
		Если ОтменитьОбновление
		   И ПоследнееОбновлениеДоступа.ДатаЗапускаНаСервере > ПоследнееОбновлениеДоступа.ДатаЗавершенияНаСервере
		   И ( Не ПоследнееОбновлениеДоступа.ОбновлениеОтменено
		      Или ПоследнееОбновлениеДоступа.ТекстОшибкиЗавершения <> "") Тогда
			
			ПоследнееОбновлениеДоступа.ОбновлениеОтменено = Истина;
			ПоследнееОбновлениеДоступа.ТекстОшибкиЗавершения = "";
			ПоследнееОбновлениеДоступа.ДатаЗавершенияНаСервере = ТекущаяДатаНаСервере();
			ПоследнееОбновлениеДоступа.ПоследнееВыполнениеСекунд =
				ПоследнееОбновлениеДоступа.ДатаЗавершенияНаСервере - ПоследнееОбновлениеДоступа.ДатаЗапускаНаСервере
					+ СекундОжиданияЗавершенияФоновогоЗадания() + 1;
			Записать = Истина;
		КонецЕсли;
		
		Если Записать Тогда
			Константы.ПоследнееОбновлениеДоступа.Установить(
				Новый ХранилищеЗначения(ПоследнееОбновлениеДоступа));
		КонецЕсли;
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Для процедур ОтменитьОбновлениеДоступаНаУровнеЗаписей, УстановитьЗапретОбновленияДоступа.
Функция СекундОжиданияЗавершенияФоновогоЗадания()
	
	Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		Возврат 3;
	Иначе
		Возврат 15;
	КонецЕсли;
	
КонецФункции

// Обработчик регламентного задания ОбновлениеДоступаНаУровнеЗаписей.
Процедура ОбновлениеДоступаНаУровнеЗаписей(ОбновитьВсе = Ложь, ВызыватьИсключениеВместоРегистрацииОшибки = Ложь) Экспорт
	
	// Регламентное задание должно запускаться сразу, как только было запланировано обновление доступа.
	// После обработки первой порции по всем таблицам (2 мин на все) можно сделать
	// небольшую паузу вместо непрерывного выполнения до конца.
	// В данном случае пауза - это перезапуск через 15 секунд.
	// В отличие от обычных регламентных заданий это задание самоотключаемое,
	// то есть после отработки запланированного обновления, задание выключает само себя и
	// запуски полностью прекращаются до того, как будет запланировано новое обновление доступа.
	
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(
		Метаданные.РегламентныеЗадания.ОбновлениеДоступаНаУровнеЗаписей);
	
	ВыполнитьОбновлениеДоступаНаУровнеЗаписей(ОбновитьВсе, ВызыватьИсключениеВместоРегистрацииОшибки, 0);
	
КонецПроцедуры

// Выполняет обновление доступа, если запланировано.
Процедура ВыполнитьОбновлениеДоступаНаУровнеЗаписей(ОбновитьВсе,
			ВызыватьИсключениеВместоРегистрацииОшибки, СекундНеБолее, ПослеОбновлениеИБ = Ложь)
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	ТекущийСеанс = ПолучитьТекущийСеансИнформационнойБазы();
	ОписаниеОсновногоСеанса = Новый Структура("ИдентификаторФоновогоЗадания, ФоновоеЗадание");
	ОписаниеОсновногоСеанса.Вставить("НомерСеанса",  ТекущийСеанс.НомерСеанса);
	ОписаниеОсновногоСеанса.Вставить("НачалоСеанса", ТекущийСеанс.НачалоСеанса);
	
	Если ТекущийСеанс.ИмяПриложения <> "BackgroundJob" Тогда
		Если ОбновитьВсе Тогда
			ИдентификаторФоновогоЗадания = ИдентификаторПроизвольногоСеанса();
		Иначе
			ТекстОшибки = НСтр("ru = 'Обновление доступа может выполняться порциями только в фоновом задании.'");
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
		ИдентификаторОсновногоСеанса = Строка(Новый УникальныйИдентификатор);
	Иначе
		ТекущееФоновоеЗадание = ТекущийСеанс.ПолучитьФоновоеЗадание();
		Если ТекущееФоновоеЗадание = Неопределено Тогда
			ТекстОшибки = НСтр("ru = 'Не удалось получить фоновое задание текущего сеанса.'");
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
		ИдентификаторФоновогоЗадания = ТекущееФоновоеЗадание.УникальныйИдентификатор;
		ОписаниеОсновногоСеанса.ФоновоеЗадание = ТекущееФоновоеЗадание;
		ОписаниеОсновногоСеанса.ИдентификаторФоновогоЗадания = ИдентификаторФоновогоЗадания;
		ИдентификаторОсновногоСеанса = Строка(ИдентификаторФоновогоЗадания);
	КонецЕсли;
	ОписаниеОсновногоСеанса.Вставить("Идентификатор", ИдентификаторОсновногоСеанса
		+ " (" + НСтр("ru = 'Идентификатор основного сеанса'") + ")");
	
	БлокировкаДанных = Новый БлокировкаДанных;
	БлокировкаДанных.Добавить("Константа.ПоследнееОбновлениеДоступа");
	
	НачатьТранзакцию();
	Попытка
		БлокировкаДанных.Заблокировать();
		ЗначениеКонстанты = Константы.ПоследнееОбновлениеДоступа.Получить();
		ПоследнееОбновлениеДоступа = ПоследнееОбновлениеДоступа(ЗначениеКонстанты);
		
		Если ОбновитьВсе Или Не ПоследнееОбновлениеДоступа.ОбновлениеДоступаЗапрещено Тогда
			Исполнитель = ИсполнительОбновленияДоступа(ПоследнееОбновлениеДоступа, ИдентификаторФоновогоЗадания);
			
			Если Исполнитель = Неопределено Тогда
				ПоследнееОбновлениеДоступа.ОбновлениеОтменено   = Ложь;
				ПоследнееОбновлениеДоступа.ДатаЗапускаНаСервере = ТекущаяДатаНаСервере();
				ПоследнееОбновлениеДоступа.НомерСеанса          = ТекущийСеанс.НомерСеанса;
				ПоследнееОбновлениеДоступа.НачалоСеанса         = ТекущийСеанс.НачалоСеанса;
				ПоследнееОбновлениеДоступа.ИмяКомпьютера        = ТекущийСеанс.ИмяКомпьютера;
				ПоследнееОбновлениеДоступа.ИдентификаторФоновогоЗадания = ИдентификаторФоновогоЗадания;
				
				Константы.ПоследнееОбновлениеДоступа.Установить(
					Новый ХранилищеЗначения(ПоследнееОбновлениеДоступа));
			КонецЕсли;
		КонецЕсли;
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	Если Не ОбновитьВсе И ПоследнееОбновлениеДоступа.ОбновлениеДоступаЗапрещено Тогда
		Если ТекущееФоновоеЗадание.РегламентноеЗадание <> Неопределено Тогда
			УстановитьОбновлениеДоступа(Ложь);
		КонецЕсли;
		ТекстОшибки =
			НСтр("ru = 'Обновление доступа запрещено.
			           |Чтобы разрешить нужно нажать ""Разрешить"" в форме ""Обновление доступа на уровне записей"".
			           |Форму можно открыть из панели ""Настройки пользователей и прав"" или перейти по навигационной ссылке:
			           |e1cib/app/РегистрСведений.ОбновлениеКлючейДоступаКДанным.Форма.ОбновлениеДоступаНаУровнеЗаписей'");
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Если Исполнитель <> Неопределено Тогда
		Если Не ОбновитьВсе Или ПослеОбновлениеИБ Тогда
			Возврат;
		КонецЕсли;
		
		Если ТипЗнч(Исполнитель) = Тип("ФоновоеЗадание")
		   И Исполнитель.УникальныйИдентификатор <> ПоследнееОбновлениеДоступа.ИдентификаторФоновогоЗадания Тогда
			
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Не удалось начать обновление доступа, так как оно уже запущено %3 в %4'"),
				Формат(Исполнитель.Начало, "ДЛФ=D"),
				Формат(Исполнитель.Начало, "ДЛФ=T"));
		Иначе
			СвойстваСеанса = ?(ТипЗнч(Исполнитель) = Тип("ФоновоеЗадание"),
				ПоследнееОбновлениеДоступа, Исполнитель);
			
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Не удалось начать обновление доступа, так как оно уже выполняется
				           |(компьютер: %1, сеанс: %2, начат: %3 в %4)'"),
				СвойстваСеанса.ИмяКомпьютера,
				СвойстваСеанса.НомерСеанса,
				Формат(СвойстваСеанса.НачалоСеанса, "ДЛФ=D"),
				Формат(СвойстваСеанса.НачалоСеанса, "ДЛФ=T"));
		КонецЕсли;
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	ПоследнееОбновлениеДоступа.ОбновлениеОтменено = Ложь;
	ПоследнееОбновлениеДоступа.ТекстОшибкиЗавершения = "";
	ПоследнееОбновлениеДоступа.ИдентификаторФоновогоЗадания =
		ОбщегоНазначенияКлиентСервер.ПустойУникальныйИдентификатор();
	
	ТекстОшибкиПланирования = "";
	ТекстВсехОшибок = "";
	ТекстОшибкиЗавершения = "";
	Попытка
		Если КонфигурацияБазыДанныхИзмененаДинамически() Тогда
			СтандартныеПодсистемыСервер.ПотребоватьПерезапускСеансаПоПричинеДинамическогоОбновленияВерсииПрограммы();
		КонецЕсли;
		Если ОграничиватьДоступНаУровнеЗаписейУниверсально() Тогда
			ПроверитьОбновитьДействующиеПараметрыОграниченияДоступа();
			ЗапланироватьОбработкуУстаревшихЭлементов(ТекстОшибкиПланирования,
				ПоследнееОбновлениеДоступа.ПоследнееПланированиеОбработкиУстаревшихЭлементов);
			ВыполнитьОбновлениеДоступа(ОбновитьВсе, ОписаниеОсновногоСеанса,
				ПоследнееОбновлениеДоступа.ОбновлениеОтменено, ТекстОшибкиЗавершения, СекундНеБолее);
		Иначе
			УстановитьОбновлениеДоступа(Ложь);
		КонецЕсли;
	Исключение
		ТекстВсехОшибок = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Попытка
		ЗавершитьПотокиОбновленияДоступа();
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ДобавитьТекстОшибкиЗавершения(ТекстВсехОшибок, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось завершить потоки обновления доступа по причине:
			           |%1'"),
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке)));
	КонецПопытки;
	
	Попытка
		ОтменитьФоновыеЗаданияПотоковОбновленияДоступа(2);
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ДобавитьТекстОшибкиЗавершения(ТекстВсехОшибок, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось отменить фоновые задания потоков обновления доступа по причине:
			           |%1'"),
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке)));
	КонецПопытки;
	
	ДобавитьТекстОшибкиЗавершения(ТекстВсехОшибок, ТекстОшибкиПланирования);
	ДобавитьТекстОшибкиЗавершения(ТекстВсехОшибок, ТекстОшибкиЗавершения);
	
	ПоследнееОбновлениеДоступа.ТекстОшибкиЗавершения = ТекстВсехОшибок;
	ПоследнееОбновлениеДоступа.ДатаЗавершенияНаСервере = ТекущаяДатаНаСервере();
	ПоследнееОбновлениеДоступа.ПоследнееВыполнениеСекунд =
		ПоследнееОбновлениеДоступа.ДатаЗавершенияНаСервере - ПоследнееОбновлениеДоступа.ДатаЗапускаНаСервере;
	
	НачатьТранзакцию();
	Попытка
		БлокировкаДанных.Заблокировать();
		ЗначениеКонстанты = Константы.ПоследнееОбновлениеДоступа.Получить();
		ТекущееПоследнееОбновлениеДоступа = ПоследнееОбновлениеДоступа(ЗначениеКонстанты);

		ПоследнееОбновлениеДоступа.ОбновлениеДоступаЗапрещено =
			ТекущееПоследнееОбновлениеДоступа.ОбновлениеДоступаЗапрещено;
		
		Константы.ПоследнееОбновлениеДоступа.Установить(Новый ХранилищеЗначения(ПоследнееОбновлениеДоступа));
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	Если Не ЗначениеЗаполнено(ТекстВсехОшибок) Тогда
		Возврат;
	КонецЕсли;
	
	ТекстВсехОшибок = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Не удалось выполнить обновление доступа по причине:
		           |%1'"), ТекстВсехОшибок);
	
	Если ВызыватьИсключениеВместоРегистрацииОшибки Тогда
		ВызватьИсключение ТекстВсехОшибок;
	Иначе
		ЗарегистрироватьОшибкуОбновленияДоступа(ТекстВсехОшибок,
			Новый Структура("ОписаниеОсновногоСеанса", ОписаниеОсновногоСеанса));
	КонецЕсли;
	
КонецПроцедуры

// Для функции ЗапуститьОбновлениеДоступаНаУровнеЗаписей.
Функция ЗапланированоОбновлениеДоступа()
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА КАК ЗначениеИстина
	|ИЗ
	|	РегистрСведений.ОбновлениеКлючейДоступаКДанным КАК ОбновлениеКлючейДоступаКДанным
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА
	|ИЗ
	|	РегистрСведений.ОбновлениеКлючейДоступаПользователей КАК ОбновлениеКлючейДоступаПользователей";
	
	Возврат Не Запрос.Выполнить().Пустой();
	
КонецФункции

// Для функции ЗапуститьОбновлениеДоступаНаУровнеЗаписей и
// процедур ОбновлениеДоступаНаУровнеЗаписей, ОтменитьОбновлениеДоступаНаУровнеЗаписей и
// формы ОбновлениеДоступаНаУровнеЗаписей.
//
Функция ПоследнееОбновлениеДоступа(ТекущееЗначение = Неопределено) Экспорт
	
	Если ТекущееЗначение = Неопределено Тогда
		Запрос = Новый Запрос;
		Запрос.Текст =
		"ВЫБРАТЬ
		|	ПоследнееОбновлениеДоступа.Значение КАК Значение
		|ИЗ
		|	Константа.ПоследнееОбновлениеДоступа КАК ПоследнееОбновлениеДоступа";
		
		Выборка = Запрос.Выполнить().Выбрать();
		ТекущееЗначение = ?(Выборка.Следующий(), Выборка.Значение, Неопределено);
	КонецЕсли;
	
	Свойства = Новый Структура;
	Свойства.Вставить("ДатаЗапускаНаСервере",      '00010101');
	Свойства.Вставить("ДатаЗавершенияНаСервере",   '00010101');
	Свойства.Вставить("ОбновлениеОтменено",        Ложь);
	Свойства.Вставить("ПоследнееВыполнениеСекунд", 0);
	Свойства.Вставить("ТекстОшибкиЗавершения",     "");
	Свойства.Вставить("НомерСеанса",               0);
	Свойства.Вставить("НачалоСеанса",              '00010101');
	Свойства.Вставить("ИмяКомпьютера",             "");
	Свойства.Вставить("ОбновлениеДоступаЗапрещено", Ложь);
	Свойства.Вставить("ИдентификаторФоновогоЗадания",
		ОбщегоНазначенияКлиентСервер.ПустойУникальныйИдентификатор());
	Свойства.Вставить("ПоследнееПланированиеОбработкиУстаревшихЭлементов", '00010101');
	
	Если ТипЗнч(ТекущееЗначение) <> Тип("ХранилищеЗначения") Тогда
		Возврат Свойства;
	КонецЕсли;
	
	ТекущиеСвойства = ТекущееЗначение.Получить();
	
	Если ТипЗнч(ТекущиеСвойства) <> Тип("Структура") Тогда
		Возврат Свойства;
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(Свойства, ТекущиеСвойства);
	
	Возврат Свойства;
	
КонецФункции

// Для функции ЗапуститьОбновлениеДоступаНаУровнеЗаписей и
// процедур ОбновлениеДоступаНаУровнеЗаписей, ОтменитьОбновлениеДоступаНаУровнеЗаписей и
// формы ОбновлениеДоступаНаУровнеЗаписей.
//
Функция ИсполнительОбновленияДоступа(ПоследнееОбновлениеДоступа, ИдентификаторИсключаемогоЗадания = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ПоследнееОбновлениеДоступа.ИдентификаторФоновогоЗадания) Тогда
		Если ПоследнееОбновлениеДоступа.ИдентификаторФоновогоЗадания = ИдентификаторПроизвольногоСеанса() Тогда
			Сеансы = ПолучитьСеансыИнформационнойБазы();
			Для Каждого Сеанс Из Сеансы Цикл
				Если Сеанс.НомерСеанса  = ПоследнееОбновлениеДоступа.НомерСеанса
				   И Сеанс.НачалоСеанса = ПоследнееОбновлениеДоступа.НачалоСеанса Тогда
					Возврат Сеанс;
				КонецЕсли;
			КонецЦикла;
		Иначе
			ИсполняющееФоновоеЗадание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(
				ПоследнееОбновлениеДоступа.ИдентификаторФоновогоЗадания);
		
			Если ИсполняющееФоновоеЗадание <> Неопределено
			   И ИсполняющееФоновоеЗадание.Состояние = СостояниеФоновогоЗадания.Активно Тогда
				
				Возврат ИсполняющееФоновоеЗадание;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Отбор = Новый Структура("Состояние, ИмяМетода", СостояниеФоновогоЗадания.Активно,
		Метаданные.РегламентныеЗадания.ОбновлениеДоступаНаУровнеЗаписей.ИмяМетода);
	
	НайденныеЗадания = ФоновыеЗадания.ПолучитьФоновыеЗадания(Отбор);
	Для Каждого НайденноеЗадание Из НайденныеЗадания Цикл
		Если НайденноеЗадание.УникальныйИдентификатор <> ИдентификаторИсключаемогоЗадания Тогда
			Возврат НайденноеЗадание;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Для процедуры ОбновлениеДоступаНаУровнеЗаписей, ИсполнительОбновленияДоступа.
Функция ИдентификаторПроизвольногоСеанса()
	
	Возврат Новый УникальныйИдентификатор("ba4730f7-0493-402d-b5d3-8052c80fb125");
	
КонецФункции

// Для процедур ОбновлениеДоступаНаУровнеЗаписей, ДобавитьЗаданияОбновленияДоступа.
Процедура ПроверитьОбновитьДействующиеПараметрыОграниченияДоступа()
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	ДатаОбновленияВерсииРасширений = Справочники.ВерсииРасширений.ПоследняяВерсияРасширений().ДатаОбновления;
	
	ДатаОбновленияВсехПараметровРаботыПрограммы =
		РегистрыСведений.ПараметрыРаботыПрограммы.ДатаОбновленияВсехПараметровРаботыПрограммы();
	
	ДатаПоследнегоЗаполненияВсехПараметровРаботыРасширений =
		РегистрыСведений.ПараметрыРаботыВерсийРасширений.ДатаПоследнегоЗаполненияВсехПараметровРаботыРасширений();
	
	ДействующиеПараметры = ДействующиеПараметрыОграниченияДоступа(Неопределено, Неопределено, Ложь);
	ДатаСозданияПараметровОграниченияДоступа = ПараметрыСеанса.ПараметрыОграниченияДоступа.ДатаСоздания;
	
	ИмяПараметра = "СтандартныеПодсистемы.УправлениеДоступом.ДатаПроверкиПараметровОграниченияДоступа";
	ДатаПроверкиПараметровОграниченияДоступа = СтандартныеПодсистемыСервер.ПараметрРаботыРасширения(ИмяПараметра, Истина);
	Если ТипЗнч(ДатаПроверкиПараметровОграниченияДоступа) <> Тип("Дата") Тогда
		ДатаПроверкиПараметровОграниченияДоступа = '00010101';
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Ложь);
	УстановитьОтключениеБезопасногоРежима(Ложь);
	
	Если ДатаПроверкиПараметровОграниченияДоступа > ДатаСозданияПараметровОграниченияДоступа Тогда
		ДатаАктуальностиПараметровОграниченияДоступа = ДатаПроверкиПараметровОграниченияДоступа;
	Иначе
		ДатаАктуальностиПараметровОграниченияДоступа = ДатаСозданияПараметровОграниченияДоступа;
	КонецЕсли;
	
	Если ДатаОбновленияВерсииРасширений                         > ДатаАктуальностиПараметровОграниченияДоступа
	 Или ДатаОбновленияВсехПараметровРаботыПрограммы            > ДатаАктуальностиПараметровОграниченияДоступа
	 Или ДатаПоследнегоЗаполненияВсехПараметровРаботыРасширений > ДатаАктуальностиПараметровОграниченияДоступа
	 Или ИспользованиеВидовДоступаИзменено(ДействующиеПараметры) Тогда
		
		ДействующиеПараметрыОграниченияДоступа(Неопределено, Неопределено, Истина);
	КонецЕсли;
	
	// Удаление устаревших параметров ограничения доступа.
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ТекущаяВерсия",   ПараметрыСеанса.ПараметрыОграниченияДоступа.Версия);
	Запрос.УстановитьПараметр("ДатаУстаревания", ТекущаяДатаСеанса() - 2 * 24 * 60 *60);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ПараметрыОграниченияДоступа.Версия КАК Версия,
	|	ПараметрыОграниченияДоступа.ДатаСоздания КАК ДатаСоздания
	|ИЗ
	|	РегистрСведений.ПараметрыОграниченияДоступа КАК ПараметрыОграниченияДоступа
	|ГДЕ
	|	ПараметрыОграниченияДоступа.Версия < &ТекущаяВерсия
	|	И ПараметрыОграниченияДоступа.ДатаСоздания <= &ДатаУстаревания
	|
	|УПОРЯДОЧИТЬ ПО
	|	Версия УБЫВ,
	|	ДатаСоздания УБЫВ";
	
	// АПК:1328-выкл. См. 648.1.1. Допустимо чтение без предварительной
	// управляемой разделяемой блокировки, так как используется только
	// для очистки и какой сеанс очистит первым не важно.
	// Если установить разделяемую блокировку, то позже будет повышение
	// до исключительной, что ведет к взаимоблокировке и недопустимо.
	// Если установить исключительную блокировку на таблицу, то
	// это вызовет избыточное замедление запуска сеансов при установке
	// параметров сеанса из параметров ограничения, что недопустимо.
	РезультатЗапроса = Запрос.Выполнить();
	// АПК:1328-вкл.
	Если РезультатЗапроса.Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	НаименьшаяДатаНачалаСеанса = '39991231';
	Сеансы = ПолучитьСеансыИнформационнойБазы();
	Для Каждого Сеанс Из Сеансы Цикл
		Если НаименьшаяДатаНачалаСеанса > Сеанс.НачалоСеанса Тогда
			НаименьшаяДатаНачалаСеанса = Сеанс.НачалоСеанса;
		КонецЕсли;
	КонецЦикла;
	
	НаименьшаяДатаНачалаСеанса = НаименьшаяДатаНачалаСеанса
		- (МестноеВремя('00010101', ЧасовойПояс()) - '00010101')
		+ (МестноеВремя('00010101', ЧасовойПоясСеанса())  - '00010101');
	
	НаборЗаписей = РегистрыСведений.ПараметрыОграниченияДоступа.СоздатьНаборЗаписей();
	
	Выборка = РезультатЗапроса.Выбрать();
	Пока Выборка.Следующий() Цикл
		Если Выборка.ДатаСоздания >= НаименьшаяДатаНачалаСеанса Тогда
			Продолжить;
		КонецЕсли;
		НаборЗаписей.Отбор.Версия.Установить(Выборка.Версия);
		НаборЗаписей.Записать();
	КонецЦикла;
	
	УстановитьПривилегированныйРежим(Ложь);
	УстановитьОтключениеБезопасногоРежима(Ложь);
	
КонецПроцедуры

// Для процедуры ПроверитьОбновитьДействующиеПараметрыОграниченияДоступа.
Функция ИспользованиеВидовДоступаИзменено(ДействующиеПараметры)
	
	Если ДействующиеПараметры.ВнешниеПользователиВключены
	        <> Константы.ИспользоватьВнешнихПользователей.Получить()
	 Или ДействующиеПараметры.ОграничениеДоступаВключено
	        <> Константы.ОграничиватьДоступНаУровнеЗаписей.Получить() Тогда
		Возврат Истина;
	КонецЕсли;
	
	СвойстваВидовДоступа = УправлениеДоступомСлужебныйПовтИсп.СвойстваВидовДоступа();
	ТекущиеИспользуемыеТипыЗначений = ИспользуемыеТипыЗначений(СвойстваВидовДоступа);
	
	ИспользуемыеТипыЗначений = ДействующиеПараметры.ИспользуемыеТипыЗначений.Получить();
	
	Если ТекущиеИспользуемыеТипыЗначений.Количество() <> ИспользуемыеТипыЗначений.Количество() Тогда
		Возврат Истина;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из ИспользуемыеТипыЗначений Цикл
		Если ТекущиеИспользуемыеТипыЗначений.Получить(КлючИЗначение.Ключ) <> КлючИЗначение.Значение Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Для процедур ОбновлениеДоступаНаУровнеЗаписей, ВыполнитьОбновлениеДоступа,
// ОтменитьОбновлениеДоступаНаУровнеЗаписей, ЗавершитьОбновлениеДоступа.
//
Процедура ЗавершитьПотокиОбновленияДоступа(ОтменитьОбновление = Ложь)
	
	НаборЗаписей = СлужебныйНаборЗаписей(РегистрыСведений.ОбновлениеКлючейДоступаТекущиеЗадания);
	
	Если ОтменитьОбновление Тогда
		НаборЗаписей.Добавить().ИдентификаторПотока = ИдентификаторОтменыОбновленияДоступаНаУровнеЗаписей();
	Иначе
		Запрос = Новый Запрос;
		Запрос.Текст =
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	ИСТИНА КАК ЗначениеИстина
		|ИЗ
		|	РегистрСведений.ОбновлениеКлючейДоступаТекущиеЗадания КАК ОбновлениеКлючейДоступаТекущиеЗадания";
		
		Если Запрос.Выполнить().Пустой() Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	НаборЗаписей.Записать();
	
КонецПроцедуры

// Для процедур ОбработатьВыполненныеЗадания, ЗавершитьПотокиОбновленияДоступа.
Функция ИдентификаторОтменыОбновленияДоступаНаУровнеЗаписей()
	
	Возврат Новый УникальныйИдентификатор("06cc4b5f-a2f9-4622-bef0-df4870ab5dd5");
	
КонецФункции

// Для процедур ОбновлениеДоступаНаУровнеЗаписей, ВыполнитьОбновлениеДоступа,
// ОтменитьОбновлениеДоступаНаУровнеЗаписей, ЗавершитьОбновлениеДоступа.
//
Процедура ОтменитьФоновыеЗаданияПотоковОбновленияДоступа(СекундОжидания = 5)
	
	Отбор = Новый Структура;
	Отбор.Вставить("Состояние", СостояниеФоновогоЗадания.Активно);
	Отбор.Вставить("ИмяМетода", ИмяМетодаПотокаОбновленияДоступа());
	
	ФоновыеЗаданияПотоков = ФоновыеЗадания.ПолучитьФоновыеЗадания(Отбор);
	Если ФоновыеЗаданияПотоков.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ФоновыеЗаданияПотоков = ФоновыеЗадания.ОжидатьЗавершенияВыполнения(ФоновыеЗаданияПотоков, СекундОжидания);
	Для Каждого ФоновоеЗаданиеПотока Из ФоновыеЗаданияПотоков Цикл
		Если ФоновоеЗаданиеПотока.Состояние = СостояниеФоновогоЗадания.Активно Тогда
			ФоновоеЗаданиеПотока.Отменить();
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Обновляет ключи доступа к данным на основе записей в регистре сведений
// ОбновлениеКлючейДоступаКДанным и ключи доступа пользователей на основе записей
// регистра сведений ОбновлениеКлючейДоступаПользователей.
//
// Обновляется порция данных для каждой таблицы, начиная с самых свежих данных.
// Процедура должна вызываться повторно, пока обработка не будет завершена,
// при этом регламентное задание выключается.
//
// Процедура предназначена для работы в единственном экземпляре, то есть без параллельной
// работы (вызов из процедуры регламентного задания ОбновлениеДоступаНаУровнеЗаписей).
// Параллельность обеспечивает сама процедура путем запуска до двух фоновых заданий
// на каждый список, но не более значения константы КоличествоПотоковОбновленияДоступа.
//
Процедура ВыполнитьОбновлениеДоступа(Знач ОбновитьВсе, ОписаниеОсновногоСеанса,
				ОбновлениеОтменено, ТекстОшибкиЗавершения, СекундНеБолее)
	
	Если СекундНеБолее > 0 Тогда
		ОбновитьВсе = Ложь;
	КонецЕсли;
	
	Контекст = Новый Структура;
	Контекст.Вставить("ОписаниеОсновногоСеанса",  ОписаниеОсновногоСеанса);
	Контекст.Вставить("ТекущееФоновоеЗадание",    ОписаниеОсновногоСеанса.ФоновоеЗадание);
	Контекст.Вставить("Задания",                  ТаблицаЗаданийОбновления());
	Контекст.Вставить("ЗаданияДляЗапуска",        Новый Массив);
	Контекст.Вставить("ЗанятыеПотоки",            Новый Соответствие);
	Контекст.Вставить("СвободныеПотоки",          Новый Массив);
	Контекст.Вставить("ГраницаОбновленияЗаданий", '00010101');
	Контекст.Вставить("ОбщиеПараметрыОбновления", ОписаниеОбщихПараметровОбновления());
	Контекст.Вставить("ОбновлениеВЭтомСеансе",    Ложь);
	Контекст.Вставить("КоличествоПотоков",        0);
	Контекст.Вставить("ТекстОшибкиЗавершения",    "");
	Контекст.Вставить("ЕстьОтложенныеЗадания",    Ложь);
	Контекст.Вставить("ЕстьЗапущенноеЗадание",    Истина);
	Контекст.Вставить("ОбработкаЗавершена",       Ложь);
	Контекст.Вставить("ОбновлениеОтменено",       Ложь);
	Контекст.Вставить("МаксимумПорцийИзИсходной", 0);
	Контекст.Вставить("КоличествоДополнительныхПорций", 0);
	Контекст.Вставить("ИдентификаторСправочникаНаборыГруппДоступа",
		ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Справочник.НаборыГруппДоступа"));
	ОписаниеОсновногоСеанса.Удалить("ФоновоеЗадание");
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапросаЗаданий();
	Запрос.УстановитьПараметр("МаксимальнаяДата", МаксимальнаяДата());
	Запрос.УстановитьПараметр("ПустойИдентификатор",
		ОбщегоНазначенияКлиентСервер.ПустойУникальныйИдентификатор());
	
	ЗавершитьПотокиОбновленияДоступа();
	ОтменитьФоновыеЗаданияПотоковОбновленияДоступа(1);
	
	Задания = Контекст.Задания;
	ЗанятыеПотоки = Контекст.ЗанятыеПотоки;
	
	Если СекундНеБолее > 0 Тогда
		ОкончаниеВыполнения = ТекущаяДатаСеанса() + СекундНеБолее;
	Иначе
		ОкончаниеВыполнения = ТекущаяДатаСеанса()
			+ МаксимальноеКоличествоМинутВыполненияФоновогоЗаданияОбновленияДоступа() * 60;
	КонецЕсли;
	
	ЗаполнитьКоличествоПотоков(Контекст);
	Контекст.Вставить("Показатели", ПоказателиОбновленияУправляющегоПотока(Контекст));
	
	Пока Истина Цикл
		Если Не ОбновитьВсе И ТекущаяДатаСеанса() > ОкончаниеВыполнения
		 Или ЗначениеЗаполнено(Контекст.ТекстОшибкиЗавершения) Тогда
			Прервать;
		КонецЕсли;
		Контекст.ОбработкаЗавершена = Истина;
		
		ЗаполнитьКоличествоПотоков(Контекст);
		ОбработатьВыполненныеЗадания(Контекст);
		
		Если Контекст.ОбновлениеОтменено Тогда
			Контекст.ОбработкаЗавершена = Ложь;
			Прервать;
		КонецЕсли;
		
		РезультатыЗапроса = Запрос.ВыполнитьПакет();
		ДобавитьЗаданияОбновленияДоступа(РезультатыЗапроса, Контекст);
		
		Если Контекст.ОбработкаЗавершена Тогда
			Прервать;
		КонецЕсли;
		
		ОкончаниеТекущегоЗапуска = ТекущаяДатаСеанса() + 5;
		Контекст.Вставить("ПервыйПроход", Истина);
		
		Пока Истина Цикл
			
			Если Не ОбновитьВсе И ТекущаяДатаСеанса() > ОкончаниеВыполнения
			 Или ТекущаяДатаСеанса() > ОкончаниеТекущегоЗапуска
			 Или ЗначениеЗаполнено(Контекст.ТекстОшибкиЗавершения)
			 Или Задания.Количество() = 0
			 Или Контекст.ОбновлениеОтменено Тогда
				Прервать;
			КонецЕсли;
			
			ПрерватьПроход = Ложь;
			МоментПрерыванияПрохода = ТекущаяУниверсальнаяДатаВМиллисекундах() + 1000;
			ЗаполнитьОбщиеПараметрыОбновления(Контекст);
			Контекст.ЕстьЗапущенноеЗадание = Ложь;
			ЗаданияДляЗапуска = Контекст.ЗаданияДляЗапуска;
			
			Для Каждого Задание Из ЗаданияДляЗапуска Цикл
				
				Пока ЗанятыеПотоки.Количество() >= Контекст.КоличествоПотоков Цикл
					ОбработатьВыполненныеЗадания(Контекст);
					
					Если Контекст.ОбновлениеОтменено Тогда
						ПрерватьПроход = Истина;
						Прервать;
					КонецЕсли;
					
					Если ЗанятыеПотоки.Количество() >= Контекст.КоличествоПотоков Тогда
						Если Не ОбновитьВсе И ТекущаяДатаСеанса() > ОкончаниеВыполнения
						 Или ТекущаяДатаСеанса() > ОкончаниеТекущегоЗапуска Тогда
							ПрерватьПроход = Истина;
							Прервать;
						КонецЕсли;
						ПодождатьОсвобожденияПотока(Контекст, Истина);
						Если Не Контекст.ПервыйПроход
						   И ТекущаяУниверсальнаяДатаВМиллисекундах() > МоментПрерыванияПрохода Тогда
							ПрерватьПроход = Истина;
							Прервать;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
				Если ПрерватьПроход Тогда
					Прервать;
				КонецЕсли;
				Если ЗанятыеПотоки.Количество() < Контекст.КоличествоПотоков Тогда
					ЗапуститьОбновлениеДоступаСписка(Задание, Контекст);
					Если ЗначениеЗаполнено(Контекст.ТекстОшибкиЗавершения) Тогда
						Прервать;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			Если Не Контекст.ЕстьЗапущенноеЗадание
			   И (ЗанятыеПотоки.Количество() >= Контекст.КоличествоПотоков
			      Или Не Контекст.ЕстьОтложенныеЗадания) Тогда
				
				ПодождатьОсвобожденияПотока(Контекст, Истина);
			КонецЕсли;
			ОбработатьВыполненныеЗадания(Контекст);
			Контекст.ПервыйПроход = Ложь;
		КонецЦикла;
	КонецЦикла;
	
	ЗавершитьОбновлениеДоступа(Контекст);
	
	ТекстОшибкиЗавершения = Контекст.ТекстОшибкиЗавершения;
	ОбновлениеОтменено    = Контекст.ОбновлениеОтменено;
	
КонецПроцедуры

// Для процедуры ВыполнитьОбновлениеДоступаНаУровнеЗаписей.
Процедура ЗапланироватьОбработкуУстаревшихЭлементов(ТекстОшибкиПланирования,
			ПоследнееПланированиеОбработкиУстаревшихЭлементов)
	
	Если Не ЗначениеЗаполнено(ПоследнееПланированиеОбработкиУстаревшихЭлементов) Тогда
		ПоследнееПланированиеОбработкиУстаревшихЭлементов = ТекущаяДатаСеанса();
	КонецЕсли;
	Попытка
		ГраницаОжидания = ТекущаяДатаСеанса() - КоличествоЧасовМеждуПланированиемОбработкиУстаревшихЭлементов() * 60 * 60;
		Если ПоследнееПланированиеОбработкиУстаревшихЭлементов < ГраницаОжидания Тогда
			ПараметрыПланирования = ПараметрыПланированияОбновленияДоступа(Ложь);
			ПараметрыПланирования.ЭтоОбработкаУстаревшихЭлементов = Истина;
			ПараметрыПланирования.Описание = "ОбновлениеДоступаНаУровнеЗаписей";
			ЗапланироватьОбновлениеДоступа(, ПараметрыПланирования);
			ПоследнееПланированиеОбработкиУстаревшихЭлементов = ТекущаяДатаСеанса();
		КонецЕсли;
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ТекстОшибкиПланирования = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось запланировать обработку устаревших элементов ограничения доступа по причине:
			           |%1'"),
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
	КонецПопытки;
	
КонецПроцедуры

// Для процедуры ВыполнитьОбновлениеДоступа.
Функция ТаблицаЗаданийОбновления()
	
	ТипыИдентификаторов = Новый Массив;
	ТипыИдентификаторов.Добавить(Тип("СправочникСсылка.ИдентификаторыОбъектовМетаданных"));
	ТипыИдентификаторов.Добавить(Тип("СправочникСсылка.ИдентификаторыОбъектовРасширений"));
	
	Задания = Новый ТаблицаЗначений;
	Задания.Колонки.Добавить("ЕстьТочечноеЗадание",                    Новый ОписаниеТипов("Булево"));
	Задания.Колонки.Добавить("ЕстьНачальноеОбновлениеТочечногоЗадания",Новый ОписаниеТипов("Дата"));
	Задания.Колонки.Добавить("ДатаПоследнегоЗапускаТочечногоЗадания",  Новый ОписаниеТипов("Дата"));
	Задания.Колонки.Добавить("ДатаДобавленияТочечногоЗадания",         Новый ОписаниеТипов("Дата"));
	Задания.Колонки.Добавить("УровеньЗависимости",                     Новый ОписаниеТипов("Число"));
	Задания.Колонки.Добавить("ЗависимыеСписки",                        Новый ОписаниеТипов("Массив,Строка"));
	Задания.Колонки.Добавить("ЕстьНачальноеОбновление",                Новый ОписаниеТипов("Булево"));
	Задания.Колонки.Добавить("ЕстьПерезапуск",                         Новый ОписаниеТипов("Булево"));
	Задания.Колонки.Добавить("ДатаПоследнегоЗапускаОбщегоЗадания",     Новый ОписаниеТипов("Дата"));
	Задания.Колонки.Добавить("ЕстьДатаПоследнегоОбновленногоЭлемента", Новый ОписаниеТипов("Булево"));
	Задания.Колонки.Добавить("ДатаПоследнегоОбновленногоЭлемента",     Новый ОписаниеТипов("Дата"));
	Задания.Колонки.Добавить("ДатаДобавленияОбщегоЗадания",            Новый ОписаниеТипов("Дата"));
	Задания.Колонки.Добавить("ИдентификаторСписка",                    Новый ОписаниеТипов(ТипыИдентификаторов));
	Задания.Колонки.Добавить("ДляВнешнихПользователей",                Новый ОписаниеТипов("Булево"));
	Задания.Колонки.Добавить("ЭтоОбновлениеПрав",                      Новый ОписаниеТипов("Булево"));
	Задания.Колонки.Добавить("Запускать",                              Новый ОписаниеТипов("Булево"));
	Задания.Колонки.Добавить("ДополнительныйЗапуск",                   Новый ОписаниеТипов("Булево"));
	Задания.Колонки.Добавить("ЗанятыеПотоки",                          Новый ОписаниеТипов("Соответствие"));
	Задания.Колонки.Добавить("НаборПорций",                            Новый ОписаниеТипов("Массив"));
	Задания.Колонки.Добавить("КоличествоПорцийДляОбработки",           Новый ОписаниеТипов("Число"));
	Задания.Колонки.Добавить("ИндексСледующейПорцииДляОбработки",      Новый ОписаниеТипов("Число"));
	Задания.Колонки.Добавить("Пропустить",                             Новый ОписаниеТипов("Булево"));
	Задания.Колонки.Добавить("Удалить",                                Новый ОписаниеТипов("Булево"));
	Задания.Колонки.Добавить("ПорядокВидаКлючаДанных",                 Новый ОписаниеТипов("Число"));
	Задания.Колонки.Добавить("ЭтоОбработкаУстаревшихЭлементов",        Новый ОписаниеТипов("Булево"));
	Задания.Колонки.Добавить("ОбновитьУровеньЗависимости",             Новый ОписаниеТипов("Булево"));
	
	Задания.Индексы.Добавить(
		"ЕстьТочечноеЗадание,
		|ЕстьНачальноеОбновлениеТочечногоЗадания,
		|ДатаПоследнегоЗапускаТочечногоЗадания,
		|ДатаДобавленияТочечногоЗадания,
		|ЕстьНачальноеОбновление,
		|ДатаПоследнегоЗапускаОбщегоЗадания,
		|ЕстьДатаПоследнегоОбновленногоЭлемента,
		|ДатаПоследнегоОбновленногоЭлемента,
		|ДатаДобавленияОбщегоЗадания");
	
	Задания.Индексы.Добавить("ИдентификаторСписка, ДляВнешнихПользователей, ЭтоОбновлениеПрав");
	Задания.Индексы.Добавить("ИдентификаторСписка, ДляВнешнихПользователей, ЭтоОбновлениеПрав, ЭтоОбработкаУстаревшихЭлементов");
	Задания.Индексы.Добавить("Удалить, ЭтоОбработкаУстаревшихЭлементов");
	Задания.Индексы.Добавить("УровеньЗависимости");
	
	Возврат Задания;
	
КонецФункции

// Для процедуры ДобавитьЗаданияОбновленияДоступа.
Функция ТаблицаКлючейЗаданий()
	
	ТипыИдентификаторов = Новый Массив;
	ТипыИдентификаторов.Добавить(Тип("СправочникСсылка.ИдентификаторыОбъектовМетаданных"));
	ТипыИдентификаторов.Добавить(Тип("СправочникСсылка.ИдентификаторыОбъектовРасширений"));
	
	Задания = Новый ТаблицаЗначений;
	Задания.Колонки.Добавить("ИдентификаторСписка",     Новый ОписаниеТипов(ТипыИдентификаторов));
	Задания.Колонки.Добавить("ДляВнешнихПользователей", Новый ОписаниеТипов("Булево"));
	Задания.Колонки.Добавить("ЭтоОбновлениеПрав",       Новый ОписаниеТипов("Булево"));
	
	Задания.Индексы.Добавить("ИдентификаторСписка, ДляВнешнихПользователей, ЭтоОбновлениеПрав");
	
	Возврат Задания;
	
КонецФункции

// Для процедуры ВыполнитьОбновлениеДоступа.
Функция НовыйПоток()
	
	Поток = Новый Структура;
	Поток.Вставить("ИдентификаторПотока");
	Поток.Вставить("ФоновоеЗадание");
	Поток.Вставить("Задание");
	Поток.Вставить("ОтменитьЗадание", Ложь);
	Поток.Вставить("ПорцияИзНабора");
	Поток.Вставить("ДатаОсвобождения", '00010101');
	
	Возврат Поток;
	
КонецФункции

// Для процедуры ВыполнитьОбновлениеДоступа.
Функция ОписаниеОбщихПараметровОбновления(Контекст = Неопределено)
	
	ОбщиеПараметрыОбновления = Новый Структура;
	ОбщиеПараметрыОбновления.Вставить("ЭтоОбновлениеПрав",            Ложь);
	ОбщиеПараметрыОбновления.Вставить("ИдентификаторСписка",          Неопределено);
	ОбщиеПараметрыОбновления.Вставить("ДляВнешнихПользователей",      Ложь);
	ОбщиеПараметрыОбновления.Вставить("ДатаНачала",                   '00010101');
	ОбщиеПараметрыОбновления.Вставить("ДатаОкончания",                '00010101');
	ОбщиеПараметрыОбновления.Вставить("НачальноеОбновление",          Ложь);
	ОбщиеПараметрыОбновления.Вставить("ОбработкаЗавершена",           Истина);
	ОбщиеПараметрыОбновления.Вставить("МаксимумМиллисекундОбработки", 1000);
	
	Если Контекст = Неопределено Тогда
		ОбщиеПараметрыОбновления.Вставить("ИдентификаторСправочникаНаборыГруппДоступа",
			ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Справочник.НаборыГруппДоступа"));
	Иначе
		ОбщиеПараметрыОбновления.Вставить("ИдентификаторСправочникаНаборыГруппДоступа",
			Контекст.ИдентификаторСправочникаНаборыГруппДоступа);
		
		Если Контекст.ОбновлениеВЭтомСеансе Тогда
			ОбщиеПараметрыОбновления.Вставить("Кэш", Контекст.Кэш);
		КонецЕсли;
		ОбщиеПараметрыОбновления.Вставить("МаксимумПорцийИзИсходной", Контекст.МаксимумПорцийИзИсходной);
	КонецЕсли;
	
	Возврат ОбщиеПараметрыОбновления;
	
КонецФункции

// Для процедуры ВыполнитьОбновлениеДоступа.
Функция ТекстЗапросаЗаданий()
	
	Возврат
	"ВЫБРАТЬ
	|	ЛОЖЬ КАК ЭтоОбновлениеПрав,
	|	Списки.Список КАК ИдентификаторСписка,
	|	Списки.ДляВнешнихПользователей КАК ДляВнешнихПользователей,
	|	МАКСИМУМ(Списки.ТочечноеЗадание) КАК ЕстьТочечноеЗадание,
	|	МАКСИМУМ(Списки.ТочечноеЗадание
	|			И Списки.ДатаПоследнегоОбновленногоЭлемента = &МаксимальнаяДата) КАК ЕстьНачальноеОбновлениеТочечногоЗадания,
	|	МАКСИМУМ(ВЫБОР
	|			КОГДА Списки.ТочечноеЗадание
	|					И Списки.КлючУникальности <> &ПустойИдентификатор
	|				ТОГДА Списки.ДатаИзмененияЗаписиРегистра
	|			ИНАЧЕ ДАТАВРЕМЯ(1, 1, 1)
	|		КОНЕЦ) КАК ДатаДобавленияТочечногоЗадания,
	|	МАКСИМУМ((НЕ Списки.ТочечноеЗадание
	|			ИЛИ Списки.КлючУникальности = &ПустойИдентификатор)
	|			И Списки.ДатаПоследнегоОбновленногоЭлемента = &МаксимальнаяДата) КАК ЕстьНачальноеОбновление,
	|	МАКСИМУМ(НЕ Списки.ТочечноеЗадание
	|			И Списки.КлючУникальности <> &ПустойИдентификатор) КАК ЕстьПерезапуск,
	|	МАКСИМУМ(ВЫБОР
	|			КОГДА НЕ Списки.ТочечноеЗадание
	|					ИЛИ Списки.КлючУникальности = &ПустойИдентификатор
	|				ТОГДА Списки.ДатаПоследнегоОбновленногоЭлемента
	|			ИНАЧЕ ДАТАВРЕМЯ(1, 1, 1)
	|		КОНЕЦ) КАК ДатаПоследнегоОбновленногоЭлемента,
	|	МАКСИМУМ(ВЫБОР
	|			КОГДА НЕ Списки.ТочечноеЗадание
	|					И Списки.КлючУникальности <> &ПустойИдентификатор
	|				ТОГДА Списки.ДатаИзмененияЗаписиРегистра
	|			ИНАЧЕ ДАТАВРЕМЯ(1, 1, 1)
	|		КОНЕЦ) КАК ДатаДобавленияОбщегоЗадания
	|ИЗ
	|	РегистрСведений.ОбновлениеКлючейДоступаКДанным КАК Списки
	|
	|СГРУППИРОВАТЬ ПО
	|	Списки.Список,
	|	Списки.ДляВнешнихПользователей
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	ИСТИНА,
	|	Списки.Список,
	|	Списки.ДляВнешнихПользователей,
	|	МАКСИМУМ(Списки.ТочечноеЗадание),
	|	ЛОЖЬ,
	|	МАКСИМУМ(ВЫБОР
	|			КОГДА Списки.ТочечноеЗадание
	|					И Списки.КлючУникальности <> &ПустойИдентификатор
	|				ТОГДА Списки.ДатаИзмененияЗаписиРегистра
	|			ИНАЧЕ ДАТАВРЕМЯ(1, 1, 1)
	|		КОНЕЦ),
	|	ЛОЖЬ,
	|	МАКСИМУМ(НЕ Списки.ТочечноеЗадание
	|			И Списки.КлючУникальности <> &ПустойИдентификатор),
	|	ДАТАВРЕМЯ(1, 1, 1),
	|	МАКСИМУМ(ВЫБОР
	|			КОГДА НЕ Списки.ТочечноеЗадание
	|					И Списки.КлючУникальности <> &ПустойИдентификатор
	|				ТОГДА Списки.ДатаИзмененияЗаписиРегистра
	|			ИНАЧЕ ДАТАВРЕМЯ(1, 1, 1)
	|		КОНЕЦ)
	|ИЗ
	|	РегистрСведений.ОбновлениеКлючейДоступаПользователей КАК Списки
	|
	|СГРУППИРОВАТЬ ПО
	|	Списки.Список,
	|	Списки.ДляВнешнихПользователей";
	
КонецФункции

// Для процедуры ВыполнитьОбновлениеДоступа.
Процедура ЗаполнитьКоличествоПотоков(Контекст)
	
	Если Контекст.ОбновлениеВЭтомСеансе Тогда
		Возврат;
	КонецЕсли;
	
	Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		КоличествоПотоков = 1;
		Контекст.МаксимумПорцийИзИсходной = 5;
	Иначе
		КоличествоПотоков = Константы.КоличествоПотоковОбновленияДоступа.Получить();
		Контекст.МаксимумПорцийИзИсходной = 5 + (КоличествоПотоков - 1) * 2;
	КонецЕсли;
	
	Если КоличествоПотоков < 1 Тогда
		КоличествоПотоков = 1;
	КонецЕсли;
	
	Если Контекст.КоличествоПотоков = 0 Тогда
		Контекст.ОбновлениеВЭтомСеансе = КоличествоПотоков = 1;
	КонецЕсли;
	
	Контекст.КоличествоПотоков = КоличествоПотоков;
	
КонецПроцедуры

// Для процедуры ВыполнитьОбновлениеДоступа.
Процедура ДобавитьЗаданияОбновленияДоступа(РезультатыЗапроса, Контекст)
	
	Если Контекст.Свойство("Кэш") Тогда
		Кэш = Контекст.Кэш;
	Иначе
		Кэш = Новый Структура;
		Контекст.Вставить("Кэш", Кэш);
		Контекст.Вставить("ИдентификаторыПоПолнымИменам", Новый Соответствие);
		Контекст.Вставить("ВерсияПараметровОграничения");
		Контекст.Вставить("ХешСуммаПараметровОграничения");
	КонецЕсли;
	Если Не Кэш.Свойство("ОбъектыМетаданныхПоИдентификаторам") Тогда
		Кэш.Вставить("ОбъектыМетаданныхПоИдентификаторам", Новый Соответствие);
	КонецЕсли;
	
	ПроверитьОбновитьДействующиеПараметрыОграниченияДоступа();
	ДействующиеПараметры = ДействующиеПараметрыОграниченияДоступа(Неопределено, Неопределено, Ложь);
	Задания = Контекст.Задания;
	ИдентификаторыСписков = Новый Массив;
	
	Если Контекст.ВерсияПараметровОграничения   <> ПараметрыСеанса.ПараметрыОграниченияДоступа.Версия
	 Или Контекст.ХешСуммаПараметровОграничения <> ПараметрыСеанса.ПараметрыОграниченияДоступа.ХешСумма Тогда
		
		Задания.ЗаполнитьЗначения(-1, "УровеньЗависимости");
		Задания.ЗаполнитьЗначения(Неопределено, "ЗависимыеСписки");
		Контекст.Вставить("ИдентификаторыПоПолнымИменам", Новый Соответствие);
		Контекст.Вставить("ВедущиеСпискиПоЗависимым", ТаблицаКлючейЗаданий());
		Контекст.ВедущиеСпискиПоЗависимым.Колонки.Добавить("ВедущиеСписки");
		
		ТекущиеИдентификаторыСписка = Задания.Скопировать(, "ИдентификаторСписка");
		ТекущиеИдентификаторыСписка.Свернуть("ИдентификаторСписка");
		ИдентификаторыСписков = ТекущиеИдентификаторыСписка.ВыгрузитьКолонку("ИдентификаторСписка");
		
		Контекст.ВерсияПараметровОграничения   = ПараметрыСеанса.ПараметрыОграниченияДоступа.Версия;
		Контекст.ХешСуммаПараметровОграничения = ПараметрыСеанса.ПараметрыОграниченияДоступа.ХешСумма;
	КонецЕсли;
	
	Задания.ЗаполнитьЗначения(Истина, "Удалить");
	Отбор = Новый Структура("ИдентификаторСписка, ДляВнешнихПользователей, ЭтоОбновлениеПрав");
	
	Выгрузка = РезультатыЗапроса[0].Выгрузить();
	Если Выгрузка.Количество() > 0 Тогда
		Контекст.ОбработкаЗавершена = Ложь;
	КонецЕсли;
	
	Для Каждого Строка Из Выгрузка Цикл
		ЗаполнитьЗначенияСвойств(Отбор, Строка);
		Строки = Задания.НайтиСтроки(Отбор);
		Если Строки.Количество() = 0 Тогда
			Задание = Задания.Добавить();
			Задание.УровеньЗависимости = -1; // Не заполнен.
			Если Строка.ИдентификаторСписка <> Неопределено
			   И Кэш.ОбъектыМетаданныхПоИдентификаторам.Получить(Строка.ИдентификаторСписка) = Неопределено Тогда
				ИдентификаторыСписков.Добавить(Строка.ИдентификаторСписка);
			КонецЕсли;
		Иначе
			Задание = Строки[0];
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(Задание, Строка);
		Задание.Удалить = Ложь;
		ОбновитьСвойствоЭтоОбработкаУстаревшихЭлементов(Задание, Ложь);
		Задание.ЕстьДатаПоследнегоОбновленногоЭлемента
			= ЗначениеЗаполнено(Задание.ДатаПоследнегоОбновленногоЭлемента);
		
		Если Задание.ЕстьПерезапуск Тогда
			ОтменитьЗадание(Задание);
		КонецЕсли;
	КонецЦикла;
	
	Если ИдентификаторыСписков.Количество() > 0 Тогда
		ОбъектыМетаданныхПоИдентификаторам =
			ОбщегоНазначения.ОбъектыМетаданныхПоИдентификаторам(ИдентификаторыСписков, Ложь);
		Для Каждого КлючИЗначение Из ОбъектыМетаданныхПоИдентификаторам Цикл
			Кэш.ОбъектыМетаданныхПоИдентификаторам.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
			Если ТипЗнч(КлючИЗначение.Значение) = Тип("ОбъектМетаданных") Тогда
				Контекст.ИдентификаторыПоПолнымИменам.Вставить(КлючИЗначение.Значение.ПолноеИмя(), КлючИЗначение.Ключ);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ЗаполнитьУровниЗависимостиЗаданий(Контекст, ДействующиеПараметры.ВедущиеСписки);
	
КонецПроцедуры

// Для процедур ДобавитьЗаданияОбновленияДоступа, ОбновитьСвойстваЗадания и
// функции ЗапуститьОбновлениеДоступаСписка.
//
Процедура ОбновитьСвойствоЭтоОбработкаУстаревшихЭлементов(Задание, ТребуетсяОбновитьУровеньЗависимостиПриИзменении = Истина)
	
	ЭтоОбработкаУстаревшихЭлементов = Не Задание.ЕстьТочечноеЗадание
		И Задание.ПорядокВидаКлючаДанных >= ПорядокВидаКлючаДанных("УстаревшиеЭлементы")
		И Задание.ПорядокВидаКлючаДанных < ПорядокВидаКлючаДанных("НетДанных");
	
	Если Задание.ЭтоОбработкаУстаревшихЭлементов <> ЭтоОбработкаУстаревшихЭлементов Тогда
		Задание.ЭтоОбработкаУстаревшихЭлементов = ЭтоОбработкаУстаревшихЭлементов;
		Задание.ОбновитьУровеньЗависимости = ТребуетсяОбновитьУровеньЗависимостиПриИзменении;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ЗаполнитьОбщиеПараметрыОбновления.
Функция ЭтоОбновлениеСоставаНаборовГруппДоступа(Задание, Контекст)
	
	Возврат Задание.ИдентификаторСписка = Контекст.ИдентификаторСправочникаНаборыГруппДоступа
	      И Задание.ПорядокВидаКлючаДанных < ПорядокВидаКлючаДанных("НовыеНаборыГруппСУстаревшимиПравами");
	
КонецФункции

// Для процедуры ДобавитьЗаданияОбновленияДоступа.
Процедура ЗаполнитьУровниЗависимостиЗаданий(Контекст, СвойстваВедущихСписков)
	
	Задания = Контекст.Задания;
	ОбъектыМетаданныхПоИдентификаторам = Контекст.Кэш.ОбъектыМетаданныхПоИдентификаторам;
	ИдентификаторыПоПолнымИменам       = Контекст.ИдентификаторыПоПолнымИменам;
	
	ЗаданияДляЗаполнения = Задания.НайтиСтроки(Новый Структура("УровеньЗависимости", -1));
	ВедущиеСпискиПоЗависимым = Контекст.ВедущиеСпискиПоЗависимым;
	ОтборЗадания = Новый Структура("ИдентификаторСписка, ДляВнешнихПользователей, ЭтоОбновлениеПрав");
	
	Для Каждого Задание Из ЗаданияДляЗаполнения Цикл
		УстановитьУровеньЗависимостиПоВедущим(Задание, Задания, ВедущиеСпискиПоЗависимым);
		
		ОбъектМетаданных = ОбъектыМетаданныхПоИдентификаторам.Получить(Задание.ИдентификаторСписка);
		Если ТипЗнч(ОбъектМетаданных) <> Тип("ОбъектМетаданных") Тогда
			Продолжить;
		КонецЕсли;
		ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
		СвойстваВедущегоСписка = СвойстваВедущихСписков.Получить(ПолноеИмя);
		Если СвойстваВедущегоСписка = Неопределено
		 Или СвойстваВедущегоСписка.ПоКлючамДоступа = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ЗависимыеСписки = СвойстваВедущегоСписка.ПоКлючамДоступа[?(Задание.ДляВнешнихПользователей,
			"ДляВнешнихПользователей", "ДляПользователей")];
		Если ЗависимыеСписки = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(ОтборЗадания, Задание);
		Для Каждого ЗависимыйСписок Из ЗависимыеСписки Цикл
			ИдентификаторЗависимого = ИдентификаторыПоПолнымИменам.Получить(ЗависимыйСписок);
			Если Задание.ЗависимыеСписки = Неопределено Тогда
				Задание.ЗависимыеСписки = Новый Массив;
			КонецЕсли;
			Задание.ЗависимыеСписки.Добавить(ИдентификаторЗависимого);
			ОтборЗадания.ИдентификаторСписка = ИдентификаторЗависимого;
			Найденные = ВедущиеСпискиПоЗависимым.НайтиСтроки(ОтборЗадания);
			Если Найденные.Количество() = 0 Тогда
				ВедущиеСписки = Новый Соответствие;
				НоваяСтрока = ВедущиеСпискиПоЗависимым.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока, ОтборЗадания);
				НоваяСтрока.ВедущиеСписки = ВедущиеСписки;
			Иначе
				ВедущиеСписки = Найденные[0].ВедущиеСписки;
			КонецЕсли;
			ВедущиеСписки.Вставить(Задание.ИдентификаторСписка, Истина);
			ЗависимыеЗадания = Задания.НайтиСтроки(ОтборЗадания);
			Если ЗависимыеЗадания.Количество() > 0 Тогда
				УстановитьУровеньЗависимостиПоВедущим(ЗависимыеЗадания[0], Задания, ВедущиеСпискиПоЗависимым);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

// Для процедур ЗаполнитьУровниЗависимостиЗаданий, ОбновитьУровеньЗависимости.
Процедура УстановитьУровеньЗависимостиПоВедущим(Задание, Задания, ВедущиеСпискиПоЗависимым)
	
	Задание.УровеньЗависимости = 0;
	Если Задание.ЭтоОбработкаУстаревшихЭлементов Тогда
		Возврат;
	КонецЕсли;
	
	ОтборЗадания = Новый Структура("ИдентификаторСписка, ДляВнешнихПользователей, ЭтоОбновлениеПрав",
		Задание.ИдентификаторСписка, Задание.ДляВнешнихПользователей, Задание.ЭтоОбновлениеПрав);
	
	Найденные = ВедущиеСпискиПоЗависимым.НайтиСтроки(ОтборЗадания);
	Если Найденные.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ОтборЗадания.Вставить("ЭтоОбработкаУстаревшихЭлементов", Ложь);
	
	Для Каждого ОписаниеВедущегоСписка Из Найденные[0].ВедущиеСписки Цикл
		ОтборЗадания.ИдентификаторСписка = ОписаниеВедущегоСписка.Ключ;
		ВедущиеЗадания = Задания.НайтиСтроки(ОтборЗадания);
		Если ВедущиеЗадания.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли;
		Если Задание.УровеньЗависимости < ВедущиеЗадания[0].УровеньЗависимости + 1 Тогда
			Задание.УровеньЗависимости = ВедущиеЗадания[0].УровеньЗависимости + 1;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ЗаполнитьОбщиеПараметрыОбновления.
Процедура ОбновитьУровеньЗависимости(СвойстваЗадания, Задания, ВедущиеСпискиПоЗависимым)
	
	Если Не ЗначениеЗаполнено(СвойстваЗадания.ЗависимыеСписки) Тогда
		Возврат;
	КонецЕсли;
	ОтборЗадания = Новый Структура("ИдентификаторСписка, ДляВнешнихПользователей, ЭтоОбновлениеПрав");
	ЗаполнитьЗначенияСвойств(ОтборЗадания, СвойстваЗадания);
	
	Для Каждого ЗависимыйСписок Из СвойстваЗадания.ЗависимыеСписки Цикл
		ОтборЗадания.ИдентификаторСписка = ЗависимыйСписок;
		ЗависимыеЗадания = Задания.НайтиСтроки(ОтборЗадания);
		Если ЗависимыеЗадания.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли;
		УстановитьУровеньЗависимостиПоВедущим(ЗависимыеЗадания[0], Задания, ВедущиеСпискиПоЗависимым);
		ОбновитьУровеньЗависимости(ЗависимыеЗадания[0], Задания, ВедущиеСпискиПоЗависимым);
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ВыполнитьОбновлениеДоступа.
Процедура ЗаполнитьОбщиеПараметрыОбновления(Контекст)
	
	Задания = Контекст.Задания;
	Задания.Сортировать(
		"ЕстьТочечноеЗадание Убыв,
		|ЕстьНачальноеОбновлениеТочечногоЗадания Убыв,
		|ДатаПоследнегоЗапускаТочечногоЗадания Возр,
		|ДатаДобавленияТочечногоЗадания Убыв,
		|ЕстьНачальноеОбновление Убыв,
		|ДатаПоследнегоЗапускаОбщегоЗадания Возр,
		|ЕстьДатаПоследнегоОбновленногоЭлемента Возр,
		|ДатаПоследнегоОбновленногоЭлемента Убыв,
		|ДатаДобавленияОбщегоЗадания Убыв");
	
	ЗаданияДляУдаления = Задания.НайтиСтроки(Новый Структура("Удалить", Истина));
	Для Каждого Задание Из ЗаданияДляУдаления Цикл
		Если Не Задание.Удалить Или Задание.ЗанятыеПотоки.Количество() > 0 Тогда
			Продолжить;
		КонецЕсли;
		СвойстваЗадания = Новый Структура("ИдентификаторСписка,
		|ДляВнешнихПользователей, ЭтоОбновлениеПрав, ЗависимыеСписки");
		ЗаполнитьЗначенияСвойств(СвойстваЗадания, Задание);
		Задания.Удалить(Задание);
		ОбновитьУровеньЗависимости(СвойстваЗадания, Задания, Контекст.ВедущиеСпискиПоЗависимым);
	КонецЦикла;
	ЗаданияДляОбновленияУровня = Задания.НайтиСтроки(Новый Структура("ОбновитьУровеньЗависимости", Истина));
	Для Каждого Задание Из ЗаданияДляОбновленияУровня Цикл
		УстановитьУровеньЗависимостиПоВедущим(Задание, Задания, Контекст.ВедущиеСпискиПоЗависимым);
		ОбновитьУровеньЗависимости(Задание, Задания, Контекст.ВедущиеСпискиПоЗависимым);
		Задание.ОбновитьУровеньЗависимости = Ложь;
	КонецЦикла;
	
	ОтборУровней = Новый Структура("Удалить, ЭтоОбработкаУстаревшихЭлементов", Ложь, Ложь);
	Уровни = Задания.Скопировать(ОтборУровней, "УровеньЗависимости");
	Уровни.Свернуть("УровеньЗависимости");
	Уровни.Сортировать("УровеньЗависимости");
	НаименьшийУровеньЗависимости = ?(Уровни.Количество() > 0, Уровни[0].УровеньЗависимости, 0);
	ЭтоОбработкаУстаревшихЭлементов = Уровни.Количество() = 0;
	ДатаПоследнегоЗапускаЗависимогоОбщегоЗадания = '00010101';
	ДатаПоследнегоЗапускаОбщегоЗаданияОбработкиУстаревших = '00010101';
	Если Уровни.Количество() > 1 Или Не ЭтоОбработкаУстаревшихЭлементов Тогда
		Для Каждого Задание Из Задания Цикл
			Если Задание.Удалить
			 Или Задание.ЕстьТочечноеЗадание Тогда
				Продолжить;
			КонецЕсли;
			Если Задание.УровеньЗависимости > НаименьшийУровеньЗависимости
			   И ДатаПоследнегоЗапускаЗависимогоОбщегоЗадания < Задание.ДатаПоследнегоЗапускаОбщегоЗадания Тогда
				ДатаПоследнегоЗапускаЗависимогоОбщегоЗадания = Задание.ДатаПоследнегоЗапускаОбщегоЗадания;
			КонецЕсли;
			Если Задание.ЭтоОбработкаУстаревшихЭлементов
			   И ДатаПоследнегоЗапускаОбщегоЗаданияОбработкиУстаревших < Задание.ДатаПоследнегоЗапускаОбщегоЗадания Тогда
				ДатаПоследнегоЗапускаОбщегоЗаданияОбработкиУстаревших = Задание.ДатаПоследнегоЗапускаОбщегоЗадания;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	ЗапускаемоеЗависимоеОбщееЗадание =
		?(ДатаПоследнегоЗапускаЗависимогоОбщегоЗадания > ТекущаяДатаСеанса() - 10, Null, Неопределено);
	
	ЗапускаемоеОбщееЗаданиеОбработкиУстаревших =
		?(ДатаПоследнегоЗапускаОбщегоЗаданияОбработкиУстаревших > ТекущаяДатаСеанса() - 15, Null, Неопределено);
	
	ОбщиеПараметрыОбновления = Контекст.ОбщиеПараметрыОбновления;
	ОбщиеПараметрыОбновления.НачальноеОбновление = Ложь;
	ПоследняяДата = '00010101';
	ЗаданиеСправочникаНаборыГруппДоступа = Неопределено;
	ГраницаОжиданияДляЗависимыхЗаданий = ТекущаяДатаСеанса() - 3;
	
	Для Каждого Задание Из Задания Цикл
		Если Задание.Удалить Тогда
			Продолжить;
		КонецЕсли;
		Если ЭтоОбновлениеСоставаНаборовГруппДоступа(Задание, Контекст) Тогда
			ЗаданиеСправочникаНаборыГруппДоступа = Задание;
		КонецЕсли;
		Задание.ДополнительныйЗапуск = Ложь;
		Задание.Пропустить = Ложь;
		Если Задание.ЕстьНачальноеОбновление Тогда
			ОбщиеПараметрыОбновления.НачальноеОбновление = Истина;
		Иначе
			Если Задание.УровеньЗависимости > НаименьшийУровеньЗависимости Тогда
				Если Задание.ЕстьТочечноеЗадание Тогда
					Если Задание.ДатаПоследнегоЗапускаТочечногоЗадания > ГраницаОжиданияДляЗависимыхЗаданий Тогда
						Задание.Пропустить = Истина;
						Продолжить;
					КонецЕсли;
				ИначеЕсли ЗапускаемоеЗависимоеОбщееЗадание <> Неопределено Тогда
					Задание.Пропустить = Истина;
					Продолжить;
				Иначе
					ЗапускаемоеЗависимоеОбщееЗадание = Задание;
				КонецЕсли;
			КонецЕсли;
			Если Не ЭтоОбработкаУстаревшихЭлементов И Задание.ЭтоОбработкаУстаревшихЭлементов Тогда
				Если ЗапускаемоеОбщееЗаданиеОбработкиУстаревших <> Неопределено Тогда
					Задание.Пропустить = Истина;
					Продолжить;
				Иначе
					ЗапускаемоеОбщееЗаданиеОбработкиУстаревших = Задание;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если Задание.ЕстьПерезапуск Тогда
			ОбщиеПараметрыОбновления.НачальноеОбновление = Истина;
		КонецЕсли;
		Если Задание.ДатаПоследнегоОбновленногоЭлемента > ПоследняяДата Тогда
			ПоследняяДата = Задание.ДатаПоследнегоОбновленногоЭлемента;
		КонецЕсли;
	КонецЦикла;
	
	Если ОбщиеПараметрыОбновления.НачальноеОбновление Тогда
		// Начало обновления.
		ОбщиеПараметрыОбновления.ДатаНачала = НачалоДня(ТекущаяДатаСеанса()) - 7 * (60 * 60 * 24); // 7 Дней.
	Иначе
		// Продолжение обновления.
		МаксимальныйПериод = МаксимальныйПериодПолученияПорцийЗапросом();
		
		Если МаксимальныйПериод = "Неделя" Тогда
			ДатаНачала = НачалоНедели(ПоследняяДата);
			
		ИначеЕсли МаксимальныйПериод = "Месяц" Тогда
			ДатаНачала = НачалоМесяца(ПоследняяДата);
		Иначе
			ЭтотГод = Год(ТекущаяДатаСеанса()) - Год(ПоследняяДата) = 0;
			СмещениеМесяца = Месяц(ТекущаяДатаСеанса()) - Месяц(ПоследняяДата);
			
			Если ЭтотГод И СмещениеМесяца = 0 Тогда
				ДатаНачала = НачалоМесяца(ПоследняяДата);
				
			ИначеЕсли ЭтотГод И СмещениеМесяца < 3 Или МаксимальныйПериод = "Квартал" Тогда
				ДатаНачала = НачалоКвартала(ПоследняяДата);
			Иначе
				ДатаНачала = НачалоГода(ПоследняяДата);
			КонецЕсли;
		КонецЕсли;
		
		ОбщиеПараметрыОбновления.ДатаНачала = ДатаНачала;
	КонецЕсли;
	ОбщиеПараметрыОбновления.ДатаОкончания = ПоследняяДата;
	
	ЗаданияДляЗапуска = Новый Массив;
	Контекст.ЗаданияДляЗапуска = ЗаданияДляЗапуска;
	Контекст.ЕстьОтложенныеЗадания = Ложь;
	
	Если ЗаданиеСправочникаНаборыГруппДоступа <> Неопределено Тогда
		ЗаданиеСправочникаНаборыГруппДоступа.Запускать = Истина;
		ЗаданияДляЗапуска.Добавить(ЗаданиеСправочникаНаборыГруппДоступа);
		Контекст.ЕстьОтложенныеЗадания = Задания.Количество() > 1;
	Иначе
		Для Каждого Задание Из Задания Цикл
			Если Задание.Удалить Или Задание.Пропустить Тогда
				Задание.Запускать = Ложь;
				Если Задание.Пропустить Тогда
					Контекст.ЕстьОтложенныеЗадания = Истина;
				КонецЕсли;
				Продолжить;
			КонецЕсли;
			
			Если Задание.ЕстьТочечноеЗадание Или Задание.ЭтоОбновлениеПрав Тогда
				Задание.Запускать = Истина;
				
			ИначеЕсли ОбщиеПараметрыОбновления.НачальноеОбновление Тогда
				Задание.Запускать = Задание.ЕстьНачальноеОбновление Или Задание.ЕстьПерезапуск;
			Иначе
				Задание.Запускать = Не ПериодОбновленияДоПериодаДанных(ОбщиеПараметрыОбновления.ДатаНачала,
					Задание.ДатаПоследнегоОбновленногоЭлемента);
			КонецЕсли;
			
			Если Задание.Запускать Тогда
				ЗаданияДляЗапуска.Добавить(Задание);
			Иначе
				Контекст.ЕстьОтложенныеЗадания = Истина;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если Не ЗагружатьСвободныеПотокиСледующимиЗаданиямиПриДлительныхЗапросах() Тогда
		Контекст.ЕстьОтложенныеЗадания = Ложь;
	КонецЕсли;
	
	Если Не Контекст.ЕстьЗапущенноеЗадание
	   И Контекст.ЕстьОтложенныеЗадания
	   И Контекст.ЗанятыеПотоки.Количество() < Контекст.КоличествоПотоков Тогда
		
		Контекст.ЕстьОтложенныеЗадания = Ложь;
		КоличествоСвободныхПотоков = Контекст.КоличествоПотоков - Контекст.ЗанятыеПотоки.Количество();
		КоличествоДополнительныхЗаданий = 0;
		
		Для Каждого Задание Из Задания Цикл
			Если Задание.Удалить Или Задание.Запускать Тогда
				Продолжить;
			КонецЕсли;
			Если КоличествоДополнительныхЗаданий >= КоличествоСвободныхПотоков Тогда
				Контекст.ЕстьОтложенныеЗадания = Истина;
				Прервать;
			КонецЕсли;
			Задание.Запускать = Истина;
			Задание.ДополнительныйЗапуск = Истина;
			ЗаданияДляЗапуска.Добавить(Задание);
			КоличествоДополнительныхЗаданий = КоличествоДополнительныхЗаданий + 1;
		КонецЦикла;
	КонецЕсли;
	
	КоличествоОсновныхЗаданий = ЗаданияДляЗапуска.Количество();
	Если КоличествоОсновныхЗаданий > 0 Тогда
		Контекст.КоличествоДополнительныхПорций = Цел(Контекст.КоличествоПотоков / КоличествоОсновныхЗаданий);
	Иначе
		Контекст.КоличествоДополнительныхПорций = 0;
	КонецЕсли;
	
	КоличествоЗаданий = Задания.Количество();
	Если КоличествоЗаданий = 0 Тогда
		ДостаточностьПотоков = 0;
	ИначеЕсли Контекст.КоличествоПотоков > КоличествоЗаданий Тогда
		ДостаточностьПотоков = 1;
	Иначе
		ДостаточностьПотоков = Контекст.КоличествоПотоков / КоличествоЗаданий;
	КонецЕсли;
	НагруженностьОтПотоков = Контекст.КоличествоПотоков * 0.025;
	Если НагруженностьОтПотоков > 1 Тогда
		НагруженностьОтПотоков = 1;
	КонецЕсли;
	ОбщиеПараметрыОбновления.МаксимумМиллисекундОбработки =
		Цел(МинимальноеКоличествоСекундОбработкиПорцииВОтдельномПотоке() * 1000
		* (1 + НагруженностьОтПотоков) * (1 + ДостаточностьПотоков));
	
КонецПроцедуры

// Для процедур ДобавитьЗаданияОбновленияДоступа, ЗапуститьОбновлениеДоступаСписка,
// ВыполнитьОбновлениеДоступаСписка.
//
Функция ПериодОбновленияДоПериодаДанных(ДатаНачала, ДатаПоследнегоОбновленногоЭлемента)
	
	// ДатаНачала - например, 01.01.2012, а дата окончания 31.12.2012,
	// при этом ДатаПоследнегоОбновленногоЭлемента, например, 03.01.2013.
	// В таком случае данные для обновления старее, чем период обновления.
	Возврат ЗначениеЗаполнено(ДатаПоследнегоОбновленногоЭлемента)
		  И ДатаНачала > ДатаПоследнегоОбновленногоЭлемента;
	
КонецФункции

// Для процедуры ВыполнитьОбновлениеДоступа.
Процедура ЗавершитьОбновлениеДоступа(Контекст)
	
	Если Не Контекст.ОбновлениеОтменено Тогда
		Если ЗначениеЗаполнено(Контекст.ТекстОшибкиЗавершения) Тогда
			ГраницаОжидания = ТекущаяДатаСеанса() + 3;
		Иначе
			ГраницаОжидания = ТекущаяДатаСеанса() + 15;
		КонецЕсли;
		Пока Контекст.ЗанятыеПотоки.Количество() > 0 Цикл
			ПодождатьОсвобожденияПотока(Контекст);
			ОбработатьВыполненныеЗадания(Контекст);
			Если ТекущаяДатаСеанса() > ГраницаОжидания Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ЗавершитьПотокиОбновленияДоступа();
	ОтменитьФоновыеЗаданияПотоковОбновленияДоступа();
	
	Попытка
		Если Контекст.ОбработкаЗавершена Тогда
			Контекст.Вставить("ОшибкаОжиданияБлокировкиДанных", Ложь);
			Попытка
				ОтключитьРегламентноеЗаданиеЕслиНетНовыхЗаданий(Контекст);
			Исключение
				Если Не Контекст.ОшибкаОжиданияБлокировкиДанных Тогда
					ВызватьИсключение;
				КонецЕсли;
			КонецПопытки;
			Если Не Константы.ПервоеОбновлениеДоступаЗавершилось.Получить() Тогда
				Константы.ПервоеОбновлениеДоступаЗавершилось.Установить(Истина);
			КонецЕсли;
		КонецЕсли;
	Исключение
		ЗарегистрироватьПоказателиОбновленияОсновногоПотока(Контекст);
		ВызватьИсключение;
	КонецПопытки;
	
	ЗарегистрироватьПоказателиОбновленияОсновногоПотока(Контекст);
	
КонецПроцедуры

// Для процедуры ВыполнитьОбновлениеДоступа.
Процедура ОтключитьРегламентноеЗаданиеЕслиНетНовыхЗаданий(Контекст)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("НедоступныеСпискиДляОбновленияКлючейДоступаКДанным",       Новый Массив);
	Запрос.УстановитьПараметр("НедоступныеСпискиДляОбновленияКлючейДоступаПользователей", Новый Массив);
	Запрос.Текст =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ОбновлениеКлючейДоступаКДанным.Список КАК Список
	|ИЗ
	|	РегистрСведений.ОбновлениеКлючейДоступаКДанным КАК ОбновлениеКлючейДоступаКДанным
	|ГДЕ
	|	НЕ ОбновлениеКлючейДоступаКДанным.Список В (&НедоступныеСпискиДляОбновленияКлючейДоступаКДанным)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ОбновлениеКлючейДоступаПользователей.Список КАК Список
	|ИЗ
	|	РегистрСведений.ОбновлениеКлючейДоступаПользователей КАК ОбновлениеКлючейДоступаПользователей
	|ГДЕ
	|	НЕ ОбновлениеКлючейДоступаПользователей.Список В (&НедоступныеСпискиДляОбновленияКлючейДоступаПользователей)";
	РезультатыЗапроса = Запрос.ВыполнитьПакет();
	
	Если Не РезультатыЗапроса[0].Пустой() Тогда
		УстановитьНедоступныеСписки(РезультатыЗапроса[0],
			Запрос.Параметры.НедоступныеСпискиДляОбновленияКлючейДоступаКДанным);
	КонецЕсли;
	
	Если Не РезультатыЗапроса[1].Пустой() Тогда
		УстановитьНедоступныеСписки(РезультатыЗапроса[1],
			Запрос.Параметры.НедоступныеСпискиДляОбновленияКлючейДоступаКДанным);
	КонецЕсли;
	
	Если Запрос.Параметры.НедоступныеСпискиДляОбновленияКлючейДоступаКДанным.Количество() > 0
	 Или Запрос.Параметры.НедоступныеСпискиДляОбновленияКлючейДоступаПользователей.Количество() > 0 Тогда
		
		РезультатыЗапроса = Запрос.ВыполнитьПакет();
	КонецЕсли;
	
	Если РезультатыЗапроса[0].Пустой()
	   И РезультатыЗапроса[1].Пустой() Тогда
		
		Блокировка = Новый БлокировкаДанных;
		Блокировка.Добавить("РегистрСведений.ОбновлениеКлючейДоступаКДанным");
		Блокировка.Добавить("РегистрСведений.ОбновлениеКлючейДоступаПользователей");
		НачатьТранзакцию();
		Попытка
			Контекст.ОшибкаОжиданияБлокировкиДанных = Истина;
			Блокировка.Заблокировать();
			Контекст.ОшибкаОжиданияБлокировкиДанных = Ложь;
			
			РезультатыЗапроса = Запрос.ВыполнитьПакет();
			
			Если РезультатыЗапроса[0].Пустой()
			   И РезультатыЗапроса[1].Пустой() Тогда
				
				УстановитьОбновлениеДоступа(Ложь);
			Иначе
				Контекст.ОбработкаЗавершена = Ложь;
			КонецЕсли;
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			Контекст.ОбработкаЗавершена = Ложь;
			ВызватьИсключение;
		КонецПопытки;
	Иначе
		Контекст.ОбработкаЗавершена = Ложь;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ОтключитьРегламентноеЗаданиеЕслиНетНовыхЗаданий.
Процедура УстановитьНедоступныеСписки(РезультатЗапроса, НедоступныеСписки)
	
	ОбъектыМетаданныхПоИдентификаторам = ОбщегоНазначения.ОбъектыМетаданныхПоИдентификаторам(
		РезультатЗапроса.Выгрузить().ВыгрузитьКолонку("Список"), Ложь);
	
	Для Каждого КлючИЗначение Из ОбъектыМетаданныхПоИдентификаторам Цикл
		Если КлючИЗначение.Значение = Неопределено Тогда
			НедоступныеСписки.Добавить(КлючИЗначение.Ключ);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ВыполнитьОбновлениеДоступа.
Функция ЗапуститьОбновлениеДоступаСписка(Задание, Контекст)
	
	Показатели = Контекст.Показатели;
	Если Показатели <> Неопределено Тогда
		Показатели.НачалоВыдачиЗадания = ТекущаяУниверсальнаяДатаВМиллисекундах();
	КонецЕсли;
	
	ОбработатьВыполненныеЗадания(Контекст, Задание.ЗанятыеПотоки);
	
	Если ЗначениеЗаполнено(Контекст.ТекстОшибкиЗавершения) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Задание.ЗанятыеПотоки.Количество() > 0 И Контекст.ПервыйПроход Тогда
		Возврат Истина; // Уже запущено.
	КонецЕсли;
	
	Если ОбщееЗаданиеВыполняется(Задание)
	   И Не ЗапускатьОбновлениеПолученныхПорцийПриПолученииНовыхПорций() Тогда
		Возврат Истина;
	КонецЕсли;
	
	ОбщиеПараметрыОбновления = ОписаниеОбщихПараметровОбновления(Контекст);
	ЗаполнитьЗначенияСвойств(ОбщиеПараметрыОбновления, Контекст.ОбщиеПараметрыОбновления);
	ОбщиеПараметрыОбновления.ЭтоОбновлениеПрав       = Задание.ЭтоОбновлениеПрав;
	ОбщиеПараметрыОбновления.ИдентификаторСписка     = Задание.ИдентификаторСписка;
	ОбщиеПараметрыОбновления.ДляВнешнихПользователей = Задание.ДляВнешнихПользователей;
	
	НаборПорций = Задание.НаборПорций;
	ПоследнийИндекс = НаборПорций.Количество() - 1;
	
	ИндексСледующейПорцииДляОбработки = Задание.ИндексСледующейПорцииДляОбработки;
	ПорцияДляОбработки = Неопределено;
	Для Индекс = ИндексСледующейПорцииДляОбработки По ПоследнийИндекс Цикл
		ПорцияЭлементов = НаборПорций.Получить(Индекс);
		Если Не ПорцияЭлементов.Обработана И Не ПорцияЭлементов.Обрабатывается Тогда
			ПорцияДляОбработки = ПорцияЭлементов;
			Задание.ИндексСледующейПорцииДляОбработки = Индекс;
			ИндексСледующейПорцииДляОбработки = Индекс + 1;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если ПорцияДляОбработки = Неопределено Тогда
		Задание.ИндексСледующейПорцииДляОбработки = ПоследнийИндекс + 1;
		ПредыдущаяПорция = Неопределено;
		
	ИначеЕсли Индекс > 0 Тогда
		ПредыдущаяПорция = НаборПорций.Получить(Индекс - 1);
	Иначе
		ПредыдущаяПорция = Неопределено;
	КонецЕсли;
	
	Если Не Задание.ЕстьТочечноеЗадание И ПорцияДляОбработки <> Неопределено Тогда
		Если ПериодОбновленияДоПериодаДанных(ОбщиеПараметрыОбновления.ДатаНачала,
		         ?(ПредыдущаяПорция = Неопределено, Задание.ДатаПоследнегоОбновленногоЭлемента,
		             ПредыдущаяПорция.ДатаПоследнегоЭлементаПорции)) Тогда
			Возврат Истина;
		КонецЕсли;
		ОбщиеПараметрыОбновления.Вставить("ПорцияИзНабора", ПорцияДляОбработки);
		ПорцияДляОбработки.Обрабатывается = Истина;
		Задание.ИндексСледующейПорцииДляОбработки = ИндексСледующейПорцииДляОбработки;
	Иначе
		ПоследняяПорция = ?(ПоследнийИндекс > -1, НаборПорций[ПоследнийИндекс], Неопределено);
		
		Если ПоследняяПорция <> Неопределено
		   И (ПоследняяПорция.ПоследнийЭлементПорции.ВидКлючаДанных
		       <> ПоследняяПорция.НовыйПоследнийЭлементПорции.ВидКлючаДанных
		      Или ПоследняяПорция.НовыйПоследнийЭлементПорции.КлючДанных = Null
		      Или Не ОбщиеПараметрыОбновления.ЭтоОбновлениеПрав
		        И ПериодОбновленияДоПериодаДанных(ОбщиеПараметрыОбновления.ДатаНачала,
		              ПоследняяПорция.ДатаПоследнегоЭлементаПорции)) Тогда
			
			ПолучитьПорции = 0;
		Иначе
			КоличествоПорцийДляОбработки = Задание.КоличествоПорцийДляОбработки;
			ПолучитьПорции = (Контекст.КоличествоДополнительныхПорций + 2) * 2;
			Если Задание.ЕстьТочечноеЗадание Тогда
				ПолучитьПорции = ПолучитьПорции - КоличествоПорцийДляОбработки;
				Если ПолучитьПорции - КоличествоПорцийДляОбработки < Цел(ПолучитьПорции / 3) Тогда
					ПолучитьПорции = Цел(ПолучитьПорции / 3);
				Иначе
					ПолучитьПорции = ПолучитьПорции - КоличествоПорцийДляОбработки;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		Если Не Задание.ЕстьТочечноеЗадание И ПолучитьПорции = 0 Тогда
			Возврат Истина;
		КонецЕсли;
		
		ОбщиеПараметрыОбновления.Вставить("ПолучитьПорции", ПолучитьПорции);
		Если ПоследняяПорция <> Неопределено Тогда
			ОбщиеПараметрыОбновления.Вставить("НовыйПоследнийЭлементПорции",
				ПоследняяПорция.НовыйПоследнийЭлементПорции);
		КонецЕсли;
	КонецЕсли;
	
	Если Не ОбщиеПараметрыОбновления.Свойство("ПорцияИзНабора") И ОбщееЗаданиеВыполняется(Задание) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Задание.ЕстьТочечноеЗадание Тогда
		Задание.ЕстьТочечноеЗадание = Ложь;
		ОбновитьСвойствоЭтоОбработкаУстаревшихЭлементов(Задание);
		Задание.ДатаПоследнегоЗапускаТочечногоЗадания = ТекущаяДатаСеанса();
	Иначе
		Задание.ДатаПоследнегоЗапускаОбщегоЗадания = ТекущаяДатаСеанса();
	КонецЕсли;
	
	Если Контекст.ОбновлениеВЭтомСеансе Тогда
		ВыполнитьОбновлениеДоступаСпискаСПопыткамиПовтора(ОбщиеПараметрыОбновления, Контекст);
		ОбработатьРезультатЗадания(Контекст, ОбщиеПараметрыОбновления, Задание);
	Иначе
		Для Каждого СвободныйПоток Из Контекст.СвободныеПотоки Цикл
			Прервать;
		КонецЦикла;
		Если СвободныйПоток = Неопределено Тогда
			Если Контекст.ЗанятыеПотоки.Количество() >= Контекст.КоличествоПотоков Тогда
				Возврат Истина;
			КонецЕсли;
			СвободныйПоток = НовыйПоток();
			Параметры = Новый Массив;
			Параметры.Добавить(Контекст.ОписаниеОсновногоСеанса);
			СвободныйПоток.ФоновоеЗадание = ФоновыеЗадания.Выполнить(ИмяМетодаПотокаОбновленияДоступа(), Параметры);
			СвободныйПоток.ИдентификаторПотока = СвободныйПоток.ФоновоеЗадание.УникальныйИдентификатор;
			Контекст.СвободныеПотоки.Добавить(СвободныйПоток);
		КонецЕсли;
		
		ИдентификаторПотока = СвободныйПоток.ИдентификаторПотока;
		НаборЗаписей = СлужебныйНаборЗаписей(РегистрыСведений.ОбновлениеКлючейДоступаТекущиеЗадания);
		НаборЗаписей.Отбор.ИдентификаторПотока.Установить(ИдентификаторПотока);
		ЗаписьНабора = НаборЗаписей.Добавить();
		ЗаписьНабора.ИдентификаторПотока = ИдентификаторПотока;
		ЗаписьНабора.ЭтоЗапуск = Истина;
		ЗаписьНабора.Параметры = Новый ХранилищеЗначения(ОбщиеПараметрыОбновления);
		ЗаписьНабора.ДатаИзмененияЗаписиРегистра = ТекущаяДатаСеанса();
		
		НаборЗаписей.Записать();
		
		СвободныйПоток.Задание = Задание;
		Если ОбщиеПараметрыОбновления.Свойство("ПорцияИзНабора") Тогда
			СвободныйПоток.ПорцияИзНабора = ОбщиеПараметрыОбновления.ПорцияИзНабора;
		КонецЕсли;
		Задание.ЗанятыеПотоки.Вставить(ИдентификаторПотока, СвободныйПоток);
		Контекст.ЗанятыеПотоки.Вставить(ИдентификаторПотока, СвободныйПоток);
		Контекст.СвободныеПотоки.Удалить(0);
		Если Показатели <> Неопределено Тогда
			СнятьПоказателиВыдачиЗаданий(Показатели);
		КонецЕсли;
		Контекст.ЕстьЗапущенноеЗадание = Истина;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Для функции ЗапуститьОбновлениеДоступаСписка и процедуры ОбработатьРезультатЗадания.
Функция ОбщееЗаданиеВыполняется(Задание)
	
	Для Каждого ОписаниеЗанятогоПотока Из Задание.ЗанятыеПотоки Цикл
		Если ОписаниеЗанятогоПотока.Значение.ПорцияИзНабора = Неопределено Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Для функции ЗапуститьОбновлениеДоступаСписка и процедуры ОтменитьФоновыеЗаданияПотоковОбновленияДоступа.
Функция ИмяМетодаПотокаОбновленияДоступа()
	
	Возврат "УправлениеДоступомСлужебный.ВыполнитьОбновлениеДоступаСпискаВФоне";
	
КонецФункции

// Для процедуры ВыполнитьОбновлениеДоступа, ЗавершитьОбновлениеДоступа.
Процедура ПодождатьОсвобожденияПотока(Контекст, ЖдатьЗавершенияЗадания = Ложь)
	
	Если Контекст.ОбновлениеВЭтомСеансе Тогда
		Возврат;
	КонецЕсли;
	
	Показатели = Контекст.Показатели;
	Если Показатели <> Неопределено Тогда
		НачалоОжидания = ТекущаяУниверсальнаяДатаВМиллисекундах();
	КонецЕсли;
	
	Выполнять = Истина;
	
	Если ЖдатьЗавершенияЗадания Тогда
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ИдентификаторыПотоков", ИдентификаторыПотоков(Контекст.ЗанятыеПотоки));
		Запрос.Текст =
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	ИСТИНА КАК ЗначениеИстина
		|ИЗ
		|	РегистрСведений.ОбновлениеКлючейДоступаТекущиеЗадания КАК ТекущиеЗадания
		|ГДЕ
		|	НЕ ТекущиеЗадания.ЭтоЗапуск
		|	И ТекущиеЗадания.ИдентификаторПотока В(&ИдентификаторыПотоков)";
		Если Не Запрос.Выполнить().Пустой() Тогда
			Выполнять = Ложь;
		КонецЕсли;
		ГраницаОжидания = ТекущаяДатаСеанса() + 5;
	КонецЕсли;
	
	Пока Выполнять Цикл
		Если Контекст.ТекущееФоновоеЗадание <> Неопределено Тогда
			ФоновоеЗадание = Контекст.ТекущееФоновоеЗадание;
		Иначе
			ФоновоеЗадание = Неопределено;
			Для Каждого ОписаниеПотока Из Контекст.ЗанятыеПотоки Цикл
				Поток = ОписаниеПотока.Значение;
				ОбновитьСвойстваФоновогоЗадания(Поток, Контекст);
				Если Поток.ФоновоеЗадание <> Неопределено
				   И Поток.ФоновоеЗадание.Состояние = СостояниеФоновогоЗадания.Активно Тогда
					
					ФоновоеЗадание = Поток.ФоновоеЗадание;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Если ФоновоеЗадание = Неопределено Тогда
			Прервать;
		КонецЕсли;
		ФоновоеЗадание.ОжидатьЗавершенияВыполнения(0.025);
		Если Не ЖдатьЗавершенияЗадания
		 Или ТекущаяДатаСеанса() > ГраницаОжидания
		 Или Контекст.ЗанятыеПотоки.Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		Если Не Запрос.Выполнить().Пустой() Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если Показатели <> Неопределено Тогда
		Показатели.ВремяОжиданийСвободногоПотока = Показатели.ВремяОжиданийСвободногоПотока
			+ (ТекущаяУниверсальнаяДатаВМиллисекундах() - НачалоОжидания);
	КонецЕсли;
	
КонецПроцедуры

// Для процедур ПодождатьОсвобожденияПотока, ОбработатьВыполненныеЗадания.
Функция ИдентификаторыПотоков(ЗанятыеПотоки)
	
	ИдентификаторыПотоков = Новый Массив;
	
	Для Каждого ОписаниеПотока Из ЗанятыеПотоки Цикл
		ИдентификаторыПотоков.Добавить(ОписаниеПотока.Ключ);
	КонецЦикла;
	
	Возврат ИдентификаторыПотоков;
	
КонецФункции

// Для процедур ПодождатьОсвобожденияПотока, УдалитьОстановленныеПотоки.
Процедура ОбновитьСвойстваФоновогоЗадания(Поток, Контекст)
	
	ФоновоеЗадание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(Поток.ИдентификаторПотока);
	
	Если ФоновоеЗадание = Неопределено Тогда
		Если РегистрироватьПоказателиОбновленияДоступа() Тогда
			ЗарегистрироватьОшибкуОбновленияДоступа(ТекстОшибкиОбновленияСКонтекстом(
				НСтр("ru = 'Не удалось найти запущенное фоновое задание.'"), Поток.Задание, Истина), Контекст);
		КонецЕсли;
		Контекст.ОбработкаЗавершена = Ложь;
		Возврат;
	КонецЕсли;
	Поток.ФоновоеЗадание = ФоновоеЗадание;
	
КонецПроцедуры

// Для процедуры ЗавершитьОбновлениеДоступа.
Процедура ОтменитьФоновоеЗаданиеПотока(Поток, Контекст)
	
	ОбновитьСвойстваФоновогоЗадания(Поток, Контекст);
	ФоновоеЗадание = Поток.ФоновоеЗадание;
	
	Если ФоновоеЗадание = Неопределено
	 Или ФоновоеЗадание.Состояние <> СостояниеФоновогоЗадания.Активно Тогда
		
		Возврат;
	КонецЕсли;
	
	Попытка
		ФоновоеЗадание.Отменить();
	Исключение
		ПредставлениеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось отменить фоновое задание потока по причине:
			           |%1'"), КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		ЗарегистрироватьОшибкуОбновленияДоступа(ТекстОшибкиОбновленияСКонтекстом(
			ПредставлениеОшибки, Поток.Задание, Истина), Контекст);
	КонецПопытки;
	
	Контекст.ОбработкаЗавершена = Ложь;
	
КонецПроцедуры

// Для процедуры ВыполнитьОбновлениеДоступа, ОбработатьРезультатЗадания.
Процедура ОбработатьВыполненныеЗадания(Контекст, ЗанятыеПотоки = Неопределено)
	
	Если Контекст.ОбновлениеВЭтомСеансе Тогда
		Если ОбновлениеДоступаОтменено() Тогда
			Контекст.ОбновлениеОтменено = Истина;
		КонецЕсли;
		Возврат;
	КонецЕсли;
	
	Показатели = Контекст.Показатели;
	Если Показатели <> Неопределено Тогда
		НачалоОбработки = ТекущаяУниверсальнаяДатаВМиллисекундах();
	КонецЕсли;
	
	Если ЗанятыеПотоки = Неопределено Тогда
		ЗанятыеПотоки = Контекст.ЗанятыеПотоки;
	КонецЕсли;
	ОписаниеПотоков = Новый Соответствие(Новый ФиксированноеСоответствие(ЗанятыеПотоки));
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ИдентификаторОтмены", ИдентификаторОтменыОбновленияДоступаНаУровнеЗаписей());
	Запрос.УстановитьПараметр("ИдентификаторыПотоков", ИдентификаторыПотоков(ОписаниеПотоков));
	Запрос.УстановитьПараметр("ГраницаОжиданияВыполнения", ТекущаяДатаСеанса()
		- МаксимальноеКоличествоСекундОжиданияВыполненияОдногоЗаданияВПотоке());
	
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ТекущиеЗадания.ИдентификаторПотока КАК ИдентификаторПотока,
	|	ТекущиеЗадания.Результат КАК Результат,
	|	ТекущиеЗадания.ЭтоЗапуск
	|			И &ГраницаОжиданияВыполнения > ТекущиеЗадания.ДатаИзмененияЗаписиРегистра
	|		ИЛИ ТекущиеЗадания.ИдентификаторПотока = &ИдентификаторОтмены КАК ПревышеноВремяВыполнения,
	|	ТекущиеЗадания.ДатаИзмененияЗаписиРегистра КАК ДатаИзмененияЗаписиРегистра
	|ИЗ
	|	РегистрСведений.ОбновлениеКлючейДоступаТекущиеЗадания КАК ТекущиеЗадания
	|ГДЕ
	|	(НЕ ТекущиеЗадания.ЭтоЗапуск
	|				И ТекущиеЗадания.ИдентификаторПотока В (&ИдентификаторыПотоков)
	|			ИЛИ ТекущиеЗадания.ЭтоЗапуск
	|				И &ГраницаОжиданияВыполнения > ТекущиеЗадания.ДатаИзмененияЗаписиРегистра
	|			ИЛИ ТекущиеЗадания.ИдентификаторПотока = &ИдентификаторОтмены)";
	
	ОписаниеРезультатов = Новый Соответствие;
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Если Выборка.ПревышеноВремяВыполнения = Истина Тогда
			Если Выборка.ИдентификаторПотока = ИдентификаторОтменыОбновленияДоступаНаУровнеЗаписей() Тогда
				Контекст.ОбновлениеОтменено = Истина;
				Возврат;
			КонецЕсли;
			Поток = Контекст.ЗанятыеПотоки.Получить(Выборка.ИдентификаторПотока);
			Если Поток = Неопределено Тогда
				Для Каждого СвободныйПоток Из Контекст.СвободныеПотоки Цикл
					Если СвободныйПоток.ИдентификаторПотока = Выборка.ИдентификаторПотока Тогда
						Поток = СвободныйПоток;
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			Если Поток = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ПредставлениеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Превышено время выполнения задания в потоке (%1 сек).
				           |Фоновое задание потока отменено и перезапущено.'"),
				МаксимальноеКоличествоСекундОжиданияВыполненияОдногоЗаданияВПотоке());
			
			ЗарегистрироватьОшибкуОбновленияДоступа(ТекстОшибкиОбновленияСКонтекстом(
				ПредставлениеОшибки, Поток.Задание, Истина), Контекст);
			
			ОтменитьФоновоеЗаданиеПотока(Поток, Контекст);
			УдалитьПоток(Поток, Контекст);
			ОписаниеПотоков.Удалить(Поток.ИдентификаторПотока);
			
			Если Показатели <> Неопределено Тогда
				Показатели.КоличествоПотоковСПревышениемВремениВыполнения =
					Показатели.КоличествоПотоковСПревышениемВремениВыполнения + 1;
			КонецЕсли;
			
		ИначеЕсли ТипЗнч(Выборка.Результат) = Тип("ХранилищеЗначения") Тогда
			ОписаниеРезультата = Новый Структура;
			ОписаниеРезультата.Вставить("ДатаЗавершения", Выборка.ДатаИзмененияЗаписиРегистра);
			ОписаниеРезультата.Вставить("Результат",      Выборка.Результат.Получить());
			ОписаниеРезультатов.Вставить(Выборка.ИдентификаторПотока, ОписаниеРезультата);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ОписаниеПотока Из ОписаниеПотоков Цикл
		Поток = ОписаниеПотока.Значение;
		ОписаниеРезультата = ОписаниеРезультатов.Получить(Поток.ИдентификаторПотока);
		ОбработатьРезультатВыполненногоЗадания(Поток, ОписаниеРезультата, Контекст);
	КонецЦикла;
	
	КоличествоПотоков = Контекст.ЗанятыеПотоки.Количество() + Контекст.СвободныеПотоки.Количество();
	Если КоличествоПотоков > Контекст.КоличествоПотоков Тогда
		Индекс = Контекст.СвободныеПотоки.Количество() - 1;
		Пока Индекс >= 0 Цикл
			СвободныйПоток = Контекст.СвободныеПотоки.Получить(Индекс);
			УдалитьПоток(СвободныйПоток, Контекст);
			Индекс = Индекс - 1;
			КоличествоПотоков = КоличествоПотоков - 1;
			Если КоличествоПотоков <= Контекст.КоличествоПотоков Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если ТекущаяДатаСеанса() > Контекст.ГраницаОбновленияЗаданий Тогда
		Контекст.ГраницаОбновленияЗаданий = ТекущаяДатаСеанса() + 2;
		УдалитьОстановленныеПотоки(Контекст, Контекст.ЗанятыеПотоки);
		УдалитьОстановленныеПотоки(Контекст, Контекст.СвободныеПотоки);
		УдалитьНеиспользуемыеСвободныеПотоки(Контекст);
	КонецЕсли;
	
	Если Показатели <> Неопределено Тогда
		Показатели.ВремяОбработкиРезультатовЗаданий = Показатели.ВремяОбработкиРезультатовЗаданий
			+ (ТекущаяУниверсальнаяДатаВМиллисекундах() - НачалоОбработки);
	КонецЕсли;
	
КонецПроцедуры

// Для процедур ОбработатьВыполненныеЗадания, ВыполнитьОбновлениеДоступаСпискаСПопыткамиПовтора.
Функция ОбновлениеДоступаОтменено()
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ИдентификаторПотока", ИдентификаторОтменыОбновленияДоступаНаУровнеЗаписей());
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА КАК ЗначениеИстина
	|ИЗ
	|	РегистрСведений.ОбновлениеКлючейДоступаТекущиеЗадания КАК ТекущиеЗадания
	|ГДЕ
	|	ТекущиеЗадания.ИдентификаторПотока = &ИдентификаторПотока";
	
	Возврат Не Запрос.Выполнить().Пустой();
	
КонецФункции

// Для процедуры ОбработатьВыполненныеЗадания.
Процедура ОбработатьРезультатВыполненногоЗадания(Поток, ОписаниеРезультата, Контекст)
	
	Если Не Поток.ОтменитьЗадание
	   И Не Поток.Задание.Удалить Тогда
		
		Если ОписаниеРезультата = Неопределено Тогда
			Возврат;
		ИначеЕсли ТипЗнч(ОписаниеРезультата.Результат) <> Тип("Структура") Тогда
			Контекст.ОбработкаЗавершена = Ложь;
		Иначе
			Результат = ОписаниеРезультата.Результат;
			Если Результат.Свойство("ПорцияИзНабора") Тогда
				Результат.ПорцияИзНабора = Поток.ПорцияИзНабора;
			КонецЕсли;
			Показатели = Контекст.Показатели;
			Если Показатели <> Неопределено Тогда
				Показатели.НачалоОбработкиЗадания = ТекущаяУниверсальнаяДатаВМиллисекундах();
			КонецЕсли;
			ОбработатьРезультатЗадания(Контекст, Результат, Поток.Задание);
			Если Показатели <> Неопределено Тогда
				СнятьПоказателиОбработкиРезультатаЗадания(Показатели);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если ОписаниеРезультата = Неопределено Тогда
		ДатаЗавершения = Неопределено;
	Иначе
		ДатаЗавершения = ОписаниеРезультата.ДатаЗавершения;
	КонецЕсли;
	
	ОсвободитьПоток(Поток, Контекст, ДатаЗавершения);
	
КонецПроцедуры

// Для процедур ОбработатьРезультатВыполненногоЗадания, УдалитьПоток.
Процедура ОсвободитьПоток(Поток, Контекст, ДатаЗавершения = Неопределено)
	
	ПозицияВставки = 0;
	Если ДатаЗавершения = Неопределено Тогда
		Поток.ДатаОсвобождения = ТекущаяДатаСеанса();
	Иначе
		Поток.ДатаОсвобождения = ДатаЗавершения;
		Количество = Контекст.СвободныеПотоки.Количество();
		Пока ПозицияВставки < Количество Цикл
			ТекущийПоток = Контекст.СвободныеПотоки.Получить(ПозицияВставки);
			Если ТекущийПоток.ДатаОсвобождения <= ДатаЗавершения Тогда
				Прервать;
			КонецЕсли;
			ПозицияВставки = ПозицияВставки + 1;
		КонецЦикла;
	КонецЕсли;
	
	Контекст.СвободныеПотоки.Вставить(ПозицияВставки, Поток);
	Контекст.ЗанятыеПотоки.Удалить(Поток.ИдентификаторПотока);
	Поток.Задание.ЗанятыеПотоки.Удалить(Поток.ИдентификаторПотока);
	Если Поток.ПорцияИзНабора <> Неопределено Тогда
		СнятьПризнакОбрабатываетсяДляПорции(Поток, Поток.Задание);
		Поток.ПорцияИзНабора = Неопределено;
	КонецЕсли;
	Поток.Задание = Неопределено;
	Поток.ОтменитьЗадание = Ложь;
	
КонецПроцедуры

// Для процедур ЗапуститьОбновлениеДоступаСписка, ОбработатьРезультатВыполненногоЗадания, ОсвободитьПоток.
Процедура СнятьПризнакОбрабатываетсяДляПорции(ПотокИлиРезультат, Задание)
	
	ПорцияИзНабора = Неопределено;
	
	Если Не ПотокИлиРезультат.Свойство("ПорцияИзНабора", ПорцияИзНабора)
	 Или ПорцияИзНабора = Неопределено
	 Или Не ПорцияИзНабора.Обрабатывается Тогда
		Возврат;
	КонецЕсли;
	
	Если Не ПорцияИзНабора.Обработана Тогда
		ИндексПорции = Задание.НаборПорций.Найти(ПорцияИзНабора);
		
		Если ИндексПорции = Неопределено Тогда
			Задание.ИндексСледующейПорцииДляОбработки = 0;
			
		ИначеЕсли Задание.ИндексСледующейПорцииДляОбработки > ИндексПорции Тогда
			Задание.ИндексСледующейПорцииДляОбработки = ИндексПорции;
		КонецЕсли;
	КонецЕсли;
	
	ПорцияИзНабора.Обрабатывается = Ложь;
	
КонецПроцедуры

// Для процедуры ОбработатьРезультатВыполненногоЗадания, ЗавершитьОбновлениеДоступа.
Процедура УдалитьПоток(Поток, Контекст)
	
	НаборЗаписей = СлужебныйНаборЗаписей(РегистрыСведений.ОбновлениеКлючейДоступаТекущиеЗадания);
	НаборЗаписей.Отбор.ИдентификаторПотока.Установить(Поток.ИдентификаторПотока);
	НаборЗаписей.Записать();
	
	Если Контекст.ЗанятыеПотоки.Получить(Поток.ИдентификаторПотока) <> Неопределено Тогда
		ОсвободитьПоток(Поток, Контекст);
	КонецЕсли;
	
	Индекс = Контекст.СвободныеПотоки.Найти(Поток);
	Если Индекс <> Неопределено Тогда
		Контекст.СвободныеПотоки.Удалить(Индекс);
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ОбработатьРезультатВыполненногоЗадания, ЗавершитьОбновлениеДоступа.
Процедура УдалитьОстановленныеПотоки(Контекст, ОписаниеПотоков)
	
	Если ТипЗнч(ОписаниеПотоков) = Тип("Соответствие") Тогда
		ИсходноеОписаниеПотоков = Новый ФиксированноеСоответствие(ОписаниеПотоков);
	Иначе
		ИсходноеОписаниеПотоков = Новый ФиксированныйМассив(ОписаниеПотоков);
	КонецЕсли;
	
	Для Каждого ОписаниеПотока Из ИсходноеОписаниеПотоков Цикл
		Если ТипЗнч(ОписаниеПотока) = Тип("КлючИЗначение") Тогда
			Поток = ОписаниеПотока.Значение;
		Иначе
			Поток = ОписаниеПотока;
		КонецЕсли;
		ОбновитьСвойстваФоновогоЗадания(Поток, Контекст);
		ФоновоеЗадание = Поток.ФоновоеЗадание;
		
		Если ФоновоеЗадание <> Неопределено
		   И ФоновоеЗадание.Состояние = СостояниеФоновогоЗадания.Активно Тогда
			Продолжить;
		КонецЕсли;
		Контекст.ОбработкаЗавершена = Ложь;
		
		УдалитьПоток(Поток, Контекст);
		
		Если ФоновоеЗадание <> Неопределено
		   И ФоновоеЗадание.Состояние = СостояниеФоновогоЗадания.ЗавершеноАварийно Тогда
			
			ЗарегистрироватьОшибкуОбновленияДоступа(ТекстОшибкиОбновленияСКонтекстом(
				ФоновоеЗадание.ИнформацияОбОшибке, Поток.Задание, Истина), Контекст);
			
			Если Контекст.Показатели <> Неопределено Тогда
				Контекст.Показатели.КоличествоПотоковСНештатнымЗавершением =
					Контекст.Показатели.КоличествоПотоковСНештатнымЗавершением + 1;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ОбработатьВыполненныеЗадания.
Процедура УдалитьНеиспользуемыеСвободныеПотоки(Контекст)
	
	Количество = Контекст.СвободныеПотоки.Количество();
	Если Количество = 0 Тогда
		Возврат;
	КонецЕсли;
	
	СвободныеПотоки = Контекст.СвободныеПотоки;
	Индекс = Количество - 1;
	ТекущаяДатаСеанса = ТекущаяДатаСеанса();
	
	Пока Индекс >= 0 Цикл
		Поток = СвободныеПотоки.Получить(Индекс);
		Если ТекущаяДатаСеанса > Поток.ДатаОсвобождения + 15 Тогда
			УдалитьПоток(Поток, Контекст);
		КонецЕсли;
		Индекс = Индекс - 1;
	КонецЦикла;
	
КонецПроцедуры

// Для процедур ДобавитьЗаданияОбновленияДоступа и ОбработатьРезультатЗадания.
Процедура ОтменитьЗадание(Задание)
	
	Задание.НаборПорций = Новый Массив;
	Задание.КоличествоПорцийДляОбработки = 0;
	Задание.ИндексСледующейПорцииДляОбработки = 0;
	
	Для Каждого ОписаниеПотока Из Задание.ЗанятыеПотоки Цикл
		ОписаниеПотока.Значение.ОтменитьЗадание = Истина;
	КонецЦикла;
	
КонецПроцедуры

// Для процедур ЗапуститьОбновлениеДоступаСписка, ОбработатьРезультатВыполненногоЗадания.
Процедура ОбработатьРезультатЗадания(Контекст, Результат, Задание)
	
	Если Результат.Свойство("НетЗаданий") Или Результат.Свойство("ПерезапускОбновления") Тогда
		Если Результат.Свойство("ПерезапускОбновления") Тогда
			Задание.ЕстьПерезапуск = Истина;
			Если Результат.Свойство("ПерезапускОбновленияСНачала") Тогда
				Задание.ЕстьНачальноеОбновление = Истина;
			КонецЕсли;
		КонецЕсли;
		ОтменитьЗадание(Задание);
		Если Результат.Свойство("НетЗаданий") Тогда
			СнятьПризнакОбрабатываетсяДляПорции(Результат, Задание);
			ОбновитьСвойстваЗадания(Задание, Новый Структура("КлючДанных", Null));
		КонецЕсли;
	КонецЕсли;
	
	Если Результат.Свойство("ТекстОшибкиЗавершения") Тогда
		Если Не Результат.ОбработкаЗавершена Тогда
			Контекст.ОбработкаЗавершена = Ложь;
		КонецЕсли;
		Если ЗначениеЗаполнено(Результат.ТекстОшибкиЗавершения) Тогда
			СнятьПризнакОбрабатываетсяДляПорции(Результат, Задание);
			ДобавитьТекстОшибкиЗавершения(Контекст.ТекстОшибкиЗавершения, Результат.ТекстОшибкиЗавершения);
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	Если Результат.Свойство("НетЗаданий") Тогда
		Возврат;
	КонецЕсли;
	
	Если Результат.Свойство("НачальноеОбновлениеЗавершено") Тогда
		Задание.ЕстьНачальноеОбновление = Ложь;
		Задание.ЕстьПерезапуск = Ложь;
	КонецЕсли;
	
	Если Результат.Свойство("ПорцияИзНабора") Тогда
		ИсходнаяПорцияИзНабора = Результат.ПорцияИзНабора;
		Если Результат.Свойство("НаборПорций") Тогда
			Индекс = Задание.НаборПорций.Найти(ИсходнаяПорцияИзНабора);
			Если Задание.ИндексСледующейПорцииДляОбработки > Индекс Тогда
				Задание.ИндексСледующейПорцииДляОбработки = Индекс + 1;
			КонецЕсли;
			Для Каждого НоваяПорцияИзИсходной Из Результат.НаборПорций Цикл
				Индекс = Индекс + 1;
				Задание.НаборПорций.Вставить(Индекс, НоваяПорцияИзИсходной);
			КонецЦикла;
			Задание.КоличествоПорцийДляОбработки = Задание.КоличествоПорцийДляОбработки
				+ Результат.НаборПорций.Количество();
			ИсходнаяПорцияИзНабора.ПоследнийЭлементПорции      = Результат.НовыйПоследнийОбновленныйЭлемент;
			ИсходнаяПорцияИзНабора.НовыйПоследнийЭлементПорции = Результат.НовыйПоследнийОбновленныйЭлемент;
		КонецЕсли;
		ИсходнаяПорцияИзНабора.Обработана = Истина;
		СнятьПризнакОбрабатываетсяДляПорции(Результат, Задание);
		
	ИначеЕсли Результат.Свойство("НаборПорций") Тогда
		Для Каждого НоваяПорция Из Результат.НаборПорций Цикл
			Задание.НаборПорций.Добавить(НоваяПорция);
		КонецЦикла;
		Задание.КоличествоПорцийДляОбработки = Задание.КоличествоПорцийДляОбработки
			+ Результат.НаборПорций.Количество();
		
	ИначеЕсли Результат.Свойство("НовыйПоследнийОбновленныйЭлемент") Тогда
		ОбновитьСвойстваЗадания(Задание, Результат.НовыйПоследнийОбновленныйЭлемент);
	КонецЕсли;
	
	Если Результат.Свойство("ПорцияИзНабора") И ОбщееЗаданиеВыполняется(Задание) Тогда
		Возврат;
	КонецЕсли;
	
	Зафиксировать = Ложь;
	Пока Задание.НаборПорций.Количество() > 0 Цикл
		ПорцияИзНабора = Задание.НаборПорций[0];
		Если Не ПорцияИзНабора.Обработана Тогда
			Прервать;
		КонецЕсли;
		Зафиксировать = Истина;
		НовыйПоследнийОбновленныйЭлемент = ПорцияИзНабора.НовыйПоследнийЭлементПорции;
		Задание.НаборПорций.Удалить(0);
		Если Задание.ИндексСледующейПорцииДляОбработки > 0 Тогда
			Задание.ИндексСледующейПорцииДляОбработки = Задание.ИндексСледующейПорцииДляОбработки - 1;
		КонецЕсли;
	КонецЦикла;
	
	Если Зафиксировать Тогда
		ЗаписатьПоследнийОбновленныйЭлемент(Результат, НовыйПоследнийОбновленныйЭлемент);
		ОбновитьСвойстваЗадания(Задание, НовыйПоследнийОбновленныйЭлемент);
		Если Не Результат.ОбработкаЗавершена Тогда
			Контекст.ОбработкаЗавершена = Ложь;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ОбработатьРезультатЗадания.
Процедура ОбновитьСвойстваЗадания(Задание, НовыйПоследнийОбновленныйЭлемент)
	
	Если НовыйПоследнийОбновленныйЭлемент.КлючДанных = Null Тогда
		Задание.Удалить = Истина;
	Иначе
		Если НовыйПоследнийОбновленныйЭлемент.Свойство("Дата") Тогда
			Задание.ДатаПоследнегоОбновленногоЭлемента = НовыйПоследнийОбновленныйЭлемент.Дата;
		Иначе
			Задание.ДатаПоследнегоОбновленногоЭлемента = '00010101';
		КонецЕсли;
		Задание.ЕстьДатаПоследнегоОбновленногоЭлемента
			= ЗначениеЗаполнено(Задание.ДатаПоследнегоОбновленногоЭлемента);
		
		Задание.ПорядокВидаКлючаДанных = НовыйПоследнийОбновленныйЭлемент.ПорядокВидаКлючаДанных;
		ОбновитьСвойствоЭтоОбработкаУстаревшихЭлементов(Задание);
	КонецЕсли;
	
КонецПроцедуры

// Для функции ЗапуститьОбновлениеДоступаСписка.
Процедура ВыполнитьОбновлениеДоступаСпискаВФоне(ОписаниеРодительскогоСеанса) Экспорт
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	Контекст = Новый Структура;
	Контекст.Вставить("Показатели", ПоказателиОбновленияИсполняющегоПотока());
	Контекст.Вставить("ОписаниеРодительскогоСеанса", ОписаниеРодительскогоСеанса);
	
	Если Не ИсполняющийПотокЗапущен(Контекст) Тогда
		Возврат;
	КонецЕсли;
	Кэш = Новый Структура;
	
	Пока Истина Цикл
		Запрос = Контекст.Запрос; // Запрос -
		Выборка = Запрос.Выполнить().Выбрать();
		Если Не Выборка.Следующий() Тогда
			Прервать;
		КонецЕсли;
		Если ТипЗнч(Выборка.Параметры) <> Тип("ХранилищеЗначения") Тогда
			Если ПродолжитьОжиданиеНовогоЗадания(Контекст) Тогда
				Продолжить;
			Иначе
				Прервать;
			КонецЕсли;
		КонецЕсли;
		Результат = ОписаниеОбщихПараметровОбновления();
		Результат.Вставить("ОбработкаЗавершена", Ложь);
		Результат.Вставить("ТекстОшибкиЗавершения", "");
		Попытка
			ОбщиеПараметрыОбновления = Выборка.Параметры.Получить();
			ЗаполнитьЗначенияСвойств(Результат, ОбщиеПараметрыОбновления);
			ОбщиеПараметрыОбновления.Вставить("Кэш", Кэш);
			Контекст.КоличествоСекундОжиданияДоПоискаНовогоЗадания =
				Цел(0.025 * Результат.МаксимумМиллисекундОбработки) / 1000;
			
			ВыполнитьОбновлениеДоступаСпискаСПопыткамиПовтора(ОбщиеПараметрыОбновления, Контекст);
			Результат.ОбработкаЗавершена = ОбщиеПараметрыОбновления.ОбработкаЗавершена;
			
			ВозвращаемыеСвойства = "НетЗаданий, ПерезапускОбновления, ПерезапускОбновленияСНачала, НаборПорций,
				|НовыйПоследнийОбновленныйЭлемент, НачальноеОбновлениеЗавершено, ТекстОшибкиЗавершения";
			Для Каждого КлючИЗначение Из Новый Структура(ВозвращаемыеСвойства) Цикл
				Если ОбщиеПараметрыОбновления.Свойство(КлючИЗначение.Ключ) Тогда
					Результат.Вставить(КлючИЗначение.Ключ, ОбщиеПараметрыОбновления[КлючИЗначение.Ключ]);
				КонецЕсли;
			КонецЦикла;
			Если ОбщиеПараметрыОбновления.Свойство("ПорцияИзНабора") Тогда
				Результат.Вставить("ПорцияИзНабора");
			КонецЕсли;
		Исключение
			ДобавитьТекстОшибкиЗавершения(Результат.ТекстОшибкиЗавершения, ТекстОшибкиОбновленияСКонтекстом(
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), Результат));
		КонецПопытки;
		ЗаписатьРезультатОбновленияДоступаСпискаВФоне(Результат, Выборка.Параметры, Контекст);
	КонецЦикла;
	
	Если РегистрироватьПоказателиОбновленияДоступа() Тогда
		ЗарегистрироватьПоказателиОбновленияИсполняющегоПотока(Контекст);
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ВыполнитьОбновлениеДоступаСпискаВФоне.
Функция ИсполняющийПотокЗапущен(Контекст)
	
	ТекущийСеанс = ПолучитьТекущийСеансИнформационнойБазы();
	Контекст.Вставить("ТекущийСеанс", ТекущийСеанс);
	
	Если ТекущийСеанс.ИмяПриложения <> "BackgroundJob" Тогда
		ТекстОшибки = НСтр("ru = 'Порция обновления доступа может обрабатываться только в фоновом задании.'");
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Контекст.Вставить("ТекущееФоновоеЗадание", ТекущийСеанс.ПолучитьФоновоеЗадание());
	ИдентификаторПотока = Контекст.ТекущееФоновоеЗадание.УникальныйИдентификатор;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ИдентификаторПотока", ИдентификаторПотока);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ВЫБОР
	|		КОГДА ТекущиеЗадания.ЭтоЗапуск
	|			ТОГДА ТекущиеЗадания.Параметры
	|		ИНАЧЕ НЕОПРЕДЕЛЕНО
	|	КОНЕЦ КАК Параметры
	|ИЗ
	|	РегистрСведений.ОбновлениеКлючейДоступаТекущиеЗадания КАК ТекущиеЗадания
	|ГДЕ
	|	ТекущиеЗадания.ИдентификаторПотока = &ИдентификаторПотока";
	Контекст.Вставить("Запрос", Запрос);
	
	Блокировка = Новый("БлокировкаДанных");
	ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ОбновлениеКлючейДоступаТекущиеЗадания");
	ЭлементБлокировки.УстановитьЗначение("ИдентификаторПотока", ИдентификаторПотока);
	Контекст.Вставить("Блокировка", Блокировка);
	
	НаборЗаписей = СлужебныйНаборЗаписей(РегистрыСведений.ОбновлениеКлючейДоступаТекущиеЗадания);
	НаборЗаписей.Отбор.ИдентификаторПотока.Установить(ИдентификаторПотока);
	Контекст.Вставить("НаборЗаписей", НаборЗаписей);
	
	ЗаписьНабора = НаборЗаписей.Добавить();
	ЗаписьНабора.ИдентификаторПотока = ИдентификаторПотока;
	ЗаписьНабора.ЭтоЗапуск = Ложь;
	Контекст.Вставить("ЗаписьНабора", ЗаписьНабора);
	
	// Ожидание признака запуска.
	ГраницаОжидания = ТекущаяУниверсальнаяДатаВМиллисекундах() + 1000;
	Пока Истина Цикл
		Если Не Запрос.Выполнить().Пустой() Тогда
			Прервать;
		КонецЕсли;
		Если ТекущаяУниверсальнаяДатаВМиллисекундах() > ГраницаОжидания Тогда
			Возврат Ложь;
		КонецЕсли;
		Контекст.ТекущееФоновоеЗадание.ОжидатьЗавершенияВыполнения(0.025);
	КонецЦикла;
	
	Контекст.Вставить("ГраницаПроверкиРодительскогоСеанса", ТекущаяУниверсальнаяДатаВМиллисекундах() + 1000);
	Контекст.Вставить("КоличествоСекундОжиданияДоПоискаНовогоЗадания", 0.025);
	
	Возврат Истина;
	
КонецФункции

// Для процедуры ВыполнитьОбновлениеДоступаСпискаВФоне.
Функция ПродолжитьОжиданиеНовогоЗадания(Контекст)
	
	Если ТекущаяУниверсальнаяДатаВМиллисекундах() > Контекст.ГраницаПроверкиРодительскогоСеанса Тогда
		Если ОбновлениеДоступаОтменено() Тогда
			Возврат Ложь;
		КонецЕсли;
		Контекст.ГраницаПроверкиРодительскогоСеанса = ТекущаяУниверсальнаяДатаВМиллисекундах() + 1000;
		Если Не СеансСуществует(Контекст.ОписаниеРодительскогоСеанса) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Показатели = Контекст.Показатели;
	Если Показатели <> Неопределено Тогда
		Показатели.КоличествоОжиданийНовыхЗаданий = Показатели.КоличествоОжиданийНовыхЗаданий + 1;
	КонецЕсли;
	
	НачалоОжидания = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	Контекст.ТекущееФоновоеЗадание.ОжидатьЗавершенияВыполнения(
		Контекст.КоличествоСекундОжиданияДоПоискаНовогоЗадания);
	
	Если Показатели <> Неопределено Тогда
		Показатели.ВремяОжиданияНовыхЗаданий = Показатели.ВремяОжиданияНовыхЗаданий
			+ (ТекущаяУниверсальнаяДатаВМиллисекундах() - НачалоОжидания);
	КонецЕсли;
	Если Контекст.КоличествоСекундОжиданияДоПоискаНовогоЗадания < 1 Тогда
		Контекст.КоличествоСекундОжиданияДоПоискаНовогоЗадания =
			Контекст.КоличествоСекундОжиданияДоПоискаНовогоЗадания + 0.010;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Для функции ПродолжитьОжиданиеНовогоЗадания.
Функция СеансСуществует(ОписаниеСеанса)
	
	Если ЗначениеЗаполнено(ОписаниеСеанса.ИдентификаторФоновогоЗадания) Тогда
		ФоновоеЗадание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(
			ОписаниеСеанса.ИдентификаторФоновогоЗадания);
		
		Возврат ФоновоеЗадание <> Неопределено
		      И ФоновоеЗадание.Состояние = СостояниеФоновогоЗадания.Активно;
	КонецЕсли;
	
	ОсновнойСеансНайден = Ложь;
	Сеансы = ПолучитьСеансыИнформационнойБазы();
	
	Для Каждого Сеанс Из Сеансы Цикл
		
		Если Сеанс.НачалоСеанса = ОписаниеСеанса.НачалоСеанса
		   И Сеанс.НомерСеанса  = ОписаниеСеанса.НомерСеанса Тогда
			
			ОсновнойСеансНайден = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ОсновнойСеансНайден;
	
КонецФункции

// Для процедуры ВыполнитьОбновлениеДоступаСпискаВФоне.
Процедура ЗаписатьРезультатОбновленияДоступаСпискаВФоне(Результат, ИсходныеПараметры, Контекст)
	
	НачатьТранзакцию();
	Попытка
		Контекст.Блокировка.Заблокировать();
		Запрос = Контекст.Запрос; // Запрос - 
		Выборка = Запрос.Выполнить().Выбрать();
		
		Если Выборка.Следующий()
		   И XMLСтрока(Выборка.Параметры) = XMLСтрока(ИсходныеПараметры) Тогда
			
			Контекст.ЗаписьНабора.Параметры = ИсходныеПараметры;
			Контекст.ЗаписьНабора.Результат = Новый ХранилищеЗначения(Результат);
			Контекст.ЗаписьНабора.ДатаИзмененияЗаписиРегистра = ТекущаяДатаСеанса();
			НаборЗаписей = Контекст.НаборЗаписей; // РегистрСведенийНаборЗаписей - 
			НаборЗаписей.Записать();
		КонецЕсли;
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Для процедуры ВыполнитьОбновлениеДоступаСпискаВФоне.
Функция ПоказателиОбновленияУправляющегоПотока(Контекст)
	
	Если Не РегистрироватьПоказателиОбновленияДоступа() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Показатели = Новый Структура;
	
	// Переменные.
	Показатели.Вставить("НачалоРаботыВМиллисекундах", ТекущаяУниверсальнаяДатаВМиллисекундах());
	Показатели.Вставить("НачалоВыдачиЗадания");
	
	Если Контекст.ОбновлениеВЭтомСеансе Тогда
		ДобавитьПоказателиВыполненияЗаданий(Показатели);
	Иначе
		Показатели.Вставить("ВремяОжиданийСвободногоПотока", 0);
		
		Показатели.Вставить("КоличествоВыданныхЗаданий", 0);
		Показатели.Вставить("ВремяВыдачиЗаданий", 0);
		Показатели.Вставить("МинимальноеВремяВыдачиЗадания", 0);
		Показатели.Вставить("МаксимальноеВремяВыдачиЗадания", 0);
		
		Показатели.Вставить("ВремяОбработкиРезультатовЗаданий", 0);
		Показатели.Вставить("МинимальноеВремяОбработкиРезультатаЗадания", 0);
		Показатели.Вставить("МаксимальноеВремяОбработкиРезультатаЗадания", 0);
		
		Показатели.Вставить("КоличествоПотоковСПревышениемВремениВыполнения", 0);
		Показатели.Вставить("КоличествоПотоковСНештатнымЗавершением", 0);
		
		// Переменные.
		Показатели.Вставить("НачалоОбработкиЗадания", 0);
	КонецЕсли;
	
	Возврат Показатели;
	
КонецФункции

// Для процедуры ВыполнитьОбновлениеДоступаСпискаВФоне.
Функция ПоказателиОбновленияИсполняющегоПотока()
	
	Если Не РегистрироватьПоказателиОбновленияДоступа() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Показатели = Новый Структура;
	
	Показатели.Вставить("НачалоРаботыВМиллисекундах", ТекущаяУниверсальнаяДатаВМиллисекундах());
	Показатели.Вставить("КоличествоОжиданийНовыхЗаданий", 0);
	Показатели.Вставить("ВремяОжиданияНовыхЗаданий", 0);
	
	ДобавитьПоказателиВыполненияЗаданий(Показатели);
	
	Возврат Показатели;
	
КонецФункции

// Для функций ПоказателиОбновленияУправляющегоПотока, ПоказателиОбновленияИсполняющегоПотока.
Процедура ДобавитьПоказателиВыполненияЗаданий(Показатели)
	
	// Переменные.
	Показатели.Вставить("ЗаданиеСПолучениемПорций", Истина);
	Показатели.Вставить("НачалоПервойПопыткиВыполненияЗадания", 0);
	Показатели.Вставить("НачалоВыполненияЗадания", 0);
	
	// Общие показатели.
	Показатели.Вставить("КоличествоЗаданийСПовторамиИзЗаОшибок", 0);
	Показатели.Вставить("ВремяВыполненияЗаданийСПовторамиИзЗаОшибок", 0);
	Показатели.Вставить("КоличествоПовторовЗаданийИзЗаОшибок", 0);
	Показатели.Вставить("МаксимальноеКоличествоПовторовЗаданияПриОшибке", 0);
	Показатели.Вставить("ТекстОшибокПриПопыткахПовтора", "");
	
	// Получение порций или сразу обработка маленькой порции.
	Показатели.Вставить("КоличествоВыполненныхЗаданийСПолучениемПорций", 0);
	Показатели.Вставить("ВремяВыполненияЗаданийСПолучениемПорций", 0);
	Показатели.Вставить("МинимальноеВремяВыполненияЗаданийСПолучениемПорций", 0);
	Показатели.Вставить("МаксимальноеВремяВыполненияЗаданийСПолучениемПорций", 0);
	
	// Только обработки порции.
	Показатели.Вставить("КоличествоВыполненныхЗаданийБезПолученияПорций", 0);
	Показатели.Вставить("ВремяВыполненияЗаданийБезПолученияПорций", 0);
	Показатели.Вставить("МинимальноеВремяВыполненияЗаданийБезПолученияПорций", 0);
	Показатели.Вставить("МаксимальноеВремяВыполненияЗаданийБезПолученияПорций", 0);
	
КонецПроцедуры

// Для функции ЗапуститьОбновлениеДоступаСписка.
Процедура СнятьПоказателиВыдачиЗаданий(Показатели)
	
	ВремяВыдачиЗадания = ТекущаяУниверсальнаяДатаВМиллисекундах() - Показатели.НачалоВыдачиЗадания;
	
	Показатели.КоличествоВыданныхЗаданий = Показатели.КоличествоВыданныхЗаданий + 1;
	Показатели.ВремяВыдачиЗаданий = Показатели.ВремяВыдачиЗаданий + ВремяВыдачиЗадания;
	
	Если Показатели.МинимальноеВремяВыдачиЗадания = 0 Тогда
		Показатели.МинимальноеВремяВыдачиЗадания = ВремяВыдачиЗадания;
	КонецЕсли;
	Если ВремяВыдачиЗадания < Показатели.МинимальноеВремяВыдачиЗадания Тогда
		Показатели.МинимальноеВремяВыдачиЗадания = ВремяВыдачиЗадания;
	КонецЕсли;
	
	Если ВремяВыдачиЗадания > Показатели.МаксимальноеВремяВыдачиЗадания Тогда
		Показатели.МаксимальноеВремяВыдачиЗадания = ВремяВыдачиЗадания;
	КонецЕсли;
	
КонецПроцедуры

// Для функции ЗапуститьОбновлениеДоступаСписка.
Процедура СнятьПоказателиОбработкиРезультатаЗадания(Показатели)
	
	ВремяОбработкиЗадания = ТекущаяУниверсальнаяДатаВМиллисекундах() - Показатели.НачалоОбработкиЗадания;
	
	Показатели.ВремяОбработкиРезультатовЗаданий =
		Показатели.ВремяОбработкиРезультатовЗаданий + ВремяОбработкиЗадания;
	
	Если Показатели.МинимальноеВремяОбработкиРезультатаЗадания = 0 Тогда
		Показатели.МинимальноеВремяОбработкиРезультатаЗадания = ВремяОбработкиЗадания;
	КонецЕсли;
	Если ВремяОбработкиЗадания < Показатели.МинимальноеВремяОбработкиРезультатаЗадания Тогда
		Показатели.МинимальноеВремяОбработкиРезультатаЗадания = ВремяОбработкиЗадания;
	КонецЕсли;
	
	Если ВремяОбработкиЗадания > Показатели.МаксимальноеВремяОбработкиРезультатаЗадания Тогда
		Показатели.МаксимальноеВремяОбработкиРезультатаЗадания = ВремяОбработкиЗадания;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ВыполнитьОбновлениеДоступаСпискаВФоне.
Процедура СнятьПоказателиВыполненияЗадания(Показатели)
	
	ВремяВыполненияЗадания = ТекущаяУниверсальнаяДатаВМиллисекундах() - Показатели.НачалоВыполненияЗадания;
	
	Если Показатели.ЗаданиеСПолучениемПорций Тогда
		Показатели.КоличествоВыполненныхЗаданийСПолучениемПорций =
			Показатели.КоличествоВыполненныхЗаданийСПолучениемПорций + 1;
		
		Показатели.ВремяВыполненияЗаданийСПолучениемПорций =
			Показатели.ВремяВыполненияЗаданийСПолучениемПорций + ВремяВыполненияЗадания;
		
		Если Показатели.МинимальноеВремяВыполненияЗаданийСПолучениемПорций = 0 Тогда
			Показатели.МинимальноеВремяВыполненияЗаданийСПолучениемПорций = ВремяВыполненияЗадания;
		КонецЕсли;
		Если ВремяВыполненияЗадания < Показатели.МинимальноеВремяВыполненияЗаданийСПолучениемПорций Тогда
			Показатели.МинимальноеВремяВыполненияЗаданийСПолучениемПорций = ВремяВыполненияЗадания;
		КонецЕсли;
		
		Если ВремяВыполненияЗадания > Показатели.МаксимальноеВремяВыполненияЗаданийСПолучениемПорций Тогда
			Показатели.МаксимальноеВремяВыполненияЗаданийСПолучениемПорций = ВремяВыполненияЗадания;
		КонецЕсли;
	Иначе
		Показатели.КоличествоВыполненныхЗаданийБезПолученияПорций =
			Показатели.КоличествоВыполненныхЗаданийБезПолученияПорций + 1;
		
		Показатели.ВремяВыполненияЗаданийБезПолученияПорций =
			Показатели.ВремяВыполненияЗаданийБезПолученияПорций + ВремяВыполненияЗадания;
		
		Если Показатели.МинимальноеВремяВыполненияЗаданийБезПолученияПорций = 0 Тогда
			Показатели.МинимальноеВремяВыполненияЗаданийБезПолученияПорций = ВремяВыполненияЗадания;
		КонецЕсли;
		Если ВремяВыполненияЗадания < Показатели.МинимальноеВремяВыполненияЗаданийБезПолученияПорций Тогда
			Показатели.МинимальноеВремяВыполненияЗаданийБезПолученияПорций = ВремяВыполненияЗадания;
		КонецЕсли;
		
		Если ВремяВыполненияЗадания > Показатели.МаксимальноеВремяВыполненияЗаданийБезПолученияПорций Тогда
			Показатели.МаксимальноеВремяВыполненияЗаданийБезПолученияПорций = ВремяВыполненияЗадания;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ВыполнитьОбновлениеДоступаСпискаВФоне.
Процедура СнятьПоказателиОшибокВыполненияЗадания(Показатели, ТекстОшибок, КоличествоОшибок);
	
	Если КоличествоОшибок = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Показатели.КоличествоЗаданийСПовторамиИзЗаОшибок = Показатели.КоличествоЗаданийСПовторамиИзЗаОшибок + 1;
	
	Показатели.ВремяВыполненияЗаданийСПовторамиИзЗаОшибок = Показатели.ВремяВыполненияЗаданийСПовторамиИзЗаОшибок
		+ (ТекущаяУниверсальнаяДатаВМиллисекундах() - Показатели.НачалоПервойПопыткиВыполненияЗадания);
	
	Показатели.КоличествоПовторовЗаданийИзЗаОшибок =
		Показатели.КоличествоПовторовЗаданийИзЗаОшибок + КоличествоОшибок;
	
	Если КоличествоОшибок > Показатели.МаксимальноеКоличествоПовторовЗаданияПриОшибке Тогда
		Показатели.МаксимальноеКоличествоПовторовЗаданияПриОшибке = КоличествоОшибок;
	КонецЕсли;
	
	ДобавитьТекстОшибкиЗавершения(Показатели.ТекстОшибокПриПопыткахПовтора, ТекстОшибок);
	
КонецПроцедуры

// Для процедур ЗарегистрироватьПоказателиОбновленияОсновногоПотока,
// ЗарегистрироватьПоказателиОбновленияИсполняющегоПотока,
// ДобавитьЗначенияПоказателейРаботыСеанса,
// ДобавитьЗначенияПоказателейВыполненияЗаданий.
//
Функция ФорматСекунд(ЧислоСекунд)
	
	Если ЧислоСекунд = 0 Тогда
		Возврат СтрЗаменить(Формат(1.111), "1", "0");
	КонецЕсли;
	
	Возврат Формат(ЧислоСекунд, "ЧДЦ=3; ЧГ=");
	
КонецФункции

// Для процедур ЗарегистрироватьПоказателиОбновленияОсновногоПотока,
// ЗарегистрироватьПоказателиОбновленияИсполняющегоПотока,
// ДобавитьЗначенияПоказателейВыполненияЗаданий.
//
Функция ФорматКоличества(ЧислоКоличества)
	
	Возврат Формат(ЧислоКоличества, "ЧН=0; ЧГ=");
	
КонецФункции

// Для процедуры ЗавершитьОбновлениеДоступа.
Процедура ЗарегистрироватьПоказателиОбновленияОсновногоПотока(Контекст)
	
	Показатели = Контекст.Показатели;
	
	Если Контекст.ОбновлениеВЭтомСеансе Тогда
		Комментарий = НСтр("ru = 'Завершен сеанс обновления доступа.'");
		ДобавитьЗначенияПоказателейРаботыСеанса(Комментарий, Показатели, Контекст.ОписаниеОсновногоСеанса);
		ДобавитьЗначенияПоказателейВыполненияЗаданий(Комментарий, Показатели);
	Иначе
		ВремяОжиданийСвободногоПотока = Показатели.ВремяОжиданийСвободногоПотока / 1000;
		
		ВремяВыдачиЗаданий             = Показатели.ВремяВыдачиЗаданий / 1000;
		МинимальноеВремяВыдачиЗадания  = Показатели.МинимальноеВремяВыдачиЗадания / 1000;
		МаксимальноеВремяВыдачиЗадания = Показатели.МаксимальноеВремяВыдачиЗадания / 1000;
		
		ВремяОбработкиРезультатовЗаданий            = Показатели.ВремяОбработкиРезультатовЗаданий / 1000;
		МинимальноеВремяОбработкиРезультатаЗадания  = Показатели.МинимальноеВремяОбработкиРезультатаЗадания / 1000;
		МаксимальноеВремяОбработкиРезультатаЗадания = Показатели.МаксимальноеВремяОбработкиРезультатаЗадания / 1000;
		
		Комментарий = НСтр("ru = 'Завершен сеанс управляющего потока обновления доступа.'");
		ДобавитьЗначенияПоказателейРаботыСеанса(Комментарий, Показатели, Контекст.ОписаниеОсновногоСеанса);
		
		Комментарий = Комментарий + Символы.ПС + Символы.ПС + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Время ожиданий свободного потока: %1 сек
			           |
			           |Количество выданных заданий: %2
			           |Время выдачи заданий: %3 сек
			           |Минимальное время выдачи заданий: %4 сек
			           |Максимальное время выдачи заданий: %5 сек'"),
			ФорматСекунд(ВремяОжиданийСвободногоПотока),
			ФорматКоличества(Показатели.КоличествоВыданныхЗаданий),
			ФорматСекунд(ВремяВыдачиЗаданий),
			ФорматСекунд(МинимальноеВремяВыдачиЗадания),
			ФорматСекунд(МаксимальноеВремяВыдачиЗадания));
		
		Комментарий = Комментарий + Символы.ПС + Символы.ПС + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Время обработки результатов заданий: %1 сек
			           |Минимальное время обработки результатов заданий: %2 сек
			           |Максимальное время обработки результатов заданий: %3 сек
			           |
			           |Количество потоков с превышением времени выполнения: %4
			           |Количество потоков с нештатным завершением: %5'"),
			ФорматСекунд(ВремяОбработкиРезультатовЗаданий),
			ФорматСекунд(МинимальноеВремяОбработкиРезультатаЗадания),
			ФорматСекунд(МаксимальноеВремяОбработкиРезультатаЗадания),
			ФорматКоличества(Показатели.КоличествоПотоковСПревышениемВремениВыполнения),
			ФорматКоличества(Показатели.КоличествоПотоковСНештатнымЗавершением));
	КонецЕсли;
	Данные = Контекст.ОписаниеОсновногоСеанса.Идентификатор;
	
	ЗаписьЖурналаРегистрации(
		НСтр("ru = 'Управление доступом.Показатели.Обновление доступа'",
		     ОбщегоНазначения.КодОсновногоЯзыка()),
		УровеньЖурналаРегистрации.Информация, , Данные, Комментарий);
		
КонецПроцедуры

// Для процедуры ВыполнитьОбновлениеДоступаСпискаВФоне.
Процедура ЗарегистрироватьПоказателиОбновленияИсполняющегоПотока(Контекст)
	
	Показатели = Контекст.Показатели;
	
	ВремяОжиданияНовыхЗаданий = Показатели.ВремяОжиданияНовыхЗаданий / 1000;
	
	ФорматЧисла = "ЧН=0; ЧГ=";
	Комментарий = НСтр("ru = 'Завершен сеанс исполняющего потока обновления доступа.'");
	ДобавитьЗначенияПоказателейРаботыСеанса(Комментарий, Показатели, Контекст.ТекущийСеанс);
	
	Комментарий = Комментарий + Символы.ПС + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Номер сеанса управляющего потока: %1
		           |Начало сеанса управляющего потока: %2
		           |
		           |Количество ожиданий новых заданий: %3
		           |Время ожидания новых заданий: %4 сек'"),
		Контекст.ОписаниеРодительскогоСеанса.НомерСеанса,
		Контекст.ОписаниеРодительскогоСеанса.НачалоСеанса,
		ФорматКоличества(Показатели.КоличествоОжиданийНовыхЗаданий),
		ФорматСекунд(ВремяОжиданияНовыхЗаданий));
	
	ДобавитьЗначенияПоказателейВыполненияЗаданий(Комментарий, Показатели);
	Данные = Контекст.ОписаниеРодительскогоСеанса.Идентификатор;
	
	ЗаписьЖурналаРегистрации(
		НСтр("ru = 'Управление доступом.Показатели.Обновление доступа'",
		     ОбщегоНазначения.КодОсновногоЯзыка()),
		УровеньЖурналаРегистрации.Информация, , Данные, Комментарий);
		
КонецПроцедуры

// Для процедур ЗарегистрироватьПоказателиОбновленияУправляющегоПотока и
// ЗарегистрироватьПоказателиОбновленияИсполняющегоПотока.
//
Процедура ДобавитьЗначенияПоказателейРаботыСеанса(Комментарий, Показатели, ОписаниеСеанса)
	
	ВремяРаботы = (ТекущаяУниверсальнаяДатаВМиллисекундах()
		- Показатели.НачалоРаботыВМиллисекундах) / 1000;
	
	ФорматЧисла = "ЧН=0; ЧГ=";
	Комментарий = Комментарий + Символы.ПС + Символы.ПС + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Номер сеанса: %1
		           |Начало сеанса: %2
		           |Время работы: %3 сек'"),
		ОписаниеСеанса.НомерСеанса,
		ОписаниеСеанса.НачалоСеанса,
		ФорматСекунд(ВремяРаботы));
	
КонецПроцедуры

// Для процедур ЗарегистрироватьПоказателиОбновленияУправляющегоПотока и
// ЗарегистрироватьПоказателиОбновленияИсполняющегоПотока.
//
Процедура ДобавитьЗначенияПоказателейВыполненияЗаданий(Комментарий, Показатели)
	
	ВремяВыполненияЗаданийСПолучениемПорций              = Показатели.ВремяВыполненияЗаданийСПолучениемПорций / 1000;
	МаксимальноеВремяВыполненияЗаданийСПолучениемПорций  = Показатели.МаксимальноеВремяВыполненияЗаданийСПолучениемПорций / 1000;
	МинимальноеВремяВыполненияЗаданийСПолучениемПорций   = Показатели.МинимальноеВремяВыполненияЗаданийСПолучениемПорций / 1000;
	
	ВремяВыполненияЗаданийБезПолученияПорций             = Показатели.ВремяВыполненияЗаданийБезПолученияПорций / 1000;
	МаксимальноеВремяВыполненияЗаданийБезПолученияПорций = Показатели.МаксимальноеВремяВыполненияЗаданийБезПолученияПорций / 1000;
	МинимальноеВремяВыполненияЗаданийБезПолученияПорций  = Показатели.МинимальноеВремяВыполненияЗаданийБезПолученияПорций / 1000;
	
	КоличествоВыполненныхЗаданий = Показатели.КоличествоВыполненныхЗаданийСПолучениемПорций
		+ Показатели.КоличествоВыполненныхЗаданийБезПолученияПорций;
	
	ВремяВыполненияЗаданий = ВремяВыполненияЗаданийСПолучениемПорций + ВремяВыполненияЗаданийБезПолученияПорций;
	ВремяВыполненияЗаданийСПовторамиИзЗаОшибок = Показатели.ВремяВыполненияЗаданийСПовторамиИзЗаОшибок / 1000;
	
	Комментарий = Комментарий + Символы.ПС + Символы.ПС + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Количество выполненных заданий: %1
		           |Время выполнения заданий: %2 сек
		           |
		           |Количество заданий с повторами из-за ошибок: %3
		           |Время выполнения заданий с повторами из-за ошибок: %4 сек
		           |Количество повторов заданий из-за ошибок: %5
		           |Максимум повторов отдельного задания из-за ошибок: %6'"),
		ФорматКоличества(КоличествоВыполненныхЗаданий),
		ФорматСекунд(ВремяВыполненияЗаданий),
		ФорматКоличества(Показатели.КоличествоЗаданийСПовторамиИзЗаОшибок),
		ФорматСекунд(ВремяВыполненияЗаданийСПовторамиИзЗаОшибок),
		ФорматКоличества(Показатели.КоличествоПовторовЗаданийИзЗаОшибок),
		ФорматКоличества(Показатели.МаксимальноеКоличествоПовторовЗаданияПриОшибке));
	
	Комментарий = Комментарий + Символы.ПС + Символы.ПС + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Задания получения порций и/или обработки маленькой порции:
		           |- количество выполненных заданий: %1
		           |- время выполнения заданий: %2 сек
		           |- минимальное время выполнения задания: %3 сек
		           |- максимальное время выполнения задания: %4 сек
		           |
		           |Задания обработки порций:
		           |- количество выполненных заданий: %5
		           |- время выполнения заданий: %6 сек
		           |- минимальное время выполнения задания: %7 сек
		           |- максимальное время выполнения задания: %8 сек'"),
		ФорматКоличества(Показатели.КоличествоВыполненныхЗаданийСПолучениемПорций),
		ФорматСекунд(ВремяВыполненияЗаданийСПолучениемПорций),
		ФорматСекунд(МинимальноеВремяВыполненияЗаданийСПолучениемПорций),
		ФорматСекунд(МаксимальноеВремяВыполненияЗаданийСПолучениемПорций),
		ФорматКоличества(Показатели.КоличествоВыполненныхЗаданийБезПолученияПорций),
		ФорматСекунд(ВремяВыполненияЗаданийБезПолученияПорций),
		ФорматСекунд(МинимальноеВремяВыполненияЗаданийБезПолученияПорций),
		ФорматСекунд(МаксимальноеВремяВыполненияЗаданийБезПолученияПорций));
	
	Если ЗначениеЗаполнено(Показатели.ТекстОшибокПриПопыткахПовтора) Тогда
		Комментарий = Комментарий + Символы.ПС + Символы.ПС
			+ НСтр("ru = 'Тексты ошибок при попытках повторного выполнения:'")
			+ Символы.ПС + Символы.ПС + Показатели.ТекстОшибокПриПопыткахПовтора;
	КонецЕсли;
	
КонецПроцедуры

// Для процедур ОбновлениеДоступаНаУровнеЗаписей, ОбработатьРезультатЗадания, ЗарегистрироватьОшибкуОбновленияДоступа.
Процедура ДобавитьТекстОшибкиЗавершения(ТекстОшибкиЗавершения, ТекстОшибки)
	
	Если Не ЗначениеЗаполнено(ТекстОшибки) Тогда
		Возврат;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ТекстОшибкиЗавершения) Тогда
		Если СтрНайти(ТекстОшибкиЗавершения, ТекстОшибки) > 0 Тогда
			Возврат;
		КонецЕсли;
		ТекстОшибкиЗавершения = ТекстОшибкиЗавершения + Символы.ПС + Символы.ПС;
	КонецЕсли;
	
	ТекстОшибкиЗавершения = ТекстОшибкиЗавершения + ТекстОшибки;
	
КонецПроцедуры

// Для процедур ОбновитьСвойстваФоновогоЗадания, ОтменитьФоновоеЗаданиеПотока, ОбработатьВыполненныеЗадания,
// УдалитьОстановленныеПотоки, ВыполнитьОбновлениеДоступаСпискаВФоне.
//
Функция ТекстОшибкиОбновленияСКонтекстом(ИнформацияОбОшибке, ОбщиеПараметрыОбновления, УстранимаяОшибка = Ложь)
	
	Если ТипЗнч(ИнформацияОбОшибке) = Тип("ИнформацияОбОшибке") Тогда
		ПредставлениеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
	Иначе
		ПредставлениеОшибки = Строка(ИнформацияОбОшибке);
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ПредставлениеОшибки) Тогда
		Возврат "";
	КонецЕсли;
	
	Если ОбщиеПараметрыОбновления = Неопределено Тогда
		ТекстОшибки = ПредставлениеОшибки;
		
	ИначеЕсли Не ОбщиеПараметрыОбновления.ЭтоОбновлениеПрав Тогда
		
		Если ОбщиеПараметрыОбновления.ДляВнешнихПользователей Тогда
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'При обновлении ключей доступа к элементам данных списка
				           |""%1"" (для внешних пользователей)
				           |возникла ошибка:
				           |%2'"),
				Строка(ОбщиеПараметрыОбновления.ИдентификаторСписка),
				ПредставлениеОшибки);
		Иначе
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'При обновлении ключей доступа к элементам данных списка
				           |""%1"" (для пользователей)
				           |возникла ошибка:
				           |%2'"),
				Строка(ОбщиеПараметрыОбновления.ИдентификаторСписка),
				ПредставлениеОшибки);
		КонецЕсли;
		
	Иначе // ОбновлениеКлючейДоступаПользователей.
		
		Если ОбщиеПараметрыОбновления.ДляВнешнихПользователей Тогда
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'При обновлении ключей доступа внешних пользователей списка
				           |""%1""
				           |возникла ошибка:
				           |%2'"),
				Строка(ОбщиеПараметрыОбновления.ИдентификаторСписка),
				ПредставлениеОшибки);
		Иначе
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'При обновлении ключей доступа пользователей списка
				           |""%1""
				           |возникла ошибка:
				           |%2'"),
				Строка(ОбщиеПараметрыОбновления.ИдентификаторСписка),
				ПредставлениеОшибки);
		КонецЕсли;
	КонецЕсли;
	
	Если УстранимаяОшибка Тогда
		ТекстОшибки = НСтр("ru = 'Возникла устранимая ошибка (обновление продолжается автоматически).'")
			+ Символы.ПС + ТекстОшибки;
	КонецЕсли;
	
	Возврат ТекстОшибки;
	
КонецФункции

// Для процедур ОбновлениеДоступаНаУровнеЗаписей, ЗавершитьФоновыеЗадания,
// ОбработатьРезультатВыполненногоЗадания, ОбновитьСвойстваФоновогоЗадания,
// ВыполнитьОбновлениеДоступаСпискаВФоне.
//
Процедура ЗарегистрироватьОшибкуОбновленияДоступа(ТекстОшибки, Контекст)
	
	Если Контекст.Свойство("ОписаниеРодительскогоСеанса") Тогда
		Данные = Контекст.ОписаниеРодительскогоСеанса.Идентификатор;
	Иначе
		Данные = Контекст.ОписаниеОсновногоСеанса.Идентификатор;
	КонецЕсли;
	
	ЗаписьЖурналаРегистрации(
		НСтр("ru = 'Управление доступом.Обновление доступа на уровне записей'",
			ОбщегоНазначения.КодОсновногоЯзыка()),
		УровеньЖурналаРегистрации.Ошибка, , Данные, ТекстОшибки);
	
КонецПроцедуры

// Для функции ЗапуститьОбновлениеДоступаСписка и процедуры ВыполнитьОбновлениеДоступаСпискаВФоне.
Процедура ВыполнитьОбновлениеДоступаСпискаСПопыткамиПовтора(ОбщиеПараметрыОбновления, Контекст)
	
	Показатели = Контекст.Показатели;
	
	Если Показатели <> Неопределено Тогда
		Показатели.НачалоПервойПопыткиВыполненияЗадания = ТекущаяУниверсальнаяДатаВМиллисекундах();
	КонецЕсли;
	
	ПопыткаВыполнения = 1;
	ОшибкиПопытокВыполнения = Новый Массив;
	Пока Истина Цикл
		ТекстОшибкиТекущейПопытки = "";
		Если Показатели <> Неопределено Тогда
			Показатели.ЗаданиеСПолучениемПорций = Не ОбщиеПараметрыОбновления.Свойство("ПорцияИзНабора");
			Показатели.НачалоВыполненияЗадания = ТекущаяУниверсальнаяДатаВМиллисекундах();
		КонецЕсли;
		Попытка
			ВыполнитьОбновлениеДоступаСписка(ОбщиеПараметрыОбновления);
		Исключение
			ТекстОшибкиТекущейПопытки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		КонецПопытки;
		Если Показатели <> Неопределено И Не ЗначениеЗаполнено(ТекстОшибкиТекущейПопытки) Тогда
			СнятьПоказателиВыполненияЗадания(Показатели);
		КонецЕсли;
		Если ЗначениеЗаполнено(ТекстОшибкиТекущейПопытки) Тогда
			ВремяОшибкиТекущейПопытки = Формат(ТекущаяДатаСеанса(), "ДЛФ=DT");
			ОшибкиПопытокВыполнения.Добавить(ВремяОшибкиТекущейПопытки + " " + ТекстОшибкиТекущейПопытки);
			ПопыткаВыполнения = ПопыткаВыполнения + 1;
			Если ПопыткаВыполнения < 9 Тогда
				Для Счетчик = 1 По ПопыткаВыполнения Цикл
					Если ОбновлениеДоступаОтменено() Тогда
						Прервать;
					КонецЕсли;
					Если Контекст.ТекущееФоновоеЗадание <> Неопределено Тогда
						Контекст.ТекущееФоновоеЗадание.ОжидатьЗавершенияВыполнения(1);
					Иначе
						ГраницаОжидания = ТекущаяУниверсальнаяДатаВМиллисекундах() + 1000;
						Пока ГраницаОжидания > ТекущаяУниверсальнаяДатаВМиллисекундах() Цикл
							Продолжить;
						КонецЦикла;
					КонецЕсли;
				КонецЦикла;
				Если Не ОбновлениеДоступаОтменено() Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		ТекстОшибки = СтрСоединить(ОшибкиПопытокВыполнения, Символы.ПС + "---" + Символы.ПС);
		ТекстОшибки = ТекстОшибкиОбновленияСКонтекстом(ТекстОшибки, ОбщиеПараметрыОбновления);
		
		Если ЗначениеЗаполнено(ТекстОшибкиТекущейПопытки) Тогда
			ОбщиеПараметрыОбновления.Вставить("ТекстОшибкиЗавершения", "");
			ДобавитьТекстОшибкиЗавершения(ОбщиеПараметрыОбновления.ТекстОшибкиЗавершения, ТекстОшибки);
		КонецЕсли;
		Если Показатели <> Неопределено Тогда
			СнятьПоказателиОшибокВыполненияЗадания(Показатели, ТекстОшибки, ОшибкиПопытокВыполнения.Количество());
		КонецЕсли;
		Прервать;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ВыполнитьОбновлениеДоступаСпискаСПопыткамиПовтора.
Процедура ВыполнитьОбновлениеДоступаСписка(ОбщиеПараметрыОбновления)
	
	Если Не ОбщиеПараметрыОбновления.Свойство("Кэш") Тогда
		ОбщиеПараметрыОбновления.Вставить("Кэш", Новый Структура);
	КонецЕсли;
	
	Если ОбщиеПараметрыОбновления.ИдентификаторСписка = Неопределено Тогда
		ОбъектМетаданных = Null;
	ИначеЕсли ОбщиеПараметрыОбновления.Свойство("Кэш")
	        И ОбщиеПараметрыОбновления.Кэш.Свойство("ОбъектыМетаданныхПоИдентификаторам") Тогда
		
		ОбъектМетаданных = ОбщиеПараметрыОбновления.Кэш.ОбъектыМетаданныхПоИдентификаторам.Получить(
			ОбщиеПараметрыОбновления.ИдентификаторСписка);
	Иначе
		ОбъектМетаданных = ОбщегоНазначения.ОбъектМетаданныхПоИдентификатору(
			ОбщиеПараметрыОбновления.ИдентификаторСписка, Ложь);
	КонецЕсли;
	
	Если ОбъектМетаданных = Неопределено Тогда
		// Если расширение конфигурации отключено, тогда обновление невозможно,
		// но нельзя очищать регистрацию к обновлению.
		Возврат;
	КонецЕсли;
	
	ЭтоОбновлениеПрав = ОбщиеПараметрыОбновления.ЭтоОбновлениеПрав;
	
	Если Не ОбщиеПараметрыОбновления.ДляВнешнихПользователей
	   И ОбщиеПараметрыОбновления.ИдентификаторСписка
	       = Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка() Тогда
		УдалитьОбъектыНедопустимыхТиповВРегистреКлючиДоступаКОбъектам();
	КонецЕсли;
	
	ПараметрыОбновления = ПараметрыОбновления(ОбщиеПараметрыОбновления, ОбъектМетаданных);
	
	// Обработка ранее подготовленной порции для обработки.
	Если ОбщиеПараметрыОбновления.Свойство("ПорцияИзНабора") Тогда
		ПорцияИзНабора = ОбщиеПараметрыОбновления.ПорцияИзНабора;
		ЭлементыПорции = ПорцияИзНабора.Элементы.Получить();
		ПараметрыОбновления.Вставить("ПоследнийОбновленныйЭлемент",
			ПорцияИзНабора.ПоследнийЭлементПорции);
		
		ОбновитьПорциюЭлементов(ЭлементыПорции, ПараметрыОбновления);
		
		ОбщиеПараметрыОбновления.Вставить("НовыйПоследнийОбновленныйЭлемент",
			ПараметрыОбновления.НовыйПоследнийОбновленныйЭлемент);
		
		Если ЭлементыПорции <> Неопределено Тогда
			ОбщиеПараметрыОбновления.ОбработкаЗавершена = Ложь;
			ВыбраныВсеЭлементы = ПорцияИзНабора.ПоследнийЭлементПорции.КлючДанных = Null;
			ОбщиеПараметрыОбновления.Вставить("НаборПорций", НаборПорцийЭлементов(
				ПараметрыОбновления, ЭлементыПорции, ВыбраныВсеЭлементы));
		КонецЕсли;
		Возврат;
	КонецЕсли;
	
	// Подготовка плана обработки элементов данных.
	ПодготовкаЗавершена = Ложь;
	ПараметрыОбновления.Вставить("ПерезапускОбновления", Ложь);
	
	Пока Не ПодготовкаЗавершена Цикл
		ПодготовкаЗавершена = Истина;
		ПараметрыОбновления.Вставить("ЕстьЗадания", Истина);
		ПараметрыОбновления.Вставить("ТочечноеЗадание", Неопределено);
		ПараметрыОбновления.Вставить("ПоследнийОбновленныйЭлемент", НачальныйЭлемент(ПараметрыОбновления));
		ПодготовитьПланОбновления(ПараметрыОбновления, ПодготовкаЗавершена);
	КонецЦикла;
	
	Если Не ПараметрыОбновления.ЕстьЗадания Тогда
		ОбщиеПараметрыОбновления.Вставить("НетЗаданий");
		Возврат;
	КонецЕсли;
	
	Если ПараметрыОбновления.ТочечноеЗадание <> Неопределено Тогда
		ВыбраныВсеЭлементы = Ложь;
		Элементы = ЭлементыТочечногоЗаданияДляОбновления(ПараметрыОбновления,
			КоличествоЭлементовВЗапросе(ЭтоОбновлениеПрав), ВыбраныВсеЭлементы);
		
		Если Элементы <> Неопределено Тогда
			МаксимумМиллисекунд = МинимальноеКоличествоСекундВыполненияТочечногоЗадания() * 1000;
			Если ПараметрыОбновления.ГраницаВремениОбработки - ТекущаяУниверсальнаяДатаВМиллисекундах() < МаксимумМиллисекунд Тогда
				ПараметрыОбновления.ГраницаВремениОбработки = ТекущаяУниверсальнаяДатаВМиллисекундах() + МаксимумМиллисекунд;
			КонецЕсли;
			ОбновитьПорциюЭлементов(Элементы, ПараметрыОбновления, Истина);
		КонецЕсли;
		Если Элементы <> Неопределено Или Не ВыбраныВсеЭлементы Тогда
			ПерезапуститьОбновлениеПриНезавершенномТочечномОбновлении(ПараметрыОбновления);
		КонецЕсли;
	КонецЕсли;
	
	УточнитьПоследнийОбновленныйЭлемент(ПараметрыОбновления);
	
	Если ПараметрыОбновления.ПоследнийОбновленныйЭлемент.ВидКлючаДанных = "НетДанных" Тогда
		ПараметрыОбновления.ПоследнийОбновленныйЭлемент.КлючДанных = Null;
		ЗаписатьПоследнийОбновленныйЭлемент(ОбщиеПараметрыОбновления,
			ПараметрыОбновления.ПоследнийОбновленныйЭлемент);
		ОбщиеПараметрыОбновления.Вставить("НетЗаданий");
		Возврат;
	КонецЕсли;
	
	Если ПараметрыОбновления.ТочечноеЗадание <> Неопределено Тогда
		ПараметрыОбновления.ПоследнийОбновленныйЭлемент.Вставить("ОчиститьТочечноеЗадание");
		ЗаписатьПоследнийОбновленныйЭлемент(ОбщиеПараметрыОбновления,
			ПараметрыОбновления.ПоследнийОбновленныйЭлемент);
		ПараметрыОбновления.ПоследнийОбновленныйЭлемент.Удалить("ОчиститьТочечноеЗадание");
	КонецЕсли;
	
	Если ПараметрыОбновления.ПерезапускОбновления Тогда
		ОбщиеПараметрыОбновления.Вставить("ПерезапускОбновления");
		Если ОбщиеПараметрыОбновления.Свойство("НовыйПоследнийЭлементПорции") Тогда
			ОбщиеПараметрыОбновления.Удалить("НовыйПоследнийЭлементПорции");
		КонецЕсли;
	КонецЕсли;
	
	Если ОбщиеПараметрыОбновления.ПолучитьПорции > 0
	   И ОбщиеПараметрыОбновления.Свойство("НовыйПоследнийЭлементПорции") Тогда
		
		ПараметрыОбновления.ПоследнийОбновленныйЭлемент = НачальныйЭлемент(ПараметрыОбновления);
		ЗаполнитьЗначенияСвойств(ПараметрыОбновления.ПоследнийОбновленныйЭлемент,
			ОбщиеПараметрыОбновления.НовыйПоследнийЭлементПорции);
	КонецЕсли;
	
	Если Не ЭтоОбновлениеПрав
	   И ПериодОбновленияДоПериодаДанных(ОбщиеПараметрыОбновления.ДатаНачала,
	         ПараметрыОбновления.ПоследнийОбновленныйЭлемент.Дата) Тогда
		
		ОбщиеПараметрыОбновления.Вставить("НовыйПоследнийОбновленныйЭлемент",
			ПараметрыОбновления.ПоследнийОбновленныйЭлемент);
		
		ОбщиеПараметрыОбновления.ОбработкаЗавершена = Ложь;
		Возврат;
	КонецЕсли;
	
	// Однопоточное обновление некоторых наборов групп доступа.
	Если Не ЭтоОбновлениеПрав
	   И ЭтоСправочникНаборыГруппДоступа(ПараметрыОбновления)
	   И ПараметрыОбновления.ПоследнийОбновленныйЭлемент.КлючДанных = Неопределено Тогда
		
		Если ПараметрыОбновления.ПоследнийОбновленныйЭлемент.ВидКлючаДанных = "НовыеНаборыИзОдногоПользователя" Тогда
			УстранитьДублиНаборовИзОдногоПользователяВСправочнике(ПараметрыОбновления);
			
		ИначеЕсли ПараметрыОбновления.ПоследнийОбновленныйЭлемент.ВидКлючаДанных = "НаборыГруппДоступаНазначенныеПользователям" Тогда
			ЗаполнитьПустыеХешиНаборовГрупп(ПараметрыОбновления);
			
		ИначеЕсли ПараметрыОбновления.ПоследнийОбновленныйЭлемент.ВидКлючаДанных = "НовыеНаборыГруппСУстаревшимиПравами" Тогда
			Если Не ПараметрыОбновления.ДляВнешнихПользователей Тогда
				ОбновитьПраваНаРазрешенныйКлючДоступа();
			КонецЕсли;
			ОчиститьПраваПустогоНабораГруппДоступа(ПараметрыОбновления);
			
		ИначеЕсли ЭтоОбработкаУстаревшихЭлементов(ПараметрыОбновления) Тогда
			ОчиститьПраваНесуществующихНаборовГруппДоступа(ПараметрыОбновления);
		КонецЕсли;
	КонецЕсли;
	
	// Запрос элементов для обработки.
	ВыбраныВсеЭлементы = Ложь;
	
	Если ОбщиеПараметрыОбновления.ПолучитьПорции > 0 Тогда
		КоличествоВПорции = КоличествоЭлементовВПорции(ПараметрыОбновления);
		КоличествоВЗапросе = КоличествоВПорции * ОбщиеПараметрыОбновления.ПолучитьПорции;
		Элементы = ЭлементыДляОбновления(ПараметрыОбновления, КоличествоВЗапросе, ВыбраныВсеЭлементы);
		
		Если ОбщиеПараметрыОбновления.Свойство("НовыйПоследнийЭлементПорции")
		 Или Элементы <> Неопределено
		   И Элементы.Количество() > КоличествоВПорции * 2 Тогда
			
			ОбщиеПараметрыОбновления.ОбработкаЗавершена = Ложь;
			ОбщиеПараметрыОбновления.Вставить("НаборПорций", НаборПорцийЭлементов(
				ПараметрыОбновления, Элементы, ВыбраныВсеЭлементы, КоличествоВПорции));
			Возврат;
		КонецЕсли;
	Иначе
		Возврат;
	КонецЕсли;
	
	// Обработка элементов данных.
	ПараметрыОбновления.Вставить("НовыйПоследнийОбновленныйЭлемент",
		НачальныйЭлемент(ПараметрыОбновления, , Истина));
	
	ОбщиеПараметрыОбновления.Вставить("НачальноеОбновлениеЗавершено");
	
	Если Элементы <> Неопределено Тогда
		ОбновитьПорциюЭлементов(Элементы, ПараметрыОбновления);
	КонецЕсли;
	
	// Уточнение нового последнего элемента.
	Если Элементы = Неопределено И ВыбраныВсеЭлементы Тогда
		УстановитьПустойПоследнийЭлемент(ПараметрыОбновления.НовыйПоследнийОбновленныйЭлемент,
			ПараметрыОбновления);
	КонецЕсли;
	
	// Запись нового последнего элемента.
	ЗаписатьПоследнийОбновленныйЭлемент(ОбщиеПараметрыОбновления,
		ПараметрыОбновления.НовыйПоследнийОбновленныйЭлемент);
	
	Если ПараметрыОбновления.НовыйПоследнийОбновленныйЭлемент.КлючДанных = Null Тогда
		ОбщиеПараметрыОбновления.Вставить("НетЗаданий");
		Возврат;
	КонецЕсли;
	
	ОбщиеПараметрыОбновления.Вставить("НовыйПоследнийОбновленныйЭлемент",
		ПараметрыОбновления.НовыйПоследнийОбновленныйЭлемент);
	
	// Подготовка оставшихся элементов к продолжению обновления.
	Если Элементы <> Неопределено Тогда
		ОбщиеПараметрыОбновления.Вставить("НаборПорций",
			НаборПорцийЭлементов(ПараметрыОбновления, Элементы, ВыбраныВсеЭлементы));
	КонецЕсли;
	
КонецПроцедуры

Функция ЭтоСправочникНаборыГруппДоступа(ПараметрыОбновления)
	
	Если ПараметрыОбновления.Свойство("Список") Тогда
		Возврат ПараметрыОбновления.Список = "Справочник.НаборыГруппДоступа";
	КонецЕсли;
	
	Возврат ПараметрыОбновления.ИдентификаторСписка
		= ПараметрыОбновления.ИдентификаторСправочникаНаборыГруппДоступа;
	
КонецФункции

// Для процедура ВыполнитьОбновлениеДоступаСписка.
Функция ПараметрыОбновления(ОбщиеПараметрыОбновления, ОбъектМетаданных)
	
	ПараметрыОбновления = Новый Структура("ЭтоОбновлениеПрав,
		|ИдентификаторСписка, ДляВнешнихПользователей, Кэш,
		|ДатаНачала, ДатаОкончания, МаксимумПорцийИзИсходной,
		|ЭтоФоновоеОбновлениеДоступа, ИдентификаторСправочникаНаборыГруппДоступа");
	
	ЗаполнитьЗначенияСвойств(ПараметрыОбновления, ОбщиеПараметрыОбновления);
	
	Если ТипЗнч(ОбъектМетаданных) = Тип("ОбъектМетаданных") Тогда
		ПараметрыОбновления.Вставить("Список", ОбъектМетаданных.ПолноеИмя());
	КонецЕсли;

	ПараметрыОбновления.Вставить("ГраницаВремениОбработки",
		ТекущаяУниверсальнаяДатаВМиллисекундах()
		+ ОбщиеПараметрыОбновления.МаксимумМиллисекундОбработки);
	
	ДобавитьПараметрыОграничения(ПараметрыОбновления);
	
	Возврат ПараметрыОбновления;
	
КонецФункции

// Для процедура ВыполнитьОбновлениеДоступаСписка.
Процедура ДобавитьПараметрыОграничения(ПараметрыОбновления)
	
	Если ЭтоСправочникНаборыГруппДоступа(ПараметрыОбновления) Тогда
		ПараметрыОбновления.Вставить("СписокСДатой", Ложь);
		ПараметрыОбновления.Вставить("СписокСПериодом", Ложь);
		ПараметрыОбновления.Вставить("ЭтоСсылочныйТип", Истина);
		ПараметрыОбновления.Вставить("ПустойНаборГруппДоступа", Справочники.НаборыГруппДоступа.ПустаяСсылка());
		Возврат;
	КонецЕсли;
	
	ИдентификаторТранзакции = Новый УникальныйИдентификатор;
	Список = ?(ПараметрыОбновления.Свойство("Список"), ПараметрыОбновления.Список, "");
	СвойстваСпискаКакВедущего = СвойстваСпискаКакВедущего(Список, ИдентификаторТранзакции);
	ПараметрыОграничения = ПараметрыОграничения(Список,
		ИдентификаторТранзакции, ПараметрыОбновления.ДляВнешнихПользователей);
	
	ПараметрыОграничения = Новый Структура(ПараметрыОграничения);
	Для Каждого КлючИЗначение Из ПараметрыОбновления Цикл
		ПараметрыОграничения.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	ПараметрыОбновления = ПараметрыОграничения;
	ПараметрыОбновления.Вставить("ИдентификаторТранзакции", ИдентификаторТранзакции);
	
	ИмяСвойстваВидаПользователей = ?(ПараметрыОбновления.ДляВнешнихПользователей,
		"ДляВнешнихПользователей", "ДляПользователей");
	
	Если СвойстваСпискаКакВедущего = Неопределено
	 Или СвойстваСпискаКакВедущего.ПоКлючамДоступа = Неопределено
	 Или СвойстваСпискаКакВедущего.ПоКлючамДоступа[ИмяСвойстваВидаПользователей] = Неопределено Тогда
		
		ПараметрыОбновления.Вставить("ЗависимыеСпискиПоКлючамДоступа", Новый Массив);
	Иначе
		ПараметрыОбновления.Вставить("ЗависимыеСпискиПоКлючамДоступа",
			СвойстваСпискаКакВедущего.ПоКлючамДоступа[ИмяСвойстваВидаПользователей]);
	КонецЕсли;
	
КонецПроцедуры

// Для процедур ВыполнитьОбновлениеДоступаСписка, ПодготовитьПланОбновления.
Функция НачальныйЭлемент(ПараметрыОбновления, ВидКлючаДанных = Неопределено,
			СохранитьВидКлючаДанных = Ложь, ПерезапускОбновленияСНачала = Ложь)
	
	НачальныйЭлемент = Новый Структура;
	НачальныйЭлемент.Вставить("КлючДанных");
	НачальныйЭлемент.Вставить("ОбработатьУстаревшиеЭлементы", Ложь);
	НачальныйЭлемент.Вставить("ОбработатьНаборыГруппСУстаревшимиПравами", Ложь);
	СохранитьСвойства = Ложь;
	
	Если ВидКлючаДанных = Неопределено Тогда
		Если СохранитьВидКлючаДанных Тогда
			ВидКлючаДанных = ПараметрыОбновления.ПоследнийОбновленныйЭлемент.ВидКлючаДанных;
			СохранитьСвойства = Истина;
			
		ИначеЕсли ЭтоСправочникНаборыГруппДоступа(ПараметрыОбновления) Тогда
			ВидКлючаДанных = "НовыеНаборыИзОдногоПользователя";
			
		ИначеЕсли ПараметрыОбновления.ЭтоОбновлениеПрав Тогда
			ВидКлючаДанных = "ЭлементыСУстаревшимиПравами";
		Иначе
			ВидКлючаДанных = "ЭлементыСУстаревшимиКлючами";
		КонецЕсли;
	ИначеЕсли ВидКлючаДанных <> "НетДанных"
	        И ПараметрыОбновления.Свойство("ПоследнийОбновленныйЭлемент") Тогда
		СохранитьСвойства = Истина;
	КонецЕсли;
	Если СохранитьСвойства Тогда
		Если ПараметрыОбновления.ПоследнийОбновленныйЭлемент.ОбработатьУстаревшиеЭлементы Тогда
			НачальныйЭлемент.ОбработатьУстаревшиеЭлементы = Истина;
		КонецЕсли;
		Если ПараметрыОбновления.ПоследнийОбновленныйЭлемент.ОбработатьНаборыГруппСУстаревшимиПравами Тогда
			НачальныйЭлемент.ОбработатьНаборыГруппСУстаревшимиПравами = Истина;
		КонецЕсли;
	КонецЕсли;
	УстановитьВидКлючаДанных(НачальныйЭлемент, ВидКлючаДанных);
	
	Если Не ПараметрыОбновления.ЭтоОбновлениеПрав Тогда
		НачальныйЭлемент.Вставить("Дата", ?(ПерезапускОбновленияСНачала,
			МаксимальнаяДата(), МаксимальнаяДатаПриПродолжении()));
	КонецЕсли;
	
	Возврат НачальныйЭлемент;
	
КонецФункции

// Для процедура ВыполнитьОбновлениеДоступаСписка.
Процедура ПодготовитьПланОбновления(ПараметрыОбновления, ПодготовкаЗавершена)
	
	ИдентификаторСписка     = ПараметрыОбновления.ИдентификаторСписка;
	ДляВнешнихПользователей = ПараметрыОбновления.ДляВнешнихПользователей;
	ЭтоОбновлениеПрав       = ПараметрыОбновления.ЭтоОбновлениеПрав;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Список", ИдентификаторСписка);
	Запрос.УстановитьПараметр("ДляВнешнихПользователей", ДляВнешнихПользователей);
	
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1000
	|	КлючиУникальности.КлючУникальности КАК КлючУникальности,
	|	КлючиУникальности.ПараметрыЗадания КАК ПараметрыЗадания,
	|	КлючиУникальности.ДатаПоследнегоОбновленногоЭлемента КАК ДатаПоследнегоОбновленногоЭлемента
	|ИЗ
	|	РегистрСведений.ОбновлениеКлючейДоступаКДанным КАК КлючиУникальности
	|ГДЕ
	|	КлючиУникальности.Список = &Список
	|	И КлючиУникальности.ДляВнешнихПользователей = &ДляВнешнихПользователей
	|
	|УПОРЯДОЧИТЬ ПО
	|	КлючиУникальности.Список,
	|	КлючиУникальности.ДляВнешнихПользователей,
	|	КлючиУникальности.КлючУникальности";
	
	Если ЭтоОбновлениеПрав Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст,
			"РегистрСведений.ОбновлениеКлючейДоступаКДанным",
			"РегистрСведений.ОбновлениеКлючейДоступаПользователей");
		Запрос.Текст = СтрЗаменить(Запрос.Текст, ",
			|	КлючиУникальности.ДатаПоследнегоОбновленногоЭлемента КАК ДатаПоследнегоОбновленногоЭлемента",
			"");
	КонецЕсли;
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		ПараметрыОбновления.ЕстьЗадания = Ложь;
		Возврат;
	КонецЕсли;
	
	Выгрузка = РезультатЗапроса.Выгрузить();
	
	ПерезапускОбновления = Ложь;
	ПерезапускОбновленияСНачала = Ложь;
	СохраняемыеПараметрыЗадания = СохраняемыеПараметрыЗадания(ЭтоОбновлениеПрав, ПараметрыОбновления);
	
	Если Не ЗначениеЗаполнено(Выгрузка[0].КлючУникальности) Тогда
		ТекущийИтог = Выгрузка[0];
		ПараметрыЗадания = ТекущийИтог.ПараметрыЗадания.Получить();
		Если ТипЗнч(ПараметрыЗадания) = Тип("Структура") Тогда
			СохраняемыеПараметрыЗадания = СохраняемыеПараметрыЗадания(ЭтоОбновлениеПрав,
				ПараметрыОбновления, ПараметрыЗадания, ПерезапускОбновления);
		Иначе
			ПерезапускОбновления = Истина;
		КонецЕсли;
		Если Не ПерезапускОбновления И Не ЭтоОбновлениеПрав Тогда
			СохраненнаяДата = ТекущийИтог.ДатаПоследнегоОбновленногоЭлемента;
			Если ТипЗнч(СохраненнаяДата) = Тип("Дата") Тогда
				СохраняемыеПараметрыЗадания.ПоследнийОбновленныйЭлемент.Дата = СохраненнаяДата;
			Иначе
				ПерезапускОбновления = Истина;
			КонецЕсли;
		КонецЕсли;
		Выгрузка.Удалить(0);
		Если Не ПерезапускОбновления Тогда
			ПараметрыОбновления.ПоследнийОбновленныйЭлемент =
				СохраняемыеПараметрыЗадания.ПоследнийОбновленныйЭлемент;
		КонецЕсли;
	КонецЕсли;
	
	Если Не ПерезапускОбновления
	   И ТекущийИтог <> Неопределено
	   И Выгрузка.Количество() = 0 Тогда
		
		ПараметрыОбновления.ТочечноеЗадание = ПодготовленноеТочечноеЗадание(
			ЭтоОбновлениеПрав, СохраняемыеПараметрыЗадания.ТочечноеЗадание, ПерезапускОбновления);
		Если Не ПерезапускОбновления Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ПустойИдентификатор = ОбщегоНазначенияКлиентСервер.ПустойУникальныйИдентификатор();
	ПолноеИмяРегистра = ?(ЭтоОбновлениеПрав, "РегистрСведений.ОбновлениеКлючейДоступаПользователей",
		"РегистрСведений.ОбновлениеКлючейДоступаКДанным");
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить(ПолноеИмяРегистра);
	ЭлементБлокировки.УстановитьЗначение("Список",                  ИдентификаторСписка);
	ЭлементБлокировки.УстановитьЗначение("ДляВнешнихПользователей", ДляВнешнихПользователей);
	ЭлементБлокировки.УстановитьЗначение("КлючУникальности",        ПустойИдентификатор);
	
	Для Каждого Строка Из Выгрузка Цикл
		ЭлементБлокировки = Блокировка.Добавить(ПолноеИмяРегистра);
		ЭлементБлокировки.УстановитьЗначение("Список",                  ИдентификаторСписка);
		ЭлементБлокировки.УстановитьЗначение("ДляВнешнихПользователей", ДляВнешнихПользователей);
		ЭлементБлокировки.УстановитьЗначение("КлючУникальности",        Строка.КлючУникальности);
		Прервать;
	КонецЦикла;
	
	МаксимальнаяДата = МаксимальнаяДата();
	СвойстваКлючаДанных = НачальныйЭлемент(ПараметрыОбновления, "НетДанных");
	ВидКлючаДанныхУстановлен = Истина;
	Для Каждого Строка Из Выгрузка Цикл
		ПараметрыЗадания = Строка.ПараметрыЗадания.Получить();
		Если ТипЗнч(ПараметрыЗадания) = Тип("Структура") И ПараметрыЗадания.Свойство("ТочечноеЗадание") Тогда
			ДобавитьВедущийОбъектКТочечномуЗаданию(ПараметрыЗадания.ТочечноеЗадание,
				СохраняемыеПараметрыЗадания.ТочечноеЗадание, ПерезапускОбновления);
		Иначе
			ПерезапускОбновления = Истина;
			Если Не ЭтоОбновлениеПрав И Строка.ДатаПоследнегоОбновленногоЭлемента = МаксимальнаяДата Тогда
				ПерезапускОбновленияСНачала = Истина;
			КонецЕсли;
			Если ЕстьСвойстваКлючаДанных(ПараметрыЗадания) Тогда
				Если СвойстваКлючаДанных.ПорядокВидаКлючаДанных > ПараметрыЗадания.ПорядокВидаКлючаДанных Тогда
					СвойстваКлючаДанных.ПорядокВидаКлючаДанных = ПараметрыЗадания.ПорядокВидаКлючаДанных;
					СвойстваКлючаДанных.ВидКлючаДанных         = ПараметрыЗадания.ВидКлючаДанных;
				КонецЕсли;
				Если ЭтоОбработкаУстаревшихЭлементов(Новый Структура("ПоследнийОбновленныйЭлемент", ПараметрыЗадания)) Тогда
					СвойстваКлючаДанных.ОбработатьУстаревшиеЭлементы = Истина;
				КонецЕсли;
				Если ПараметрыЗадания.Свойство("ОбработатьНаборыГруппСУстаревшимиПравами")
				   И ПараметрыЗадания.ОбработатьНаборыГруппСУстаревшимиПравами = Истина Тогда
					СвойстваКлючаДанных.ОбработатьНаборыГруппСУстаревшимиПравами = Истина;
				КонецЕсли;
			Иначе
				ВидКлючаДанныхУстановлен = Ложь;
				Если ЭтоСправочникНаборыГруппДоступа(ПараметрыОбновления) Тогда
					СвойстваКлючаДанных.ОбработатьНаборыГруппСУстаревшимиПравами = Истина;
				КонецЕсли;
				Если ЭтоОбновлениеПрав Или ПерезапускОбновленияСНачала Тогда
					Прервать;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	ПараметрыОбновления.ТочечноеЗадание = ПодготовленноеТочечноеЗадание(
		ЭтоОбновлениеПрав, СохраняемыеПараметрыЗадания.ТочечноеЗадание, ПерезапускОбновления);
	
	Если ПерезапускОбновления Тогда
		ПараметрыОбновления.ПерезапускОбновления = Истина;
		Если ПерезапускОбновленияСНачала Тогда
			ПараметрыОбновления.Вставить("ПерезапускОбновленияСНачала");
		КонецЕсли;
		ПараметрыОбновления.ПоследнийОбновленныйЭлемент =
			НачальныйЭлемент(ПараметрыОбновления, , , ПерезапускОбновленияСНачала);
	КонецЕсли;
	
	ПоследнийОбновленныйЭлемент = ПараметрыОбновления.ПоследнийОбновленныйЭлемент;
	Если ВидКлючаДанныхУстановлен Тогда
		Если ТекущийИтог = Неопределено Тогда
			УстановитьВидКлючаДанных(ПоследнийОбновленныйЭлемент, СвойстваКлючаДанных.ВидКлючаДанных);
			
		ИначеЕсли ПоследнийОбновленныйЭлемент.ПорядокВидаКлючаДанных > СвойстваКлючаДанных.ПорядокВидаКлючаДанных  Тогда
			ПоследнийОбновленныйЭлемент.ПорядокВидаКлючаДанных = СвойстваКлючаДанных.ПорядокВидаКлючаДанных;
			ПоследнийОбновленныйЭлемент.ВидКлючаДанных         = СвойстваКлючаДанных.ВидКлючаДанных;
		КонецЕсли;
	КонецЕсли;
	Если СвойстваКлючаДанных.ОбработатьУстаревшиеЭлементы Тогда
		ПоследнийОбновленныйЭлемент.ОбработатьУстаревшиеЭлементы = Истина;
	КонецЕсли;
	Если СвойстваКлючаДанных.ОбработатьНаборыГруппСУстаревшимиПравами Тогда
		ПоследнийОбновленныйЭлемент.ОбработатьНаборыГруппСУстаревшимиПравами = Истина;
	КонецЕсли;
	СохраняемыеПараметрыЗадания.ПоследнийОбновленныйЭлемент = ПоследнийОбновленныйЭлемент;
	
	Если ПараметрыОбновления.ПоследнийОбновленныйЭлемент.ВидКлючаДанных = "НетДанных" Тогда
		РазмерЗадания = 1;
	ИначеЕсли ЭтоОбработкаУстаревшихЭлементов(Новый Структура("ПоследнийОбновленныйЭлемент",
					ПоследнийОбновленныйЭлемент)) Тогда
		РазмерЗадания = 2;
	Иначе
		РазмерЗадания = 3;
	КонецЕсли;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ВЫБРАТЬ ПЕРВЫЕ 1000", "ВЫБРАТЬ ПЕРВЫЕ 1");
	ЗаданияУдалены = Ложь;
	
	Если ЭтоОбновлениеПрав Тогда
		ПланОбновления = СлужебныйНаборЗаписей(РегистрыСведений.ОбновлениеКлючейДоступаПользователей);
	Иначе
		ПланОбновления = СлужебныйНаборЗаписей(РегистрыСведений.ОбновлениеКлючейДоступаКДанным);
	КонецЕсли;
	
	ПланОбновления.Отбор.Список.Установить(ИдентификаторСписка);
	ПланОбновления.Отбор.ДляВнешнихПользователей.Установить(ДляВнешнихПользователей);
	ПланОбновления.Отбор.КлючУникальности.Установить(ПустойИдентификатор);
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		РезультатЗапроса = Запрос.Выполнить();
		Если РезультатЗапроса.Пустой() Тогда
			ЗаданияУдалены = Истина;
		Иначе
			Запись = ПланОбновления.Добавить();
			Запись.Список                  = ИдентификаторСписка;
			Запись.ДляВнешнихПользователей = ДляВнешнихПользователей;
			Запись.ТочечноеЗадание         = ПараметрыОбновления.ТочечноеЗадание <> Неопределено;
			Запись.ПараметрыЗадания        = Новый ХранилищеЗначения(СохраняемыеПараметрыЗадания);
			Запись.РазмерЗадания           = РазмерЗадания;
			Если Не ЭтоОбновлениеПрав Тогда
				Запись.ДатаПоследнегоОбновленногоЭлемента =
					ПараметрыОбновления.ПоследнийОбновленныйЭлемент.Дата;
			КонецЕсли;
			Запись.ДатаИзмененияЗаписиРегистра = ТекущаяДатаСеанса();
			ПланОбновления.Записать();
		КонецЕсли;
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	Если ЗаданияУдалены Тогда
		ПараметрыОбновления.ЕстьЗадания = Ложь;
		ПараметрыОбновления.ТочечноеЗадание = Неопределено;
		ПараметрыОбновления.ПоследнийОбновленныйЭлемент = НачальныйЭлемент(ПараметрыОбновления);
		Возврат;
	КонецЕсли;
	
	ПланОбновления.Очистить();
	Для Каждого Строка Из Выгрузка Цикл
		ПланОбновления.Отбор.КлючУникальности.Установить(Строка.КлючУникальности);
		ПланОбновления.Записать();
	КонецЦикла;
	
	Если Выгрузка.Количество() = 1000 Тогда
		ПодготовкаЗавершена = Ложь;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ПодготовитьПланОбновления, ЗаписатьПоследнийОбновленныйЭлемент.
Функция СохраняемыеПараметрыЗадания(ЭтоОбновлениеПрав, ПараметрыОбновления, ПараметрыЗадания = Неопределено,
			ПерезапускОбновления = Ложь, ОчиститьТочечноеЗадание = Ложь)
	
	ТочечноеЗадание = Новый Структура;
	ТочечноеЗадание.Вставить("ПоКлючамДоступа", Новый Соответствие);
	Если Не ЭтоОбновлениеПрав Тогда
		ТочечноеЗадание.Вставить("ПоЗначениямПолей",     Новый Соответствие);
		ТочечноеЗадание.Вставить("ПоЗначениямСГруппами", Новый Соответствие);
	КонецЕсли;
	
	СохраняемыеПараметры = Новый Структура;
	СохраняемыеПараметры.Вставить("ТочечноеЗадание", ТочечноеЗадание);
	СохраняемыеПараметры.Вставить("ПоследнийОбновленныйЭлемент", НачальныйЭлемент(ПараметрыОбновления));
	
	Если ТипЗнч(ПараметрыЗадания) <> Тип("Структура") Тогда
		Возврат СохраняемыеПараметры;
	КонецЕсли;
	
	Если ПараметрыЗадания.Свойство("ПоследнийОбновленныйЭлемент") Тогда
		Порядок = ПорядокВидаКлючаДанных(ПараметрыЗадания.ПоследнийОбновленныйЭлемент.ВидКлючаДанных);
		Если Порядок <> Неопределено Тогда
			ЗаполнитьЗначенияСвойств(СохраняемыеПараметры.ПоследнийОбновленныйЭлемент,
				ПараметрыЗадания.ПоследнийОбновленныйЭлемент);
		КонецЕсли;
	КонецЕсли;
	
	Если ОчиститьТочечноеЗадание Или Не ПараметрыЗадания.Свойство("ТочечноеЗадание") Тогда
		Возврат СохраняемыеПараметры;
	КонецЕсли;
	
	ТекущееТочечноеЗадание = ПараметрыЗадания.ТочечноеЗадание;
	Если ТипЗнч(ТекущееТочечноеЗадание) <> Тип("Структура") Тогда
		ПерезапускОбновления = Истина;
		Возврат СохраняемыеПараметры;
	КонецЕсли;
	
	Для Каждого ВариантЗадания Из ТочечноеЗадание Цикл
		Если Не ТекущееТочечноеЗадание.Свойство(ВариантЗадания.Ключ)
		 Или ТипЗнч(ТекущееТочечноеЗадание[ВариантЗадания.Ключ]) <> Тип("Соответствие") Тогда
			ПерезапускОбновления = Истина;
			Продолжить;
		КонецЕсли;
		ТочечноеЗадание[ВариантЗадания.Ключ] = ТекущееТочечноеЗадание[ВариантЗадания.Ключ];
	КонецЦикла;
	
	Возврат СохраняемыеПараметры;
	
КонецФункции

// Для процедуры ПодготовитьПланОбновления.
Процедура ДобавитьВедущийОбъектКТочечномуЗаданию(ТочечноеЗадание, СохраняемоеТочечноеЗадание,
			ПерезапускОбновления)
	
	Если ТипЗнч(ТочечноеЗадание) <> Тип("Структура") Тогда
		ПерезапускОбновления = Истина;
		Возврат;
	КонецЕсли;
	МаксимальноеКоличество = МаксимальноеКоличествоКомбинацийЗначенийВедущихПолейПриВычисленииСоставаИзмененных();
	
	Для Каждого ВариантЗадания Из ТочечноеЗадание Цикл
		Если Не СохраняемоеТочечноеЗадание.Свойство(ВариантЗадания.Ключ) Тогда
			ПерезапускОбновления = Истина;
			Продолжить;
		КонецЕсли;
		Если ВариантЗадания.Ключ <> "ПоЗначениямПолей" Тогда
			Ссылки = ?(ТипЗнч(ВариантЗадания.Значение) = Тип("Массив"), ВариантЗадания.Значение,
				ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ВариантЗадания.Значение));
			СохраняемыеСсылки = СохраняемоеТочечноеЗадание[ВариантЗадания.Ключ];
			Для Каждого Ссылка Из Ссылки Цикл
				СохраняемыеСсылки.Вставить(Ссылка, Истина);
				Если СохраняемыеСсылки.Количество() >= МаксимальноеКоличество Тогда
					ПерезапускОбновления = Истина;
					Продолжить;
				КонецЕсли;
			КонецЦикла;
		Иначе
			Свойства = ВариантЗадания.Значение;
			СохраняемыеТаблицы = СохраняемоеТочечноеЗадание[ВариантЗадания.Ключ];
			
			Если Не Свойства.Свойство("ИзмененнаяТаблица")
			 Или Не Свойства.Свойство("СоставИзменений")
			 Или ТипЗнч(Свойства.СоставИзменений) <> Тип("ТаблицаЗначений")
			 Или ТипЗнч(СохраняемыеТаблицы) <> Тип("Соответствие") Тогда
				
				ПерезапускОбновления = Истина;
				Продолжить;
			КонецЕсли;
			СохраняемаяТаблица = СохраняемыеТаблицы.Получить(Свойства.ИзмененнаяТаблица);
			СоставИзменений = Свойства.СоставИзменений;
			Если СохраняемаяТаблица = Неопределено Тогда
				СохраняемыеТаблицы.Вставить(Свойства.ИзмененнаяТаблица, СоставИзменений);
				
			ИначеЕсли ТипЗнч(СохраняемаяТаблица) <> Тип("ТаблицаЗначений")
			      Или СоставИзменений.Колонки.Количество() <> СохраняемаяТаблица.Колонки.Количество() Тогда
				
				ПерезапускОбновления = Истина;
				Продолжить;
			Иначе
				ИменаКолонок = Новый Массив;
				Для Каждого Колонка Из СохраняемаяТаблица.Колонки Цикл
					Если СоставИзменений.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
						ИменаКолонок = Неопределено;
						Прервать;
					КонецЕсли;
					ИменаКолонок.Добавить(Колонка.Имя);
				КонецЦикла;
				Если ИменаКолонок = Неопределено Тогда
					ПерезапускОбновления = Истина;
					Продолжить;
				КонецЕсли;
				Отбор = Новый Структура(СтрСоединить(ИменаКолонок, ", "));
				Для Каждого Строка Из СоставИзменений Цикл
					ЗаполнитьЗначенияСвойств(Отбор, Строка);
					Если СохраняемаяТаблица.НайтиСтроки(Отбор).Количество() = 0 Тогда
						ЗаполнитьЗначенияСвойств(СохраняемаяТаблица.Добавить(), Строка);
						Если СохраняемаяТаблица.Количество() >= МаксимальноеКоличество Тогда
							ПерезапускОбновления = Истина;
							Прервать;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ПодготовитьПланОбновления.
Функция ЕстьСвойстваКлючаДанных(ПараметрыЗадания)
	
	Если ТипЗнч(ПараметрыЗадания) <> Тип("Структура")
	 Или Не ПараметрыЗадания.Свойство("ВидКлючаДанных")
	 Или Не ПараметрыЗадания.Свойство("ПорядокВидаКлючаДанных") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Порядок = ПорядокВидаКлючаДанных(ПараметрыЗадания.ВидКлючаДанных);
	
	Возврат Порядок <> Неопределено И Порядок = ПараметрыЗадания.ПорядокВидаКлючаДанных;
	
КонецФункции

// Для процедур ВыполнитьОбновлениеДоступаСписка, ОбновитьПорциюЭлементов,
// УстановитьТекстЗапросаИПараметрыПоследнегоОбновленногоЭлементаДанных, ОбновитьНаборыГруппДоступа и
// функций ЭлементыДляОбновления, ПоследнийЭлемент, КлючДанных, НаборыГруппДоступаДляОбновления.
//
Функция ЭтоОбработкаУстаревшихЭлементов(ПараметрыОбновления)
	
	Порядок = ПорядокВидаКлючаДанных(ПараметрыОбновления.ПоследнийОбновленныйЭлемент.ВидКлючаДанных);
	
	Возврат Порядок >= ПорядокВидаКлючаДанных("УстаревшиеЭлементы")
	      И Порядок < ПорядокВидаКлючаДанных("НетДанных");
	
КонецФункции

// Для функций СохраняемыеПараметрыЗадания, ЕстьСвойстваКлючаДанных и
// процедур ОбновитьСвойствоЭтоОбработкаУстаревшихЭлементов, УстановитьВидКлючаДанных.
//
Функция ПорядокВидаКлючаДанных(ВидКлючаДанных)
	
	ВидыКлючейДанных = Новый Соответствие;
	ВидыКлючейДанных.Вставить("ЭлементыСУстаревшимиКлючами", 0);
	ВидыКлючейДанных.Вставить("ЭлементыБезКлючейПоЗначениямПолей", 1);
	ВидыКлючейДанных.Вставить("ЭлементыБезКлючейПоПериоду", 1);
	
	ВидыКлючейДанных.Вставить("ЭлементыСУстаревшимиПравами", 0);
	
	ВидыКлючейДанных.Вставить("НовыеНаборыИзОдногоПользователя", 0);
	ВидыКлючейДанных.Вставить("НаборыГруппДоступаНазначенныеПользователям", 1);
	ВидыКлючейДанных.Вставить("НаборыГруппПользователейНазначенныеПользователям", 2);
	ВидыКлючейДанных.Вставить("НовыеНаборыГруппСУстаревшимиПравами", 3);
	ВидыКлючейДанных.Вставить("НаборыГруппРазрешенныеПользователям", 4);
	ВидыКлючейДанных.Вставить("НаборыГруппСУстаревшимиПравами", 5);
	
	ВидыКлючейДанных.Вставить("УстаревшиеЭлементы", 10);
	ВидыКлючейДанных.Вставить("УстаревшиеЭлементыОбщегоРегистра", 11);
	
	ВидыКлючейДанных.Вставить("НетДанных", 99);
	
	Возврат ВидыКлючейДанных.Получить(ВидКлючаДанных);
	
КонецФункции

// Для процедур ЗапланироватьОбновлениеДоступа, ЗапланироватьОбновлениеНаборовГруппДоступа,
// УточнитьПустойПоследнийЭлемент и функции НачальныйЭлемент.
//
Процедура УстановитьВидКлючаДанных(Элемент, ВидКлючаДанных)
	
	Порядок = ПорядокВидаКлючаДанных(ВидКлючаДанных);
	Если Порядок = Неопределено Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Некорректный имя вида порядка ключа данных ""%1""'"), ВидКлючаДанных);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	Элемент.Вставить("ВидКлючаДанных", ВидКлючаДанных);
	Элемент.Вставить("ПорядокВидаКлючаДанных", Порядок);
	
КонецПроцедуры

// Для процедуры ПодготовитьПланОбновления.
Функция ПодготовленноеТочечноеЗадание(ЭтоОбновлениеПрав, СохраняемоеТочечноеЗадание, ПерезапускОбновления)
	
	ТочечноеЗадание = Новый Структура;
	Если ЭтоОбновлениеПрав Тогда
		ТочечноеЗадание.Вставить("ПоКлючамДоступа", Новый Массив);
	Иначе
		ТочечноеЗадание.Вставить("ПоЗначениямПолей",     Новый Соответствие);
		ТочечноеЗадание.Вставить("ПоКлючамДоступа",      Новый ТаблицаЗначений);
		ТочечноеЗадание.Вставить("ПоЗначениямСГруппами", Новый ТаблицаЗначений);
	КонецЕсли;
	
	ЭтоПустоеЗадание = Истина;
	МаксимальноеКоличество = МаксимальноеКоличествоКомбинацийЗначенийВедущихПолейПриВычисленииСоставаИзмененных();
	ТипыВедущихОбъектов = УправлениеДоступомСлужебныйПовтИсп.ТиповСсылокВедущихОбъектов();
	
	Для Каждого ВариантЗадания Из СохраняемоеТочечноеЗадание Цикл
		Если ВариантЗадания.Ключ = "ПоЗначениямПолей" Тогда
			Если ЗначениеЗаполнено(ВариантЗадания.Значение) Тогда
				ЭтоПустоеЗадание = Ложь;
				ТочечноеЗадание.ПоЗначениямПолей = ВариантЗадания.Значение;
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		
		УдаляемыеСсылки = Новый Массив;
		ОписаниеСсылок = ВариантЗадания.Значение;
		Если ЭтоОбновлениеПрав Тогда
			Ссылки = ТочечноеЗадание[ВариантЗадания.Ключ];
		Иначе
			Ссылки = Новый Массив;
			Типы = Новый Соответствие;
			Таблица = ТочечноеЗадание[ВариантЗадания.Ключ];
		КонецЕсли;
		Для Каждого ОписаниеСсылки Из ОписаниеСсылок Цикл
			Ссылка = ОписаниеСсылки.Ключ;
			Тип = ТипЗнч(Ссылка);
			Если ТипыВедущихОбъектов.Получить(Тип) = Неопределено Тогда
				ПерезапускОбновления = Истина;
				УдаляемыеСсылки.Добавить(Ссылка);
				Продолжить;
			КонецЕсли;
			Ссылки.Добавить(Ссылка);
			Если Не ЭтоОбновлениеПрав Тогда
				Типы.Вставить(Тип, Истина);
				Таблица.Добавить();
			КонецЕсли;
			Если Ссылки.Количество() >= МаксимальноеКоличество Тогда
				ПерезапускОбновления = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Для Каждого Ссылка Из УдаляемыеСсылки Цикл
			ОписаниеСсылок.Удалить(Ссылка);
		КонецЦикла;
		Если Ссылки.Количество() > 0 Тогда
			ЭтоПустоеЗадание = Ложь;
		Иначе
			Продолжить;
		КонецЕсли;
		Если Не ЭтоОбновлениеПрав Тогда
			ТипыКолонки = Новый Массив;
			Для Каждого КлючИЗначение Из Типы Цикл
				ТипыКолонки.Добавить(КлючИЗначение.Ключ);
			КонецЦикла;
			Таблица.Колонки.Добавить("Ссылка", Новый ОписаниеТипов(ТипыКолонки));
			Таблица.ЗагрузитьКолонку(Ссылки, "Ссылка");
		КонецЕсли;
	КонецЦикла;
	
	Если ЭтоПустоеЗадание Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ТочечноеЗадание;
	
КонецФункции

// Для процедура ВыполнитьОбновлениеДоступаСписка.
Функция КоличествоЭлементовВПорции(ПараметрыОбновления)
	
	Если ЭтоСправочникНаборыГруппДоступа(ПараметрыОбновления) Тогда
		Возврат 25;
	ИначеЕсли ПараметрыОбновления.ЭтоОбновлениеПрав Тогда
		Возврат КоличествоКлючейДоступаВПорции();
	Иначе
		Возврат КоличествоЭлементовДанныхВПорции();
	КонецЕсли;
	
КонецФункции

// Для процедура ВыполнитьОбновлениеДоступаСписка.
Функция КоличествоЭлементовВЗапросе(ЭтоОбновлениеПрав)
	
	Если ЭтоОбновлениеПрав Тогда
		Возврат КоличествоКлючейДоступаВЗапросе();
	Иначе
		Возврат КоличествоЭлементовДанныхВЗапросе();
	КонецЕсли;
	
КонецФункции

// Для процедуры ВыполнитьОбновлениеДоступаСписка.
Процедура ОбновитьПорциюЭлементов(Элементы, ПараметрыОбновления, ЭтоТочечноеЗадание = Ложь)
	
	ПараметрыОбновления.Вставить("КоличествоОбработанныхЭлементов", 0);
	ПараметрыОбновления.Вставить("СоставУдаленныхЭлементов", Новый Массив);
	
	Если ЭтоТочечноеЗадание Тогда
		Если ПараметрыОбновления.ЭтоОбновлениеПрав Тогда
			ОбновитьПраваПорцииКлючейДоступаСписка(Элементы, ПараметрыОбновления);
		Иначе
			ОбновитьЭлементыДанныхСпискаСУстаревшимиКлючами(Элементы, ПараметрыОбновления);
		КонецЕсли;
		
	ИначеЕсли ПараметрыОбновления.ЭтоОбновлениеПрав Тогда
		Если ЭтоОбработкаУстаревшихЭлементов(ПараметрыОбновления) Тогда
			ОбработатьУстаревшиеКлючиДоступаСписка(Элементы, ПараметрыОбновления);
		Иначе
			ОбновитьПраваПорцииКлючейДоступаСписка(Элементы, ПараметрыОбновления);
		КонецЕсли;
		
	ИначеЕсли ЭтоСправочникНаборыГруппДоступа(ПараметрыОбновления) Тогда
		ОбновитьНаборыГруппДоступа(Элементы, ПараметрыОбновления);
		
	ИначеЕсли ЭтоОбработкаУстаревшихЭлементов(ПараметрыОбновления) Тогда
		УдалитьУстаревшиеЭлементыДанныхСписка(Элементы, ПараметрыОбновления);
		
	ИначеЕсли ПараметрыОбновления.СЗаписьюВсегдаРазрешенногоКлючаДоступа Тогда
		ОбновитьЭлементыДанныхСпискаСУстаревшимРазрешеннымКлючом(Элементы, ПараметрыОбновления);
		ПараметрыОбновления.КоличествоОбработанныхЭлементов = Элементы.Количество();
	Иначе
		ОбновитьЭлементыДанныхСпискаСУстаревшимиКлючами(Элементы, ПараметрыОбновления);
	КонецЕсли;
	
	Если Не ЭтоТочечноеЗадание И Элементы.Количество() = ПараметрыОбновления.СоставУдаленныхЭлементов.Количество() Тогда
		ПараметрыОбновления.Вставить("НовыйПоследнийОбновленныйЭлемент",
			ПоследнийЭлемент(Элементы, ПараметрыОбновления));
	КонецЕсли;
	
	Для Каждого Элемент Из ПараметрыОбновления.СоставУдаленныхЭлементов Цикл
		Элементы.Удалить(Элемент);
	КонецЦикла;
	
	Если Не ЭтоТочечноеЗадание И Элементы.Количество() > 0 Тогда
		ПараметрыОбновления.Вставить("НовыйПоследнийОбновленныйЭлемент",
			ПоследнийЭлемент(Элементы, ПараметрыОбновления, Истина));
	КонецЕсли;
	
	Если Элементы.Количество() = ПараметрыОбновления.КоличествоОбработанныхЭлементов Тогда
		Элементы = Неопределено;
	Иначе
		Для Счетчик = 1 По ПараметрыОбновления.КоличествоОбработанныхЭлементов Цикл
			Элементы.Удалить(0);
		КонецЦикла;
	КонецЕсли;
	
	ПараметрыОбновления.КоличествоОбработанныхЭлементов =
		ПараметрыОбновления.КоличествоОбработанныхЭлементов
			+ ПараметрыОбновления.СоставУдаленныхЭлементов.Количество();
	
КонецПроцедуры

// Для процедур ОбновитьНаборыГруппДоступа, УдалитьУстаревшиеЭлементыДанныхСписка,
// ЗаписатьКлючиДоступаОбъектов, ЗаписатьКлючиДоступаРегистров,
// ОбновитьПраваПорцииКлючейДоступаСписка, УдалитьПорциюКлючейДоступаСписка,
// УдалитьТекущуюПорциюКлючейДоступаСписка.
//
Функция ТребуетсяПрерватьОбработкуЭлементов(ПараметрыОбновления, КоличествоОбработанныхНаШаге = 1)
	
	Если Не ПараметрыОбновления.Свойство("КоличествоОбработанныхЭлементов")
	 Или Не ПараметрыОбновления.Свойство("ГраницаВремениОбработки") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ПараметрыОбновления.КоличествоОбработанныхЭлементов =
		ПараметрыОбновления.КоличествоОбработанныхЭлементов + КоличествоОбработанныхНаШаге;
	
	Если ТекущаяУниверсальнаяДатаВМиллисекундах() > ПараметрыОбновления.ГраницаВремениОбработки Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Для процедур ВыполнитьОбновлениеДоступаСписка, ПроверитьЗавершитьОбновлениеПоПорциям.
Процедура ЗаписатьПоследнийОбновленныйЭлемент(ОбщиеПараметрыОбновления, ПоследнийОбновленныйЭлемент)
	
	ЭтоОбновлениеПрав       = ОбщиеПараметрыОбновления.ЭтоОбновлениеПрав;
	ДляВнешнихПользователей = ОбщиеПараметрыОбновления.ДляВнешнихПользователей;
	ИдентификаторСписка     = ОбщиеПараметрыОбновления.ИдентификаторСписка;
	
	МенеджерРегистра = ?(ЭтоОбновлениеПрав, РегистрыСведений.ОбновлениеКлючейДоступаПользователей,
		РегистрыСведений.ОбновлениеКлючейДоступаКДанным);
	
	ПланОбновления = СлужебныйНаборЗаписей(МенеджерРегистра);
	ПланОбновления.Отбор.Список.Установить(ИдентификаторСписка);
	ПланОбновления.Отбор.ДляВнешнихПользователей.Установить(ДляВнешнихПользователей);
	ПланОбновления.Отбор.КлючУникальности.Установить(
		ОбщегоНазначенияКлиентСервер.ПустойУникальныйИдентификатор());
	
	ПолноеИмяРегистра = ?(ЭтоОбновлениеПрав, "РегистрСведений.ОбновлениеКлючейДоступаПользователей",
		"РегистрСведений.ОбновлениеКлючейДоступаКДанным");
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить(ПолноеИмяРегистра);
	ЭлементБлокировки.УстановитьЗначение("Список", ИдентификаторСписка);
	ЭлементБлокировки.УстановитьЗначение("ДляВнешнихПользователей", ДляВнешнихПользователей);
	ЭлементБлокировки.УстановитьЗначение("КлючУникальности",
		ОбщегоНазначенияКлиентСервер.ПустойУникальныйИдентификатор());
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		ПланОбновления.Прочитать();
		Если ПланОбновления.Количество() > 0 Тогда
			Если ПоследнийОбновленныйЭлемент.КлючДанных = Null Тогда
				ПланОбновления.Очистить();
			Иначе
				Запись = ПланОбновления[0];
				Если ПоследнийОбновленныйЭлемент.Свойство("ОчиститьТочечноеЗадание") Тогда
					Запись.ТочечноеЗадание = Ложь;
				КонецЕсли;
				
				ТекущиеПараметрыЗадания = Запись.ПараметрыЗадания.Получить();
				ПараметрыЗадания = СохраняемыеПараметрыЗадания(ЭтоОбновлениеПрав, ОбщиеПараметрыОбновления,
					ТекущиеПараметрыЗадания, , ПоследнийОбновленныйЭлемент.Свойство("ОчиститьТочечноеЗадание"));
				
				ЗаполнитьЗначенияСвойств(ПараметрыЗадания.ПоследнийОбновленныйЭлемент, ПоследнийОбновленныйЭлемент);
				
				Если Не ЭтоОбновлениеПрав И ПоследнийОбновленныйЭлемент.Свойство("Дата") Тогда
					Запись.ДатаПоследнегоОбновленногоЭлемента = ПоследнийОбновленныйЭлемент.Дата;
				КонецЕсли;
				
				Запись.ПараметрыЗадания = Новый ХранилищеЗначения(ПараметрыЗадания);
				Запись.РазмерЗадания = ?(ЭтоОбработкаУстаревшихЭлементов(
					Новый Структура("ПоследнийОбновленныйЭлемент", ПоследнийОбновленныйЭлемент)), 2, 3);
				
				Запись.ДатаИзмененияЗаписиРегистра = ТекущаяДатаСеанса();
				ОбщиеПараметрыОбновления.ОбработкаЗавершена = Ложь;
			КонецЕсли;
			ПланОбновления.Записать();
		КонецЕсли;
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Для процедуры ВыполнитьОбновлениеДоступаСписка.
Функция ЭлементыДляОбновления(ПараметрыОбновления, КоличествоВЗапросе, ВыбраныВсеЭлементы)
	
	Если ЭтоСправочникНаборыГруппДоступа(ПараметрыОбновления) Тогда
		Если ПараметрыОбновления.ЭтоОбновлениеПрав Тогда
			ВыбраныВсеЭлементы = Истина;
			Возврат Неопределено;
		КонецЕсли;
		Элементы = НаборыГруппДоступаДляОбновления(ПараметрыОбновления, КоличествоВЗапросе);
	Иначе
		Запрос = Новый Запрос;
		Если ПараметрыОбновления.ЭтоОбновлениеПрав Тогда
			Запрос.УстановитьПараметр("Список", ПараметрыОбновления.ИдентификаторСписка);
			Запрос.УстановитьПараметр("ДляВнешнихПользователей", ПараметрыОбновления.ДляВнешнихПользователей);
			
			ПоследнийКлючДоступа = ПараметрыОбновления.ПоследнийОбновленныйЭлемент.КлючДанных;
			Если ТипЗнч(ПоследнийКлючДоступа) <> Тип("СправочникСсылка.КлючиДоступа") Тогда
				ПоследнийКлючДоступа = Неопределено;
			КонецЕсли;
			Запрос.УстановитьПараметр("ПоследнийКлючДоступа", ПоследнийКлючДоступа);
			
			Если ПараметрыОбновления.БезЗаписиКлючейДоступа
			 Или ПараметрыОбновления.СЗаписьюВсегдаРазрешенногоКлючаДоступа Тогда
				
				Запрос.Текст =
				"ВЫБРАТЬ ПЕРВЫЕ " + МаркерРазмераПорции() + "
				|	КлючиДоступа.Ссылка КАК Ссылка
				|ИЗ
				|	Справочник.КлючиДоступа КАК КлючиДоступа
				|ГДЕ
				|	КлючиДоступа.Список = &Список
				|	И КлючиДоступа.ДляВнешнихПользователей = &ДляВнешнихПользователей
				|	И КлючиДоступа.Ссылка > &ПоследнийКлючДоступа
				|	И &УточнениеПланаЗапроса
				|
				|УПОРЯДОЧИТЬ ПО
				|	КлючиДоступа.Ссылка";
				
			ИначеЕсли ЭтоОбработкаУстаревшихЭлементов(ПараметрыОбновления) Тогда
				Запрос.УстановитьПараметр("ДатаУстаревания", ДатаУстаревания());
				Запрос.Текст = ПараметрыОбновления.ТекстЗапросаУстаревшихКлючейДоступа;
			Иначе
				Запрос.Текст = ПараметрыОбновления.ТекстЗапросаКлючейДоступаДляОбновленияПрав;
			КонецЕсли;
			
		ИначеЕсли ПараметрыОбновления.ЭтоСсылочныйТип
		        И ПараметрыОбновления.ДляВнешнихПользователей
		        И ЭтоОбработкаУстаревшихЭлементов(ПараметрыОбновления)
		        И (Не ПараметрыОбновления.БезЗаписиКлючейДоступа
		           Или ПараметрыОбновления.БезЗаписиКлючейДоступаДляПользователейИВнешнихПользователей) Тогда
			
			ВыбраныВсеЭлементы = Истина;
			Возврат Неопределено;
		Иначе
			УстановитьТекстЗапросаИПараметрыПоследнегоОбновленногоЭлементаДанных(Запрос, ПараметрыОбновления);
		КонецЕсли;
		
		КоличествоВЗапросе = ?(КоличествоВЗапросе < 1000, 1000, ?(КоличествоВЗапросе > 10000, 10000, КоличествоВЗапросе));
		Запрос.Текст = СтрЗаменить(Запрос.Текст, МаркерРазмераПорции(), Формат(КоличествоВЗапросе, "ЧГ="));
		УстановитьУточнениеПланаЗапроса(Запрос.Текст);
		
		Элементы = Запрос.Выполнить().Выгрузить();
	КонецЕсли;
	
	Если Элементы.Количество() = 0 Тогда
		ВыбраныВсеЭлементы = Истина;
		Возврат Неопределено;
	КонецЕсли;
	
	ВыбраныВсеЭлементы = Элементы.Количество() < КоличествоВЗапросе;
	
	Возврат Элементы;
	
КонецФункции

// Для процедур выполнения запросов.
Процедура УстановитьУточнениеПланаЗапроса(ТекстЗапроса, УникальныйПлан = Ложь)
	
	Если УправлениеДоступомСлужебныйПовтИсп.ТребуетсяУточнениеПланаЗапроса() Тогда
		Если УникальныйПлан Тогда
			ТекущаяДатаСеанса = ТекущаяДатаСеанса();
			ВсегоМинут   = Цел((ТекущаяДатаСеанса - '00010101') / 60);
			ОстатокМинут = ВсегоМинут - Цел(ВсегоМинут / 2048) * 2048;
			УточнениеПланаЗапроса = УправлениеДоступомСлужебныйПовтИсп.УточнениеПланаЗапроса(ОстатокМинут, 11);
		Иначе
			ТочноеВремя = ТекущаяУниверсальнаяДатаВМиллисекундах();
			ВсегоДесятыхСекунд = Цел(ТочноеВремя / 100);
			ОстатокДесятыхСекунд = ВсегоДесятыхСекунд - Цел(ВсегоДесятыхСекунд / 1048576) * 1048576;
			УточнениеПланаЗапроса = УправлениеДоступомСлужебныйПовтИсп.УточнениеПланаЗапроса(ОстатокДесятыхСекунд, 20);
		КонецЕсли;
	Иначе
		УточнениеПланаЗапроса = "ИСТИНА";
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УточнениеПланаЗапроса", УточнениеПланаЗапроса);
	
КонецПроцедуры

// Для процедуры ВыполнитьОбновлениеДоступаСписка.
Функция ЭлементыТочечногоЗаданияДляОбновления(ПараметрыОбновления, КоличествоВЗапросе, ВыбраныВсеЭлементы)
	
	Если ЭтоСправочникНаборыГруппДоступа(ПараметрыОбновления)
	 Или ПараметрыОбновления.БезЗаписиКлючейДоступа
	 Или ПараметрыОбновления.СЗаписьюВсегдаРазрешенногоКлючаДоступа Тогда
		
		Возврат Неопределено;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Если ПараметрыОбновления.ЭтоОбновлениеПрав Тогда
		Запрос.Текст = ПараметрыОбновления.ТекстЗапросаКлючейПоВедущимКлючамДляОбновленияПрав;
		Если Не ЗначениеЗаполнено(Запрос.Текст) Тогда
			Возврат Неопределено;
		КонецЕсли;
		Запрос.УстановитьПараметр("Список", ПараметрыОбновления.ИдентификаторСписка);
		Запрос.УстановитьПараметр("ВедущиеКлючиДоступа", ПараметрыОбновления.ТочечноеЗадание.ПоКлючамДоступа);
	Иначе
		Если Не ПараметрыОбновления.ЭтоСсылочныйТип Тогда
			Запрос.УстановитьПараметр("ИдентификаторРегистра", ПараметрыОбновления.ИдентификаторСписка);
		КонецЕсли;
		ОписаниеЗапросов = ПараметрыОбновления.ОписаниеЗапросовУстаревшихКлючейДоступаПоВедущимОбъектам;
		ЗапросыПакета = Новый Массив;
		ЗапросыДанных = Новый Массив;
		Если ЗначениеЗаполнено(ПараметрыОбновления.ТочечноеЗадание.ПоЗначениямПолей) Тогда
			ОписаниеЗапросовПоЗначениямПолей = ОписаниеЗапросов.Получить("ПоЗначениямПолей");
			Если ОписаниеЗапросовПоЗначениямПолей = Неопределено Тогда
				Возврат Неопределено;
			КонецЕсли;
			Для Каждого ОписаниеИзменений Из ПараметрыОбновления.ТочечноеЗадание.ПоЗначениямПолей Цикл
				ОписаниеЗапроса = ОписаниеЗапросовПоЗначениямПолей.Получить(ОписаниеИзменений.Ключ);
				Если ОписаниеЗапроса = Неопределено Тогда
					Возврат Неопределено;
				КонецЕсли;
				СоставИзменений = ОписаниеИзменений.Значение;
				Если ОписаниеЗапроса.ТипыПолей.Количество() <> СоставИзменений.Колонки.Количество() Тогда
					Возврат Неопределено;
				КонецЕсли;
				Для Каждого Колонка Из СоставИзменений.Колонки Цикл
					ТипыПоля = ОписаниеЗапроса.ТипыПолей.Получить(Колонка.Имя);
					Если ТипЗнч(ТипыПоля) <> Тип("ХранилищеЗначения") Тогда
						Возврат Неопределено;
					КонецЕсли;
					ТипКолонки = Новый ОписаниеТипов(Колонка.ТипЗначения,, "Null");
					Если ТипыПоля.Получить() <> ТипКолонки Тогда
						Возврат Неопределено;
					КонецЕсли;
				КонецЦикла;
				ИмяВременнойТаблицыИПараметра = СтрЗаменить(ОписаниеИзменений.Ключ, ".", "_");
				Запрос.УстановитьПараметр(ИмяВременнойТаблицыИПараметра, СоставИзменений);
				ЗапросыПакета.Добавить(ОписаниеЗапроса.ТекстЗапросаПараметров);
				Для Каждого ТекстЗапросаДанных Из ОписаниеЗапроса.ТекстыЗапросовДанных Цикл
					ЗапросыДанных.Добавить(ТекстЗапросаДанных);
				КонецЦикла;
			КонецЦикла;
		КонецЕсли;
		Если Не ДобавитьЗапросыТочечногоЗадания("ПоКлючамДоступа",
		            Запрос, ЗапросыПакета, ЗапросыДанных, ПараметрыОбновления)
		 Или Не ДобавитьЗапросыТочечногоЗадания("ПоЗначениямСГруппами",
		            Запрос, ЗапросыПакета, ЗапросыДанных, ПараметрыОбновления)
		 Или ЗапросыДанных.Количество() = 0 Тогда
			Возврат Неопределено;
		КонецЕсли;
		Если ЗапросыДанных.Количество() = 1 Тогда
			ЗапросыПакета.Добавить(СтрЗаменить(ЗапросыДанных[0],
			"
			|ИЗ
			|	",
			"
			|ПОМЕСТИТЬ ТекущийСписокПоВедущимОбъектам
			|ИЗ
			|	"));
		Иначе
			ТекстыЗапросов = СтрСоединить(ЗапросыДанных,
			"
			|
			|ОБЪЕДИНИТЬ ВСЕ
			|
			|");
			ЗапросыПакета.Добавить(СтрЗаменить(ОписаниеЗапросов.Получить("ТекстЗапросаОберткиВыбораДанных"),
				"#ЗапросыВыбораДанных", ТекстСОтступом(ТекстыЗапросов, "	")));
		КонецЕсли;
		ЗапросыПакета.Добавить(ОписаниеЗапросов.Получить("ТекстЗапросаТочечнойПроверки"));
		Запрос.Текст = СтрСоединить(ЗапросыПакета, ОбщегоНазначения.РазделительПакетаЗапросов());
	КонецЕсли;
	
	КоличествоВЗапросе = ?(КоличествоВЗапросе < 1000, 1000, ?(КоличествоВЗапросе > 4000, 4000, КоличествоВЗапросе));
	Запрос.Текст = СтрЗаменить(Запрос.Текст, МаркерРазмераПорции(), Формат(КоличествоВЗапросе, "ЧГ="));
	УстановитьУточнениеПланаЗапроса(Запрос.Текст);
	
	Если ПараметрыОбновления.ЭтоОбновлениеПрав Тогда
		Элементы = Запрос.Выполнить().Выгрузить();
		КоличествоВыбранных = Элементы.Количество();
	Иначе
		РезультатыЗапроса = Запрос.ВыполнитьПакет();
		КоличествоВыбранных = РезультатыЗапроса[ЗапросыПакета.Количество() - 2].Выгрузить()[0].Количество;
		Элементы = РезультатыЗапроса[ЗапросыПакета.Количество() - 1].Выгрузить();
	КонецЕсли;
	
	ВыбраныВсеЭлементы = КоличествоВыбранных < КоличествоВЗапросе;
	
	Если Элементы.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Элементы;
	
КонецФункции

// Для функции ЭлементыТочечногоЗаданияДляОбновления.
Функция ДобавитьЗапросыТочечногоЗадания(ВидЗадания, Запрос, ЗапросыПакета, ЗапросыДанных, ПараметрыОбновления)
	
	Данные = ПараметрыОбновления.ТочечноеЗадание[ВидЗадания];
	Если Не ЗначениеЗаполнено(Данные) Тогда
		Возврат Истина;
	КонецЕсли;
	
	ОписаниеЗапросов =
		ПараметрыОбновления.ОписаниеЗапросовУстаревшихКлючейДоступаПоВедущимОбъектам.Получить(ВидЗадания);
	
	Если ОписаниеЗапросов = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ТипКолонки = Данные.Колонки.Ссылка.ТипЗначения;
	НедостающиеТипы = Новый ОписаниеТипов(ТипКолонки, , ОписаниеЗапросов.ТипСсылки.Получить().Типы());
	Если НедостающиеТипы.Типы().Количество() > 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Запрос.УстановитьПараметр(ВидЗадания, Данные);
	ЗапросыПакета.Добавить(ОписаниеЗапросов.ТекстЗапросаПараметров);
	
	КлючиЗапросов = Новый Соответствие;
	Для Каждого Тип Из ТипКолонки.Типы() Цикл
		ТекущиеКлючи = ОписаниеЗапросов.КлючиЗапросовПоТипам.Получить(Тип);
		Если ТекущиеКлючи = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
		Для Каждого Ключ Из ТекущиеКлючи Цикл
			КлючиЗапросов.Вставить(Ключ, Истина);
		КонецЦикла;
	КонецЦикла;
	
	Для Каждого КлючИЗначение Из КлючиЗапросов Цикл
		ТекстЗапроса = ОписаниеЗапросов.ТекстыЗапросовПоКлючам.Получить(КлючИЗначение.Ключ);
		Если ТекстЗапроса = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
		ЗапросыДанных.Добавить(ТекстЗапроса);
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Для процедуры ВыполнитьОбновлениеДоступаСписка.
Процедура ПерезапуститьОбновлениеПриНезавершенномТочечномОбновлении(ПараметрыОбновления)
	
	ПараметрыОбновления.ПерезапускОбновления = Истина;
	ПараметрыОбновления.ПоследнийОбновленныйЭлемент = НачальныйЭлемент(ПараметрыОбновления);
	
	// Регистрация косвенного планирования обновления доступа.
	ПараметрыПланирования = ПараметрыПланированияОбновленияДоступа(Ложь);
	ПараметрыПланирования.РазрешенныеКлючиДоступа  =    ПараметрыОбновления.ЭтоОбновлениеПрав;
	ПараметрыПланирования.ДляПользователей         = Не ПараметрыОбновления.ДляВнешнихПользователей;
	ПараметрыПланирования.ДляВнешнихПользователей  =    ПараметрыОбновления.ДляВнешнихПользователей;
	ПараметрыПланирования.ЭтоПродолжениеОбновления = Истина;
	ПараметрыПланирования.Описание = "ПерезапуститьОбновлениеПриНезавершенномТочечномОбновлении";
	
	СпискиПоИдентификаторам = Новый Соответствие;
	СпискиПоИдентификаторам.Вставить(ПараметрыОбновления.ИдентификаторСписка, ПараметрыОбновления.Список);
	
	ЗарегистрироватьПланированиеОбновленияДоступа(СпискиПоИдентификаторам, ПараметрыПланирования);
	
КонецПроцедуры

// Для процедуры ВыполнитьОбновлениеДоступаСписка.
Функция НаборПорцийЭлементов(ПараметрыОбновления, Элементы, ВыбраныВсеЭлементы, РазмерПорции = Неопределено)
	
	НаборПорций = Новый Массив;
	
	Если Элементы = Неопределено Тогда
		ПорцияИзНабора = Новый Структура;
		ПорцияИзНабора.Вставить("Обработана", Истина);
		ПорцияИзНабора.Вставить("Обрабатывается", Ложь);
		ПорцияИзНабора.Вставить("Элементы", Новый ХранилищеЗначения(Новый ТаблицаЗначений));
		ПорцияИзНабора.Вставить("ДатаПоследнегоЭлементаПорции", '00010101');
		ПорцияИзНабора.Вставить("ПоследнийЭлементПорции", НачальныйЭлемент(ПараметрыОбновления,, Истина));
		ПорцияИзНабора.Вставить("НовыйПоследнийЭлементПорции");
		НаборПорций.Добавить(ПорцияИзНабора);
		ПорцияИзНабора.ПоследнийЭлементПорции.КлючДанных = Null;
		Если ПорцияИзНабора.ПоследнийЭлементПорции.Свойство("Дата") Тогда
			ПорцияИзНабора.ПоследнийЭлементПорции.Дата = '00010101';
		КонецЕсли;
		УстановитьПустойПоследнийЭлемент(ПорцияИзНабора.НовыйПоследнийЭлементПорции,
			ПараметрыОбновления, '00010101');
		Возврат НаборПорций;
	КонецЕсли;
	
	Если РазмерПорции = Неопределено Тогда
		РазмерПорции = ПараметрыОбновления.КоличествоОбработанныхЭлементов;
		МаксимумНовыхПорций = ПараметрыОбновления.МаксимумПорцийИзИсходной;
		Если Элементы.Количество() / РазмерПорции > МаксимумНовыхПорций Тогда
			РазмерПорции = Элементы.Количество() / МаксимумНовыхПорций;
			Если РазмерПорции <> Цел(РазмерПорции) Тогда
				РазмерПорции = Цел(РазмерПорции) + 1;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	ПараметрыОбновления.Вставить("НаборПорций", НаборПорций);
	Индекс = 0;
	Для Каждого Элемент Из Элементы Цикл
		Если Индекс / РазмерПорции = Цел(Индекс / РазмерПорции) Тогда
			ПорцияИзНабора = Новый Массив;
			НаборПорций.Добавить(ПорцияИзНабора);
		КонецЕсли;
		ПорцияИзНабора.Добавить(Элемент);
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Для Индекс = 0 По НаборПорций.Количество() - 1 Цикл
		ЭлементыПорции = Элементы.Скопировать(НаборПорций[Индекс]);
		ПорцияИзНабора = Новый Структура;
		ПорцияИзНабора.Вставить("Обработана", Ложь);
		ПорцияИзНабора.Вставить("Обрабатывается", Ложь);
		НаборПорций[Индекс] = ПорцияИзНабора;
		ПорцияИзНабора.Вставить("Элементы", Новый ХранилищеЗначения(ЭлементыПорции));
		ПорцияИзНабора.Вставить("ПоследнийЭлементПорции",
			ПоследнийЭлемент(ЭлементыПорции, ПараметрыОбновления));
		ПорцияИзНабора.Вставить("ДатаПоследнегоЭлементаПорции",
			?(ПорцияИзНабора.ПоследнийЭлементПорции.Свойство("Дата"),
				ПорцияИзНабора.ПоследнийЭлементПорции.Дата, '00010101'));
		ПорцияИзНабора.Вставить("НовыйПоследнийЭлементПорции",
			ПоследнийЭлемент(ЭлементыПорции, ПараметрыОбновления));
	КонецЦикла;
	
	Если ВыбраныВсеЭлементы Тогда
		ПорцияИзНабора.ПоследнийЭлементПорции.КлючДанных = Null;
		УстановитьПустойПоследнийЭлемент(ПорцияИзНабора.НовыйПоследнийЭлементПорции,
			ПараметрыОбновления, '00010101');
	КонецЕсли;
	
	Возврат НаборПорций;
	
КонецФункции

// Для процедур ВыполнитьОбновлениеДоступаСписка, ОбновитьПорциюЭлементов, НаборПорцийЭлементов.
Функция ПоследнийЭлемент(Элементы, ПараметрыОбновления, ПоследнийОбработанный = Ложь)
	
	НомерПоследнего = ?(ПоследнийОбработанный,
		ПараметрыОбновления.КоличествоОбработанныхЭлементов, Элементы.Количество());
	
	ПоследнийЭлемент = Элементы[НомерПоследнего - 1];
	
	ЭлементДанных = НачальныйЭлемент(ПараметрыОбновления, , Истина);
	
	Если ПараметрыОбновления.ЭтоОбновлениеПрав Тогда
		ЭлементДанных.КлючДанных = ПоследнийЭлемент.Ссылка;
		Возврат ЭлементДанных;
	КонецЕсли;
	
	Если ПараметрыОбновления.СписокСДатой
	   И Не ЭтоОбработкаУстаревшихЭлементов(ПараметрыОбновления) Тогда
		
		ЭлементДанных.Дата = ПоследнийЭлемент.Дата;
		
	ИначеЕсли ПараметрыОбновления.ЭтоСсылочныйТип Тогда
		ЭлементДанных.КлючДанных = ПоследнийЭлемент.ТекущаяСсылка;
	Иначе
		ЭлементДанных.КлючДанных = КлючДанных(ПараметрыОбновления);
		ЗаполнитьЗначенияСвойств(ЭлементДанных.КлючДанных, ПоследнийЭлемент);
		
		Если ПараметрыОбновления.СписокСПериодом
		   И ЭлементДанных.ВидКлючаДанных = "ЭлементыБезКлючейПоПериоду" Тогда
			
			ЭлементДанных.Дата = ПоследнийЭлемент.Период;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ЭлементДанных;
	
КонецФункции

// Для процедуры ВыполнитьОбновлениеДоступаСписка.
Процедура УточнитьПоследнийОбновленныйЭлемент(ПараметрыОбновления)
	
	Если ПараметрыОбновления.Список = "Справочник.НаборыГруппДоступа"
	 Или ПараметрыОбновления.ПоследнийОбновленныйЭлемент.ВидКлючаДанных = "НетДанных" Тогда
		Возврат;
	КонецЕсли;
	
	Если ПараметрыОбновления.БезЗаписиКлючейДоступа
	 Или ПараметрыОбновления.ЭтоОбновлениеПрав
	   И ПараметрыОбновления.СЗаписьюВсегдаРазрешенногоКлючаДоступа Тогда
		
		Если Не ПараметрыОбновления.ПоследнийОбновленныйЭлемент.ОбработатьУстаревшиеЭлементы Тогда
			ПараметрыОбновления.ПоследнийОбновленныйЭлемент =
				НачальныйЭлемент(ПараметрыОбновления, "НетДанных");
			
		ИначеЕсли Не ЭтоОбработкаУстаревшихЭлементов(ПараметрыОбновления) Тогда
			ПараметрыОбновления.ПоследнийОбновленныйЭлемент =
				НачальныйЭлемент(ПараметрыОбновления, "УстаревшиеЭлементы");
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Для процедур ВыполнитьОбновлениеДоступаСписка, НаборПорцийЭлементов.
Процедура УстановитьПустойПоследнийЭлемент(Элемент, ПараметрыОбновления, ДатаЭлемента = '00010101')
	
	ДатаЭлемента = '00010101';
	Элемент = НачальныйЭлемент(ПараметрыОбновления, , Истина);
	Элемент.КлючДанных = Null;
	
	// Уточнение нового последнего элемента.
	Если ЭтоСправочникНаборыГруппДоступа(ПараметрыОбновления) Тогда
		Если ПараметрыОбновления.ЭтоОбновлениеПрав Тогда
			Возврат;
		КонецЕсли;
		НовыйВидКлючаДанных = "";
		Если Элемент.ВидКлючаДанных = "НовыеНаборыИзОдногоПользователя" Тогда
			НовыйВидКлючаДанных = "НаборыГруппДоступаНазначенныеПользователям";
			
		ИначеЕсли Элемент.ВидКлючаДанных = "НаборыГруппДоступаНазначенныеПользователям" Тогда
			НовыйВидКлючаДанных = "НаборыГруппПользователейНазначенныеПользователям";
			
		ИначеЕсли Элемент.ВидКлючаДанных = "НаборыГруппПользователейНазначенныеПользователям" Тогда
			НовыйВидКлючаДанных = "НовыеНаборыГруппСУстаревшимиПравами";
			
		ИначеЕсли Элемент.ВидКлючаДанных = "НовыеНаборыГруппСУстаревшимиПравами" Тогда
			НовыйВидКлючаДанных = "НаборыГруппРазрешенныеПользователям";
			
		ИначеЕсли Элемент.ВидКлючаДанных = "НаборыГруппРазрешенныеПользователям"
		        И Элемент.ОбработатьНаборыГруппСУстаревшимиПравами Тогда
			
			НовыйВидКлючаДанных = "НаборыГруппСУстаревшимиПравами";
			
		ИначеЕсли Элемент.ОбработатьУстаревшиеЭлементы
		        И (    Элемент.ВидКлючаДанных = "НаборыГруппРазрешенныеПользователям"
		           Или Элемент.ВидКлючаДанных = "НаборыГруппСУстаревшимиПравами") Тогда
			
			НовыйВидКлючаДанных = "УстаревшиеЭлементы";
		КонецЕсли;
		Если ЗначениеЗаполнено(НовыйВидКлючаДанных) Тогда
			Элемент = НачальныйЭлемент(ПараметрыОбновления, НовыйВидКлючаДанных);
		КонецЕсли;
		Возврат;
	КонецЕсли;
	
	Если ПараметрыОбновления.ЭтоОбновлениеПрав Тогда
		Если Элемент.ВидКлючаДанных = "ЭлементыСУстаревшимиПравами"
		   И Элемент.ОбработатьУстаревшиеЭлементы Тогда
			
			Элемент = НачальныйЭлемент(ПараметрыОбновления, "УстаревшиеЭлементы");
		КонецЕсли;
		Возврат;
	КонецЕсли;
	
	Если Элемент.ВидКлючаДанных = "УстаревшиеЭлементыОбщегоРегистра" Тогда
		Возврат;
	КонецЕсли;
	
	Если Элемент.ВидКлючаДанных = "УстаревшиеЭлементы" Тогда
		Если Не ПараметрыОбновления.ЭтоСсылочныйТип
		   И ЗначениеЗаполнено(ПараметрыОбновления.ИмяОтдельногоРегистраКлючей) Тогда
		
			Элемент = НачальныйЭлемент(ПараметрыОбновления, "УстаревшиеЭлементыОбщегоРегистра");
		КонецЕсли;
		Возврат;
	КонецЕсли;
	
	Если ПараметрыОбновления.СписокСДатой Тогда
		УстановитьЭлементСледующегоПериода(ПараметрыОбновления, Элемент, ДатаЭлемента);
		Возврат;
	КонецЕсли;
	
	Если ПараметрыОбновления.ЭтоСсылочныйТип Тогда
		Если Элемент.ВидКлючаДанных = "ЭлементыСУстаревшимиКлючами"
		   И Элемент.ОбработатьУстаревшиеЭлементы
		   И (ПараметрыОбновления.БезЗаписиКлючейДоступа
		      Или Не ПараметрыОбновления.ДляВнешнихПользователей) Тогда
			
			Элемент = НачальныйЭлемент(ПараметрыОбновления, "УстаревшиеЭлементы");
		КонецЕсли;
		Возврат;
	КонецЕсли;
	
	Если ПараметрыОбновления.БезЗаписиКлючейДоступа Тогда
		Если Элемент.ВидКлючаДанных = "ЭлементыСУстаревшимиКлючами"
		   И Элемент.ОбработатьУстаревшиеЭлементы Тогда
			
			Элемент = НачальныйЭлемент(ПараметрыОбновления, "УстаревшиеЭлементы");
		КонецЕсли;
		Возврат;
	КонецЕсли;
	
	Если Элемент.ВидКлючаДанных = "ЭлементыБезКлючейПоЗначениямПолей" Тогда
		Если Элемент.ОбработатьУстаревшиеЭлементы Тогда
			Элемент = НачальныйЭлемент(ПараметрыОбновления, "УстаревшиеЭлементы");
		КонецЕсли;
		Возврат;
	КонецЕсли;
	
	Если Элемент.ВидКлючаДанных = "ЭлементыБезКлючейПоПериоду" Тогда
		УстановитьЭлементСледующегоПериода(ПараметрыОбновления, Элемент, ДатаЭлемента);
		Если Элемент.КлючДанных = Null И Элемент.ОбработатьУстаревшиеЭлементы Тогда
			Элемент = НачальныйЭлемент(ПараметрыОбновления, "УстаревшиеЭлементы");
		КонецЕсли;
		Возврат;
	КонецЕсли;
	
	Если Не ПараметрыОбновления.СписокСПериодом Тогда
		Элемент = НачальныйЭлемент(ПараметрыОбновления, "ЭлементыБезКлючейПоЗначениямПолей");
		Возврат;
	КонецЕсли;
	
	Элемент = НачальныйЭлемент(ПараметрыОбновления, "ЭлементыБезКлючейПоПериоду");
	ПоследнийОбновленныйЭлемент = ПараметрыОбновления.ПоследнийОбновленныйЭлемент;
	ПараметрыОбновления.ПоследнийОбновленныйЭлемент = Элемент;
	УстановитьЭлементСледующегоПериода(ПараметрыОбновления, Элемент, ДатаЭлемента, МаксимальнаяДата());
	ПараметрыОбновления.ПоследнийОбновленныйЭлемент = ПоследнийОбновленныйЭлемент;
	
	Если Элемент.КлючДанных = Null И Элемент.ОбработатьУстаревшиеЭлементы Тогда
		Элемент = НачальныйЭлемент(ПараметрыОбновления, "УстаревшиеЭлементы");
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры УточнитьПустойПоследнийЭлемент.
Процедура УстановитьЭлементСледующегоПериода(ПараметрыОбновления, Элемент, ДатаЭлемента,
			ДатаНачалаТекущегоПериода = Неопределено)
	
	Если ДатаНачалаТекущегоПериода = Неопределено Тогда
		ДатаНачалаТекущегоПериода = ПараметрыОбновления.ДатаНачала;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ДатаНачала", ДатаНачалаТекущегоПериода);
	
	Запрос.Текст = ПараметрыОбновления.ТекстЗапросаДатыСледующегоЭлементаДанных;
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		Элемент.КлючДанных = Null;
		Возврат;
	КонецЕсли;
	
	Элемент = ПоследнийЭлемент(РезультатЗапроса.Выгрузить(), ПараметрыОбновления);
	ДатаЭлемента = ?(Элемент.Свойство("Дата"), Элемент.Дата, '00010101');
	
КонецПроцедуры

// Для функции ЭлементыДляОбновления.
Процедура УстановитьТекстЗапросаИПараметрыПоследнегоОбновленногоЭлементаДанных(Запрос, ПараметрыОбновления)
	
	Если ЭтоОбработкаУстаревшихЭлементов(ПараметрыОбновления) Тогда
		Если ПараметрыОбновления.ПоследнийОбновленныйЭлемент.ВидКлючаДанных = "УстаревшиеЭлементы" Тогда
			Запрос.Текст = ПараметрыОбновления.ТекстЗапросаУстаревшихЭлементовДанных;
		Иначе
			Запрос.Текст = ПараметрыОбновления.ТекстЗапросаУстаревшихЭлементовДанныхИзОбщегоРегистра;
		КонецЕсли;
	Иначе
		Если ПараметрыОбновления.СЗаписьюВсегдаРазрешенногоКлючаДоступа Тогда
			Запрос.УстановитьПараметр("РазрешенныйКлючДоступа", УправлениеДоступомСлужебныйПовтИсп.РазрешенныйКлючДоступа());
			Запрос.Текст = ПараметрыОбновления.ТекстЗапросаЭлементовДанныхСУстаревшимРазрешеннымКлючом;
		Иначе
			Запрос.Текст = ПараметрыОбновления.ТекстЗапросаЭлементовДанныхСУстаревшимиКлючами;
		КонецЕсли;
		Если ПараметрыОбновления.СписокСДатой Тогда
			Запрос.УстановитьПараметр("ДатаНачала",    ПараметрыОбновления.ДатаНачала);
			Запрос.УстановитьПараметр("ДатаОкончания", ПараметрыОбновления.ПоследнийОбновленныйЭлемент.Дата);
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	КлючДанных = ПараметрыОбновления.ПоследнийОбновленныйЭлемент.КлючДанных;
	
	Если ПараметрыОбновления.ЭтоСсылочныйТип Тогда
		УстановленныйКлючДанных = ?(ОбщегоНазначения.ЭтоСсылка(ТипЗнч(КлючДанных)), КлючДанных, Неопределено);
		Запрос.УстановитьПараметр("ПоследняяОбработаннаяСсылка", УстановленныйКлючДанных);
		Возврат;
	КонецЕсли;
	
	Запрос.УстановитьПараметр("ИдентификаторРегистра", ПараметрыОбновления.ИдентификаторСписка);
	УстановленныйКлючДанных = КлючДанных(ПараметрыОбновления, КлючДанных);
	ВидКлючаДанных = ПараметрыОбновления.ПоследнийОбновленныйЭлемент.ВидКлючаДанных;
	
	Если ПараметрыОбновления.СписокСПериодом
	   И СтрНачинаетсяС(ВидКлючаДанных, "ЭлементыБезКлючей") Тогда
		
		Если ВидКлючаДанных <> "ЭлементыБезКлючейПоПериоду" Тогда
			УстановитьВидКлючаДанных(ПараметрыОбновления.ПоследнийОбновленныйЭлемент,
				"ЭлементыБезКлючейПоПериоду");
		КонецЕсли;
		Запрос.Текст = ПараметрыОбновления.ТекстЗапросаЭлементовДанныхБезКлючейДоступа;
		Запрос.УстановитьПараметр("ДатаНачала",    ПараметрыОбновления.ДатаНачала);
		Запрос.УстановитьПараметр("ДатаОкончания", ПараметрыОбновления.ПоследнийОбновленныйЭлемент.Дата);
		
	ИначеЕсли СтрНачинаетсяС(ВидКлючаДанных, "ЭлементыБезКлючей") Тогда
		Если ВидКлючаДанных <> "ЭлементыБезКлючейПоЗначениямПолей" Тогда
			УстановитьВидКлючаДанных(ПараметрыОбновления.ПоследнийОбновленныйЭлемент,
				"ЭлементыБезКлючейПоЗначениямПолей");
		КонецЕсли;
		Запрос.Текст = ПараметрыОбновления.ТекстЗапросаЭлементовДанныхБезКлючейДоступа;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из УстановленныйКлючДанных Цикл
		Если КлючИЗначение.Значение = Неопределено Тогда
			ИмяПоля = КлючИЗначение.Ключ;
			Запрос.Текст = СтрЗаменить(Запрос.Текст, " > &" + ИмяПоля, " >= &" + ИмяПоля);
		КонецЕсли;
		Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	
КонецПроцедуры

// Для процедур ПоследнийЭлемент, УстановитьПараметрыПоследнегоОбновленногоЭлемента и
// функции ТекстЗапросаКоличестваОставшихсяЭлементовРегистра.
//
Функция КлючДанных(ПараметрыОбновления, ИсходныйКлючДанных = Неопределено)
	
	КоличествоПолей = ПараметрыОбновления.ОпорныеПоля.Используемые.Количество();
	
	Если КоличествоПолей = 0
	 Или ПараметрыОбновления.ИспользуетсяОграничениеПоВладельцу
	 Или ЭтоОбработкаУстаревшихЭлементов(ПараметрыОбновления) Тогда
		
		КоличествоПолей = ПараметрыОбновления.ОпорныеПоля.МаксимальноеКоличество;
	КонецЕсли;
	
	Если ТипЗнч(ИсходныйКлючДанных) = Тип("Структура")
	   И ИсходныйКлючДанных.Количество() = КоличествоПолей Тогда
		
		ЗначенияПолей = ИсходныйКлючДанных;
	Иначе
		ЗначенияПолей = Новый Структура;
	КонецЕсли;
	
	НовыеЗначенияПолей = Новый Структура;
	
	Для Номер = 1 По КоличествоПолей Цикл
		ИмяПоля = "Поле" + Номер;
		Если ЗначенияПолей.Свойство(ИмяПоля) Тогда
			НовыеЗначенияПолей.Вставить(ИмяПоля, ЗначенияПолей[ИмяПоля]);
		Иначе
			НовыеЗначенияПолей.Вставить(ИмяПоля, Неопределено);
		КонецЕсли;
	КонецЦикла;
	
	Возврат НовыеЗначенияПолей;
	
КонецФункции

// Для процедуры ЭлементыДляОбновления.
Функция НаборыГруппДоступаДляОбновления(ПараметрыОбновления, КоличествоВЗапросе)
	
	ПоследнийОбновленныйЭлемент = ПараметрыОбновления.ПоследнийОбновленныйЭлемент;
	ВидКлючаДанных = ПоследнийОбновленныйЭлемент.ВидКлючаДанных;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ДляВнешнихПользователей", ПараметрыОбновления.ДляВнешнихПользователей);
	Запрос.УстановитьПараметр("ПоследняяОбработаннаяСсылка", ПоследнийОбновленныйЭлемент.КлючДанных);
	
	Если ВидКлючаДанных = "НаборыГруппСУстаревшимиПравами" Тогда
		Запрос.Текст =
		"ВЫБРАТЬ ПЕРВЫЕ " + МаркерРазмераПорции() + "
		|	ТекущийСписок.Ссылка КАК ТекущаяСсылка
		|ИЗ
		|	Справочник.НаборыГруппДоступа КАК ТекущийСписок
		|ГДЕ
		|	ТекущийСписок.ДляВнешнихПользователей = &ДляВнешнихПользователей
		|	И ТекущийСписок.ТипЭлементовНабора В (ЗНАЧЕНИЕ(Справочник.ГруппыДоступа.ПустаяСсылка), ЗНАЧЕНИЕ(Справочник.ГруппыПользователей.ПустаяСсылка))
		|	И ТекущийСписок.Ссылка > &ПоследняяОбработаннаяСсылка
		|	И &УточнениеПланаЗапроса
		|
		|УПОРЯДОЧИТЬ ПО
		|	ТекущийСписок.Ссылка";
		
		Если ПараметрыОбновления.ДляВнешнихПользователей Тогда
			Запрос.Текст = СтрЗаменить(Запрос.Текст,
				"Справочник.ГруппыПользователей", "Справочник.ГруппыВнешнихПользователей");
		КонецЕсли;
		
	ИначеЕсли ВидКлючаДанных = "НовыеНаборыИзОдногоПользователя" Тогда
		Запрос.УстановитьПараметр("ПустойУникальныйИдентификатор",
			ОбщегоНазначенияКлиентСервер.ПустойУникальныйИдентификатор());
		Запрос.Текст =
		"ВЫБРАТЬ ПЕРВЫЕ " + МаркерРазмераПорции() + "
		|	СоставыГруппПользователей.Пользователь КАК ТекущаяСсылка,
		|	СоставыГруппПользователей.Пользователь.Наименование КАК Наименование,
		|	СоставыГруппПользователей.Используется КАК Используется,
		|	НаборыГруппДоступа.НеИспользуетсяС КАК НеИспользуетсяС
		|ИЗ
		|	РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
		|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.НаборыГруппДоступа КАК НаборыГруппДоступа
		|		ПО (НаборыГруппДоступа.Пользователь = СоставыГруппПользователей.Пользователь)
		|			И (НаборыГруппДоступа.ДляВнешнихПользователей = &ДляВнешнихПользователей)
		|			И (НаборыГруппДоступа.ТипЭлементовНабора = ЗНАЧЕНИЕ(Справочник.Пользователи.ПустаяСсылка))
		|			И (НЕ ЛОЖЬ В
		|					(ВЫБРАТЬ ПЕРВЫЕ 1
		|						ЛОЖЬ
		|					ИЗ
		|						Справочник.НаборыГруппДоступа.Группы КАК ГруппыНаборов
		|					ГДЕ
		|						ГруппыНаборов.Ссылка = НаборыГруппДоступа.Ссылка))
		|ГДЕ
		|	ТИПЗНАЧЕНИЯ(СоставыГруппПользователей.ГруппаПользователей) = ТИП(Справочник.Пользователи)
		|	И ВЫБОР
		|			КОГДА СоставыГруппПользователей.Используется
		|					И ВЫРАЗИТЬ(СоставыГруппПользователей.Пользователь КАК Справочник.Пользователи).ИдентификаторПользователяИБ <> &ПустойУникальныйИдентификатор
		|				ТОГДА НаборыГруппДоступа.Пользователь ЕСТЬ NULL
		|						ИЛИ НаборыГруппДоступа.НеИспользуетсяС <> ДАТАВРЕМЯ(1, 1, 1)
		|			ИНАЧЕ НаборыГруппДоступа.НеИспользуетсяС = ДАТАВРЕМЯ(1, 1, 1)
		|		КОНЕЦ
		|	И СоставыГруппПользователей.Пользователь > &ПоследняяОбработаннаяСсылка
		|	И &УточнениеПланаЗапроса
		|
		|УПОРЯДОЧИТЬ ПО
		|	СоставыГруппПользователей.Пользователь";
		
		Если ПараметрыОбновления.ДляВнешнихПользователей Тогда
			Запрос.Текст = СтрЗаменить(Запрос.Текст,
				"Справочник.Пользователи", "Справочник.ВнешниеПользователи");
		КонецЕсли;
		
	ИначеЕсли ВидКлючаДанных = "НаборыГруппДоступаНазначенныеПользователям" Тогда
		Возврат НаборыИзОдногоПользователяДляОбновленияНазначенныхНаборовГруппДоступа(
			ПараметрыОбновления, КоличествоВЗапросе);
		
	ИначеЕсли ВидКлючаДанных = "НаборыГруппПользователейНазначенныеПользователям" Тогда
		Возврат НаборыИзОдногоПользователяДляОбновленияНазначенныхНаборовГруппПользователей(
			ПараметрыОбновления, КоличествоВЗапросе);
		
	ИначеЕсли ВидКлючаДанных = "НовыеНаборыГруппСУстаревшимиПравами" Тогда
		Запрос.Текст =
		"ВЫБРАТЬ ПЕРВЫЕ " + МаркерРазмераПорции() + "
		|	ТекущийСписок.Ссылка КАК ТекущаяСсылка
		|ИЗ
		|	Справочник.НаборыГруппДоступа КАК ТекущийСписок
		|ГДЕ
		|	ТекущийСписок.ДляВнешнихПользователей = &ДляВнешнихПользователей
		|	И ТекущийСписок.ТипЭлементовНабора В (ЗНАЧЕНИЕ(Справочник.ГруппыДоступа.ПустаяСсылка), ЗНАЧЕНИЕ(Справочник.ГруппыПользователей.ПустаяСсылка))
		|	И (ИСТИНА В
		|				(ВЫБРАТЬ ПЕРВЫЕ 1
		|					ИСТИНА
		|				ИЗ
		|					Справочник.НаборыГруппДоступа КАК НаборыГруппДоступа
		|				ГДЕ
		|					НаборыГруппДоступа.НовыйНаборГруппДоступа = ТекущийСписок.Ссылка)
		|			ИЛИ ИСТИНА В
		|				(ВЫБРАТЬ ПЕРВЫЕ 1
		|					ИСТИНА
		|				ИЗ
		|					Справочник.НаборыГруппДоступа КАК НаборыГруппДоступа
		|				ГДЕ
		|					НаборыГруппДоступа.НовыйНаборГруппПользователей = ТекущийСписок.Ссылка))
		|	И ТекущийСписок.Ссылка > &ПоследняяОбработаннаяСсылка
		|	И &УточнениеПланаЗапроса
		|
		|УПОРЯДОЧИТЬ ПО
		|	ТекущийСписок.Ссылка";
		
	ИначеЕсли ВидКлючаДанных = "НаборыГруппРазрешенныеПользователям" Тогда
		Запрос.Текст =
		"ВЫБРАТЬ ПЕРВЫЕ " + МаркерРазмераПорции() + "
		|	ТекущийСписок.Ссылка КАК ТекущаяСсылка
		|ИЗ
		|	Справочник.НаборыГруппДоступа КАК ТекущийСписок
		|ГДЕ
		|	ТекущийСписок.ДляВнешнихПользователей = &ДляВнешнихПользователей
		|	И (ТекущийСписок.НовыйНаборГруппДоступа <> ЗНАЧЕНИЕ(Справочник.НаборыГруппДоступа.ПустаяСсылка)
		|			ИЛИ ТекущийСписок.НовыйНаборГруппПользователей <> ЗНАЧЕНИЕ(Справочник.НаборыГруппДоступа.ПустаяСсылка))
		|	И ТекущийСписок.Ссылка > &ПоследняяОбработаннаяСсылка
		|	И &УточнениеПланаЗапроса
		|
		|УПОРЯДОЧИТЬ ПО
		|	ТекущийСписок.Ссылка";
		
	ИначеЕсли ЭтоОбработкаУстаревшихЭлементов(ПараметрыОбновления) Тогда
		Возврат УстаревшиеНаборыГруппДоступаВСправочнике(ПараметрыОбновления, КоличествоВЗапросе);
	КонецЕсли;
	
	КоличествоВЗапросе = ?(КоличествоВЗапросе < 25, 25, ?(КоличествоВЗапросе > 10000, 10000, КоличествоВЗапросе));
	Запрос.Текст = СтрЗаменить(Запрос.Текст, МаркерРазмераПорции(), Формат(КоличествоВЗапросе, "ЧГ="));
	УстановитьУточнениеПланаЗапроса(Запрос.Текст);
	
	ЭлементыДанных = Запрос.Выполнить().Выгрузить();
	
	Возврат ЭлементыДанных;
	
КонецФункции

// Для процедуры ОбновитьПорциюЭлементов.
Процедура ОбновитьНаборыГруппДоступа(ЭлементыДанных, ПараметрыОбновления)
	
	ВидКлючаДанных = ПараметрыОбновления.ПоследнийОбновленныйЭлемент.ВидКлючаДанных;
	
	Если ВидКлючаДанных = "НаборыГруппСУстаревшимиПравами" Тогда
		ОбновитьНаборыГруппСУстаревшимиПравами(ЭлементыДанных, ПараметрыОбновления);
		
	ИначеЕсли ВидКлючаДанных = "НовыеНаборыИзОдногоПользователя" Тогда
		ОбновитьНаборыИзОдногоПользователяВСправочнике(ЭлементыДанных, ПараметрыОбновления);
		
	ИначеЕсли ВидКлючаДанных = "НаборыГруппДоступаНазначенныеПользователям" Тогда
		ОбновитьНаборыГруппНазначенныеПользователямВСправочнике(ЭлементыДанных, ПараметрыОбновления, Истина);
		
	ИначеЕсли ВидКлючаДанных = "НаборыГруппПользователейНазначенныеПользователям" Тогда
		ОбновитьНаборыГруппНазначенныеПользователямВСправочнике(ЭлементыДанных, ПараметрыОбновления, Ложь);
		
	ИначеЕсли ВидКлючаДанных = "НовыеНаборыГруппСУстаревшимиПравами" Тогда
		ОбновитьНаборыГруппСУстаревшимиПравами(ЭлементыДанных, ПараметрыОбновления);
		
	ИначеЕсли ВидКлючаДанных = "НаборыГруппРазрешенныеПользователям" Тогда
		ОбновитьНаборыГруппРазрешенныеПользователямВСправочнике(ЭлементыДанных, ПараметрыОбновления);
		
	ИначеЕсли ЭтоОбработкаУстаревшихЭлементов(ПараметрыОбновления) Тогда
		ОбработатьУстаревшиеНаборыВСправочнике(ЭлементыДанных, ПараметрыОбновления);
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ВыполнитьОбновлениеДоступаСписка.
Процедура ОчиститьПраваПустогоНабораГруппДоступа(ПараметрыОбновления)
	
	Если ПараметрыОбновления.ДляВнешнихПользователей Тогда
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА КАК ЗначениеИстина
	|ИЗ
	|	РегистрСведений.КлючиДоступаНаборовГруппДоступа КАК КлючиДоступаНаборовГруппДоступа
	|ГДЕ
	|	КлючиДоступаНаборовГруппДоступа.НаборГруппДоступа = ЗНАЧЕНИЕ(Справочник.НаборыГруппДоступа.ПустаяСсылка)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА КАК ЗначениеИстина
	|ИЗ
	|	РегистрСведений.КлючиДоступаПользователей КАК КлючиДоступаПользователей
	|ГДЕ
	|	КлючиДоступаПользователей.Пользователь = ЗНАЧЕНИЕ(Справочник.НаборыГруппДоступа.ПустаяСсылка)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА КАК ЗначениеИстина
	|ИЗ
	|	РегистрСведений.КлючиДоступаВнешнихПользователей КАК КлючиДоступаВнешнихПользователей
	|ГДЕ
	|	КлючиДоступаВнешнихПользователей.ВнешнийПользователь = ЗНАЧЕНИЕ(Справочник.НаборыГруппДоступа.ПустаяСсылка)";
	
	РезультатыЗапроса = Запрос.ВыполнитьПакет();
	
	Если Не РезультатыЗапроса[0].Пустой() Тогда
		НаборЗаписей = СлужебныйНаборЗаписей(РегистрыСведений.КлючиДоступаНаборовГруппДоступа);
		НаборЗаписей.Отбор.НаборГруппДоступа.Установить(Справочники.НаборыГруппДоступа.ПустаяСсылка());
		НаборЗаписей.Записать();
	КонецЕсли;
	
	Если Не РезультатыЗапроса[1].Пустой() Тогда
		НаборЗаписей = СлужебныйНаборЗаписей(РегистрыСведений.КлючиДоступаПользователей);
		НаборЗаписей.Отбор.Пользователь.Установить(Справочники.НаборыГруппДоступа.ПустаяСсылка());
		НаборЗаписей.Записать();
	КонецЕсли;
	
	Если Не РезультатыЗапроса[2].Пустой() Тогда
		НаборЗаписей = СлужебныйНаборЗаписей(РегистрыСведений.КлючиДоступаВнешнихПользователей);
		НаборЗаписей.Отбор.ВнешнийПользователь.Установить(Справочники.НаборыГруппДоступа.ПустаяСсылка());
		НаборЗаписей.Записать();
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ОбновитьНаборыГруппДоступа.
Процедура ОбновитьНаборыГруппСУстаревшимиПравами(ЭлементыДанных, ПараметрыОбновления)
	
	ПорцииНаборовГрупп = Новый Массив;
	НаборыГрупп = Новый Массив;
	
	Для Каждого ЭлементДанных Из ЭлементыДанных Цикл
		Если НаборыГрупп.Количество() > 4 Тогда
			ПорцииНаборовГрупп.Добавить(НаборыГрупп);
			НаборыГрупп = Новый Массив;
		КонецЕсли;
		НаборыГрупп.Добавить(ЭлементДанных.ТекущаяСсылка);
	КонецЦикла;
	ПорцииНаборовГрупп.Добавить(НаборыГрупп);
	
	Для Каждого НаборыГрупп Из ПорцииНаборовГрупп Цикл
		ОбновитьКлючиДоступаНаборовГрупп(ПараметрыОбновления,
			НаборыГрупп, "КлючиДоступаНаборовГруппДоступа", "ГруппыДоступа", "НаборГруппДоступа");
		
		Если Не ПараметрыОбновления.ДляВнешнихПользователей Тогда
			ОбновитьКлючиДоступаНаборовГрупп(ПараметрыОбновления,
				НаборыГрупп, "КлючиДоступаПользователей", "ГруппыПользователей", "Пользователь");
		Иначе
			ОбновитьКлючиДоступаНаборовГрупп(ПараметрыОбновления,
				НаборыГрупп, "КлючиДоступаВнешнихПользователей", "ГруппыВнешнихПользователей", "ВнешнийПользователь");
		КонецЕсли;
		
		Если ТребуетсяПрерватьОбработкуЭлементов(ПараметрыОбновления, НаборыГрупп.Количество()) Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ОбновитьНаборыГруппСУстаревшимиПравами.
Процедура ОбновитьКлючиДоступаНаборовГрупп(ПараметрыОбновления, НаборыГрупп, ИмяРегистраПрав,
				ИмяСправочникаГрупп, ИмяПоляНабораГрупп)
	
	ТекстЗапросаВыбораПорцииДляБлокировки =
	"ВЫБРАТЬ ПЕРВЫЕ 1000
	|	ВсеСтроки.НаборГруппДоступа КАК НаборГруппДоступа,
	|	СУММА(ВсеСтроки.ВидИзмененияСтроки) КАК ВидИзмененияСтроки,
	|	ВсеСтроки.КлючДоступа КАК КлючДоступа
	|ИЗ
	|	(ВЫБРАТЬ
	|		ГруппыВходящиеВНаборы.Ссылка КАК НаборГруппДоступа,
	|		КлючиДоступаГруппДоступа.КлючДоступа КАК КлючДоступа,
	|		МАКСИМУМ(КлючиДоступаГруппДоступа.Изменение) КАК Изменение,
	|		МАКСИМУМ(КлючиДоступаГруппДоступа.Добавление) КАК Добавление,
	|		1 КАК ВидИзмененияСтроки
	|	ИЗ
	|		РегистрСведений.КлючиДоступаГруппДоступа КАК КлючиДоступаГруппДоступа
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.НаборыГруппДоступа.Группы КАК ГруппыВходящиеВНаборы
	|			ПО (ГруппыВходящиеВНаборы.Группа = КлючиДоступаГруппДоступа.ГруппаДоступа)
	|				И (ТИПЗНАЧЕНИЯ(КлючиДоступаГруппДоступа.ГруппаДоступа) = ТИП(Справочник.ГруппыДоступа))
	|				И (&УсловиеОтбораНаборовГруппДоступа1)
	|	
	|	СГРУППИРОВАТЬ ПО
	|		КлючиДоступаГруппДоступа.КлючДоступа,
	|		ГруппыВходящиеВНаборы.Ссылка
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ВЫБРАТЬ
	|		&РазрешенныйПустойНабор,
	|		КлючиДоступаГруппДоступа.КлючДоступа,
	|		КлючиДоступаГруппДоступа.Изменение,
	|		КлючиДоступаГруппДоступа.Добавление,
	|		1
	|	ИЗ
	|		РегистрСведений.КлючиДоступаГруппДоступа КАК КлючиДоступаГруппДоступа
	|	ГДЕ
	|		КлючиДоступаГруппДоступа.ГруппаДоступа = ЗНАЧЕНИЕ(Справочник.ГруппыДоступа.ПустаяСсылка)
	|		И &УсловиеОтбораНаборовГруппДоступа2
	|		И &УточнениеПланаЗапроса
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ВЫБРАТЬ
	|		СтарыеДанные.НаборГруппДоступа,
	|		СтарыеДанные.КлючДоступа,
	|		СтарыеДанные.Изменение,
	|		СтарыеДанные.Добавление,
	|		-1
	|	ИЗ
	|		РегистрСведений.КлючиДоступаНаборовГруппДоступа КАК СтарыеДанные
	|	ГДЕ
	|		&УсловиеОтбораПравГрупп
	|		И &УсловиеОтбораНаборовГруппДоступа3) КАК ВсеСтроки
	|
	|СГРУППИРОВАТЬ ПО
	|	ВсеСтроки.НаборГруппДоступа,
	|	ВсеСтроки.КлючДоступа,
	|	ВсеСтроки.Изменение,
	|	ВсеСтроки.Добавление
	|
	|ИМЕЮЩИЕ
	|	СУММА(ВсеСтроки.ВидИзмененияСтроки) <> 0
	|
	|УПОРЯДОЧИТЬ ПО
	|	НаборГруппДоступа,
	|	ВидИзмененияСтроки,
	|	КлючДоступа";
	
	ТекстЗапросаВыбораПорцииДляОбновления =
	"ВЫБРАТЬ ПЕРВЫЕ 1000
	|	ВсеСтроки.НаборГруппДоступа КАК НаборГруппДоступа,
	|	ВсеСтроки.КлючДоступа КАК КлючДоступа,
	|	ВсеСтроки.Изменение КАК Изменение,
	|	ВсеСтроки.Добавление КАК Добавление,
	|	ИСТИНА КАК ЭтоПраваНабораГрупп,
	|	СУММА(ВсеСтроки.ВидИзмененияСтроки) КАК ВидИзмененияСтроки
	|ИЗ
	|	(ВЫБРАТЬ
	|		ГруппыВходящиеВНаборы.Ссылка КАК НаборГруппДоступа,
	|		КлючиДоступаГруппДоступа.КлючДоступа КАК КлючДоступа,
	|		МАКСИМУМ(КлючиДоступаГруппДоступа.Изменение) КАК Изменение,
	|		МАКСИМУМ(КлючиДоступаГруппДоступа.Добавление) КАК Добавление,
	|		1 КАК ВидИзмененияСтроки
	|	ИЗ
	|		РегистрСведений.КлючиДоступаГруппДоступа КАК КлючиДоступаГруппДоступа
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.НаборыГруппДоступа.Группы КАК ГруппыВходящиеВНаборы
	|			ПО (ГруппыВходящиеВНаборы.Группа = КлючиДоступаГруппДоступа.ГруппаДоступа)
	|				И (ТИПЗНАЧЕНИЯ(КлючиДоступаГруппДоступа.ГруппаДоступа) = ТИП(Справочник.ГруппыДоступа))
	|				И (&УсловиеОтбораНаборовГруппДоступа1)
	|				И (&УсловиеОтбораКлючейДоступа1)
	|	
	|	СГРУППИРОВАТЬ ПО
	|		КлючиДоступаГруппДоступа.КлючДоступа,
	|		ГруппыВходящиеВНаборы.Ссылка
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ВЫБРАТЬ
	|		&РазрешенныйПустойНабор,
	|		КлючиДоступаГруппДоступа.КлючДоступа,
	|		КлючиДоступаГруппДоступа.Изменение,
	|		КлючиДоступаГруппДоступа.Добавление,
	|		1
	|	ИЗ
	|		РегистрСведений.КлючиДоступаГруппДоступа КАК КлючиДоступаГруппДоступа
	|	ГДЕ
	|		КлючиДоступаГруппДоступа.ГруппаДоступа = ЗНАЧЕНИЕ(Справочник.ГруппыДоступа.ПустаяСсылка)
	|		И &УсловиеОтбораНаборовГруппДоступа2
	|		И &УсловиеОтбораКлючейДоступа2
	|		И &УточнениеПланаЗапроса
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ВЫБРАТЬ
	|		СтарыеДанные.НаборГруппДоступа,
	|		СтарыеДанные.КлючДоступа,
	|		СтарыеДанные.Изменение,
	|		СтарыеДанные.Добавление,
	|		-1
	|	ИЗ
	|		РегистрСведений.КлючиДоступаНаборовГруппДоступа КАК СтарыеДанные
	|	ГДЕ
	|		&УсловиеОтбораПравГрупп
	|		И &УсловиеОтбораНаборовГруппДоступа3
	|		И &УсловиеОтбораКлючейДоступа3) КАК ВсеСтроки
	|
	|СГРУППИРОВАТЬ ПО
	|	ВсеСтроки.НаборГруппДоступа,
	|	ВсеСтроки.КлючДоступа,
	|	ВсеСтроки.Изменение,
	|	ВсеСтроки.Добавление
	|
	|ИМЕЮЩИЕ
	|	СУММА(ВсеСтроки.ВидИзмененияСтроки) <> 0
	|
	|УПОРЯДОЧИТЬ ПО
	|	ВидИзмененияСтроки";
	
	ТекстЗапросаВыбораПорцииДляБлокировки = СтрЗаменить(ТекстЗапросаВыбораПорцииДляБлокировки,
		"ТИП(Справочник.ГруппыДоступа)", "ТИП(Справочник." + ИмяСправочникаГрупп + ")");
	
	ТекстЗапросаВыбораПорцииДляОбновления = СтрЗаменить(ТекстЗапросаВыбораПорцииДляОбновления,
		"НаборГруппДоступа", ИмяПоляНабораГрупп);
	
	ТекстЗапросаВыбораПорцииДляБлокировки = СтрЗаменить(ТекстЗапросаВыбораПорцииДляБлокировки,
		"НаборГруппДоступа", ИмяПоляНабораГрупп);
	
	ТекстЗапросаВыбораПорцииДляОбновления = СтрЗаменить(ТекстЗапросаВыбораПорцииДляОбновления,
		"ТИП(Справочник.ГруппыДоступа)", "ТИП(Справочник." + ИмяСправочникаГрупп + ")");
	
	ТекстЗапросаВыбораПорцииДляБлокировки = СтрЗаменить(ТекстЗапросаВыбораПорцииДляБлокировки,
		"РегистрСведений.КлючиДоступаНаборовГруппДоступа", "РегистрСведений." + ИмяРегистраПрав);
	
	ТекстЗапросаВыбораПорцииДляОбновления = СтрЗаменить(ТекстЗапросаВыбораПорцииДляОбновления,
		"РегистрСведений.КлючиДоступаНаборовГруппДоступа", "РегистрСведений." + ИмяРегистраПрав);
	
	ТекстЗапросаВыбораПорцииДляБлокировки = СтрЗаменить(ТекстЗапросаВыбораПорцииДляБлокировки,
		"&УсловиеОтбораПравГрупп", ?(ИмяСправочникаГрупп = "ГруппыДоступа", "ИСТИНА", "СтарыеДанные.ЭтоПраваНабораГрупп"));
	
	ТекстЗапросаВыбораПорцииДляОбновления = СтрЗаменить(ТекстЗапросаВыбораПорцииДляОбновления,
		"&УсловиеОтбораПравГрупп", ?(ИмяСправочникаГрупп = "ГруппыДоступа", "ИСТИНА", "СтарыеДанные.ЭтоПраваНабораГрупп"));
	
	Пока Истина Цикл
		Запрос = Новый Запрос;
		Запрос.Текст = ТекстЗапросаВыбораПорцииДляБлокировки;
		УстановитьУточнениеПланаЗапроса(Запрос.Текст, Истина);
		
		Запрос.УстановитьПараметр("РазрешенныйПустойНабор",
			УправлениеДоступомСлужебныйПовтИсп.РазрешенныйПустойНаборГруппДоступа());
		
		УстановитьУсловиеОтбораВЗапросе(Запрос, НаборыГрупп, "НаборыГрупп",
			"&УсловиеОтбораНаборовГруппДоступа1:ГруппыВходящиеВНаборы.Ссылка
			|&УсловиеОтбораНаборовГруппДоступа2:&РазрешенныйПустойНабор
			|&УсловиеОтбораНаборовГруппДоступа3:СтарыеДанные." + ИмяПоляНабораГрупп);
		
		Выгрузка = Запрос.Выполнить().Выгрузить();
		Если Выгрузка.Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Блокировка = Новый БлокировкаДанных;
		Для Каждого Строка Из Выгрузка Цикл
			ЭлементБлокировки = Блокировка.Добавить("РегистрСведений." + ИмяРегистраПрав);
			ЭлементБлокировки.УстановитьЗначение(ИмяПоляНабораГрупп, Строка[ИмяПоляНабораГрупп]);
			ЭлементБлокировки.УстановитьЗначение("КлючДоступа",      Строка.КлючДоступа);
		КонецЦикла;
		
		Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
			ЭлементБлокировки = Блокировка.Добавить("Справочник.НаборыГруппДоступа");
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
			ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КлючиДоступаГруппДоступа");
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		КонецЕсли;
		
		Выгрузка.Свернуть("КлючДоступа");
		КлючиДоступа = Выгрузка.ВыгрузитьКолонку("КлючДоступа");
		
		Запрос = Новый Запрос;
		Запрос.Текст = ТекстЗапросаВыбораПорцииДляОбновления;
		УстановитьУточнениеПланаЗапроса(Запрос.Текст, Истина);
		
		Запрос.УстановитьПараметр("РазрешенныйПустойНабор",
			УправлениеДоступомСлужебныйПовтИсп.РазрешенныйПустойНаборГруппДоступа());
		
		УстановитьУсловиеОтбораВЗапросе(Запрос, НаборыГрупп, "НаборыГрупп",
			"&УсловиеОтбораНаборовГруппДоступа1:ГруппыВходящиеВНаборы.Ссылка
			|&УсловиеОтбораНаборовГруппДоступа2:&РазрешенныйПустойНабор
			|&УсловиеОтбораНаборовГруппДоступа3:СтарыеДанные." + ИмяПоляНабораГрупп);
		
		УстановитьУсловиеОтбораВЗапросе(Запрос, КлючиДоступа, "КлючиДоступа",
			"&УсловиеОтбораКлючейДоступа1:КлючиДоступаГруппДоступа.КлючДоступа
			|&УсловиеОтбораКлючейДоступа2:КлючиДоступаГруппДоступа.КлючДоступа
			|&УсловиеОтбораКлючейДоступа3:СтарыеДанные.КлючДоступа");
		
		НаборЗаписей = СлужебныйНаборЗаписей(РегистрыСведений[ИмяРегистраПрав]);
		
		НачатьТранзакцию();
		Попытка
			Блокировка.Заблокировать();
			Выборка = Запрос.Выполнить().Выбрать();
			
			УдалениеЗавершено = Ложь;
			Пока Выборка.Следующий() Цикл
				НаборЗаписей.Отбор[ИмяПоляНабораГрупп].Установить(Выборка[ИмяПоляНабораГрупп]);
				НаборЗаписей.Отбор.КлючДоступа.Установить(Выборка.КлючДоступа);
				Если Не УдалениеЗавершено И Выборка.ВидИзмененияСтроки = 1 Тогда
					УдалениеЗавершено = Истина;
					ОднаЗапись = НаборЗаписей.Добавить();
				КонецЕсли;
				Если УдалениеЗавершено Тогда
					ЗаполнитьЗначенияСвойств(ОднаЗапись, Выборка);
				КонецЕсли;
				НаборЗаписей.Записать();
			КонецЦикла;
			
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ВыполнитьОбновлениеДоступаСписка.
Процедура УстранитьДублиНаборовИзОдногоПользователяВСправочнике(ПараметрыОбновления)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ДляВнешнихПользователей", ПараметрыОбновления.ДляВнешнихПользователей);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	НаборыГруппДоступа.Пользователь КАК Пользователь,
	|	НаборыГруппДоступа.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.НаборыГруппДоступа КАК НаборыГруппДоступа
	|ГДЕ
	|	НаборыГруппДоступа.ДляВнешнихПользователей = &ДляВнешнихПользователей
	|	И НаборыГруппДоступа.ТипЭлементовНабора = ЗНАЧЕНИЕ(Справочник.Пользователи.ПустаяСсылка)
	|	И НаборыГруппДоступа.Пользователь В
	|			(ВЫБРАТЬ РАЗЛИЧНЫЕ
	|				НаборыГруппДоступа.Пользователь КАК Пользователь
	|			ИЗ
	|				Справочник.НаборыГруппДоступа КАК НаборыГруппДоступа
	|			ГДЕ
	|				НаборыГруппДоступа.ТипЭлементовНабора = ЗНАЧЕНИЕ(Справочник.Пользователи.ПустаяСсылка)
	|			СГРУППИРОВАТЬ ПО
	|				НаборыГруппДоступа.Пользователь
	|			ИМЕЮЩИЕ
	|				КОЛИЧЕСТВО(НаборыГруппДоступа.Пользователь) > 1)";
	
	Если ПараметрыОбновления.ДляВнешнихПользователей Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "Справочник.Пользователи", "Справочник.ВнешниеПользователи");
	КонецЕсли;
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если Выборка.Ссылка.УникальныйИдентификатор() = Выборка.Пользователь.УникальныйИдентификатор() Тогда
			Продолжить;
		КонецЕсли;
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить("Справочник.НаборыГруппДоступа");
		ЭлементБлокировки.УстановитьЗначение("Ссылка", Выборка.Ссылка);
		НачатьТранзакцию();
		Попытка
			Блокировка.Заблокировать();
			Объект = СлужебныйЭлемент(Неопределено, Выборка.Ссылка);
			Если Объект <> Неопределено Тогда
				Объект.ТипЭлементовНабора = Неопределено;
				Объект.Записать();
			КонецЕсли;
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ОбновитьНаборыГруппДоступа.
Процедура ОбновитьНаборыИзОдногоПользователяВСправочнике(ЭлементыДанных, ПараметрыОбновления)
	
	Если ПараметрыОбновления.ДляВнешнихПользователей Тогда
		ТипЭлементовНабора = Справочники.ВнешниеПользователи.ПустаяСсылка();
		ПредставлениеЭлемента = НСтр("ru = 'Внешний пользователь'", ОбщегоНазначения.КодОсновногоЯзыка());
	Иначе
		ТипЭлементовНабора = Справочники.Пользователи.ПустаяСсылка();
		ПредставлениеЭлемента = НСтр("ru = 'Пользователь'", ОбщегоНазначения.КодОсновногоЯзыка());
	КонецЕсли;
	
	Для Каждого Строка Из ЭлементыДанных Цикл
		СсылкаНабора = Справочники.НаборыГруппДоступа.ПолучитьСсылку(Строка.ТекущаяСсылка.УникальныйИдентификатор());
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить("Справочник.НаборыГруппДоступа");
		ЭлементБлокировки.УстановитьЗначение("Ссылка", СсылкаНабора);
		
		НачатьТранзакцию();
		Попытка
			Блокировка.Заблокировать();
			
			Объект = СлужебныйЭлемент(Неопределено, СсылкаНабора);
			Если Объект = Неопределено Тогда
				Объект = СлужебныйЭлемент(Справочники.НаборыГруппДоступа);
				Объект.УстановитьСсылкуНового(СсылкаНабора);
			Иначе
				Объект.Группы.Очистить();
			КонецЕсли;
			Если Строка.Используется Тогда
				Объект.НеИспользуетсяС = '00010101';
			ИначеЕсли Не ЗначениеЗаполнено(Строка.НеИспользуетсяС) Тогда
				Объект.НеИспользуетсяС = ТекущаяДатаСеанса();
			КонецЕсли;
			Объект.ДляВнешнихПользователей = ПараметрыОбновления.ДляВнешнихПользователей;
			Объект.ТипЭлементовНабора = ТипЭлементовНабора;
			Объект.Пользователь = Строка.ТекущаяСсылка;
			Объект.Наименование = Строка.Наименование + " (" + ПредставлениеЭлемента + ")";
			Объект.Записать();
			
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
		
		Если ТребуетсяПрерватьОбработкуЭлементов(ПараметрыОбновления, 1) Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ВыполнитьОбновлениеДоступаСписка.
Процедура ЗаполнитьПустыеХешиНаборовГрупп(ПараметрыОбновления)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ДляВнешнихПользователей", ПараметрыОбновления.ДляВнешнихПользователей);
	Запрос.УстановитьПараметр("РазрешенныйПустойНабор",
		УправлениеДоступомСлужебныйПовтИсп.РазрешенныйПустойНаборГруппДоступа());
	Запрос.Текст =
	"ВЫБРАТЬ
	|	НаборыГруппДоступа.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.НаборыГруппДоступа КАК НаборыГруппДоступа
	|ГДЕ
	|	НаборыГруппДоступа.ДляВнешнихПользователей = &ДляВнешнихПользователей
	|	И НаборыГруппДоступа.ТипЭлементовНабора В (ЗНАЧЕНИЕ(Справочник.ГруппыДоступа.ПустаяСсылка), ЗНАЧЕНИЕ(Справочник.ГруппыПользователей.ПустаяСсылка))
	|	И НаборыГруппДоступа.Хеш = 0
	|	И НаборыГруппДоступа.Ссылка <> &РазрешенныйПустойНабор";
	
	Если ПараметрыОбновления.ДляВнешнихПользователей Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "Справочник.ГруппыПользователей", "Справочник.ГруппыВнешнихПользователей");
	КонецЕсли;
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить("Справочник.НаборыГруппДоступа");
		ЭлементБлокировки.УстановитьЗначение("Ссылка", Выборка.Ссылка);
		НачатьТранзакцию();
		Попытка
			Блокировка.Заблокировать();
			Объект = СлужебныйЭлемент(Неопределено, Выборка.Ссылка);
			Если Объект <> Неопределено Тогда
				ЗаполнитьХешНабораГрупп(Объект);
				Объект.Записать();
			КонецЕсли;
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
	КонецЦикла;
	
КонецПроцедуры

// Для функции НаборыГруппДоступаДляОбновления.
Функция НаборыИзОдногоПользователяДляОбновленияНазначенныхНаборовГруппДоступа(ПараметрыОбновления,
			КоличествоВЗапросе)
	
	Если Не ПараметрыОбновления.ДляВнешнихПользователей Тогда
		ТекстЗапросаГрупп =
		"ВЫБРАТЬ
		|	ГруппыДоступа.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.ГруппыДоступа КАК ГруппыДоступа
		|ГДЕ
		|	ГруппыДоступа.Профиль <> ЗНАЧЕНИЕ(Справочник.ПрофилиГруппДоступа.Администратор)
		|	И НЕ ГруппыДоступа.ПометкаУдаления
		|	И НЕ ГруппыДоступа.Профиль.ПометкаУдаления
		|	И ИСТИНА В
		|			(ВЫБРАТЬ ПЕРВЫЕ 1
		|				ИСТИНА
		|			ИЗ
		|				Справочник.ГруппыДоступа.Пользователи КАК ПользователиГруппДоступа
		|			ГДЕ
		|				ПользователиГруппДоступа.Ссылка = ГруппыДоступа.Ссылка)
		|	И ВЫБОР
		|			КОГДА ИСТИНА В
		|					(ВЫБРАТЬ ПЕРВЫЕ 1
		|						ИСТИНА
		|					ИЗ
		|						Справочник.ПрофилиГруппДоступа.Назначение КАК Назначение
		|					ГДЕ
		|						Назначение.Ссылка = ГруппыДоступа.Профиль
		|						И ТИПЗНАЧЕНИЯ(Назначение.ТипПользователей) = ТИП(Справочник.Пользователи))
		|				ТОГДА ИСТИНА
		|			КОГДА НЕ ЛОЖЬ В
		|						(ВЫБРАТЬ ПЕРВЫЕ 1
		|							ЛОЖЬ
		|						ИЗ
		|							Справочник.ПрофилиГруппДоступа.Назначение КАК Назначение
		|						ГДЕ
		|							Назначение.Ссылка = ГруппыДоступа.Профиль)
		|				ТОГДА ИСТИНА
		|			ИНАЧЕ ЛОЖЬ
		|		КОНЕЦ
		|
		|УПОРЯДОЧИТЬ ПО
		|	Ссылка";
	Иначе
		ТекстЗапросаГрупп =
		"ВЫБРАТЬ
		|	ГруппыДоступа.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.ГруппыДоступа КАК ГруппыДоступа
		|ГДЕ
		|	ГруппыДоступа.Профиль <> ЗНАЧЕНИЕ(Справочник.ПрофилиГруппДоступа.Администратор)
		|	И НЕ ГруппыДоступа.ПометкаУдаления
		|	И НЕ ГруппыДоступа.Профиль.ПометкаУдаления
		|	И ИСТИНА В
		|			(ВЫБРАТЬ ПЕРВЫЕ 1
		|				ИСТИНА
		|			ИЗ
		|				Справочник.ГруппыДоступа.Пользователи КАК ПользователиГруппДоступа
		|			ГДЕ
		|				ПользователиГруппДоступа.Ссылка = ГруппыДоступа.Ссылка)
		|	И ИСТИНА В
		|			(ВЫБРАТЬ ПЕРВЫЕ 1
		|				ИСТИНА
		|			ИЗ
		|				Справочник.ПрофилиГруппДоступа.Назначение КАК Назначение
		|			ГДЕ
		|				Назначение.Ссылка = ГруппыДоступа.Профиль
		|				И Назначение.ТипПользователей <> НЕОПРЕДЕЛЕНО
		|				И ТИПЗНАЧЕНИЯ(Назначение.ТипПользователей) <> ТИП(Справочник.Пользователи))
		|
		|УПОРЯДОЧИТЬ ПО
		|	Ссылка";
	КонецЕсли;
	
	ТекстЗапросаНовыхНаборовГрупп =
	"ВЫБРАТЬ
	|	ГруппыДоступаПользователей.Пользователь КАК Пользователь,
	|	СУММА(НомераГрупп.ЧастьНомера1) КАК ЧастьНомера1
	|ПОМЕСТИТЬ НовыеНаборыГрупп
	|ИЗ
	|	(ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		СоставыГруппПользователей.Пользователь КАК Пользователь,
	|		ПользователиГруппДоступа.Ссылка КАК ГруппаДоступа
	|	ИЗ
	|		Справочник.ГруппыДоступа.Пользователи КАК ПользователиГруппДоступа
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|			ПО (СоставыГруппПользователей.ГруппаПользователей = ПользователиГруппДоступа.Пользователь)
	|				И (ТИПЗНАЧЕНИЯ(СоставыГруппПользователей.Пользователь) = ТИП(Справочник.Пользователи))
	|				И (ВЫРАЗИТЬ(СоставыГруппПользователей.Пользователь КАК Справочник.Пользователи).ИдентификаторПользователяИБ <> &ПустойУникальныйИдентификатор)
	|				И (СоставыГруппПользователей.Используется)) КАК ГруппыДоступаПользователей
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ НомераГрупп КАК НомераГрупп
	|		ПО ГруппыДоступаПользователей.ГруппаДоступа = НомераГрупп.Группа
	|
	|СГРУППИРОВАТЬ ПО
	|	ГруппыДоступаПользователей.Пользователь
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	ГруппыДоступаПользователей.Пользователь";
	
	ЭлементыДанных = НаборыИзОдногоПользователяДляОбновленияНазначенныхНаборовГрупп(ПараметрыОбновления,
		ТекстЗапросаГрупп, ТекстЗапросаНовыхНаборовГрупп, "НаборГруппДоступа", "ГруппыДоступа");
	
	КоличествоВЗапросе = ЭлементыДанных.Количество();
	Возврат ЭлементыДанных;
	
КонецФункции

// Для функции НаборыГруппДоступаДляОбновления.
Функция НаборыИзОдногоПользователяДляОбновленияНазначенныхНаборовГруппПользователей(ПараметрыОбновления,
			КоличествоВЗапросе)
	
	ТекстЗапросаГрупп =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	СоставыГруппПользователей.ГруппаПользователей КАК Ссылка
	|ИЗ
	|	РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|ГДЕ
	|	СоставыГруппПользователей.Используется
	|	И ТИПЗНАЧЕНИЯ(СоставыГруппПользователей.ГруппаПользователей) = ТИП(Справочник.ГруппыПользователей)
	|
	|УПОРЯДОЧИТЬ ПО
	|	СоставыГруппПользователей.ГруппаПользователей";
	
	Если ПараметрыОбновления.ДляВнешнихПользователей Тогда
		ТекстЗапросаГрупп = СтрЗаменить(ТекстЗапросаГрупп,
			"Справочник.ГруппыПользователей", "Справочник.ГруппыВнешнихПользователей");
	КонецЕсли;
	
	ТекстЗапросаНовыхНаборовГрупп =
	"ВЫБРАТЬ
	|	СоставыГруппПользователей.Пользователь КАК Пользователь,
	|	СУММА(НомераГрупп.ЧастьНомера1) КАК ЧастьНомера1
	|ПОМЕСТИТЬ НовыеНаборыГрупп
	|ИЗ
	|	РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ НомераГрупп КАК НомераГрупп
	|		ПО СоставыГруппПользователей.ГруппаПользователей = НомераГрупп.Группа
	|			И (ТИПЗНАЧЕНИЯ(СоставыГруппПользователей.Пользователь) = ТИП(Справочник.Пользователи))
	|			И (ВЫРАЗИТЬ(СоставыГруппПользователей.Пользователь КАК Справочник.Пользователи).ИдентификаторПользователяИБ <> &ПустойУникальныйИдентификатор)
	|			И (СоставыГруппПользователей.Используется)
	|
	|СГРУППИРОВАТЬ ПО
	|	СоставыГруппПользователей.Пользователь
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	СоставыГруппПользователей.Пользователь";
	
	Если ПараметрыОбновления.ДляВнешнихПользователей Тогда
		ИмяСправочникаГрупп = "ГруппыВнешнихПользователей";
		ПредставлениеЭлемента = НСтр("ru = 'Группы внешних пользователей'",
			ОбщегоНазначения.КодОсновногоЯзыка());
	Иначе
		ИмяСправочникаГрупп = "ГруппыПользователей";
		ПредставлениеЭлемента = НСтр("ru = 'Группы пользователей'",
			ОбщегоНазначения.КодОсновногоЯзыка());
	КонецЕсли;
	
	ЭлементыДанных = НаборыИзОдногоПользователяДляОбновленияНазначенныхНаборовГрупп(ПараметрыОбновления,
		ТекстЗапросаГрупп, ТекстЗапросаНовыхНаборовГрупп, "НаборГруппПользователей", ИмяСправочникаГрупп);
	
	КоличествоВЗапросе = ЭлементыДанных.Количество();
	Возврат ЭлементыДанных;
	
КонецФункции

// Для функций НаборыИзОдногоПользователяДляОбновленияНазначенныхНаборовГруппДоступа,
// НаборыИзОдногоПользователяДляОбновленияНазначенныхНаборовГруппПользователей.
//
Функция НаборыИзОдногоПользователяДляОбновленияНазначенныхНаборовГрупп(ПараметрыОбновления,
			ТекстЗапросаГрупп, ТекстЗапросаНовыхНаборовГрупп, ИмяПоляНабора, ИмяСправочникаГрупп)
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапросаГрупп;
	НомераГрупп = Запрос.Выполнить().Выгрузить();
	
	ИменаЧастейНомера = Новый Массив;
	ЗаполнитьНомераГрупп(НомераГрупп, ИменаЧастейНомера);
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("НомераГрупп", НомераГрупп);
	Запрос.УстановитьПараметр("ДляВнешнихПользователей", ПараметрыОбновления.ДляВнешнихПользователей);
	Запрос.УстановитьПараметр("ПустойУникальныйИдентификатор",
		ОбщегоНазначенияКлиентСервер.ПустойУникальныйИдентификатор());
	
	Запрос.Текст =
	"ВЫБРАТЬ
	|	НомераГрупп.Ссылка КАК Группа,
	|	НомераГрупп.ЧастьНомера1 КАК ЧастьНомера1
	|ПОМЕСТИТЬ НомераГрупп
	|ИЗ
	|	&НомераГрупп КАК НомераГрупп
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	НЕОПРЕДЕЛЕНО КАК Пользователь,
	|	СУММА(НомераГрупп.ЧастьНомера1) КАК ЧастьНомера1
	|ПОМЕСТИТЬ НовыеНаборыГрупп
	|ИЗ
	|	НомераГрупп КАК НомераГрупп
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	НаборыГрупп.Ссылка КАК НаборИзОдногоПользователя,
	|	НаборыГрупп.Пользователь КАК Пользователь,
	|	ЕСТЬNULL(СУММА(НомераГрупп.ЧастьНомера1), -1) КАК ЧастьНомера1
	|ПОМЕСТИТЬ СтарыеНаборыГрупп
	|ИЗ
	|	Справочник.НаборыГруппДоступа КАК НаборыГрупп
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.НаборыГруппДоступа.Группы КАК ГруппыНаборов
	|		ПО (ГруппыНаборов.Ссылка = НаборыГрупп.РазрешенныйНаборГруппДоступа)
	|		ЛЕВОЕ СОЕДИНЕНИЕ НомераГрупп КАК НомераГрупп
	|		ПО (ГруппыНаборов.Группа = НомераГрупп.Группа)
	|ГДЕ
	|	НаборыГрупп.ДляВнешнихПользователей = &ДляВнешнихПользователей
	|	И НаборыГрупп.ТипЭлементовНабора = ЗНАЧЕНИЕ(Справочник.Пользователи.ПустаяСсылка)
	|	И НаборыГрупп.НеИспользуетсяС = ДАТАВРЕМЯ(1, 1, 1)
	|	И НаборыГрупп.НовыйНаборГруппДоступа = ЗНАЧЕНИЕ(Справочник.НаборыГруппДоступа.ПустаяСсылка)
	|	И &УточнениеПланаЗапроса
	|
	|СГРУППИРОВАТЬ ПО
	|	НаборыГрупп.Ссылка,
	|	НаборыГрупп.Пользователь
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	НаборыГрупп.Ссылка,
	|	НаборыГрупп.Пользователь,
	|	ЕСТЬNULL(СУММА(НомераГрупп.ЧастьНомера1), -1)
	|ИЗ
	|	Справочник.НаборыГруппДоступа КАК НаборыГрупп
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.НаборыГруппДоступа.Группы КАК ГруппыНаборов
	|		ПО (ГруппыНаборов.Ссылка = НаборыГрупп.НовыйНаборГруппДоступа)
	|		ЛЕВОЕ СОЕДИНЕНИЕ НомераГрупп КАК НомераГрупп
	|		ПО (ГруппыНаборов.Группа = НомераГрупп.Группа)
	|ГДЕ
	|	НаборыГрупп.ДляВнешнихПользователей = &ДляВнешнихПользователей
	|	И НаборыГрупп.ТипЭлементовНабора = ЗНАЧЕНИЕ(Справочник.Пользователи.ПустаяСсылка)
	|	И НаборыГрупп.НеИспользуетсяС = ДАТАВРЕМЯ(1, 1, 1)
	|	И НаборыГрупп.НовыйНаборГруппДоступа <> ЗНАЧЕНИЕ(Справочник.НаборыГруппДоступа.ПустаяСсылка)
	|	И &УточнениеПланаЗапроса
	|
	|СГРУППИРОВАТЬ ПО
	|	НаборыГрупп.Ссылка,
	|	НаборыГрупп.Пользователь
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	СтарыеНаборы.НаборИзОдногоПользователя КАК НаборИзОдногоПользователя,
	|	НовыеНаборы.ЧастьНомера1 КАК ЧастьНомера1
	|ПОМЕСТИТЬ НаборыГруппДляОбновления
	|ИЗ
	|	СтарыеНаборыГрупп КАК СтарыеНаборы
	|		ЛЕВОЕ СОЕДИНЕНИЕ НовыеНаборыГрупп КАК НовыеНаборы
	|		ПО (НовыеНаборы.Пользователь = СтарыеНаборы.Пользователь)
	|ГДЕ
	|	СтарыеНаборы.ЧастьНомера1 <> НовыеНаборы.ЧастьНомера1
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	НаборыГрупп.Ссылка КАК НаборГрупп,
	|	СУММА(НомераГрупп.ЧастьНомера1) КАК ЧастьНомера1
	|ПОМЕСТИТЬ СуществующиеНаборыГрупп
	|ИЗ
	|	Справочник.НаборыГруппДоступа КАК НаборыГрупп
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.НаборыГруппДоступа.Группы КАК ГруппыНаборов
	|		ПО (НаборыГрупп.ДляВнешнихПользователей = &ДляВнешнихПользователей)
	|			И (НаборыГрупп.ТипЭлементовНабора = ЗНАЧЕНИЕ(Справочник.ГруппыДоступа.ПустаяСсылка))
	|			И (ГруппыНаборов.Ссылка = НаборыГрупп.Ссылка)
	|		ЛЕВОЕ СОЕДИНЕНИЕ НомераГрупп КАК НомераГрупп
	|		ПО (ГруппыНаборов.Группа = НомераГрупп.Группа)
	|			И (&УточнениеПланаЗапроса)
	|
	|СГРУППИРОВАТЬ ПО
	|	НаборыГрупп.Ссылка
	|
	|ИМЕЮЩИЕ
	|	НЕ СУММА(НомераГрупп.ЧастьНомера1) ЕСТЬ NULL
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	НовыеНаборы.НаборИзОдногоПользователя КАК ТекущаяСсылка,
	|	ЕСТЬNULL(СуществующиеНаборы.НаборГрупп, ЗНАЧЕНИЕ(Справочник.НаборыГруппДоступа.ПустаяСсылка)) КАК НаборГрупп,
	|	ИСТИНА В
	|		(ВЫБРАТЬ ПЕРВЫЕ 1
	|			ИСТИНА
	|		ИЗ
	|			Справочник.НаборыГруппДоступа КАК ВсеНаборы
	|		ГДЕ
	|			ВсеНаборы.ДляВнешнихПользователей = &ДляВнешнихПользователей
	|			И ВсеНаборы.НовыйНаборГруппДоступа = СуществующиеНаборы.НаборГрупп) КАК НаборГруппНовый,
	|	НовыеНаборы.ЧастьНомера1 КАК ЧастьНомера1
	|ИЗ
	|	НаборыГруппДляОбновления КАК НовыеНаборы
	|		ЛЕВОЕ СОЕДИНЕНИЕ СуществующиеНаборыГрупп КАК СуществующиеНаборы
	|		ПО (СуществующиеНаборы.ЧастьНомера1 = НовыеНаборы.ЧастьНомера1)
	|
	|УПОРЯДОЧИТЬ ПО
	|	ТекущаяСсылка,
	|	НаборГрупп";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст,
		"ВЫБРАТЬ
		|	НЕОПРЕДЕЛЕНО КАК Пользователь,
		|	СУММА(НомераГрупп.ЧастьНомера1) КАК ЧастьНомера1
		|ПОМЕСТИТЬ НовыеНаборыГрупп
		|ИЗ
		|	НомераГрупп КАК НомераГрупп",
		ТекстЗапросаНовыхНаборовГрупп);
	
	Если ПараметрыОбновления.ДляВнешнихПользователей Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "Справочник.Пользователи", "Справочник.ВнешниеПользователи");
	КонецЕсли;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ЗНАЧЕНИЕ(Справочник.ГруппыДоступа.ПустаяСсылка)",
		"ЗНАЧЕНИЕ(Справочник." + ИмяСправочникаГрупп + ".ПустаяСсылка)");
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "НовыйНаборГруппДоступа",       "Новый"       + ИмяПоляНабора);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "РазрешенныйНаборГруппДоступа", "Разрешенный" + ИмяПоляНабора);
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст,
		"	НомераГрупп.ЧастьНомера1 КАК ЧастьНомера1",
		"	НомераГрупп." + СтрСоединить(ИменаЧастейНомера, ",
		|	НомераГрупп."));
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст,
		"	ЕСТЬNULL(СУММА(НомераГрупп.ЧастьНомера1), -1)
		|",
		"	ЕСТЬNULL(СУММА(НомераГрупп." + СтрСоединить(ИменаЧастейНомера, "), -1),
		|	ЕСТЬNULL(СУММА(НомераГрупп.") + "), -1)
		|");
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст,
		"	НовыеНаборы.ЧастьНомера1 КАК ЧастьНомера1",
		"	НовыеНаборы." + СтрСоединить(ИменаЧастейНомера, ",
		|	НовыеНаборы."));
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст,
		"	НЕ СУММА(НомераГрупп.ЧастьНомера1) ЕСТЬ NULL",
		"	НЕ СУММА(НомераГрупп." + СтрСоединить(ИменаЧастейНомера, ") ЕСТЬ NULL
		|	И НЕ СУММА(НомераГрупп.") + ") ЕСТЬ NULL");
	
	УсловиеОтбора = "";
	УсловиеСоединения = "";
	ПоляСуммированияСтарых = "";
	ПоляСуммированияНовых = "";
	Для Каждого ИмяЧастиНомера Из ИменаЧастейНомера Цикл
		УсловиеОтбора = УсловиеОтбора + ?(УсловиеОтбора = "", "","
		|			ИЛИ ") + "СтарыеНаборы." + ИмяЧастиНомера + " <> НовыеНаборы." + ИмяЧастиНомера;
		УсловиеСоединения = УсловиеСоединения + ?(УсловиеСоединения = "", "", "
		|			И ") + "(СуществующиеНаборы." + ИмяЧастиНомера + " = НовыеНаборы." + ИмяЧастиНомера + ")";
		ПоляСуммированияСтарых = ПоляСуммированияСтарых + ?(ПоляСуммированияСтарых = "", "", ",
		|	") + "ЕСТЬNULL(СУММА(НомераГрупп." + ИмяЧастиНомера + "), -1) КАК " + ИмяЧастиНомера;
		ПоляСуммированияНовых = ПоляСуммированияНовых + ?(ПоляСуммированияНовых = "", "", ",
		|	") + "СУММА(НомераГрупп." + ИмяЧастиНомера + ") КАК " + ИмяЧастиНомера;
	КонецЦикла;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст,
		"СтарыеНаборы.ЧастьНомера1 <> НовыеНаборы.ЧастьНомера1", "(" + УсловиеОтбора + ")");
	Запрос.Текст = СтрЗаменить(Запрос.Текст,
		"(СуществующиеНаборы.ЧастьНомера1 = НовыеНаборы.ЧастьНомера1)", УсловиеСоединения);
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст,
		"ЕСТЬNULL(СУММА(НомераГрупп.ЧастьНомера1), -1) КАК ЧастьНомера1", ПоляСуммированияСтарых);
	Запрос.Текст = СтрЗаменить(Запрос.Текст,
		"СУММА(НомераГрупп.ЧастьНомера1) КАК ЧастьНомера1", ПоляСуммированияНовых);
	
	УстановитьУточнениеПланаЗапроса(Запрос.Текст);
	
	Результат = Запрос.Выполнить().Выгрузить();
	
	СписокИменЧастейНабора = СтрСоединить(ИменаЧастейНомера, ", ");
	НовыеНаборыГрупп = Результат.Скопировать(Новый Массив, СписокИменЧастейНабора);
	НовыеНаборыГрупп.Колонки.Добавить("ГруппыНабора");
	НовыеНаборыГрупп.Колонки.Добавить("ИдентификаторГрупп");
	Отбор = Новый Структура(СписокИменЧастейНабора);
	
	ЭлементыДанных = Результат.Скопировать(Новый Массив, "ТекущаяСсылка, НаборГрупп, НаборГруппНовый");
	ЭлементыДанных.Колонки.Добавить("ГруппыНабора");
	ЭлементыДанных.Колонки.Добавить("ИдентификаторГрупп");
	
	Для Каждого Строка Из Результат Цикл
		НоваяСтрока = ЭлементыДанных.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		Если ЗначениеЗаполнено(Строка.НаборГрупп) Тогда
			Продолжить;
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(Отбор, Строка);
		НайденныеСтроки = НовыеНаборыГрупп.НайтиСтроки(Отбор);
		Если НайденныеСтроки.Количество() = 0 Тогда
			СвойстваНовогоНабора = НовыеНаборыГрупп.Добавить();
			ЗаполнитьЗначенияСвойств(СвойстваНовогоНабора, Строка);
			СвойстваНовогоНабора.ИдентификаторГрупп = Новый УникальныйИдентификатор;
			СвойстваНовогоНабора.ГруппыНабора =
				ГруппыНабораПоНомерам(НомераГрупп, ИменаЧастейНомера, СвойстваНовогоНабора);
		Иначе
			СвойстваНовогоНабора = НайденныеСтроки[0];
		КонецЕсли;
		НоваяСтрока.ГруппыНабора       = СвойстваНовогоНабора.ГруппыНабора;
		НоваяСтрока.ИдентификаторГрупп = СвойстваНовогоНабора.ИдентификаторГрупп;
	КонецЦикла;
	
	Возврат ЭлементыДанных;
	
КонецФункции

// Для процедуры ОбновитьПорциюЭлементов.
Процедура ОбновитьНаборыГруппНазначенныеПользователямВСправочнике(ЭлементыДанных,
			ПараметрыОбновления, ЭтоОбновлениеНазначенныхНаборовГруппДоступа)
	
	ДляВнешнихПользователей = ПараметрыОбновления.ДляВнешнихПользователей;
	
	Если ЭтоОбновлениеНазначенныхНаборовГруппДоступа Тогда
		ИмяПоляНабора = "НаборГруппДоступа";
		ТипЭлементовНабора = Справочники.ГруппыДоступа.ПустаяСсылка();
		ПредставлениеЭлементовГрупп = НСтр("ru = 'Группы доступа'",
			ОбщегоНазначения.КодОсновногоЯзыка());
		
	Иначе
		ИмяПоляНабора = "НаборГруппПользователей";
		Если Не ДляВнешнихПользователей Тогда
			ТипЭлементовНабора = Справочники.ГруппыПользователей.ПустаяСсылка();
			ПредставлениеЭлементовГрупп = НСтр("ru = 'Группы пользователей'",
				ОбщегоНазначения.КодОсновногоЯзыка());
		Иначе
			ТипЭлементовНабора = Справочники.ГруппыВнешнихПользователей.ПустаяСсылка();
			ПредставлениеЭлементовГрупп = НСтр("ru = 'Группы внешних пользователей'",
				ОбщегоНазначения.КодОсновногоЯзыка());
		КонецЕсли;
	КонецЕсли;
	
	НовыеНаборыГрупп = Новый Соответствие;
	
	Для Каждого Строка Из ЭлементыДанных Цикл
		Если Не ЗначениеЗаполнено(Строка.НаборГрупп) Тогда
			НаборГрупп = НовыеНаборыГрупп.Получить(Строка.ИдентификаторГрупп);
			Если НаборГрупп = Неопределено Тогда
				Строка.НаборГрупп = НовыйНаборГрупп(Строка.ГруппыНабора,
					ПараметрыОбновления.ДляВнешнихПользователей,
					ТипЭлементовНабора,
					ПредставлениеЭлементовГрупп,
					Строка.НаборГруппНовый);
				НовыеНаборыГрупп.Вставить(Строка.ИдентификаторГрупп, Строка.НаборГрупп);
			Иначе
				Строка.НаборГрупп = НаборГрупп;
			КонецЕсли;
		КонецЕсли;
		
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить("Справочник.НаборыГруппДоступа");
		ЭлементБлокировки.УстановитьЗначение("Ссылка", Строка.ТекущаяСсылка);
		
		НачатьТранзакцию();
		Попытка
			Блокировка.Заблокировать();
			
			Объект = СлужебныйЭлемент(Неопределено, Строка.ТекущаяСсылка);
			Если Строка.НаборГруппНовый Тогда
				Объект["Новый" + ИмяПоляНабора] = Строка.НаборГрупп;
			Иначе
				Объект["Разрешенный" + ИмяПоляНабора] = Строка.НаборГрупп;
				Объект["Новый" + ИмяПоляНабора] = ПараметрыОбновления.ПустойНаборГруппДоступа;
			КонецЕсли;
			Объект.Записать();
			
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
		
		Если ТребуетсяПрерватьОбработкуЭлементов(ПараметрыОбновления, 1) Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ОбновитьНаборыГруппВСправочнике.
Процедура ЗаполнитьНомераГрупп(НомераГрупп, ИменаЧастейНомера)
	
	КоличествоГрупп = НомераГрупп.Количество();
	КоличествоЧастейНомера = Цел(КоличествоГрупп / 64) + 1;
	ОписаниеТиповНомера = Новый ОписаниеТипов("Число",,,
		Новый КвалификаторыЧисла(31, 0, ДопустимыйЗнак.Неотрицательный));
	
	Для Счетчик = 1 По КоличествоЧастейНомера Цикл
		ИмяЧастиНомера = "ЧастьНомера" + Формат(Счетчик, "ЧРГ=");
		ИменаЧастейНомера.Добавить(ИмяЧастиНомера);
		НомераГрупп.Колонки.Добавить(ИмяЧастиНомера, ОписаниеТиповНомера);
	КонецЦикла;
	
	ТекущаяЧастьНомера = 1;
	ТекущееИмяЧастиНомера = ИменаЧастейНомера[0];
	ТекущийНомерГруппы = 1;
	МаксимальныйНомерГруппыВЧастиНомера = 9223372036854775808; // 2^63.
	Для Каждого Строка Из НомераГрупп Цикл
		Строка[ТекущееИмяЧастиНомера] = ТекущийНомерГруппы;
		ТекущийНомерГруппы = ТекущийНомерГруппы * 2;
		Если ТекущийНомерГруппы > МаксимальныйНомерГруппыВЧастиНомера Тогда
			ТекущийНомерГруппы = 1;
			ТекущееИмяЧастиНомера = ИменаЧастейНомера[ТекущаяЧастьНомера];
			ТекущаяЧастьНомера = ТекущаяЧастьНомера + 1;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ОбновитьНаборыГруппВСправочнике.
Функция НовыйНаборГрупп(ГруппыНабора, ДляВнешнихПользователей, ТипЭлементовНабора,
			ПредставлениеЭлементовГрупп, НаборГруппДобавлен)
	
	НоваяСсылка = Справочники.НаборыГруппДоступа.ПолучитьСсылку();
	Объект = СлужебныйЭлемент(Справочники.НаборыГруппДоступа);
	Объект.УстановитьСсылкуНового(НоваяСсылка);
	Объект.ДляВнешнихПользователей = ДляВнешнихПользователей;
	Объект.ТипЭлементовНабора = ТипЭлементовНабора;
	Объект.Наименование = Строка(НоваяСсылка.УникальныйИдентификатор()) + " (" + ПредставлениеЭлементовГрупп + ")";
	
	Для Каждого ГруппаНабора Из ГруппыНабора Цикл
		Объект.Группы.Добавить().Группа = ГруппаНабора;
	КонецЦикла;
	
	ЗаполнитьХешНабораГрупп(Объект);
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить("Справочник.НаборыГруппДоступа");
	ЭлементБлокировки.УстановитьЗначение("ТипЭлементовНабора", Объект.ТипЭлементовНабора);
	ЭлементБлокировки.УстановитьЗначение("Хеш", Объект.Хеш);
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		Если Не НаборГруппСуществует(Объект) Тогда
			Объект.Записать();
			НаборГруппДобавлен = Истина;
		КонецЕсли;
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат Объект.Ссылка;
	
КонецФункции

// Для функции НовыйНаборГрупп и процедуры ЗаполнитьПустыеХешиНаборовГрупп.
Процедура ЗаполнитьХешНабораГрупп(Объект)
	
	Объект.Группы.Сортировать("Группа", Новый СравнениеЗначений);
	
	ДанныеДляХеша = Объект.Группы.ВыгрузитьКолонку("Группа");
	СтрокаДляХеша = СтрокаДанныхДляХеширования(ДанныеДляХеша);
	Хеширование = Новый ХешированиеДанных(ХешФункция.CRC32);
	Хеширование.Добавить(СтрокаДляХеша);
	Объект.Хеш = Хеширование.ХешСумма;
	
КонецПроцедуры

// Для функции НовыйНаборГрупп.
Функция ГруппыНабораПоНомерам(НомераГрупп, ИменаЧастейНомера, ЧастиНомера)
	
	ГруппыНабора = Новый Массив;
	ИндексГруппы = 0;
	Делитель = 4294967296; // 2^32.
	
	Для Каждого ИмяЧастиНомера Из ИменаЧастейНомера Цикл
		ЧастьНомера = ЧастиНомера[ИмяЧастиНомера];
		Для НомерБлокаЧастиНомера = 1 По 2 Цикл
			Целое = Цел(ЧастьНомера / Делитель);
			БлокЧастиНомера = ЧастьНомера - Целое * Делитель;
			ЧастьНомера = Целое;
			Если БлокЧастиНомера > 0 Тогда
				Для НомерБита = 0 По 31 Цикл
					Если ПроверитьБит(БлокЧастиНомера, НомерБита) Тогда
						ГруппыНабора.Добавить(НомераГрупп[ИндексГруппы + НомерБита].Ссылка);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			ИндексГруппы = ИндексГруппы + 32;
		КонецЦикла;
	КонецЦикла;
	
	Возврат ГруппыНабора;
	
КонецФункции

// Для функции НовыйНаборГрупп.
Функция НаборГруппСуществует(Объект)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ТипЭлементовНабора", Объект.ТипЭлементовНабора);
	Запрос.УстановитьПараметр("Хеш", Объект.Хеш);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	СуществующиеНаборы.Ссылка КАК Ссылка,
	|	СуществующиеНаборы.Группы.(
	|		Группа КАК Группа
	|	) КАК Группы
	|ИЗ
	|	Справочник.НаборыГруппДоступа КАК СуществующиеНаборы
	|ГДЕ
	|	СуществующиеНаборы.ТипЭлементовНабора = &ТипЭлементовНабора
	|	И СуществующиеНаборы.Хеш = &Хеш
	|
	|УПОРЯДОЧИТЬ ПО
	|	Ссылка";
	
	ГруппыОбъекта = Объект.Группы.Выгрузить(, "Группа");
	ГруппыОбъекта.Индексы.Добавить("Группа");
	
	Выгрузка = Запрос.Выполнить().Выгрузить();
	Для Каждого Строка Из Выгрузка Цикл
		Если ГруппыОбъекта.Количество() <> Строка.Группы.Количество() Тогда
			Продолжить;
		КонецЕсли;
		ГруппыСовпадают = Истина;
		Для Каждого Подстрока Из Строка.Группы Цикл
			Если ГруппыОбъекта.Найти(Подстрока.Группа, "Группа") = Неопределено Тогда
				ГруппыСовпадают = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если ГруппыСовпадают Тогда
			Объект = Новый Структура("Ссылка", Строка.Ссылка);
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Для процедуры ОбновитьНаборыГруппДоступа.
Процедура ОбновитьНаборыГруппРазрешенныеПользователямВСправочнике(ЭлементыДанных, ПараметрыОбновления)
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить("Справочник.НаборыГруппДоступа");
	
	Для Каждого Строка Из ЭлементыДанных Цикл
		ЭлементБлокировки.УстановитьЗначение("Ссылка", Строка.ТекущаяСсылка);
		
		НачатьТранзакцию();
		Попытка
			Блокировка.Заблокировать();
			
			Объект = СлужебныйЭлемент(Неопределено, Строка.ТекущаяСсылка);
			Если Объект <> Неопределено Тогда
				Если ЗначениеЗаполнено(Объект.НовыйНаборГруппДоступа) Тогда
					Объект.РазрешенныйНаборГруппДоступа = Объект.НовыйНаборГруппДоступа;
					Объект.НовыйНаборГруппДоступа = ПараметрыОбновления.ПустойНаборГруппДоступа;
				КонецЕсли;
				Если ЗначениеЗаполнено(Объект.НовыйНаборГруппПользователей) Тогда
					Объект.РазрешенныйНаборГруппПользователей = Объект.НовыйНаборГруппПользователей;
					Объект.НовыйНаборГруппПользователей = ПараметрыОбновления.ПустойНаборГруппДоступа;
				КонецЕсли;
				Если Объект.Модифицированность() Тогда
					Объект.Записать();
				КонецЕсли;
			КонецЕсли;
			
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
		
		Если ТребуетсяПрерватьОбработкуЭлементов(ПараметрыОбновления, 1) Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ВыполнитьОбновлениеДоступаСписка.
Процедура ОчиститьПраваНесуществующихНаборовГруппДоступа(ПараметрыОбновления)
	
	Если ПараметрыОбновления.ДляВнешнихПользователей Тогда
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	КлючиДоступаНаборов.НаборГруппДоступа КАК Набор
	|ИЗ
	|	РегистрСведений.КлючиДоступаНаборовГруппДоступа КАК КлючиДоступаНаборов
	|ГДЕ
	|	КлючиДоступаНаборов.НаборГруппДоступа.Ссылка ЕСТЬ NULL
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	КлючиДоступаНаборов.Пользователь КАК Набор
	|ИЗ
	|	РегистрСведений.КлючиДоступаПользователей КАК КлючиДоступаНаборов
	|ГДЕ
	|	КлючиДоступаНаборов.Пользователь.Ссылка ЕСТЬ NULL
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	КлючиДоступаНаборов.ВнешнийПользователь КАК Набор
	|ИЗ
	|	РегистрСведений.КлючиДоступаВнешнихПользователей КАК КлючиДоступаНаборов
	|ГДЕ
	|	КлючиДоступаНаборов.ВнешнийПользователь.Ссылка ЕСТЬ NULL";
	
	РезультатыЗапроса = Запрос.ВыполнитьПакет();
	
	Выборка = РезультатыЗапроса[0].Выбрать();
	Пока Выборка.Следующий() Цикл
		УдалитьЗаписиРегистраДляНабора(Выборка.Набор,
			"КлючиДоступаНаборовГруппДоступа", "НаборГруппДоступа");
	КонецЦикла;
	
	Выборка = РезультатыЗапроса[1].Выбрать();
	Пока Выборка.Следующий() Цикл
		УдалитьЗаписиРегистраДляНабора(Выборка.Набор,
			"КлючиДоступаПользователей", "Пользователь");
	КонецЦикла;
	
	Выборка = РезультатыЗапроса[2].Выбрать();
	Пока Выборка.Следующий() Цикл
		УдалитьЗаписиРегистраДляНабора(Выборка.Набор,
			"КлючиДоступаВнешнихПользователей", "ВнешнийПользователь");
	КонецЦикла;
	
КонецПроцедуры

// Для функции НаборыГруппДоступаДляОбновления.
Функция УстаревшиеНаборыГруппДоступаВСправочнике(ПараметрыОбновления, КоличествоВЗапросе)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ДляВнешнихПользователей", ПараметрыОбновления.ДляВнешнихПользователей);
	Запрос.УстановитьПараметр("ДатаУстаревания", ДатаУстаревания());
	Запрос.УстановитьПараметр("РазрешенныйПустойНабор",
		УправлениеДоступомСлужебныйПовтИсп.РазрешенныйПустойНаборГруппДоступа());
	
	Запрос.Текст =
	"ВЫБРАТЬ
	|	НаборыГруппДоступа.Ссылка КАК ТекущаяСсылка,
	|	НаборыГруппДоступа.ТипЭлементовНабора КАК ТипЭлементовНабора,
	|	ЛОЖЬ КАК Используется,
	|	ИСТИНА КАК Удалить
	|ИЗ
	|	Справочник.НаборыГруппДоступа КАК НаборыГруппДоступа
	|ГДЕ
	|	НаборыГруппДоступа.ТипЭлементовНабора = НЕОПРЕДЕЛЕНО
	|	И &УточнениеПланаЗапроса
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	НаборыГруппДоступа.Ссылка,
	|	НаборыГруппДоступа.ТипЭлементовНабора,
	|	ЛОЖЬ,
	|	ИСТИНА
	|ИЗ
	|	Справочник.НаборыГруппДоступа КАК НаборыГруппДоступа
	|ГДЕ
	|	НаборыГруппДоступа.ДляВнешнихПользователей = &ДляВнешнихПользователей
	|	И НаборыГруппДоступа.ТипЭлементовНабора = ЗНАЧЕНИЕ(Справочник.Пользователи.ПустаяСсылка)
	|	И (ВЫРАЗИТЬ(НаборыГруппДоступа.Пользователь КАК Справочник.Пользователи).Ссылка ЕСТЬ NULL
	|			ИЛИ НаборыГруппДоступа.НеИспользуетсяС <> ДАТАВРЕМЯ(1, 1, 1)
	|				И НаборыГруппДоступа.НеИспользуетсяС < &ДатаУстаревания)
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	НаборыГруппДоступа.Ссылка,
	|	НаборыГруппДоступа.ТипЭлементовНабора,
	|	НЕ МИНИМУМ(НаборыИзОдногоПользователя.Ссылка ЕСТЬ NULL),
	|	МИНИМУМ(НаборыГруппДоступа.НеИспользуетсяС <> ДАТАВРЕМЯ(1, 1, 1)
	|			И НаборыГруппДоступа.НеИспользуетсяС < &ДатаУстаревания)
	|ИЗ
	|	Справочник.НаборыГруппДоступа КАК НаборыГруппДоступа
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.НаборыГруппДоступа КАК НаборыИзОдногоПользователя
	|		ПО (НаборыИзОдногоПользователя.ДляВнешнихПользователей = &ДляВнешнихПользователей)
	|			И (НаборыИзОдногоПользователя.РазрешенныйНаборГруппДоступа = НаборыГруппДоступа.Ссылка
	|				ИЛИ НаборыИзОдногоПользователя.НовыйНаборГруппДоступа = НаборыГруппДоступа.Ссылка)
	|ГДЕ
	|	НаборыГруппДоступа.ДляВнешнихПользователей = &ДляВнешнихПользователей
	|	И НаборыГруппДоступа.ТипЭлементовНабора = ЗНАЧЕНИЕ(Справочник.ГруппыДоступа.ПустаяСсылка)
	|	И НаборыГруппДоступа.Ссылка <> &РазрешенныйПустойНабор
	|
	|СГРУППИРОВАТЬ ПО
	|	НаборыГруппДоступа.Ссылка,
	|	НаборыГруппДоступа.ТипЭлементовНабора
	|
	|ИМЕЮЩИЕ
	|	(НаборыГруппДоступа.НеИспользуетсяС = ДАТАВРЕМЯ(1, 1, 1)
	|			И МИНИМУМ(НаборыИзОдногоПользователя.Ссылка ЕСТЬ NULL)
	|		ИЛИ НаборыГруппДоступа.НеИспользуетсяС <> ДАТАВРЕМЯ(1, 1, 1)
	|			И (НЕ МИНИМУМ(НаборыИзОдногоПользователя.Ссылка ЕСТЬ NULL)
	|				ИЛИ НаборыГруппДоступа.НеИспользуетсяС < &ДатаУстаревания))
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	НаборыГруппПользователей.Ссылка,
	|	НаборыГруппПользователей.ТипЭлементовНабора,
	|	НЕ МИНИМУМ(НаборыИзОдногоПользователя.Ссылка ЕСТЬ NULL),
	|	МИНИМУМ(НаборыГруппПользователей.НеИспользуетсяС <> ДАТАВРЕМЯ(1, 1, 1)
	|			И НаборыГруппПользователей.НеИспользуетсяС < &ДатаУстаревания)
	|ИЗ
	|	Справочник.НаборыГруппДоступа КАК НаборыГруппПользователей
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.НаборыГруппДоступа КАК НаборыИзОдногоПользователя
	|		ПО (НаборыИзОдногоПользователя.ДляВнешнихПользователей = &ДляВнешнихПользователей)
	|			И (НаборыИзОдногоПользователя.РазрешенныйНаборГруппПользователей = НаборыГруппПользователей.Ссылка
	|				ИЛИ НаборыИзОдногоПользователя.НовыйНаборГруппПользователей = НаборыГруппПользователей.Ссылка)
	|ГДЕ
	|	НаборыГруппПользователей.ДляВнешнихПользователей = &ДляВнешнихПользователей
	|	И НаборыГруппПользователей.ТипЭлементовНабора = ЗНАЧЕНИЕ(Справочник.ГруппыПользователей.ПустаяСсылка)
	|
	|СГРУППИРОВАТЬ ПО
	|	НаборыГруппПользователей.Ссылка,
	|	НаборыГруппПользователей.ТипЭлементовНабора
	|
	|ИМЕЮЩИЕ
	|	(НаборыГруппПользователей.НеИспользуетсяС = ДАТАВРЕМЯ(1, 1, 1)
	|			И МИНИМУМ(НаборыИзОдногоПользователя.Ссылка ЕСТЬ NULL)
	|		ИЛИ НаборыГруппПользователей.НеИспользуетсяС <> ДАТАВРЕМЯ(1, 1, 1)
	|			И (НЕ МИНИМУМ(НаборыИзОдногоПользователя.Ссылка ЕСТЬ NULL)
	|				ИЛИ НаборыГруппПользователей.НеИспользуетсяС < &ДатаУстаревания))";
	
	Если ПараметрыОбновления.ДляВнешнихПользователей Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "Справочник.Пользователи", "Справочник.ВнешниеПользователи");
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "Справочник.ГруппыПользователей", "Справочник.ГруппыВнешнихПользователей");
	КонецЕсли;
	УстановитьУточнениеПланаЗапроса(Запрос.Текст);
	
	ЭлементыДанных = Запрос.Выполнить().Выгрузить();
	
	КоличествоВЗапросе = ЭлементыДанных.Количество();
	Возврат ЭлементыДанных;
	
КонецФункции

// Для функций УстаревшиеНаборыГруппДоступаВСправочнике, ЭлементыДляОбновления.
Функция ДатаУстаревания()
	
	Возврат ТекущаяДатаСеанса() - КоличествоЧасовУстареванияНеиспользуемыхЭлементов() * 60 * 60;
	
КонецФункции

// Для процедуры ОбновитьПорциюЭлементов.
Процедура ОбработатьУстаревшиеНаборыВСправочнике(ЭлементыДанных, ПараметрыОбновления)
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить("Справочник.НаборыГруппДоступа");
	
	Для Каждого Строка Из ЭлементыДанных Цикл
		ЭлементБлокировки.УстановитьЗначение("Ссылка", Строка.ТекущаяСсылка);
		
		НачатьТранзакцию();
		Попытка
			Блокировка.Заблокировать();
			Объект = СлужебныйЭлемент(Неопределено, Строка.ТекущаяСсылка);
			Если Объект <> Неопределено Тогда
				Если Строка.Используется Тогда
					Объект.НеИспользуетсяС = '00010101';
				ИначеЕсли Не Строка.Удалить Тогда
					Объект.НеИспользуетсяС = ТекущаяДатаСеанса();
				Иначе
					Объект.ТипЭлементовНабора = Неопределено;
					Объект.Хеш = 0;
					Объект.Группы.Очистить();
				КонецЕсли;
				Объект.Записать();
			КонецЕсли;
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
		
		Если Не Строка.Используется И Строка.Удалить Тогда
			УдалитьЗаписиРегистраДляНабора(Строка.ТекущаяСсылка, "КлючиДоступаНаборовГруппДоступа",  "НаборГруппДоступа");
			УдалитьЗаписиРегистраДляНабора(Строка.ТекущаяСсылка, "КлючиДоступаПользователей",        "Пользователь");
			УдалитьЗаписиРегистраДляНабора(Строка.ТекущаяСсылка, "КлючиДоступаВнешнихПользователей", "ВнешнийПользователь");
			
			НачатьТранзакцию();
			Попытка
				Блокировка.Заблокировать();
				Объект = СлужебныйЭлемент(Неопределено, Строка.ТекущаяСсылка);
				Если Объект <> Неопределено Тогда
					Объект.Удалить();
				КонецЕсли;
				ЗафиксироватьТранзакцию();
			Исключение
				ОтменитьТранзакцию();
				ВызватьИсключение;
			КонецПопытки;
		КонецЕсли;
		
		Если ТребуетсяПрерватьОбработкуЭлементов(ПараметрыОбновления, 1) Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры УдалитьУстаревшиеНаборыВСправочнике.
Процедура УдалитьЗаписиРегистраДляНабора(Набор, ИмяРегистраСведений, ИмяПоляНабора)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Набор", Набор);
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1000
	|	КлючиДоступаНаборов.КлючДоступа КАК КлючДоступа
	|ИЗ
	|	РегистрСведений.КлючиДоступаНаборовГруппДоступа КАК КлючиДоступаНаборов
	|ГДЕ
	|	КлючиДоступаНаборов.НаборГруппДоступа = &Набор";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "КлючиДоступаНаборовГруппДоступа", ИмяРегистраСведений);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "НаборГруппДоступа", ИмяПоляНабора);
	
	НаборЗаписей = СлужебныйНаборЗаписей(РегистрыСведений[ИмяРегистраСведений]);
	ПолноеИмяРегистраСведений = "РегистрСведений." + ИмяРегистраСведений;
	
	Пока Истина Цикл
		Выгрузка = Запрос.Выполнить().Выгрузить();
		Если Выгрузка.Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Блокировка = Новый БлокировкаДанных;
		Для Каждого Строка Из Выгрузка Цикл
			ЭлементБлокировки = Блокировка.Добавить(ПолноеИмяРегистраСведений);
			ЭлементБлокировки.УстановитьЗначение(ИмяПоляНабора, Набор);
			ЭлементБлокировки.УстановитьЗначение("КлючДоступа", Строка.КлючДоступа);
		КонецЦикла;
		
		НачатьТранзакцию();
		Попытка
			Блокировка.Заблокировать();
			Для Каждого Строка Из Выгрузка Цикл
				НаборЗаписей.Отбор[ИмяПоляНабора].Установить(Набор);
				НаборЗаписей.Отбор.КлючДоступа.Установить(Строка.КлючДоступа);
				НаборЗаписей.Записать();
			КонецЦикла;
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
	КонецЦикла;
	
КонецПроцедуры

// Для процедур ОбновитьПорциюЭлементов, ОбновитьКлючиДоступаЭлементовДанныхПриЗаписи.
Процедура ОбновитьЭлементыДанныхСпискаСУстаревшимРазрешеннымКлючом(ЭлементыДанных, ПараметрыОбновления)
	
	Если Не ПараметрыОбновления.ЭтоСсылочныйТип Тогда
		Возврат;
	КонецЕсли;
	
	Контекст = Новый Структура;
	Контекст.Вставить("СсылкиНаОбъекты", ЭлементыДанных.ВыгрузитьКолонку("ТекущаяСсылка"));
	Контекст.Вставить("ОписаниеКлючейДоступаОбъектов", ЭлементыДанных);
	
	РазрешенныйКлючДоступа = УправлениеДоступомСлужебныйПовтИсп.РазрешенныйКлючДоступа();
	
	ЭлементыДанных.Колонки.Добавить("СвойстваКлюча", Новый ОписаниеТипов("Структура"));
	ЭлементыДанных.ЗаполнитьЗначения(Новый Структура("КлючДоступа", РазрешенныйКлючДоступа), "СвойстваКлюча");
	
	ЗаписатьКлючиДоступаОбъектов(ПараметрыОбновления, Контекст);
	
	Если ПараметрыОбновления.Свойство("ОбновитьПраваНаКлючи")
	   И ПараметрыОбновления.ОбновитьПраваНаКлючи Тогда
		
		ОбновитьПраваНаРазрешенныйКлючДоступа(ПараметрыОбновления.ЕстьИзмененияПрав);
	КонецЕсли;
	
КонецПроцедуры

// Для процедур ОбновитьЭлементыДанныхСпискаСУстаревшимРазрешеннымКлючом и ЗавершитьОбновлениеДоступа.
Процедура ОбновитьПраваНаРазрешенныйКлючДоступа(ЕстьИзменения = Ложь)
	
	ОбновитьГруппыДоступаРазрешенногоКлючаДоступа( , ЕстьИзменения);
	
КонецПроцедуры

// Для процедуры ОбновитьПраваНаРазрешенныйКлючДоступа.
Процедура ОбновитьГруппыДоступаРазрешенногоКлючаДоступа(ГруппыДоступа = Неопределено, ЕстьИзменения = Ложь) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	РазрешенныйКлючДоступа = УправлениеДоступомСлужебныйПовтИсп.РазрешенныйКлючДоступа();
	РазрешенныйПустойНабор = УправлениеДоступомСлужебныйПовтИсп.РазрешенныйПустойНаборГруппДоступа();
	
	Блокировка = Новый БлокировкаДанных;
	
	// Обновление групп доступа в регистре КлючиДоступаГруппДоступа.
	ЗапросГрупп = Новый Запрос;
	ЗапросГрупп.УстановитьПараметр("КлючДоступа", РазрешенныйКлючДоступа);
	ЗапросГрупп.Текст = ТекстЗапросаВыбораРазличийГруппДоступаРазрешенногоКлюча();
	УстановитьУсловиеОтбораВЗапросе(ЗапросГрупп, ГруппыДоступа, "ГруппыДоступа",
		"&УсловиеОтбораГруппДоступа1:ГруппыДоступа.Ссылка
		|&УсловиеОтбораГруппДоступа2:СтарыеДанные.ГруппаДоступа");
	
	ЭлементБлокировкиГрупп = Блокировка.Добавить("РегистрСведений.КлючиДоступаГруппДоступа");
	ЭлементБлокировкиГрупп.УстановитьЗначение("КлючДоступа", РазрешенныйКлючДоступа);
	НаборЗаписейГрупп = СлужебныйНаборЗаписей(РегистрыСведений.КлючиДоступаГруппДоступа);
	НаборЗаписейГрупп.Отбор.КлючДоступа.Установить(РазрешенныйКлючДоступа);
	
	// Обновление наборов групп доступа в регистре КлючиДоступаНаборовГруппДоступа.
	ЗапросПравДляГруппДоступа = Новый Запрос;
	ЗапросПравДляГруппДоступа.УстановитьПараметр("КлючДоступа", РазрешенныйКлючДоступа);
	ЗапросПравДляГруппДоступа.УстановитьПараметр("РазрешенныйПустойНабор", РазрешенныйПустойНабор);
	ЗапросПравДляГруппДоступа.Текст = ТекстЗапросаВыбораРазличийПроизводныхПравДляГруппДоступа();
	
	ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КлючиДоступаНаборовГруппДоступа");
	ЭлементБлокировки.УстановитьЗначение("КлючДоступа", РазрешенныйКлючДоступа);
	ПраваДляГруппДоступа = СлужебныйНаборЗаписей(РегистрыСведений.КлючиДоступаНаборовГруппДоступа);
	ПраваДляГруппДоступа.Отбор.КлючДоступа.Установить(РазрешенныйКлючДоступа);
	
	Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		ЭлементБлокировки = Блокировка.Добавить("Справочник.ПрофилиГруппДоступа");
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		ЭлементБлокировки = Блокировка.Добавить("Справочник.ГруппыДоступа");
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		ЭлементБлокировки = Блокировка.Добавить("Справочник.НаборыГруппДоступа");
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
	КонецЕсли;
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		
		РезультатЗапросаГрупп = ЗапросГрупп.Выполнить();
		ОбновитьПроизводныеПраваНаКлючДоступа(РезультатЗапросаГрупп,
			НаборЗаписейГрупп, "ГруппаДоступа", РазрешенныйКлючДоступа, ЕстьИзменения);
		
		РезультатЗапросаПравДляГруппДоступа = ЗапросПравДляГруппДоступа.Выполнить();
		ОбновитьПроизводныеПраваНаКлючДоступа(РезультатЗапросаПравДляГруппДоступа,
			ПраваДляГруппДоступа, "НаборГруппДоступа", РазрешенныйКлючДоступа, ЕстьИзменения);
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Для процедуры ОбновитьГруппыРазрешенногоКлючаДоступа.
Функция ТекстЗапросаВыбораРазличийГруппДоступаРазрешенногоКлюча()
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ВсеСтроки.ГруппаДоступа КАК ГруппаДоступа,
	|	ВсеСтроки.Изменение КАК Изменение,
	|	ВсеСтроки.Добавление КАК Добавление,
	|	СУММА(ВсеСтроки.ВидИзмененияСтроки) КАК ВидИзмененияСтроки
	|ИЗ
	|	(ВЫБРАТЬ
	|		ГруппыДоступа.Ссылка КАК ГруппаДоступа,
	|		ИСТИНА КАК Изменение,
	|		ИСТИНА КАК Добавление,
	|		1 КАК ВидИзмененияСтроки
	|	ИЗ
	|		Справочник.ГруппыДоступа КАК ГруппыДоступа
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ПрофилиГруппДоступа КАК ПрофилиГруппДоступа
	|			ПО ГруппыДоступа.Профиль = ПрофилиГруппДоступа.Ссылка
	|				И (ГруппыДоступа.Профиль <> ЗНАЧЕНИЕ(Справочник.ПрофилиГруппДоступа.Администратор))
	|				И (НЕ ГруппыДоступа.ПометкаУдаления)
	|				И (НЕ ПрофилиГруппДоступа.ПометкаУдаления)
	|				И (&УсловиеОтбораГруппДоступа1)
	|				И (ИСТИНА В
	|					(ВЫБРАТЬ ПЕРВЫЕ 1
	|						ИСТИНА КАК ЗначениеИстина
	|					ИЗ
	|						Справочник.ГруппыДоступа.Пользователи КАК УчастникиГруппДоступа
	|					ГДЕ
	|						УчастникиГруппДоступа.Ссылка = ГруппыДоступа.Ссылка))
	|				И (&УточнениеПланаЗапроса)
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ВЫБРАТЬ
	|		СтарыеДанные.ГруппаДоступа,
	|		СтарыеДанные.Изменение,
	|		СтарыеДанные.Добавление,
	|		-1
	|	ИЗ
	|		РегистрСведений.КлючиДоступаГруппДоступа КАК СтарыеДанные
	|	ГДЕ
	|		СтарыеДанные.КлючДоступа = &КлючДоступа
	|		И &УсловиеОтбораГруппДоступа2) КАК ВсеСтроки
	|
	|СГРУППИРОВАТЬ ПО
	|	ВсеСтроки.ГруппаДоступа,
	|	ВсеСтроки.Изменение,
	|	ВсеСтроки.Добавление
	|
	|ИМЕЮЩИЕ
	|	СУММА(ВсеСтроки.ВидИзмененияСтроки) <> 0
	|
	|УПОРЯДОЧИТЬ ПО
	|	ВидИзмененияСтроки";
	
	УстановитьУточнениеПланаЗапроса(ТекстЗапроса);
	
	Возврат ТекстЗапроса;
	
КонецФункции

// Для процедуры ОбновитьПорциюЭлементов.
Процедура УдалитьУстаревшиеЭлементыДанныхСписка(ЭлементыДанных, ПараметрыОбновления)
	
	РазмерПорции = 100; // Удаление N элементов данных по 100 за раз.
	ПорцияЭлементовДанных = Неопределено;
	КоличествоЭлементов = ЭлементыДанных.Количество();
	
	Если ПараметрыОбновления.ЭтоСсылочныйТип Тогда
		НаборИзОднойЗаписи = СлужебныйНаборЗаписей(РегистрыСведений.КлючиДоступаКОбъектам);
		Индекс = 0;
		Пока Индекс < КоличествоЭлементов Цикл
			Если ПорцияЭлементовДанных = Неопределено Тогда
				ПорцияЭлементовДанных = ЭлементыДанных.Скопировать(Новый Массив);
				Блокировка = Новый БлокировкаДанных;
			КонецЕсли;
			ЭлементДанных = ЭлементыДанных[Индекс];
			ЗаполнитьЗначенияСвойств(ПорцияЭлементовДанных.Добавить(), ЭлементДанных);
			
			ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КлючиДоступаКОбъектам");
			ЭлементБлокировки.УстановитьЗначение("Объект", ЭлементДанных.ТекущаяСсылка);
			
			Индекс = Индекс + 1;
			Если ПорцияЭлементовДанных.Количество() < РазмерПорции И Индекс < КоличествоЭлементов Тогда
				Продолжить;
			КонецЕсли;
			
			КоличествоОбработанных = ПорцияЭлементовДанных.Количество();
			БлокировкаУстановлена = Ложь;
			НачатьТранзакцию();
			Попытка
				Блокировка.Заблокировать();
				БлокировкаУстановлена = Истина;
				Для Каждого Строка Из ПорцияЭлементовДанных Цикл
					НаборИзОднойЗаписи.Отбор.Объект.Установить(Строка.ТекущаяСсылка);
					Если Не ПараметрыОбновления.ДляВнешнихПользователей
					   И (ПараметрыОбновления.БезЗаписиКлючейДоступаДляПользователейИВнешнихПользователей
					      Или Строка.Удалить) Тогда
						НаборИзОднойЗаписи.Очистить();
						НаборИзОднойЗаписи.Записать();
					Иначе
						НаборИзОднойЗаписи.Прочитать();
						Если НаборИзОднойЗаписи.Количество() > 0 Тогда
							Если ПараметрыОбновления.ДляВнешнихПользователей Тогда
								НаборИзОднойЗаписи[0].КлючДоступаВнешнихПользователей = Неопределено;
							Иначе
								НаборИзОднойЗаписи[0].КлючДоступаПользователей = Неопределено;
							КонецЕсли;
							Если Не ЗначениеЗаполнено(НаборИзОднойЗаписи[0].КлючДоступаВнешнихПользователей)
							   И Не ЗначениеЗаполнено(НаборИзОднойЗаписи[0].КлючДоступаПользователей) Тогда
								НаборИзОднойЗаписи.Очистить();
							КонецЕсли;
							НаборИзОднойЗаписи.Записать();
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
				ЗафиксироватьТранзакцию();
			Исключение
				ОтменитьТранзакцию();
				Если БлокировкаУстановлена Тогда
					ВызватьИсключение;
				КонецЕсли;
			КонецПопытки;
			КоличествоОбработанных = 0;
			
			Если ТребуетсяПрерватьОбработкуЭлементов(ПараметрыОбновления) Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Возврат;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПараметрыОбновления.ИмяОтдельногоРегистраКлючей)
	   И ПараметрыОбновления.ПоследнийОбновленныйЭлемент.ВидКлючаДанных <> "УстаревшиеЭлементыОбщегоРегистра" Тогда
		
		ИмяРегистра = ПараметрыОбновления.ИмяОтдельногоРегистраКлючей;
	Иначе
		ИмяРегистра = "КлючиДоступаКРегистрам";
	КонецЕсли;
	НаборИзОднойЗаписи = СлужебныйНаборЗаписей(РегистрыСведений[ИмяРегистра]);
	
	Если ИмяРегистра = "КлючиДоступаКРегистрам" Тогда
		НаборИзОднойЗаписи.Отбор.Регистр.Установить(ПараметрыОбновления.ИдентификаторСписка);
	КонецЕсли;
	
	ИменаИзмерений = Новый Массив;
	Для Каждого Колонка Из ЭлементыДанных.Колонки Цикл
		Если СтрНачинаетсяС(Колонка.Имя, "Поле") Тогда
			ИменаИзмерений.Добавить(Колонка.Имя);
		КонецЕсли;
	КонецЦикла;
	ОтборИзмерений = Неопределено;
	
	Индекс = 0;
	Пока Индекс < КоличествоЭлементов Цикл
		Если ПорцияЭлементовДанных = Неопределено Тогда
			ТребуетсяПроверка = Не ПараметрыОбновления.БезЗаписиКлючейДоступа;
			ПорцияЭлементовДанных = ЭлементыДанных.Скопировать(Новый Массив);
			Блокировка = Новый БлокировкаДанных;
		КонецЕсли;
		ЭлементДанных = ЭлементыДанных[Индекс];
		ЗаполнитьЗначенияСвойств(ПорцияЭлементовДанных.Добавить(), ЭлементДанных);
		Если ТребуетсяПроверка И ЭлементДанных.Удалить Тогда
			ТребуетсяПроверка = Ложь;
		КонецЕсли;
		
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений." + ИмяРегистра);
		Если ИмяРегистра = "КлючиДоступаКРегистрам" Тогда
			ЭлементБлокировки.УстановитьЗначение("Регистр", ПараметрыОбновления.ИдентификаторСписка);
		КонецЕсли;
		Для Каждого ИмяИзмерения Из ИменаИзмерений Цикл
			ЭлементБлокировки.УстановитьЗначение(ИмяИзмерения, ЭлементДанных[ИмяИзмерения]);
		КонецЦикла;
		
		Индекс = Индекс + 1;
		Если ПорцияЭлементовДанных.Количество() < РазмерПорции И Индекс < КоличествоЭлементов Тогда
			Продолжить;
		КонецЕсли;
		
		Если ТребуетсяПроверка Тогда
			ЭлементБлокировки = Блокировка.Добавить(ПараметрыОбновления.Список);
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
			Запрос = Новый Запрос;
			Запрос.Текст = ПараметрыОбновления.ТекстЗапросаПроверкиУстаревшихЭлементовДанных;
			Запрос.УстановитьПараметр("КлючиДоступаКРегистрам", ПорцияЭлементовДанных);
			УстановитьУточнениеПланаЗапроса(Запрос.Текст);
		КонецЕсли;
		
		КоличествоОбработанных = ПорцияЭлементовДанных.Количество();
		БлокировкаУстановлена = Ложь;
		НачатьТранзакцию();
		Попытка
			Блокировка.Заблокировать();
			БлокировкаУстановлена = Истина;
			Если ТребуетсяПроверка Тогда
				Выгрузка = Запрос.Выполнить().Выгрузить();
				Если ОтборИзмерений = Неопределено Тогда
					ИменаПроверяемыхИзмерений = Новый Массив;
					Для Каждого Колонка Из Выгрузка.Колонки Цикл
						ИменаПроверяемыхИзмерений.Добавить(Колонка.Имя);
					КонецЦикла;
					ОтборИзмерений = Новый Структура(СтрСоединить(ИменаПроверяемыхИзмерений, ","));
				КонецЕсли;
			КонецЕсли;
			Для Каждого Строка Из ПорцияЭлементовДанных Цикл
				Если ТребуетсяПроверка И Не Строка.Удалить Тогда
					ЗаполнитьЗначенияСвойств(ОтборИзмерений, Строка);
					Если Выгрузка.НайтиСтроки(ОтборИзмерений).Количество() = 0 Тогда
						Продолжить;
					КонецЕсли;
				КонецЕсли;
				Для Каждого ИмяИзмерения Из ИменаИзмерений Цикл
					НаборИзОднойЗаписи.Отбор[ИмяИзмерения].Установить(Строка[ИмяИзмерения]);
				КонецЦикла;
				НаборИзОднойЗаписи.Записать();
			КонецЦикла;
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			Если БлокировкаУстановлена Тогда
				ВызватьИсключение;
			КонецЕсли;
			КоличествоОбработанных = 0;
		КонецПопытки;
		ПорцияЭлементовДанных = Неопределено;
		
		Если ТребуетсяПрерватьОбработкуЭлементов(ПараметрыОбновления, КоличествоОбработанных) Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ВыполнитьОбновлениеДоступаСписка.
Процедура УдалитьОбъектыНедопустимыхТиповВРегистреКлючиДоступаКОбъектам()
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ТИПЗНАЧЕНИЯ(КлючиДоступаКДанным.Объект) КАК ТипСсылки
	|ИЗ
	|	РегистрСведений.КлючиДоступаКОбъектам КАК КлючиДоступаКДанным";
	
	НаборЗаписей = СлужебныйНаборЗаписей(РегистрыСведений.КлючиДоступаКОбъектам);
	ДопустимыеТипы = УправлениеДоступомСлужебныйПовтИсп.ОписаниеТиповСсылокДопустимыхОбъектов();
	Выборка = Запрос.Выполнить().Выбрать();
	
	Запрос.Текст =
	"ВЫБРАТЬ
	|	КлючиДоступаКДанным.Объект КАК Объект
	|ИЗ
	|	РегистрСведений.КлючиДоступаКОбъектам КАК КлючиДоступаКДанным
	|ГДЕ
	|	ТИПЗНАЧЕНИЯ(КлючиДоступаКДанным.Объект) = &Тип";
	
	Пока Выборка.Следующий() Цикл
		Если Выборка.ТипСсылки = Тип("Неопределено") Тогда
			НаборЗаписей.Отбор.Объект.Установить(Неопределено);
			НаборЗаписей.Записать();
			Продолжить;
		ИначеЕсли ДопустимыеТипы.СодержитТип(Выборка.ТипСсылки) Тогда
			Продолжить;
		КонецЕсли;
		Запрос.УстановитьПараметр("Тип", Выборка.ТипСсылки);
		Объекты = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Объект");
		Для Каждого Объект Из Объекты Цикл
			НаборЗаписей.Отбор.Объект.Установить(Объект);
			НаборЗаписей.Записать();
		КонецЦикла;
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА КАК ЗначениеИстина
	|ИЗ
	|	РегистрСведений.КлючиДоступаКРегистрам КАК КлючиДоступаКРегистрам
	|ГДЕ
	|	КлючиДоступаКРегистрам.Регистр = НЕОПРЕДЕЛЕНО";
	
	Если Запрос.Выполнить().Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	НаборЗаписей = СлужебныйНаборЗаписей(РегистрыСведений.КлючиДоступаКРегистрам);
	НаборЗаписей.Отбор.Регистр.Установить(Неопределено);
	НаборЗаписей.Записать();
	
КонецПроцедуры

// Для процедуры ОбновитьПорциюЭлементов.
Процедура ОбновитьЭлементыДанныхСпискаСУстаревшимиКлючами(ЭлементыДанных, ПараметрыОбновления)
	
	РазмерПорции = 100; // Загрузка N элементов данных по 100 за раз.
	
	ЭтоОбработкаСуществующихКомбинаций = Не ПараметрыОбновления.ЭтоСсылочныйТип
		И ПараметрыОбновления.ПоследнийОбновленныйЭлемент.ВидКлючаДанных = "ЭлементыСУстаревшимиКлючами";
	
	Индекс = 0;
	Пока Индекс < ЭлементыДанных.Количество() Цикл
		
		ПорцияЭлементовДанных = ЭлементыДанных.Скопировать(Новый Массив);
		Если Не ПараметрыОбновления.ЭтоСсылочныйТип Тогда
			ПорцияЭлементовДанных.Колонки.Добавить("ТекущаяСсылка", Новый ОписаниеТипов("Число"));
			ПорцияУдаляемыхЭлементовДанных = Новый Массив;
		КонецЕсли;
		
		Пока Индекс < ЭлементыДанных.Количество()
		   И ПорцияЭлементовДанных.Количество() < РазмерПорции
		   И (ПараметрыОбновления.ЭтоСсылочныйТип
		      Или ПорцияУдаляемыхЭлементовДанных.Количество() < РазмерПорции) Цикл
			
			ЭлементДанных = ЭлементыДанных[Индекс];
			Индекс = Индекс + 1;
			
			Если ЭтоОбработкаСуществующихКомбинаций
			   И НекорректнаяКомбинацияЗначенийОпорныхПолей(ЭлементДанных, ПараметрыОбновления) Тогда
				
				ПорцияУдаляемыхЭлементовДанных.Добавить(ЭлементДанных);
				ПараметрыОбновления.СоставУдаленныхЭлементов.Добавить(ЭлементДанных);
				Продолжить;
			КонецЕсли;
			
			НоваяСтрока = ПорцияЭлементовДанных.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, ЭлементДанных);
			Если Не ПараметрыОбновления.ЭтоСсылочныйТип Тогда
				НоваяСтрока.ТекущаяСсылка = ПорцияЭлементовДанных.Индекс(НоваяСтрока) + 1;
			КонецЕсли;
		КонецЦикла;
		
		Если ЭтоОбработкаСуществующихКомбинаций
		   И ПорцияУдаляемыхЭлементовДанных.Количество() > 0 Тогда
			
			УдалитьНекорректныеКомбинацииЗначенийОпорныхПолей(ПорцияУдаляемыхЭлементовДанных, ПараметрыОбновления);
		КонецЕсли;
		
		Если ПорцияЭлементовДанных.Количество() > 0 Тогда
			ОбновитьКлючиДоступаПорцииЭлементовДанныхСписка(ПорцияЭлементовДанных, ПараметрыОбновления);
		КонецЕсли;
		
		Если ТребуетсяПрерватьОбработкуЭлементов(ПараметрыОбновления, 0) Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для функции ОбновитьЭлементыДанныхСпискаСУстаревшимиКлючами.
Функция НекорректнаяКомбинацияЗначенийОпорныхПолей(ЭлементДанных, ПараметрыОбновления)
	
	Номер = 1;
	Для Каждого ХранилищеТиповПоля Из ПараметрыОбновления.ОпорныеПоля.ТипыИспользуемых Цикл
		ТипыПоля = ХранилищеТиповПоля.Получить();
		
		Если Не ТипыПоля.СодержитТип(ТипЗнч(ЭлементДанных["Поле" + Номер]))
		   И ЭлементДанных["Поле" + Номер] <> Неопределено Тогда
			
			Возврат Истина;
		КонецЕсли;
		
		Номер = Номер + 1;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Для функции ОбновитьЭлементыДанныхСпискаСУстаревшимиКлючами, ОбновитьКлючиДоступаЭлементовДанныхПриЗаписи.
Процедура ОбновитьКлючиДоступаПорцииЭлементовДанныхСписка(ПорцияЭлементовДанных, ПараметрыОбновления)
	
	ЭтоСсылочныйТип     = ПараметрыОбновления.ЭтоСсылочныйТип;
	ИдентификаторСписка = ПараметрыОбновления.ИдентификаторСписка;
	
	Контекст = Новый Структура;
	Контекст.Вставить("ПорцияЭлементовДанных", ПорцияЭлементовДанных);
	
	ЗапросЗначенийЭлементовДанных = Новый Запрос;
	ЗапросЗначенийЭлементовДанных.Текст = ПараметрыОбновления.ТекстЗапросаЗначенийЭлементовДанныхДляКлючейДоступа;
	Если ЭтоСсылочныйТип Тогда
		Контекст.Вставить("СсылкиНаОбъекты", ПорцияЭлементовДанных.ВыгрузитьКолонку("ТекущаяСсылка"));
		ЗапросЗначенийЭлементовДанных.УстановитьПараметр("СсылкиНаОбъекты", Контекст.СсылкиНаОбъекты);
	Иначе
		ЗапросЗначенийЭлементовДанных.УстановитьПараметр("ИдентификаторРегистра", ИдентификаторСписка);
		ЗапросЗначенийЭлементовДанных.УстановитьПараметр("ЗначенияОпорныхПолей",  ПорцияЭлементовДанных);
	КонецЕсли;
	УстановитьУточнениеПланаЗапроса(ЗапросЗначенийЭлементовДанных.Текст);
	РезультатыЗапросаЗначенийЭлементов = ЗапросЗначенийЭлементовДанных.ВыполнитьПакет();
	
	ДанныеСтроковыхКлючейДоступа = Новый Соответствие;
	ТаблицыКлюча = ПараметрыОбновления.ТаблицыКлюча;
	
	ЗначенияСтрокТаблиц = Новый Соответствие;
	КлючиЗначенийСтрокОбъектов = КлючиЗначенийСтрокОбъектов(РезультатыЗапросаЗначенийЭлементов,
		?(ЭтоСсылочныйТип, 0, 1), ТаблицыКлюча, ЗначенияСтрокТаблиц);
	
	ТребуемыеКлючиДоступа         = Новый Массив;
	ХешиТребуемыхКлючейДоступа    = Новый Массив;
	ОписаниеКлючейДоступаОбъектов = Новый Массив;
	Для Каждого ЭлементДанных Из ПорцияЭлементовДанных Цикл
		ОписаниеКлючейЗначений = КлючиЗначенийСтрокОбъектов.Получить(ЭлементДанных.ТекущаяСсылка);
		СтрокаДляХеша = СтрокаДляХешаКлючаДоступа(ОписаниеКлючейЗначений, ТаблицыКлюча);
		Свойства = ДанныеСтроковыхКлючейДоступа.Получить(СтрокаДляХеша);
		Если Свойства = Неопределено Тогда
			Свойства = Новый Структура("ЗначенияТаблиц, СтрокаДляХеша, Хеш, КлючДоступа, ЗначенияКолонокТаблиц");
			ДанныеСтроковыхКлючейДоступа.Вставить(СтрокаДляХеша, Свойства);
			ЗначенияТаблиц = Новый Массив;
			Для Каждого ИмяТаблицы Из ТаблицыКлюча Цикл
				КлючЗначений = ОписаниеКлючейЗначений.КлючиЗначений[ТаблицыКлюча.Найти(ИмяТаблицы)];
				ЗначенияСтрок = ЗначенияСтрокТаблиц.Получить(ИмяТаблицы).Получить(КлючЗначений);
				Если ЗначенияСтрок = Неопределено Тогда
					ЗначенияСтрок = Новый Массив;
				КонецЕсли;
				ЗначенияТаблиц.Добавить(Новый Структура("ИмяТаблицы, Таблица", ИмяТаблицы, ЗначенияСтрок));
			КонецЦикла;
			Свойства.ЗначенияТаблиц = ЗначенияТаблиц;
			Свойства.СтрокаДляХеша = СтрокаДляХеша;
			Свойства.ЗначенияКолонокТаблиц = ОписаниеКлючейЗначений.ЗначенияКолонокТаблиц;
			Хеширование = Новый ХешированиеДанных(ХешФункция.CRC32);
			Хеширование.Добавить(СтрокаДляХеша);
			Свойства.Хеш = Хеширование.ХешСумма;
			ТребуемыеКлючиДоступа.Добавить(Свойства);
			ХешиТребуемыхКлючейДоступа.Добавить(Свойства.Хеш);
		КонецЕсли;
		ОписаниеКлючейДоступаОбъектов.Добавить(
			Новый Структура("ТекущаяСсылка, СвойстваКлюча", ЭлементДанных.ТекущаяСсылка, Свойства));
	КонецЦикла;
	Контекст.Вставить("ОписаниеКлючейДоступаОбъектов", ОписаниеКлючейДоступаОбъектов);
	
	// Получение данных существующих ключей доступа по хешам требуемых ключей доступа.
	ЗапросЗначенийКлючей = Новый Запрос;
	ЗапросЗначенийКлючей.Текст = ПараметрыОбновления.ТекстЗапросаЗначенийИзИспользуемыхКлючейДоступаДляСравнения;
	ЗапросЗначенийКлючей.УстановитьПараметр("Хеши",   ХешиТребуемыхКлючейДоступа);
	ЗапросЗначенийКлючей.УстановитьПараметр("Список", ИдентификаторСписка);
	УстановитьУточнениеПланаЗапроса(ЗапросЗначенийКлючей.Текст);
	РезультатыЗапросаЗначенийКлючей = ЗапросЗначенийКлючей.ВыполнитьПакет();
	
	КлючиЗначенийСтрокКлючей = КлючиЗначенийСтрокОбъектов(РезультатыЗапросаЗначенийКлючей,
		?(СтрНачинаетсяС(ТаблицыКлюча[0], "Шапка"), 0, 1), ТаблицыКлюча);
	
	Для Каждого ОписаниеКлючаДоступа Из КлючиЗначенийСтрокКлючей Цикл
		СтрокаДляХеша = СтрокаДляХешаКлючаДоступа(ОписаниеКлючаДоступа.Значение, ТаблицыКлюча);
		Свойства = ДанныеСтроковыхКлючейДоступа.Получить(СтрокаДляХеша);
		Если Свойства <> Неопределено И Свойства.КлючДоступа = Неопределено Тогда
			Свойства.КлючДоступа = ОписаниеКлючаДоступа.Ключ;
		КонецЕсли;
	КонецЦикла;
	
	// Создание недостающих ключей доступа.
	ОписаниеНовыхКлючей = Новый Массив;
	Для Каждого ОписаниеКлюча Из ТребуемыеКлючиДоступа Цикл
		Если ОписаниеКлюча.КлючДоступа <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ОписаниеНовыхКлючей.Добавить(ОписаниеКлюча);
	КонецЦикла;
	Если ОписаниеНовыхКлючей.Количество() > 0 Тогда
		ОбновитьПраваНаКлючиДоступа(ОписаниеНовыхКлючей, ПараметрыОбновления, Истина, Контекст);
		Для Каждого ОписаниеКлюча Из ОписаниеНовыхКлючей Цикл
			Если ЗначениеЗаполнено(ОписаниеКлюча.КлючДоступаОбъект.Ссылка) Тогда
				ОписаниеКлюча.КлючДоступа = ОписаниеКлюча.КлючДоступаОбъект.Ссылка;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Обновление ключей доступа элементов данных.
	Если ЭтоСсылочныйТип Тогда
		ЗаписатьКлючиДоступаОбъектов(ПараметрыОбновления, Контекст);
	Иначе
		ЗаписатьКлючиДоступаРегистров(ПараметрыОбновления, Контекст);
	КонецЕсли;
	
	// Принудительное обновление прав вручную.
	Если ПараметрыОбновления.Свойство("ОбновитьПраваНаКлючи")
	   И ПараметрыОбновления.ОбновитьПраваНаКлючи Тогда
		
		СуществующиеКлючиДоступа = Новый Массив;
		Для Каждого ОписаниеКлюча Из ТребуемыеКлючиДоступа Цикл
			Если ОписаниеНовыхКлючей.Найти(ОписаниеКлюча) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			СуществующиеКлючиДоступа.Добавить(ОписаниеКлюча.КлючДоступа);
		КонецЦикла;
		Если СуществующиеКлючиДоступа.Количество() > 0 Тогда
			ОбновитьПраваНаКлючиДоступа(СуществующиеКлючиДоступа, ПараметрыОбновления);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ОбновитьКлючиДоступаПорцииЭлементовДанныхСписка.
Процедура ОбновитьПраваНаКлючиДоступа(ОписаниеКлючей, ПараметрыОбновления, ЭтоНовыеКлючи = Ложь, Контекст = Неопределено)
	
	Если ПараметрыОбновления.Свойство("КоличествоОбработанныхЭлементов") Тогда
		КоличествоОбработанных = ПараметрыОбновления.КоличествоОбработанныхЭлементов;
		ПараметрыОбновления.КоличествоОбработанныхЭлементов = 0;
	КонецЕсли;
	
	Если ЭтоНовыеКлючи Тогда
		КлючиДоступа = Новый ТаблицаЗначений;
		КлючиДоступа.Колонки.Добавить("Ссылка", Новый ОписаниеТипов("СправочникСсылка.КлючиДоступа"));
		
		ЗапросЗначенийКлючей = Новый Запрос;
		ЗапросЗначенийКлючей.Текст = ПараметрыОбновления.ТекстЗапросаЗначенийИзВсехКлючейДоступаДляСравнения;
		ЗапросЗначенийКлючей.УстановитьПараметр("Список", ПараметрыОбновления.ИдентификаторСписка);
		УстановитьУточнениеПланаЗапроса(ЗапросЗначенийКлючей.Текст);
		
		ЗапросСуществованияКлючей = Новый Запрос;
		ЗапросСуществованияКлючей.Текст = ПараметрыОбновления.ТекстЗапросаСуществованияКлючейДляСравнения;
		ЗапросСуществованияКлючей.УстановитьПараметр("Список", ПараметрыОбновления.ИдентификаторСписка);
		УстановитьУточнениеПланаЗапроса(ЗапросСуществованияКлючей.Текст);
		
		ОписаниеНовыхКлючей = Новый Структура;
		ОписаниеНовыхКлючей.Вставить("ОписаниеКлючей",            ОписаниеКлючей);
		ОписаниеНовыхКлючей.Вставить("КлючиДоступа",              КлючиДоступа);
		ОписаниеНовыхКлючей.Вставить("ЗначенияТаблиц",            Новый Структура);
		ОписаниеНовыхКлючей.Вставить("ОписанияКлючейПоСсылке",    Новый Соответствие);
		ОписаниеНовыхКлючей.Вставить("ЗапросЗначенийКлючей",      ЗапросЗначенийКлючей);
		ОписаниеНовыхКлючей.Вставить("ЗапросСуществованияКлючей", ЗапросСуществованияКлючей);
		
		ДопустимыеТипыЗначений = УправлениеДоступомСлужебныйПовтИсп.ДопустимыеТипыЗначенийКлючейДоступа();
		ЗначенияТаблиц = ОписаниеНовыхКлючей.ЗначенияТаблиц;
		
		Для Каждого ТаблицаКлюча Из ПараметрыОбновления.ТаблицыКлюча Цикл
			ТаблицаЗначений = Новый ТаблицаЗначений;
			ТаблицаЗначений.Колонки.Добавить("Ссылка", Новый ОписаниеТипов("СправочникСсылка.КлючиДоступа"));
			ПоляТаблицы = ПараметрыОбновления.РеквизитыТаблицКлюча.Получить(ТаблицаКлюча);
			Если СтрНачинаетсяС(ТаблицаКлюча, "Шапка") И ТаблицаКлюча <> "Шапка0" Тогда
				ТаблицаЗначений.Колонки.Добавить("НомерСтроки", Новый ОписаниеТипов("Число"));
			КонецЕсли;
			Для Каждого Поле Из ПоляТаблицы Цикл
				ТаблицаЗначений.Колонки.Добавить(Поле, ДопустимыеТипыЗначений);
			КонецЦикла;
			ЗначенияТаблиц.Вставить(ТаблицаКлюча, ТаблицаЗначений);
		КонецЦикла;
		
		Для Каждого ОписаниеКлюча Из ОписаниеКлючей Цикл
			ПроверитьТипЗначенийКлючаДоступа(ОписаниеКлюча, ДопустимыеТипыЗначений, ПараметрыОбновления);
			ПодготовитьНовыйКлючДоступа(ОписаниеКлюча, ОписаниеНовыхКлючей, ПараметрыОбновления);
		КонецЦикла;
		ОписаниеКлючейДоступа = ОписаниеНовыхКлючей;
	Иначе
		ОписаниеКлючейДоступа = Новый ТаблицаЗначений;
		ОписаниеКлючейДоступа.Колонки.Добавить("Ссылка", Новый ОписаниеТипов("СправочникСсылка.КлючиДоступа"));
		Для Каждого КлючДоступаСсылка Из ОписаниеКлючей Цикл
			ОписаниеКлючейДоступа.Добавить().Ссылка = КлючДоступаСсылка;
		КонецЦикла;
	КонецЕсли;
	
	ОбновитьПраваПорцииКлючейДоступаСписка(ОписаниеКлючейДоступа, ПараметрыОбновления, ЭтоНовыеКлючи);
	
	Если ПараметрыОбновления.Свойство("КоличествоОбработанныхЭлементов") Тогда
		ПараметрыОбновления.КоличествоОбработанныхЭлементов = КоличествоОбработанных;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ОбновитьКлючиДоступаПорцииЭлементовДанныхСписка.
Функция СтрокаДляХешаКлючаДоступа(ОписаниеКлючейЗначений, ТаблицыКлюча)
	
	Если ОписаниеКлючейЗначений = Неопределено Тогда
		ОписаниеКлючейЗначений = Новый Структура(
			"КлючиЗначений, ИменаТаблиц, ЗначенияКолонокТаблиц",
			Новый Массив, Новый Массив, Новый Массив);
	КонецЕсли;
	
	КлючиЗначений = ОписаниеКлючейЗначений.КлючиЗначений;
	ИменаТаблиц   = ОписаниеКлючейЗначений.ИменаТаблиц;
	
	Если ИменаТаблиц.Количество() <> ТаблицыКлюча.Количество() Тогда
		// В ключе доступа используются табличные части и некоторые пустые.
		Для Индекс = 0 По ТаблицыКлюча.Количество() - 1 Цикл
			
			Если Индекс >= ИменаТаблиц.Количество()
			 Или ИменаТаблиц[Индекс] <> ТаблицыКлюча[Индекс] Тогда
				
				ИменаТаблиц.Вставить(Индекс, ТаблицыКлюча[Индекс]);
				КлючиЗначений.Вставить(Индекс, "6ab8db6a-4878-483a-b9d5-ef905ff1537e");
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат СтрСоединить(КлючиЗначений);
	
КонецФункции

// Для процедуры ОбновитьКлючиДоступаПорцииЭлементовДанных.
Процедура ЗаписатьКлючиДоступаОбъектов(ПараметрыОбновления, Контекст)
	
	ЗаписыватьТолькоИзмененные = ЗаписыватьТолькоИзмененныеКлючиДоступаЭлементовДанных();
	
	Если ПараметрыОбновления.СЗаписьюКлючейДоступаДляПользователейИВнешнихПользователей
	 Или ЗаписыватьТолькоИзмененные Тогда
		
		ЗапросТекущихКлючей = Новый Запрос;
		ЗапросТекущихКлючей.Текст =
		"ВЫБРАТЬ
		|	КлючиДоступаКОбъектам.Объект КАК Объект,
		|	КлючиДоступаКОбъектам.КлючДоступаПользователей КАК КлючДоступаПользователей,
		|	КлючиДоступаКОбъектам.КлючДоступаВнешнихПользователей КАК КлючДоступаВнешнихПользователей
		|ИЗ
		|	РегистрСведений.КлючиДоступаКОбъектам КАК КлючиДоступаКОбъектам
		|ГДЕ
		|	КлючиДоступаКОбъектам.Объект В (&СсылкиНаОбъекты)";
		ЗапросТекущихКлючей.УстановитьПараметр("СсылкиНаОбъекты", Контекст.СсылкиНаОбъекты);
	КонецЕсли;
	
	Если ПараметрыОбновления.ДляВнешнихПользователей Тогда
		ИмяРеквизитаСохраняемогоКлюча = "КлючДоступаПользователей";
		ИмяРеквизитаОбновляемогоКлюча = "КлючДоступаВнешнихПользователей";
	Иначе
		ИмяРеквизитаСохраняемогоКлюча = "КлючДоступаВнешнихПользователей";
		ИмяРеквизитаОбновляемогоКлюча = "КлючДоступаПользователей";
	КонецЕсли;
	
	НаборИзОднойЗаписи = СлужебныйНаборЗаписей(РегистрыСведений.КлючиДоступаКОбъектам);
	Запись = НаборИзОднойЗаписи.Добавить();
	ОбъектТип = Метаданные.РегистрыСведений.КлючиДоступаКОбъектам.Измерения.Объект.Тип;
	Если Не ОбъектТип.СодержитТип(ТипЗнч(Контекст.ОписаниеКлючейДоступаОбъектов[0].ТекущаяСсылка)) Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Невозможно обновить ключ доступа объекта ""%1"" типа ""%2"",
			           |так как этот тип не указан в определяемом типе ВладелецЗначенийКлючейДоступа.'"),
			Строка(Контекст.ОписаниеКлючейДоступаОбъектов[0].ТекущаяСсылка),
			Строка(ТипЗнч(Контекст.ОписаниеКлючейДоступаОбъектов[0].ТекущаяСсылка)),
			ПараметрыОбновления.Список);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Если ЗаписыватьТолькоИзмененные Тогда
		ПередЗапросомТекущихКлючейДоступа(ПараметрыОбновления);
		ТекущиеКлючиДоБлокировки = ЗапросТекущихКлючей.Выполнить().Выгрузить();
		ПослеЗапросаТекущихКлючейДоступа(ПараметрыОбновления);
	КонецЕсли;
	
	КоличествоОбработанных = 0;
	ОписаниеКлючейДоступаОбъектов = Новый Массив;
	
	Блокировка = Новый БлокировкаДанных;
	Для Каждого ОписаниеКлючаДоступаОбъекта Из Контекст.ОписаниеКлючейДоступаОбъектов Цикл
		КлючДоступа = ОписаниеКлючаДоступаОбъекта.СвойстваКлюча.КлючДоступа;
		Если КлючДоступа = Неопределено Тогда
			Прервать;
		КонецЕсли;
		Если ЗаписыватьТолькоИзмененные Тогда
			Строка = ТекущиеКлючиДоБлокировки.Найти(ОписаниеКлючаДоступаОбъекта.ТекущаяСсылка, "Объект");
			Если Строка <> Неопределено И Строка[ИмяРеквизитаОбновляемогоКлюча] = КлючДоступа Тогда
				КоличествоОбработанных = КоличествоОбработанных + 1;
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		ОписаниеКлючейДоступаОбъектов.Добавить(ОписаниеКлючаДоступаОбъекта);
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КлючиДоступаКОбъектам");
		ЭлементБлокировки.УстановитьЗначение("Объект", ОписаниеКлючаДоступаОбъекта.ТекущаяСсылка);
	КонецЦикла;
	
	Если ОписаниеКлючейДоступаОбъектов.Количество() = 0 Тогда
		ТребуетсяПрерватьОбработкуЭлементов(ПараметрыОбновления, КоличествоОбработанных);
		Возврат;
	КонецЕсли;
	
	Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		Блокировка.Добавить("РегистрСведений.ОбновлениеКлючейДоступаКДанным");
		Блокировка.Добавить("РегистрСведений.ОбновлениеКлючейДоступаПользователей");
	КонецЕсли;
	
	НачатьТранзакцию();
	Попытка
		ПередБлокировкойДанных(ПараметрыОбновления);
		Блокировка.Заблокировать();
		ПослеБлокировкиДанных(ПараметрыОбновления);
		
		Если ПараметрыОбновления.СЗаписьюКлючейДоступаДляПользователейИВнешнихПользователей Тогда
			ПередЗапросомТекущихКлючейДоступа(ПараметрыОбновления);
			ТекущиеКлючи = ЗапросТекущихКлючей.Выполнить().Выгрузить();
			ПослеЗапросаТекущихКлючейДоступа(ПараметрыОбновления);
		КонецЕсли;
		
		ПередЗаписьюСтрок(ПараметрыОбновления);
		СсылкиНаОбъекты = Новый Массив;
		Для Каждого ОписаниеКлючаДоступаОбъекта Из ОписаниеКлючейДоступаОбъектов Цикл
			СсылкиНаОбъекты.Добавить(ОписаниеКлючаДоступаОбъекта.ТекущаяСсылка);
			НаборИзОднойЗаписи.Отбор.Объект.Установить(ОписаниеКлючаДоступаОбъекта.ТекущаяСсылка);
			Запись.Объект = ОписаниеКлючаДоступаОбъекта.ТекущаяСсылка;
			Запись[ИмяРеквизитаОбновляемогоКлюча] = ОписаниеКлючаДоступаОбъекта.СвойстваКлюча.КлючДоступа;
			
			Если ПараметрыОбновления.СЗаписьюКлючейДоступаДляПользователейИВнешнихПользователей Тогда
				Строка = ТекущиеКлючи.Найти(ОписаниеКлючаДоступаОбъекта.ТекущаяСсылка, "Объект");
				Если Строка <> Неопределено Тогда
					Запись[ИмяРеквизитаСохраняемогоКлюча] = Строка[ИмяРеквизитаСохраняемогоКлюча];
				КонецЕсли;
			КонецЕсли;
			НаборИзОднойЗаписи.Записать();
		КонецЦикла;
		ПослеЗаписиСтрок(ПараметрыОбновления, ОписаниеКлючейДоступаОбъектов.Количество());
		
		СпискиДляОбновления = Новый Структура("ИменаСписков, ДляВнешнихПользователей",
			ПараметрыОбновления.ЗависимыеСпискиПоКлючамДоступа,
			ПараметрыОбновления.ДляВнешнихПользователей);
		
		ПередПланированиемОбновления(ПараметрыОбновления);
		ЗапланироватьОбновлениеУстаревшихКлючейДоступа(СпискиДляОбновления,
			ПараметрыОбновления.ИдентификаторТранзакции,
			"ЗаписатьКлючиДоступаОбъектов",
			?(СсылкиНаОбъекты.Количество() > 25, Неопределено,
				Новый Структура("ПоКлючамДоступа", СсылкиНаОбъекты)),
			ПараметрыОбновления.Свойство("ЭтоФоновоеОбновлениеДоступа"));
		ПослеПланированияОбновления(ПараметрыОбновления);
		
		// АПК:330-выкл - №783.1.3 Допустимо указать вызов после ЗафиксироватьТранзакцию,
		// так как это вызов пустой процедуры в штатном режиме (то есть исключение невозможно),
		// а в режиме анализа производительности последствия учитываются и не являются критичными.
		ПередФиксациейТранзакции(ПараметрыОбновления);
		ЗафиксироватьТранзакцию();
		ПослеФиксацииТранзакции(ПараметрыОбновления);
		// АПК:330-вкл.
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	КоличествоОбработанных = КоличествоОбработанных + ОписаниеКлючейДоступаОбъектов.Количество();
	Если ТребуетсяПрерватьОбработкуЭлементов(ПараметрыОбновления, КоличествоОбработанных) Тогда
		Возврат;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ОбновитьКлючиДоступаПорцииЭлементовДанных.
Процедура ЗаписатьКлючиДоступаРегистров(ПараметрыОбновления, Контекст)
	
	Если Не ЗначениеЗаполнено(ПараметрыОбновления.ИмяОтдельногоРегистраКлючей) Тогда
		ИмяРегистраКлючей = "КлючиДоступаКРегистрам";
	Иначе
		ИмяРегистраКлючей = ПараметрыОбновления.ИмяОтдельногоРегистраКлючей;
	КонецЕсли;
	НаборИзОднойЗаписи = СлужебныйНаборЗаписей(РегистрыСведений[ИмяРегистраКлючей]);
	Запись = НаборИзОднойЗаписи.Добавить();
	
	ПорцияЭлементовДанных = Контекст.ПорцияЭлементовДанных;
	ПустыеЗначенияОпорныхПолей = УправлениеДоступомСлужебныйПовтИсп.ПустыеЗначенияОпорныхПолей(
		ПараметрыОбновления.ОпорныеПоля.МаксимальноеКоличество);
	
	ЗаписыватьТолькоИзмененные = ЗаписыватьТолькоИзмененныеКлючиДоступаЭлементовДанных();
	Если ЗаписыватьТолькоИзмененные Тогда
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ИдентификаторРегистра", ПараметрыОбновления.ИдентификаторСписка);
		ТекстЗапроса = ПараметрыОбновления.ТекстЗапросаТекущихКлючейДоступаРегистра;
		ТекстыПакета = Новый Массив;
		НомерСтроки = 1;
		Для Каждого ОписаниеКлючаДоступаОбъекта Из Контекст.ОписаниеКлючейДоступаОбъектов Цикл
			ТекущийНомер = "_" + Формат(НомерСтроки, "ЧГ=");
			ТекстыПакета.Добавить(СтрЗаменить(ТекстЗапроса, "_%1", ТекущийНомер));
			Для НомерПоля = 1 По ПараметрыОбновления.ОпорныеПоля.Используемые.Количество() Цикл
				ИмяПоля = "Поле" + НомерПоля;
				ЭлементДанных = ПорцияЭлементовДанных.Найти(ОписаниеКлючаДоступаОбъекта.ТекущаяСсылка, "ТекущаяСсылка");
				Запрос.УстановитьПараметр(ИмяПоля + ТекущийНомер, ЭлементДанных[ИмяПоля]);
			КонецЦикла;
			НомерСтроки = НомерСтроки + 1;
		КонецЦикла;
		Запрос.Текст = СтрСоединить(ТекстыПакета, ОбщегоНазначения.РазделительПакетаЗапросов());
		ПередЗапросомТекущихКлючейДоступа(ПараметрыОбновления);
		Если ТекстыПакета.Количество() > 1 Тогда
			РезультатыЗапроса = Запрос.ВыполнитьПакет();
		Иначе
			РезультатыЗапроса = Новый Массив;
			РезультатыЗапроса.Добавить(Запрос.Выполнить());
		КонецЕсли;
		ПослеЗапросаТекущихКлючейДоступа(ПараметрыОбновления);
	КонецЕсли;
	
	КоличествоОбработанных = 0;
	ОписаниеКлючейДоступаОбъектов = Новый Массив;
	
	ИндексРезультата = -1;
	Блокировка = Новый БлокировкаДанных;
	Для Каждого ОписаниеКлючаДоступаОбъекта Из Контекст.ОписаниеКлючейДоступаОбъектов Цикл
		ИндексРезультата = ИндексРезультата + 1;
		КлючДоступа = ОписаниеКлючаДоступаОбъекта.СвойстваКлюча.КлючДоступа;
		Если КлючДоступа = Неопределено Тогда
			Прервать;
		КонецЕсли;
		Если ЗаписыватьТолькоИзмененные Тогда
			РезультатЗапроса = РезультатыЗапроса[ИндексРезультата];
			Если Не РезультатЗапроса.Пустой() Тогда
				Выгрузка = РезультатЗапроса.Выгрузить();
				Если Выгрузка.Количество() = 1 И Выгрузка[0].КлючДоступа = КлючДоступа Тогда
					КоличествоОбработанных = КоличествоОбработанных + 1;
					Продолжить;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		ОписаниеКлючейДоступаОбъектов.Добавить(ОписаниеКлючаДоступаОбъекта);
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений." + ИмяРегистраКлючей);
		Если Не ЗначениеЗаполнено(ПараметрыОбновления.ИмяОтдельногоРегистраКлючей) Тогда
			ЭлементБлокировки.УстановитьЗначение("Регистр", ПараметрыОбновления.ИдентификаторСписка);
		КонецЕсли;
		ЭлементБлокировки.УстановитьЗначение("ДляВнешнихПользователей", ПараметрыОбновления.ДляВнешнихПользователей);
		ЭлементДанных = ПорцияЭлементовДанных.Найти(ОписаниеКлючаДоступаОбъекта.ТекущаяСсылка, "ТекущаяСсылка");
		Для НомерПоля = 1 По ПараметрыОбновления.ОпорныеПоля.Используемые.Количество() Цикл
			ИмяПоля = "Поле" + НомерПоля;
			ЭлементБлокировки.УстановитьЗначение(ИмяПоля, ЭлементДанных[ИмяПоля]);
		КонецЦикла;
	КонецЦикла;
	
	Если ОписаниеКлючейДоступаОбъектов.Количество() = 0 Тогда
		ТребуетсяПрерватьОбработкуЭлементов(ПараметрыОбновления, КоличествоОбработанных);
		Возврат;
	КонецЕсли;
	
	НачатьТранзакцию();
	Попытка
		ПередБлокировкойДанных(ПараметрыОбновления);
		Блокировка.Заблокировать();
		ПослеБлокировкиДанных(ПараметрыОбновления);
		
		ПередЗаписьюСтрок(ПараметрыОбновления);
		Для Каждого ОписаниеКлючаДоступаОбъекта Из ОписаниеКлючейДоступаОбъектов Цикл
			Если Не ЗначениеЗаполнено(ПараметрыОбновления.ИмяОтдельногоРегистраКлючей) Тогда
				НаборИзОднойЗаписи.Отбор.Регистр.Установить(ПараметрыОбновления.ИдентификаторСписка);
				Запись.Регистр = ПараметрыОбновления.ИдентификаторСписка;
			КонецЕсли;
			НаборИзОднойЗаписи.Отбор.ДляВнешнихПользователей.Установить(ПараметрыОбновления.ДляВнешнихПользователей);
			Запись.ДляВнешнихПользователей = ПараметрыОбновления.ДляВнешнихПользователей;
			
			ЭлементДанных = ПорцияЭлементовДанных.Найти(ОписаниеКлючаДоступаОбъекта.ТекущаяСсылка, "ТекущаяСсылка");
			ЗаполнитьЗначенияСвойств(Запись, ПустыеЗначенияОпорныхПолей);
			Для НомерПоля = 1 По ПараметрыОбновления.ОпорныеПоля.Используемые.Количество() Цикл
				ИмяПоля = "Поле" + НомерПоля;
				Если ЭлементДанных[ИмяПоля] = Неопределено Тогда
					НаборИзОднойЗаписи.Отбор[ИмяПоля].Значение = Неопределено;
					НаборИзОднойЗаписи.Отбор[ИмяПоля].Использование = Истина;
				Иначе
					НаборИзОднойЗаписи.Отбор[ИмяПоля].Установить(ЭлементДанных[ИмяПоля]);
				КонецЕсли;
				Запись[ИмяПоля] = ЭлементДанных[ИмяПоля];
			КонецЦикла;
			
			Запись.КлючДоступа = ОписаниеКлючаДоступаОбъекта.СвойстваКлюча.КлючДоступа;
			НаборИзОднойЗаписи.Записать();
		КонецЦикла;
		ПослеЗаписиСтрок(ПараметрыОбновления, ОписаниеКлючейДоступаОбъектов.Количество());
		
		// АПК:330-выкл - №783.1.3 Допустимо указать вызов после ЗафиксироватьТранзакцию,
		// так как это вызов пустой процедуры в штатном режиме (то есть исключение невозможно),
		// а в режиме анализа производительности последствия учитываются и не являются критичными.
		ПередФиксациейТранзакции(ПараметрыОбновления);
		ЗафиксироватьТранзакцию();
		ПослеФиксацииТранзакции(ПараметрыОбновления);
		// АПК:330-вкл.
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	КоличествоОбработанных = КоличествоОбработанных + ОписаниеКлючейДоступаОбъектов.Количество();
	Если ТребуетсяПрерватьОбработкуЭлементов(ПараметрыОбновления, КоличествоОбработанных) Тогда
		Возврат;
	КонецЕсли;
	
КонецПроцедуры

// Для функции ОбновитьЭлементыДанныхСпискаСУстаревшимиКлючами.
Процедура УдалитьНекорректныеКомбинацииЗначенийОпорныхПолей(ПорцияЭлементовДанных, ПараметрыОбновления)
	
	Если Не ЗначениеЗаполнено(ПараметрыОбновления.ИмяОтдельногоРегистраКлючей) Тогда
		ИмяРегистраКлючей = "КлючиДоступаКРегистрам";
	Иначе
		ИмяРегистраКлючей = ПараметрыОбновления.ИмяОтдельногоРегистраКлючей;
	КонецЕсли;
	НаборИзОднойЗаписи = СлужебныйНаборЗаписей(РегистрыСведений[ИмяРегистраКлючей]);
	КоличествоИспользуемыхПолей = ПараметрыОбновления.ОпорныеПоля.Используемые.Количество();
	МаксимальноеКоличествоПолей = ПараметрыОбновления.ОпорныеПоля.МаксимальноеКоличество;
	
	Блокировка = Новый БлокировкаДанных;
	Для Каждого ЭлементДанных Из ПорцияЭлементовДанных Цикл
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений." + ИмяРегистраКлючей);
		Если Не ЗначениеЗаполнено(ПараметрыОбновления.ИмяОтдельногоРегистраКлючей) Тогда
			ЭлементБлокировки.УстановитьЗначение("Регистр", ПараметрыОбновления.ИдентификаторСписка);
		КонецЕсли;
		ЭлементБлокировки.УстановитьЗначение("ДляВнешнихПользователей", ПараметрыОбновления.ДляВнешнихПользователей);
		Для НомерПоля = 1 По МаксимальноеКоличествоПолей Цикл
			ИмяПоля = "Поле" + НомерПоля;
			ЭлементБлокировки.УстановитьЗначение(ИмяПоля, ?(НомерПоля > КоличествоИспользуемыхПолей,
				Перечисления.ДополнительныеЗначенияДоступа.Null, ЭлементДанных[ИмяПоля]));
		КонецЦикла;
	КонецЦикла;
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		Для Каждого ЭлементДанных Из ПорцияЭлементовДанных Цикл
			Если Не ЗначениеЗаполнено(ПараметрыОбновления.ИмяОтдельногоРегистраКлючей) Тогда
				НаборИзОднойЗаписи.Отбор.Регистр.Установить(ПараметрыОбновления.ИдентификаторСписка);
			КонецЕсли;
			Для НомерПоля = 1 По МаксимальноеКоличествоПолей Цикл
				ИмяПоля = "Поле" + НомерПоля;
				НаборИзОднойЗаписи.Отбор[ИмяПоля].Установить(?(НомерПоля > КоличествоИспользуемыхПолей,
					Перечисления.ДополнительныеЗначенияДоступа.Null, ЭлементДанных[ИмяПоля]));
			КонецЦикла;
			НаборИзОднойЗаписи.Записать();
		КонецЦикла;
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Для процедуры ОбновитьКлючиДоступаПорцииЭлементовДанных.
Функция КлючиЗначенийСтрокОбъектов(РезультатыЗапроса, Индекс, ТаблицыКлюча, ЗначенияСтрокТаблиц = Неопределено)
	
	КлючиЗначенийСтрокОбъектов = Новый Соответствие;
	
	Если ЗначенияСтрокТаблиц = Неопределено Тогда
		ЗначенияСтрокТаблиц = Новый Соответствие;
	КонецЕсли;
	
	Для Каждого ИмяТаблицыКлючаДоступа Из ТаблицыКлюча Цикл
		ЗначенияСтрокТаблицы = ЗначенияСтрокТаблиц.Получить(ИмяТаблицыКлючаДоступа);
		Если ЗначенияСтрокТаблицы = Неопределено Тогда
			ЗначенияСтрокТаблицы = Новый Соответствие;
			ЗначенияСтрокТаблиц.Вставить(ИмяТаблицыКлючаДоступа, ЗначенияСтрокТаблицы);
		КонецЕсли;
		Дерево = РезультатыЗапроса[Индекс].Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкам);
		Индекс = Индекс + 1;
		Для Каждого Строка Из Дерево.Строки Цикл
			ЗначенияКолонокТаблицы = Новый Массив;
			Для Каждого Колонка Из Дерево.Колонки Цикл
				Если СтрНачинаетсяС(Колонка.Имя, "Значение") Тогда
					ЗначенияКолонокТаблицы.Добавить(Строка.Строки.ВыгрузитьКолонку(Колонка.Имя));
				КонецЕсли;
			КонецЦикла;
			КлючЗначенийСтрок = СтрокаДанныхДляХеширования(ЗначенияКолонокТаблицы);
			Если ЗначенияСтрокТаблицы.Получить(КлючЗначенийСтрок) = Неопределено Тогда
				ЗначенияСтрокТаблицы.Вставить(КлючЗначенийСтрок, Строка.Строки);
			КонецЕсли;
			ОписаниеКлючейЗначений = КлючиЗначенийСтрокОбъектов.Получить(Строка.ТекущаяСсылка);
			Если ОписаниеКлючейЗначений = Неопределено Тогда
				ОписаниеКлючейЗначений = Новый Структура(
					"КлючиЗначений, ИменаТаблиц, ЗначенияКолонокТаблиц",
					Новый Массив, Новый Массив, Новый Массив);
				КлючиЗначенийСтрокОбъектов.Вставить(Строка.ТекущаяСсылка, ОписаниеКлючейЗначений);
			КонецЕсли;
			ОписаниеКлючейЗначений.ИменаТаблиц.Добавить(ИмяТаблицыКлючаДоступа);
			ОписаниеКлючейЗначений.КлючиЗначений.Добавить(КлючЗначенийСтрок);
			ОписаниеКлючейЗначений.ЗначенияКолонокТаблиц.Добавить(ЗначенияКолонокТаблицы);
		КонецЦикла;
	КонецЦикла;
	
	Возврат КлючиЗначенийСтрокОбъектов;
	
КонецФункции

// Для функции КлючиЗначенийСтрокОбъектов и др.
Функция СтрокаДанныхДляХеширования(Данные)
	
	// Возвращает строку данных для последующего хеширования, например,
	// строковое описание ссылок, сохраняемых в базе данных, с учетом типов
	// по внутренним идентификаторам, что обеспечивает неизменность хеш-суммы
	// при изменении имен таблиц и имен реквизитов, то есть обеспечивает
	// соответствие хеш-суммы данных самим данным, сохраняемым в базе данных.
	//
	// Это позволяет избежать избыточного массового пересоздания ключей доступа с последующим
	// перерасчетом пользователей и групп доступа для пересозданных ключей доступа.
	
	Возврат ЗначениеВСтрокуВнутр(Данные);
	
КонецФункции

// Для процедуры ОбновитьКлючиДоступаПорцииЭлементовДанных.
Процедура ПроверитьТипЗначенийКлючаДоступа(ОписаниеКлюча, ДопустимыеТипыЗначений, ПараметрыОбновления)
	
	ЗначенияКолонокТаблиц = ОписаниеКлюча.ЗначенияКолонокТаблиц;
	
	Для Каждого ЗначенияКолонокТаблицы Из ЗначенияКолонокТаблиц Цикл
		Для Каждого ЗначенияКолонкиТаблицы Из ЗначенияКолонокТаблицы Цикл
			Для Каждого Значение Из ЗначенияКолонкиТаблицы Цикл
				Если Не ДопустимыеТипыЗначений.СодержитТип(ТипЗнч(Значение)) Тогда
					ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Невозможно сохранить значение ""%1"" типа ""%2""
						           |при обновлении ключей доступа списка ""%3"",
						           |так как этот тип не указан в определяемом типе ЗначениеДоступа.'"),
						Строка(Значение),
						Строка(ТипЗнч(Значение)),
						ПараметрыОбновления.Список);
					ВызватьИсключение ТекстОшибки;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ОбновитьКлючиДоступаПорцииЭлементовДанных.
Процедура ПодготовитьНовыйКлючДоступа(ОписаниеКлюча, ОписаниеНовыхКлючей, ПараметрыОбновления)
	
	НоваяСсылка = Справочники.КлючиДоступа.ПолучитьСсылку();
	НовыйКлюч = СлужебныйЭлемент(Справочники.КлючиДоступа);
	
	НовыйКлюч.УстановитьСсылкуНового(НоваяСсылка);
	НовыйКлюч.Наименование            = Строка(НоваяСсылка.УникальныйИдентификатор());
	НовыйКлюч.Список                  = ПараметрыОбновления.ИдентификаторСписка;
	НовыйКлюч.СоставПолей             = ПараметрыОбновления.СоставПолей;
	НовыйКлюч.ДляВнешнихПользователей = ПараметрыОбновления.ДляВнешнихПользователей;
	НовыйКлюч.Хеш                     = ОписаниеКлюча.Хеш;
	
	ВсеЗначенияТаблиц = ОписаниеНовыхКлючей.ЗначенияТаблиц;
	
	Для Каждого ЗначенияТаблицы Из ОписаниеКлюча.ЗначенияТаблиц Цикл
		ВсеЗначенияТаблицы = ВсеЗначенияТаблиц[ЗначенияТаблицы.ИмяТаблицы];
		
		Если СтрНачинаетсяС(ЗначенияТаблицы.ИмяТаблицы, "Шапка") Тогда
			НоваяСтрока = ВсеЗначенияТаблицы.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, ЗначенияТаблицы.Таблица[0]);
			НоваяСтрока.Ссылка = НоваяСсылка;
			
			Если СтрЗаканчиваетсяНа(ЗначенияТаблицы.ИмяТаблицы, "0") Тогда
				ЗаполнитьЗначенияСвойств(НовыйКлюч, ЗначенияТаблицы.Таблица[0],, "Родитель");
			Иначе
				НомерСтроки = Число(Прав(ЗначенияТаблицы.ИмяТаблицы, 1));
				НовыйКлюч.Шапка.Добавить();
				ЗаполнитьЗначенияСвойств(НовыйКлюч.Шапка[НомерСтроки - 1], ЗначенияТаблицы.Таблица[0]);
				НоваяСтрока.НомерСтроки = НомерСтроки;
			КонецЕсли;
		Иначе
			Для Каждого Строка Из ЗначенияТаблицы.Таблица Цикл
				ЗаполнитьЗначенияСвойств(НовыйКлюч[ЗначенияТаблицы.ИмяТаблицы].Добавить(), Строка);
				НоваяСтрока = ВсеЗначенияТаблицы.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
				НоваяСтрока.Ссылка = НоваяСсылка;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	ОписаниеКлюча.Вставить("КлючДоступаОбъект", НовыйКлюч);
	ОписаниеНовыхКлючей.КлючиДоступа.Добавить().Ссылка = НоваяСсылка;
	ОписаниеНовыхКлючей.ОписанияКлючейПоСсылке.Вставить(НоваяСсылка, ОписаниеКлюча);
	
КонецПроцедуры

// Для процедур ОбновитьПорциюЭлементов, ОбновитьПраваНаКлючиДоступа.
Процедура ОбновитьПраваПорцииКлючейДоступаСписка(ОписаниеКлючейДоступа, ПараметрыОбновления, ЭтоНовыеКлючи = Ложь)
	
	Если Не ПараметрыОбновления.Свойство("Кэш") Тогда
		ПараметрыОбновления.Вставить("Кэш", Новый Структура);
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = ПараметрыОбновления.ТекстЗапросаЗначенийИзКлючейДоступаДляРасчетаПрав;
	НомерТаблицы = 0;
	
	Если ЭтоНовыеКлючи Тогда
		ТекстыЗапроса = Новый Массив;
		РеквизитыТаблицКлюча = ПараметрыОбновления.РеквизитыТаблицКлюча;
		Шаблон =
		"ВЫБРАТЬ
		|	&Поля
		|ПОМЕСТИТЬ Таблица
		|ИЗ
		|	&Таблица КАК Таблица";
		Для Каждого ТаблицаКлюча Из ПараметрыОбновления.ТаблицыКлюча Цикл
			ПолеНомерСтроки = "";
			Если СтрНачинаетсяС(ТаблицаКлюча, "Шапка") Тогда
				Если СтрЗаканчиваетсяНа(ТаблицаКлюча, "0") Тогда
					ИмяВременнойТаблицы = "СправочникКлючиДоступа";
					Запрос.Текст = СтрЗаменить(Запрос.Текст,
						"@Справочник.КлючиДоступа ", ИмяВременнойТаблицы + " ");
				Иначе
					ИмяВременнойТаблицы = "СправочникКлючиДоступа" + ТаблицаКлюча;
					ПолеНомерСтроки = "НомерСтроки, ";
					Запрос.Текст = СтрЗаменить(Запрос.Текст,
						"@Справочник.КлючиДоступа.Шапка КАК " + ТаблицаКлюча,
						ИмяВременнойТаблицы + " КАК " + ТаблицаКлюча);
				КонецЕсли;
			Иначе
				ИмяВременнойТаблицы = "СправочникКлючиДоступа" + ТаблицаКлюча;
				Запрос.Текст = СтрЗаменить(Запрос.Текст,
					"@Справочник.КлючиДоступа." + ТаблицаКлюча, ИмяВременнойТаблицы);
			КонецЕсли;
			ТекстЗапроса = СтрЗаменить(Шаблон, "Таблица", ИмяВременнойТаблицы);
			РеквизитыТаблицы = РеквизитыТаблицКлюча.Получить(ТаблицаКлюча);
			Поля = "Ссылка, " + ПолеНомерСтроки + СтрСоединить(РеквизитыТаблицы, ", ");
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Поля", Поля);
			ТекстыЗапроса.Добавить(ТекстЗапроса);
			Запрос.УстановитьПараметр(ИмяВременнойТаблицы, ОписаниеКлючейДоступа.ЗначенияТаблиц[ТаблицаКлюча]);
			НомерТаблицы = НомерТаблицы + 1;
		КонецЦикла;
		ТекстыЗапроса.Добавить(Запрос.Текст);
		Запрос.Текст = СтрСоединить(ТекстыЗапроса, ОбщегоНазначения.РазделительПакетаЗапросов());
		Запрос.УстановитьПараметр("КлючиДоступа", ОписаниеКлючейДоступа.КлючиДоступа);
	Иначе
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "@Справочник.КлючиДоступа", "Справочник.КлючиДоступа");
		Запрос.УстановитьПараметр("КлючиДоступа", ОписаниеКлючейДоступа);
	КонецЕсли;
	
	Запрос.УстановитьПараметр("ИдентификаторТаблицыНастроекПрав",
		ПараметрыОбновления.ИдентификаторТаблицыНастроекПрав);
	
	Запрос.УстановитьПараметр("ПустойУникальныйИдентификатор",
		ОбщегоНазначенияКлиентСервер.ПустойУникальныйИдентификатор());
	
	УстановитьУточнениеПланаЗапроса(Запрос.Текст);
	РезультатыЗапроса = Запрос.ВыполнитьПакет();
	
	ПараметрыОбновления.Вставить("ТипПользователя", ?(ПараметрыОбновления.ДляВнешнихПользователей,
		Тип("СправочникСсылка.ВнешниеПользователи"), Тип("СправочникСсылка.Пользователи")));
	
	ПараметрыОбновления.Вставить("ТипГруппыПользователей", ?(ПараметрыОбновления.ДляВнешнихПользователей,
		Тип("СправочникСсылка.ГруппыВнешнихПользователей"), Тип("СправочникСсылка.ГруппыПользователей")));
	
	ПараметрыОбновления.Вставить("ТипГруппыДоступа",    Тип("СправочникСсылка.ГруппыДоступа"));
	ПараметрыОбновления.Вставить("ПустаяГруппаДоступа", Справочники.ГруппыДоступа.ПустаяСсылка());
	
	ЗначенияТаблицКлючей = Новый Соответствие;
	Для Каждого ТаблицаКлюча Из ПараметрыОбновления.ТаблицыКлюча Цикл
		НомерТаблицы = НомерТаблицы + 1;
		ЗначенияТаблицКлючей.Вставить(ТаблицаКлюча,
			РезультатыЗапроса[НомерТаблицы].Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкам));
	КонецЦикла;
	ЗаполнитьПраваНаВедущиеКлючиДоступаИВедущиеСписки(РезультатыЗапроса, НомерТаблицы, ПараметрыОбновления);
	ЗаполнитьПраваПоВладельцамНастроекПрав(РезультатыЗапроса, НомерТаблицы, ПараметрыОбновления);
	
	ЗаполнитьПраваИУчастниковГруппДоступаСписка(ПараметрыОбновления);
	ЗаполнитьЗначенияГруппДоступаДляРасчетаПрав(ПараметрыОбновления);
	
	ЗначенияПервойТаблицы = ЗначенияТаблицКлючей.Получить(ПараметрыОбновления.ТаблицыКлюча[0]);
	ИндексПоследнегоКлюча = ЗначенияПервойТаблицы.Строки.Количество() - 1;
	
	Для ИндексКлюча = 0 По ИндексПоследнегоКлюча Цикл
		ЗначенияТаблицКлюча = Новый Структура;
		Для Каждого ТаблицаКлюча Из ПараметрыОбновления.ТаблицыКлюча Цикл
			ЗначенияТаблицы = ЗначенияТаблицКлючей.Получить(ТаблицаКлюча).Строки[ИндексКлюча].Строки;
			Если СтрНачинаетсяС(ТаблицаКлюча, "Шапка") Тогда
				ЗначенияТаблицы = ЗначенияТаблицы[0];
			КонецЕсли;
			ЗначенияТаблицКлюча.Вставить(ТаблицаКлюча, ЗначенияТаблицы);
		КонецЦикла;
		КлючДоступа = ЗначенияПервойТаблицы.Строки[ИндексКлюча].Ссылка;
		
		ПраваНаКлюч = ПраваНаКлючДоступаСписка(ЗначенияТаблицКлюча, ПараметрыОбновления);
		ОбновитьПраваНаКлючДоступаСписка(КлючДоступа, ПраваНаКлюч,
			?(ЭтоНовыеКлючи, ОписаниеКлючейДоступа, Неопределено), ПараметрыОбновления);
		
		Если ТребуетсяПрерватьОбработкуЭлементов(ПараметрыОбновления) Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ОбновитьПорциюЭлементов.
Процедура ОбработатьУстаревшиеКлючиДоступаСписка(ЭлементыДанных, ПараметрыОбновления)
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА КАК Поле1
	|ИЗ
	|	РегистрСведений.КлючиДоступаГруппДоступа КАК КлючиДоступаГруппДоступа
	|ГДЕ
	|	КлючиДоступаГруппДоступа.КлючДоступа = &КлючДоступа
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА КАК Поле1
	|ИЗ
	|	РегистрСведений.КлючиДоступаНаборовГруппДоступа КАК КлючиДоступаНаборовГруппДоступа
	|ГДЕ
	|	КлючиДоступаНаборовГруппДоступа.КлючДоступа = &КлючДоступа
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА КАК Поле1
	|ИЗ
	|	РегистрСведений.КлючиДоступаПользователей КАК КлючиДоступаПользователей
	|ГДЕ
	|	КлючиДоступаПользователей.КлючДоступа = &КлючДоступа
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА КАК Поле1
	|ИЗ
	|	РегистрСведений.КлючиДоступаВнешнихПользователей КАК КлючиДоступаВнешнихПользователей
	|ГДЕ
	|	КлючиДоступаВнешнихПользователей.КлючДоступа = &КлючДоступа";
	
	ЭтоОчисткаВсехКлючей = ПараметрыОбновления.БезЗаписиКлючейДоступа
		Или ПараметрыОбновления.СЗаписьюВсегдаРазрешенногоКлючаДоступа;
	
	Если Не ЭтоОчисткаВсехКлючей Тогда
		ЗапросИспользованияКлюча = Новый Запрос;
		ЗапросИспользованияКлюча.Текст =
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	ИСТИНА КАК ЗначениеИстина
		|ИЗ
		|	Справочник.КлючиДоступа КАК КлючиДоступа
		|ГДЕ
		|	КлючиДоступа.Ссылка = &Ссылка
		|	И КлючиДоступа.НеИспользуетсяС = ДАТАВРЕМЯ(1, 1, 1)";
	КонецЕсли;
	
	НаборЗаписейГруппДоступаКлюча         = СлужебныйНаборЗаписей(РегистрыСведений.КлючиДоступаГруппДоступа);
	НаборЗаписейНаборовГруппДоступаКлюча  = СлужебныйНаборЗаписей(РегистрыСведений.КлючиДоступаНаборовГруппДоступа);
	НаборЗаписейПользователейКлюча        = СлужебныйНаборЗаписей(РегистрыСведений.КлючиДоступаПользователей);
	НаборЗаписейВнешнихПользователейКлюча = СлужебныйНаборЗаписей(РегистрыСведений.КлючиДоступаВнешнихПользователей);
	
	Для Каждого Строка Из ЭлементыДанных Цикл
		Если Не ЭтоОчисткаВсехКлючей И Строка.Используется Тогда
			ЗапросИспользованияКлюча.УстановитьПараметр("Ссылка", Строка.Ссылка);
			Если Не ЗапросИспользованияКлюча.Выполнить().Пустой() Тогда
				Если ТребуетсяПрерватьОбработкуЭлементов(ПараметрыОбновления, 1) Тогда
					Прервать;
				КонецЕсли;
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		Блокировка = Новый БлокировкаДанных;
		Если Не ЭтоОчисткаВсехКлючей Тогда
			ЭлементБлокировки = Блокировка.Добавить("Справочник.КлючиДоступа");
			ЭлементБлокировки.УстановитьЗначение("Список",      Строка.Список);
			ЭлементБлокировки.УстановитьЗначение("Хеш",         Строка.Хеш);
			ЭлементБлокировки.УстановитьЗначение("СоставПолей", Строка.СоставПолей);
			ЭлементБлокировки.УстановитьЗначение("ДляВнешнихПользователей",
				ПараметрыОбновления.ДляВнешнихПользователей);
		КонецЕсли;
		ЭлементБлокировки = Блокировка.Добавить("Справочник.КлючиДоступа");
		ЭлементБлокировки.УстановитьЗначение("Ссылка", Строка.Ссылка);
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КлючиДоступаГруппДоступа");
		ЭлементБлокировки.УстановитьЗначение("КлючДоступа", Строка.Ссылка);
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КлючиДоступаНаборовГруппДоступа");
		ЭлементБлокировки.УстановитьЗначение("КлючДоступа", Строка.Ссылка);
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КлючиДоступаПользователей");
		ЭлементБлокировки.УстановитьЗначение("КлючДоступа", Строка.Ссылка);
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КлючиДоступаВнешнихПользователей");
		ЭлементБлокировки.УстановитьЗначение("КлючДоступа", Строка.Ссылка);
		
		НачатьТранзакцию();
		Попытка
			Блокировка.Заблокировать();
			Объект = СлужебныйЭлемент(Неопределено, Строка.Ссылка);
			УдалитьКлюч = Ложь;
			Если ЭтоОчисткаВсехКлючей Или Объект = Неопределено Тогда
				УдалитьКлюч = Истина;
			ИначеЕсли Строка.Используется Тогда
				Объект.НеИспользуетсяС = '00010101';
			ИначеЕсли Не Строка.Удалить Тогда
				Объект.НеИспользуетсяС = ТекущаяДатаСеанса();
			ИначеЕсли ЗначениеЗаполнено(Объект.НеИспользуетсяС) Тогда
				УдалитьКлюч = Истина;
			КонецЕсли;
			Если УдалитьКлюч Тогда
				Запрос.УстановитьПараметр("КлючДоступа", Строка.Ссылка);
				РезультатыЗапроса = Запрос.ВыполнитьПакет();
				Если Не РезультатыЗапроса[0].Пустой() Тогда
					НаборЗаписейГруппДоступаКлюча.Отбор.КлючДоступа.Установить(Строка.Ссылка);
					НаборЗаписейГруппДоступаКлюча.Записать();
				КонецЕсли;
				Если Не РезультатыЗапроса[1].Пустой() Тогда
					НаборЗаписейНаборовГруппДоступаКлюча.Отбор.КлючДоступа.Установить(Строка.Ссылка);
					НаборЗаписейНаборовГруппДоступаКлюча.Записать();
				КонецЕсли;
				Если Не РезультатыЗапроса[2].Пустой() Тогда
					НаборЗаписейПользователейКлюча.Отбор.КлючДоступа.Установить(Строка.Ссылка);
					НаборЗаписейПользователейКлюча.Записать();
				КонецЕсли;
				Если Не РезультатыЗапроса[3].Пустой() Тогда
					НаборЗаписейВнешнихПользователейКлюча.Отбор.КлючДоступа.Установить(Строка.Ссылка);
					НаборЗаписейВнешнихПользователейКлюча.Записать();
				КонецЕсли;
			КонецЕсли;
			Если Объект <> Неопределено Тогда
				Если УдалитьКлюч Тогда
					Объект.Удалить();
				ИначеЕсли Объект.Модифицированность() Тогда
					Объект.Записать();
				КонецЕсли;
			КонецЕсли;
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
		
		Если ТребуетсяПрерватьОбработкуЭлементов(ПараметрыОбновления, 1) Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ОбновитьПраваПорцииКлючейДоступаСписка.
Процедура ЗаполнитьПраваИУчастниковГруппДоступаСписка(ПараметрыОбновления)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Таблица", ПараметрыОбновления.ИдентификаторСписка);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Профили.Ссылка КАК Профиль,
	|	МАКСИМУМ(ВЫБОР
	|			КОГДА НазначениеПрофилей.ТипПользователей ЕСТЬ NULL
	|				ТОГДА ИСТИНА
	|			ИНАЧЕ ТИПЗНАЧЕНИЯ(НазначениеПрофилей.ТипПользователей) = ТИП(Справочник.Пользователи)
	|		КОНЕЦ) КАК ДляПользователей,
	|	МАКСИМУМ(ВЫБОР
	|			КОГДА НазначениеПрофилей.ТипПользователей ЕСТЬ NULL
	|				ТОГДА ЛОЖЬ
	|			ИНАЧЕ НазначениеПрофилей.ТипПользователей <> НЕОПРЕДЕЛЕНО
	|					И ТИПЗНАЧЕНИЯ(НазначениеПрофилей.ТипПользователей) <> ТИП(Справочник.Пользователи)
	|		КОНЕЦ) КАК ДляВнешнихПользователей
	|ПОМЕСТИТЬ НазначениеПрофилей
	|ИЗ
	|	Справочник.ПрофилиГруппДоступа КАК Профили
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ПрофилиГруппДоступа.Назначение КАК НазначениеПрофилей
	|		ПО (НазначениеПрофилей.Ссылка = Профили.Ссылка)
	|
	|СГРУППИРОВАТЬ ПО
	|	Профили.Ссылка
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТаблицыГруппДоступа.ГруппаДоступа КАК ГруппаДоступа,
	|	ТаблицыГруппДоступа.Изменение КАК Изменение,
	|	ТаблицыГруппДоступа.Добавление КАК Добавление,
	|	ТаблицыГруппДоступа.ЧтениеБезОграничения КАК ЧтениеБезОграничения,
	|	ТаблицыГруппДоступа.ИзменениеБезОграничения КАК ИзменениеБезОграничения,
	|	ТаблицыГруппДоступа.ДобавлениеБезОграничения КАК ДобавлениеБезОграничения
	|ИЗ
	|	РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступа
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ГруппыДоступа КАК ГруппыДоступа
	|		ПО (ТаблицыГруппДоступа.Таблица = &Таблица)
	|			И (ГруппыДоступа.Ссылка = ТаблицыГруппДоступа.ГруппаДоступа)
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ НазначениеПрофилей КАК НазначениеПрофилей
	|		ПО (НазначениеПрофилей.Профиль = ГруппыДоступа.Профиль)
	|			И (НазначениеПрофилей.ДляПользователей)
	|			И (&УточнениеПланаЗапроса)";
	
	ТекстЗапросаУчастников =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ГруппыДоступа.Ссылка КАК Ссылка
	|ПОМЕСТИТЬ ГруппыДоступа
	|ИЗ
	|	(ВЫБРАТЬ
	|		ТаблицыГруппДоступа.ГруппаДоступа КАК Ссылка
	|	ИЗ
	|		РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступа
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ГруппыДоступа КАК ГруппыДоступа
	|			ПО (ТаблицыГруппДоступа.Таблица = &Таблица)
	|				И (ГруппыДоступа.Ссылка = ТаблицыГруппДоступа.ГруппаДоступа)
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ НазначениеПрофилей КАК НазначениеПрофилей
	|			ПО (НазначениеПрофилей.Профиль = ГруппыДоступа.Профиль)
	|				И (НазначениеПрофилей.ДляПользователей)
	|				И (&УточнениеПланаЗапроса)
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ВЫБРАТЬ
	|		ГруппыДоступа.Ссылка
	|	ИЗ
	|		Справочник.ГруппыДоступа КАК ГруппыДоступа
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ НазначениеПрофилей КАК НазначениеПрофилей
	|			ПО (НазначениеПрофилей.Профиль = ГруппыДоступа.Профиль)
	|				И (НазначениеПрофилей.ДляПользователей)
	|				И (ГруппыДоступа.Ссылка В (&ДополнительныеГруппыДоступа))) КАК ГруппыДоступа
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ГруппыПользователей.Ссылка КАК Ссылка
	|ПОМЕСТИТЬ ГруппыПользователей
	|ИЗ
	|	(ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		ПользователиГруппыДоступа.Пользователь КАК Ссылка
	|	ИЗ
	|		Справочник.ГруппыДоступа.Пользователи КАК ПользователиГруппыДоступа
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ ГруппыДоступа КАК ГруппыДоступа
	|			ПО (ГруппыДоступа.Ссылка = ПользователиГруппыДоступа.Ссылка)
	|				И (ТИПЗНАЧЕНИЯ(ПользователиГруппыДоступа.Пользователь) = ТИП(Справочник.ГруппыПользователей))
	|	ГДЕ
	|		&УточнениеПланаЗапроса
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ВЫБРАТЬ
	|		ГруппыПользователей.Ссылка
	|	ИЗ
	|		Справочник.ГруппыПользователей КАК ГруппыПользователей
	|	ГДЕ
	|		ГруппыПользователей.Ссылка В(&ДополнительныеГруппыПользователей)) КАК ГруппыПользователей
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	СоставыГруппПользователей.ГруппаПользователей КАК ГруппаПользователей,
	|	СоставыГруппПользователей.Пользователь КАК Пользователь
	|ИЗ
	|	РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ГруппыПользователей КАК ГруппыПользователей
	|		ПО (ГруппыПользователей.Ссылка = СоставыГруппПользователей.ГруппаПользователей)
	|			И (СоставыГруппПользователей.Используется)
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Пользователи КАК Пользователи
	|		ПО (Пользователи.Ссылка = СоставыГруппПользователей.Пользователь)
	|			И (Пользователи.ИдентификаторПользователяИБ <> &ПустойУникальныйИдентификатор)
	|			И (&УточнениеПланаЗапроса)
	|ИТОГИ ПО
	|	ГруппаПользователей
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ЗначенияГруппДоступа.ЗначениеДоступа КАК Ссылка
	|ПОМЕСТИТЬ ГруппыПользователейКакЗначенияДоступа
	|ИЗ
	|	РегистрСведений.ЗначенияГруппДоступа КАК ЗначенияГруппДоступа
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ГруппыДоступа КАК ГруппыДоступа
	|		ПО (ГруппыДоступа.Ссылка = ЗначенияГруппДоступа.ГруппаДоступа)
	|			И (ТИПЗНАЧЕНИЯ(ЗначенияГруппДоступа.ЗначениеДоступа) = ТИП(Справочник.ГруппыПользователей))
	|ГДЕ
	|	&УточнениеПланаЗапроса
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	СоставыГруппПользователей.ГруппаПользователей КАК ГруппаПользователей,
	|	СоставыГруппПользователей.Пользователь КАК Пользователь
	|ИЗ
	|	РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ГруппыПользователейКакЗначенияДоступа КАК ГруппыПользователейКакЗначенияДоступа
	|		ПО (ГруппыПользователейКакЗначенияДоступа.Ссылка = СоставыГруппПользователей.ГруппаПользователей)
	|			И (&УточнениеПланаЗапроса)
	|ИТОГИ ПО
	|	ГруппаПользователей
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ПользователиГруппыДоступа.Ссылка КАК ГруппаДоступа,
	|	ПользователиГруппыДоступа.Пользователь КАК Участник
	|ИЗ
	|	Справочник.ГруппыДоступа.Пользователи КАК ПользователиГруппыДоступа
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ГруппыДоступа КАК ГруппыДоступа
	|		ПО (ГруппыДоступа.Ссылка = ПользователиГруппыДоступа.Ссылка)
	|			И (ИСТИНА В
	|				(ВЫБРАТЬ ПЕРВЫЕ 1
	|					ИСТИНА
	|				ИЗ
	|					РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|						ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Пользователи КАК Пользователи
	|						ПО
	|							СоставыГруппПользователей.ГруппаПользователей = ПользователиГруппыДоступа.Пользователь
	|								И СоставыГруппПользователей.Используется
	|								И Пользователи.Ссылка = СоставыГруппПользователей.Пользователь
	|								И Пользователи.ИдентификаторПользователяИБ <> &ПустойУникальныйИдентификатор))
	|			И (&УточнениеПланаЗапроса)
	|ИТОГИ ПО
	|	ГруппаДоступа";
	
	Если ПараметрыОбновления.РассчитыватьПраваПользователей Тогда
		Если ПараметрыОбновления.ДляВнешнихПользователей Тогда
			ТекстЗапросаУчастников = СтрЗаменить(ТекстЗапросаУчастников,
				"Справочник.Пользователи", "Справочник.ВнешниеПользователи");
			ТекстЗапросаУчастников = СтрЗаменить(ТекстЗапросаУчастников,
				"Справочник.ГруппыПользователей", "Справочник.ГруппыВнешнихПользователей");
		КонецЕсли;
		
		Запрос.Текст = Запрос.Текст + ОбщегоНазначения.РазделительПакетаЗапросов() + ТекстЗапросаУчастников;
		Запрос.УстановитьПараметр("ПустойУникальныйИдентификатор",
			ОбщегоНазначенияКлиентСервер.ПустойУникальныйИдентификатор());
		
		ДополнительныеГруппыДоступа       = Новый Массив;
		ДополнительныеГруппыПользователей = Новый Массив;
		Запрос.УстановитьПараметр("ДополнительныеГруппыДоступа",       ДополнительныеГруппыДоступа);
		Запрос.УстановитьПараметр("ДополнительныеГруппыПользователей", ДополнительныеГруппыПользователей);
		
		ДобавленныеГруппыДоступа          = Новый Соответствие;
		ДобавленныеГруппыПользователей    = Новый Соответствие;
		ТипГруппыДоступа       = ПараметрыОбновления.ТипГруппыДоступа;
		ТипГруппыПользователей = ПараметрыОбновления.ТипГруппыПользователей;
		
		Для Каждого КлючИЗначение Из ПараметрыОбновления.ПраваНаВедущиеКлючиДоступа Цикл
			Для Каждого ОписаниеПрав Из КлючИЗначение.Значение Цикл
				Если ТипЗнч(ОписаниеПрав.Ключ) = ТипГруппыДоступа Тогда
					Если ДобавленныеГруппыДоступа.Получить(ОписаниеПрав.Ключ) <> Неопределено Тогда
						ДобавленныеГруппыДоступа.Вставить(ОписаниеПрав.Ключ, Истина);
						ДополнительныеГруппыДоступа.Добавить(ОписаниеПрав.Ключ);
					КонецЕсли;
				ИначеЕсли ТипЗнч(ОписаниеПрав.Ключ) = ТипГруппыПользователей Тогда
					Если ДобавленныеГруппыПользователей.Получить(ОписаниеПрав.Ключ) <> Неопределено Тогда
						ДобавленныеГруппыПользователей.Вставить(ОписаниеПрав.Ключ, Истина);
						ДополнительныеГруппыПользователей.Добавить(ОписаниеПрав.Ключ);
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
		Для Каждого КлючИЗначение Из ПараметрыОбновления.ПраваПоВладельцамНастроекПрав Цикл
			Для Каждого ОписаниеПрав Из КлючИЗначение.Значение Цикл
				Если ТипЗнч(ОписаниеПрав.Ключ) = ТипГруппыПользователей Тогда
					Если ДобавленныеГруппыПользователей.Получить(ОписаниеПрав.Ключ) <> Неопределено Тогда
						ДобавленныеГруппыПользователей.Вставить(ОписаниеПрав.Ключ, Истина);
						ДополнительныеГруппыПользователей.Добавить(ОписаниеПрав.Ключ);
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	
	Если ПараметрыОбновления.ДляВнешнихПользователей Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст,
			"НазначениеПрофилей.ДляПользователей", "НазначениеПрофилей.ДляВнешнихПользователей");
	КонецЕсли;
	УстановитьУточнениеПланаЗапроса(Запрос.Текст);
	
	РезультатыЗапроса = Запрос.ВыполнитьПакет();
	
	Выборка = РезультатыЗапроса[1].Выбрать();
	ПраваГруппДоступаСписка = Новый Соответствие;
	
	Пока Выборка.Следующий() Цикл
		ПраваГруппыДоступа = Новый Структура;
		ПраваГруппыДоступа.Вставить("Изменение",                Выборка.Изменение);
		ПраваГруппыДоступа.Вставить("Добавление",               Выборка.Добавление);
		ПраваГруппыДоступа.Вставить("ЧтениеБезОграничения",     Выборка.ЧтениеБезОграничения);
		ПраваГруппыДоступа.Вставить("ИзменениеБезОграничения",  Выборка.ИзменениеБезОграничения);
		ПраваГруппыДоступа.Вставить("ДобавлениеБезОграничения", Выборка.ДобавлениеБезОграничения);
		ПраваГруппДоступаСписка.Вставить(Выборка.ГруппаДоступа, ПраваГруппыДоступа);
	КонецЦикла;
	ПараметрыОбновления.Вставить("ПраваГруппДоступаСписка", ПраваГруппДоступаСписка);
	
	ПараметрыОбновления.Вставить("ПользователиГруппПользователей", Новый Соответствие);
	Если ПараметрыОбновления.РассчитыватьПраваПользователей Тогда
		ЗаполнитьПользователейГруппПользователей(ПараметрыОбновления.ПользователиГруппПользователей,
			РезультатыЗапроса[4]);
	КонецЕсли;
	
	ПараметрыОбновления.Вставить("ГруппыПользователейКакЗначенияДоступа", Новый Соответствие);
	Если ПараметрыОбновления.РассчитыватьПраваПользователей Тогда
		ЗаполнитьПользователейГруппПользователей(ПараметрыОбновления.ГруппыПользователейКакЗначенияДоступа,
			РезультатыЗапроса[6]);
	КонецЕсли;
	
	УчастникиГруппДоступа           = Новый Соответствие;
	ГруппыПользователейГруппДоступа = Новый Соответствие;
	ТипГруппыПользователей          = ПараметрыОбновления.ТипГруппыПользователей;
	ПользователиГруппПользователей  = ПараметрыОбновления.ПользователиГруппПользователей;
	
	Если ПараметрыОбновления.РассчитыватьПраваПользователей Тогда
		Дерево = РезультатыЗапроса[7].Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкам);
		Для Каждого Строка Из Дерево.Строки Цикл
			УчастникиГруппыДоступа = Новый Соответствие;
			ГруппыПользователейГруппыДоступа = Новый Соответствие;
			Для Каждого Подстрока Из Строка.Строки Цикл
				УчастникиГруппыДоступа.Вставить(Подстрока.Участник, Истина);
				Если ТипЗнч(Подстрока.Участник) = ТипГруппыПользователей Тогда
					ПользователиГруппы = ПользователиГруппПользователей.Получить(Подстрока.Участник);
					Если ПользователиГруппы <> Неопределено Тогда
						ГруппыПользователейГруппыДоступа.Вставить(Подстрока.Участник, ПользователиГруппы);
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			Если УчастникиГруппыДоступа.Количество() > 0 Тогда
				УчастникиГруппДоступа.Вставить(Строка.ГруппаДоступа, УчастникиГруппыДоступа);
			КонецЕсли;
			Если ГруппыПользователейГруппыДоступа.Количество() > 0 Тогда
				ГруппыПользователейГруппДоступа.Вставить(Строка.ГруппаДоступа, ГруппыПользователейГруппыДоступа);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	ПараметрыОбновления.Вставить("УчастникиГруппДоступа",           УчастникиГруппДоступа);
	ПараметрыОбновления.Вставить("ГруппыПользователейГруппДоступа", ГруппыПользователейГруппДоступа);
	
КонецПроцедуры

// Для процедуры ЗаполнитьПраваИУчастниковГруппДоступаСписка.
Процедура ЗаполнитьПользователейГруппПользователей(ПользователиГруппПользователей, РезультатЗапроса)
	
	Дерево = РезультатЗапроса.Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкам);
	Для Каждого Строка Из Дерево.Строки Цикл
		ПользователиГруппыПользователей = Новый Соответствие;
		Для Каждого Подстрока Из Строка.Строки Цикл
			ПользователиГруппыПользователей.Вставить(Подстрока.Пользователь, Истина);
		КонецЦикла;
		ПользователиГруппПользователей.Вставить(Строка.ГруппаПользователей, ПользователиГруппыПользователей);
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ОбновитьПраваПорцииКлючейДоступаСписка.
Процедура ЗаполнитьЗначенияГруппДоступаДляРасчетаПрав(ПараметрыОбновления)
	
	Если Не ПараметрыОбновления.Кэш.Свойство("ЗначенияГруппДоступаВерсия") Тогда
		ПараметрыОбновления.Кэш.Вставить("ЗначенияГруппДоступаВерсия", Новый УникальныйИдентификатор);
	КонецЕсли;
	
	Если ТранзакцияАктивна() И ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		Блокировка = Новый БлокировкаДанных;
		Блокировка.Добавить("РегистрСведений.ПараметрыРаботыВерсийРасширений");
		Блокировка.Заблокировать();
	КонецЕсли;
	
	ИмяПараметраВерсии = "СтандартныеПодсистемы.УправлениеДоступом.ЗначенияГруппДоступаВерсия";
	ЗначенияГруппДоступаВерсия = СтандартныеПодсистемыСервер.ПараметрРаботыРасширения(ИмяПараметраВерсии, Истина);
	
	Если ПараметрыОбновления.Кэш.ЗначенияГруппДоступаВерсия = ЗначенияГруппДоступаВерсия Тогда
		ПараметрыОбновления.Вставить("ЗначенияГруппДоступа", ПараметрыОбновления.Кэш.ЗначенияГруппДоступа);
		Возврат;
	КонецЕсли;
	
	ИмяПараметра = "СтандартныеПодсистемы.УправлениеДоступом.ЗначенияГруппДоступа";
	ЗначенияГруппДоступа = СтандартныеПодсистемыСервер.ПараметрРаботыРасширения(ИмяПараметра, Истина);
	
	Если ЗначенияГруппДоступаВерсия <> Неопределено И ЗначенияГруппДоступа <> Неопределено Тогда
		ПараметрыОбновления.Кэш.Вставить("ЗначенияГруппДоступаВерсия", ЗначенияГруппДоступаВерсия);
		ПараметрыОбновления.Кэш.Вставить("ЗначенияГруппДоступа", ЗначенияГруппДоступа);
		ПараметрыОбновления.Вставить("ЗначенияГруппДоступа", ЗначенияГруппДоступа);
		Возврат;
	КонецЕсли;
	
	ЗначенияГруппДоступаВерсия = Новый УникальныйИдентификатор;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ЗначенияГруппДоступаПоУмолчанию.ГруппаДоступа КАК ГруппаДоступа,
	|	ТИПЗНАЧЕНИЯ(ЗначенияГруппДоступаПоУмолчанию.ТипЗначенийДоступа) КАК ТипЗначенийДоступа,
	|	ЗначенияГруппДоступаПоУмолчанию.ВсеРазрешены КАК ВсеРазрешены
	|ИЗ
	|	РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияГруппДоступаПоУмолчанию
	|ГДЕ
	|	НЕ ЗначенияГруппДоступаПоУмолчанию.БезНастройки
	|ИТОГИ ПО
	|	ГруппаДоступа
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ЗначенияГруппДоступа.ГруппаДоступа КАК ГруппаДоступа,
	|	ТИПЗНАЧЕНИЯ(ЗначенияГруппДоступа.ЗначениеДоступа) КАК ТипЗначенийДоступа,
	|	ЗначенияГруппДоступа.ЗначениеДоступа КАК ЗначениеДоступа
	|ИЗ
	|	РегистрСведений.ЗначенияГруппДоступа КАК ЗначенияГруппДоступа
	|ИТОГИ ПО
	|	ГруппаДоступа,
	|	ТипЗначенийДоступа";
	РезультатыЗапроса = Запрос.ВыполнитьПакет();
	
	ЗначенияГруппДоступа = Новый Соответствие;
	
	Дерево = РезультатыЗапроса[0].Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкам);
	Для Каждого Строка Из Дерево.Строки Цикл
		ЗначенияГруппыДоступа = Новый Соответствие;
		Для Каждого Подстрока Из Строка.Строки Цикл
			ЗначенияОдногоТипа = Новый Структура;
			ЗначенияОдногоТипа.Вставить("ВсеРазрешены", Подстрока.ВсеРазрешены);
			ЗначенияОдногоТипа.Вставить("Значения",     Новый Соответствие);
			ЗначенияГруппыДоступа.Вставить(Подстрока.ТипЗначенийДоступа, ЗначенияОдногоТипа);
		КонецЦикла;
		ЗначенияГруппДоступа.Вставить(Строка.ГруппаДоступа, ЗначенияГруппыДоступа);
	КонецЦикла;
	
	Дерево = РезультатыЗапроса[1].Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкам);
	Для Каждого Строка Из Дерево.Строки Цикл
		ЗначенияГруппыДоступа = ЗначенияГруппДоступа.Получить(Строка.ГруппаДоступа);
		Если ЗначенияГруппыДоступа = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Для Каждого Подстрока Из Строка.Строки Цикл
			ЗначенияОдногоТипа = ЗначенияГруппыДоступа.Получить(Подстрока.ТипЗначенийДоступа);
			Если ЗначенияОдногоТипа = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			Значения = ЗначенияОдногоТипа.Значения;
			Для Каждого ОписаниеЗначения Из Подстрока.Строки Цикл
				Значения.Вставить(ОписаниеЗначения.ЗначениеДоступа, Истина);
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
	СтандартныеПодсистемыСервер.УстановитьПараметрРаботыРасширения(ИмяПараметра, ЗначенияГруппДоступа, Истина);
	СтандартныеПодсистемыСервер.УстановитьПараметрРаботыРасширения(ИмяПараметраВерсии, ЗначенияГруппДоступаВерсия, Истина);
	
	ПараметрыОбновления.Кэш.Вставить("ЗначенияГруппДоступаВерсия", ЗначенияГруппДоступаВерсия);
	ПараметрыОбновления.Кэш.Вставить("ЗначенияГруппДоступа", ЗначенияГруппДоступа);
	ПараметрыОбновления.Вставить("ЗначенияГруппДоступа", ЗначенияГруппДоступа);
	
КонецПроцедуры

// Для процедуры ОбновитьПраваПорцииКлючейДоступаСписка.
Процедура ЗаполнитьПраваНаВедущиеКлючиДоступаИВедущиеСписки(РезультатыЗапроса, НомерТаблицы, ПараметрыОбновления)
	
	ПраваНаСпискиВедущихКлючейДоступа = Новый Соответствие;
	ПраваНаВедущиеКлючиДоступа = Новый Соответствие;
	Если ПараметрыОбновления.ЕстьВедущиеКлючиДоступа Тогда
		ДействующиеПараметры = ДействующиеПараметрыОграниченияДоступа(ПараметрыОбновления.ИдентификаторТранзакции, Неопределено, Ложь);
		Если ПараметрыОбновления.ДляВнешнихПользователей Тогда
			ДополнительныйКонтекст = ДействующиеПараметры.ДополнительныйКонтекст.ДляВнешнихПользователей;
		Иначе
			ДополнительныйКонтекст = ДействующиеПараметры.ДополнительныйКонтекст.ДляПользователей;
		КонецЕсли;
		НомерТаблицы = НомерТаблицы + 1;
		ПраваНаСписки = Новый Соответствие;
		Дерево = РезультатыЗапроса[НомерТаблицы].Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкам);
		ИдентификаторыСписков = Дерево.Строки.ВыгрузитьКолонку("Список");
		Если ПараметрыОбновления.Кэш.Свойство("ОбъектыМетаданныхПоИдентификаторам") Тогда
			ОбъектыМетаданныхПоИдентификаторам = ПараметрыОбновления.Кэш.ОбъектыМетаданныхПоИдентификаторам;
			НенайденныеИдентификаторыСписков = Новый Массив;
			Для Каждого ИдентификаторСписка Из ИдентификаторыСписков Цикл
				Если ОбъектыМетаданныхПоИдентификаторам.Получить(ИдентификаторСписка) = Неопределено Тогда
					НенайденныеИдентификаторыСписков.Добавить(ИдентификаторСписка);
				КонецЕсли;
			КонецЦикла;
			Результат = ОбщегоНазначения.ОбъектыМетаданныхПоИдентификаторам(
				НенайденныеИдентификаторыСписков, Ложь);
			Для Каждого КлючИЗначение Из Результат Цикл
				ОбъектыМетаданныхПоИдентификаторам.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
			КонецЦикла;
		Иначе
			ОбъектыМетаданныхПоИдентификаторам = ОбщегоНазначения.ОбъектыМетаданныхПоИдентификаторам(
				ИдентификаторыСписков, Ложь);
		КонецЕсли;
		Для Каждого Строка Из Дерево.Строки Цикл
			ОбъектМетаданных = ОбъектыМетаданныхПоИдентификаторам.Получить(Строка.Список);
			Если ТипЗнч(ОбъектМетаданных) <> Тип("ОбъектМетаданных") Тогда
				Продолжить;
			КонецЕсли;
			ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
			ПоГруппамДоступа = Новый Соответствие;
			Для Каждого Подстрока Из Строка.Строки Цикл
				ПоГруппамДоступа.Вставить(Подстрока.ГруппаДоступа, Подстрока.Изменение);
			КонецЦикла;
			ПраваНаСписок = Новый Структура;
			ПраваНаСписок.Вставить("ОграничениеЧтенияОтключено",
				ДополнительныйКонтекст.СпискиСОтключеннымОграничениемЧтения.Получить(ПолноеИмя) <> Неопределено);
			ПраваНаСписок.Вставить("ОграничениеОтключено",
				ДополнительныйКонтекст.СпискиСОтключеннымОграничением.Получить(ПолноеИмя) <> Неопределено);
			ПраваНаСписок.Вставить("ПоГруппамДоступа", Новый ФиксированноеСоответствие(ПоГруппамДоступа));
			ПраваНаСписки.Вставить(Строка.Список, Новый ФиксированнаяСтруктура(ПраваНаСписок));
		КонецЦикла;
		НомерТаблицы = НомерТаблицы + 1;
		Таблица = РезультатыЗапроса[НомерТаблицы].Выгрузить();
		Для Каждого Строка Из Таблица Цикл
			ПраваНаСпискиВедущихКлючейДоступа.Вставить(Строка.КлючДоступа,
				ПраваНаСписки.Получить(Строка.Список));
		КонецЦикла;
		НомерТаблицы = НомерТаблицы + 1;
		Дерево = РезультатыЗапроса[НомерТаблицы].Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкам);
		Для Каждого Строка Из Дерево.Строки Цикл
			ПраваНаВедущийКлюч = Новый Соответствие;
			Для Каждого Подстрока Из Строка.Строки Цикл
				ПраваНаВедущийКлюч.Вставить(Подстрока.ВладелецПрав, Подстрока.Изменение);
			КонецЦикла;
			ПраваНаВедущиеКлючиДоступа.Вставить(Строка.КлючДоступа,
				Новый ФиксированноеСоответствие(ПраваНаВедущийКлюч));
		КонецЦикла;
	КонецЕсли;
	ПараметрыОбновления.Вставить("ПраваНаСпискиВедущихКлючейДоступа",
		Новый ФиксированноеСоответствие(ПраваНаСпискиВедущихКлючейДоступа));
	ПараметрыОбновления.Вставить("ПраваНаВедущиеКлючиДоступа",
		Новый ФиксированноеСоответствие(ПраваНаВедущиеКлючиДоступа));
	
	ПраваНаВедущиеСписки = Новый Соответствие;
	Если ПараметрыОбновления.ЕстьВедущиеСпискиПоПравам Тогда
		НомерТаблицы = НомерТаблицы + 1;
		Дерево = РезультатыЗапроса[НомерТаблицы].Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкам);
		ДобавитьПраваПоТипам = Дерево.Колонки.Найти("ТипЗначения") <> Неопределено;
		Для Каждого Строка Из Дерево.Строки Цикл
			ПраваНаВедущийСписок = Новый Соответствие;
			Для Каждого Подстрока Из Строка.Строки Цикл
				ПраваНаВедущийСписок.Вставить(Подстрока.ВладелецПрав, Подстрока.Изменение);
				Если ДобавитьПраваПоТипам Тогда
					ТипЗначенияСписка = Подстрока.ТипЗначения;
				КонецЕсли;
			КонецЦикла;
			ПраваНаВедущиеСписки.Вставить(Строка.Список,
				Новый ФиксированноеСоответствие(ПраваНаВедущийСписок));
			Если ДобавитьПраваПоТипам Тогда
				ПраваНаВедущиеСписки.Вставить(ТипЗначенияСписка,
					Новый ФиксированноеСоответствие(ПраваНаВедущийСписок));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	ПараметрыОбновления.Вставить("ПраваНаВедущиеСписки",
		Новый ФиксированноеСоответствие(ПраваНаВедущиеСписки));
	
КонецПроцедуры

// Для процедуры ОбновитьПраваПорцииКлючейДоступаСписка.
Процедура ЗаполнитьПраваПоВладельцамНастроекПрав(РезультатыЗапроса, НомерТаблицы, ПараметрыОбновления)
	
	ПраваПоВладельцамНастроекПрав = Новый Соответствие;
	Если ПараметрыОбновления.ЕстьВладельцыНастроекПрав Тогда
		НомерТаблицы = НомерТаблицы + 5;
		Дерево = РезультатыЗапроса[НомерТаблицы].Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкам);
		Для Каждого Строка Из Дерево.Строки Цикл
			ПраваПоВладельцуНастроекПрав = Новый Соответствие;
			Для Каждого Подстрока Из Строка.Строки Цикл
				ПраваПоВладельцуНастроекПрав.Вставить(Подстрока.ВладелецПрав, Подстрока.Изменение);
			КонецЦикла;
			ПраваПоВладельцамНастроекПрав.Вставить(Строка.ВладелецНастроекПрав,
				Новый ФиксированноеСоответствие(ПраваПоВладельцуНастроекПрав));
		КонецЦикла;
	КонецЕсли;
	ПараметрыОбновления.Вставить("ПраваПоВладельцамНастроекПрав",
		Новый ФиксированноеСоответствие(ПраваПоВладельцамНастроекПрав));
	
КонецПроцедуры

// Для процедуры ОбновитьПраваНаКлючиДоступаСписка.
Функция ПраваНаКлючДоступаСписка(ЗначенияТаблицКлюча, ПараметрыОбновления)
	
	ПраваНаКлюч = Новый Структура("ДляГрупп, ДляПользователей", Новый Соответствие, Новый Соответствие);
	
	Если ПараметрыОбновления.ОграничениеОтключено Тогда
		Если Не ПараметрыОбновления.ЕстьЗависимыеСпискиБезЗаписиКлючейДоступа Тогда
			Возврат ПраваНаКлюч;
		ИначеЕсли ПараметрыОбновления.ИзменениеРазрешеноДляВсехПользователей Тогда
			ПраваНаКлюч.ДляГрупп.Вставить(ПараметрыОбновления.ПустаяГруппаДоступа,
				Новый Структура("Изменение, Добавление", Истина, Истина));
			Возврат ПраваНаКлюч;
		КонецЕсли;
	КонецЕсли;
	
	БезЗаписиПраваЧтение = ПараметрыОбновления.ОграничениеЧтенияОтключено
		И Не ПараметрыОбновления.ЕстьЗависимыеСпискиБезЗаписиКлючейДоступа;
	
	Контекст = Новый Структура;
	Контекст.Вставить("ЗначенияТаблицКлюча",                   ЗначенияТаблицКлюча);
	Контекст.Вставить("БезЗаписиПраваЧтение",                  БезЗаписиПраваЧтение);
	Контекст.Вставить("РеквизитыТаблицКлюча",                  ПараметрыОбновления.РеквизитыТаблицКлюча);
	Контекст.Вставить("УчастникиГруппДоступа",                 ПараметрыОбновления.УчастникиГруппДоступа);
	Контекст.Вставить("ГруппыПользователейГруппДоступа",       ПараметрыОбновления.ГруппыПользователейГруппДоступа);
	Контекст.Вставить("ГруппыПользователейКакЗначенияДоступа", ПараметрыОбновления.ГруппыПользователейКакЗначенияДоступа);
	Контекст.Вставить("ПользователиГруппПользователей",        ПараметрыОбновления.ПользователиГруппПользователей);
	Контекст.Вставить("ПраваНаСпискиВедущихКлючейДоступа",     ПараметрыОбновления.ПраваНаСпискиВедущихКлючейДоступа);
	Контекст.Вставить("ПраваНаВедущиеКлючиДоступа",            ПараметрыОбновления.ПраваНаВедущиеКлючиДоступа);
	Контекст.Вставить("ПраваНаВедущиеСписки",                  ПараметрыОбновления.ПраваНаВедущиеСписки);
	Контекст.Вставить("ПраваПоВладельцамНастроекПрав",         ПараметрыОбновления.ПраваПоВладельцамНастроекПрав);
	Контекст.Вставить("РассчитыватьПраваПользователей",        ПараметрыОбновления.РассчитыватьПраваПользователей);
	Контекст.Вставить("ТипГруппыДоступа",                      ПараметрыОбновления.ТипГруппыДоступа);
	Контекст.Вставить("ПустаяГруппаДоступа",                   ПараметрыОбновления.ПустаяГруппаДоступа);
	Контекст.Вставить("ТипПользователя",                       ПараметрыОбновления.ТипПользователя);
	Контекст.Вставить("ТипГруппыПользователей",                ПараметрыОбновления.ТипГруппыПользователей);
	Контекст.Вставить("ТипыВладельцевНастроекПрав",            ПараметрыОбновления.ТипыВладельцевНастроекПрав);
	
	ЧтениеРазрешеноДляВсехГруппДоступа = Истина;
	ИзменениеРазрешеноДляВсехГруппДоступа = Истина;
	ДобавлениеРазрешеноДляВсехГруппДоступа = Истина;
	
	Для Каждого ОписаниеПрав Из ПараметрыОбновления.ПраваГруппДоступаСписка Цикл
		ГруппаДоступа      = ОписаниеПрав.Ключ;
		ПраваГруппыДоступа = ОписаниеПрав.Значение;
		
		Контекст.Вставить("ГруппаДоступа", ГруппаДоступа);
		Контекст.Вставить("ЗначенияГруппыДоступа",
			ПараметрыОбновления.ЗначенияГруппДоступа.Получить(ГруппаДоступа));
		
		Если ПараметрыОбновления.ОграничениеЧтенияОтключено
		 Или ПраваГруппыДоступа.ЧтениеБезОграничения Тогда
			
			ПравоЧтение = "Истина";
		Иначе
			ПравоЧтение = РассчитанноеУсловиеДляСтрок(Контекст,
				ПараметрыОбновления.СтруктураРасчетаПраваЧтение);
		КонецЕсли;
		
		Если ПравоЧтение <> "Истина" Тогда
			ЧтениеРазрешеноДляВсехГруппДоступа = Ложь;
			ИзменениеРазрешеноДляВсехГруппДоступа = Ложь;
			ДобавлениеРазрешеноДляВсехГруппДоступа = Ложь;
		КонецЕсли;
		
		Если ПравоЧтение = "Ложь"
		 Или ТипЗнч(ПравоЧтение) = Тип("Соответствие")
		   И ПравоЧтение.Количество() = 0 Тогда
			
			Продолжить;
		КонецЕсли;
		
		Если ПараметрыОбновления.ОграничениеОтключено
		 Или ПраваГруппыДоступа.ИзменениеБезОграничения
		   И ПраваГруппыДоступа.ДобавлениеБезОграничения Тогда
			
			ПравоИзменение = "Истина";
			
		ИначеЕсли Не ПраваГруппыДоступа.Изменение Тогда
			ПравоИзменение = "Ложь";
			
		ИначеЕсли ПараметрыОбновления.ЕстьОграничениеИзменения Тогда
			ПравоИзменение = РассчитанноеУсловиеДляСтрок(Контекст,
				ПараметрыОбновления.СтруктураРасчетаПраваИзменение);
			
		ИначеЕсли ПараметрыОбновления.ОграничениеЧтенияОтключено
		      Или ПраваГруппыДоступа.ЧтениеБезОграничения Тогда
			
			ПравоИзменение = РассчитанноеУсловиеДляСтрок(Контекст,
				ПараметрыОбновления.СтруктураРасчетаПраваЧтение);
		Иначе
			ПравоИзменение = "Истина";
		КонецЕсли;
		
		ПравоДобавление = ?(ПраваГруппыДоступа.Добавление, ПравоИзменение, "Ложь");
		
		Если ПраваГруппыДоступа.ИзменениеБезОграничения Тогда
			ПравоИзменение = "Истина";
		КонецЕсли;
		
		Если ПравоИзменение <> "Истина" Тогда
			ИзменениеРазрешеноДляВсехГруппДоступа = Ложь;
		КонецЕсли;
		Если ПравоДобавление <> "Истина" Тогда
			ДобавлениеРазрешеноДляВсехГруппДоступа = Ложь;
		КонецЕсли;
		
		Если Контекст.РассчитыватьПраваПользователей Тогда
			ДобавитьПраваПользователейНаКлючДоступа(ПраваНаКлюч,
				ПравоЧтение, ПравоИзменение, ПравоДобавление, Контекст);
		
		ИначеЕсли Не БезЗаписиПраваЧтение Или ПравоИзменение = "Истина" Или ПравоДобавление = "Истина" Тогда
			ПраваНаКлюч.ДляГрупп.Вставить(ГруппаДоступа, Новый Структура("Изменение, Добавление",
				ПравоИзменение = "Истина", ПравоДобавление = "Истина"));
		КонецЕсли;
	КонецЦикла;
	
	Если Не ЧтениеРазрешеноДляВсехГруппДоступа
	 Или ПараметрыОбновления.ЕстьЗависимыеСпискиБезЗаписиКлючейДоступа
	   И Не ПараметрыОбновления.ЧтениеРазрешеноДляВсехПользователей Тогда
		
		Возврат ПраваНаКлюч;
	КонецЕсли;
	
	Если ДобавлениеРазрешеноДляВсехГруппДоступа
	   И ( Не ПараметрыОбновления.ЕстьЗависимыеСпискиБезЗаписиКлючейДоступа
	      Или ПараметрыОбновления.ИзменениеРазрешеноДляВсехПользователей) Тогда
		
		ПраваНаКлюч = Новый Структура("ДляГрупп, ДляПользователей", Новый Соответствие, Новый Соответствие);
		ПраваНаКлюч.ДляГрупп.Вставить(ПараметрыОбновления.ПустаяГруппаДоступа,
			Новый Структура("Изменение, Добавление", Истина, Истина));
		
	Иначе // ЧтениеРазрешеноДляВсехГруппДоступа.
		ТекущиеПраваНаКлюч = ПраваНаКлюч;
		ПраваНаКлюч = Новый Структура("ДляГрупп, ДляПользователей", Новый Соответствие, Новый Соответствие);
		Если Не БезЗаписиПраваЧтение Или ИзменениеРазрешеноДляВсехГруппДоступа Тогда
			ПраваНаКлюч.ДляГрупп.Вставить(ПараметрыОбновления.ПустаяГруппаДоступа,
				Новый Структура("Изменение, Добавление", ИзменениеРазрешеноДляВсехГруппДоступа, Ложь));
		КонецЕсли;
		ИмяПрава = ?(ИзменениеРазрешеноДляВсехГруппДоступа, "Добавление", "Изменение");
		Для Каждого КлючИЗначение Из ТекущиеПраваНаКлюч.ДляГрупп Цикл
			Если КлючИЗначение.Значение[ИмяПрава] Тогда
				ПраваНаКлюч.ДляГрупп.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
			КонецЕсли;
		КонецЦикла;
		Для Каждого КлючИЗначение Из ТекущиеПраваНаКлюч.ДляПользователей Цикл
			Если КлючИЗначение.Значение[ИмяПрава] Тогда
				ПраваНаКлюч.ДляПользователей.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат ПраваНаКлюч;
	
КонецФункции

// Для процедуры ПраваНаКлючДоступаСписка.
Процедура ДобавитьПраваПользователейНаКлючДоступа(ПраваНаКлюч, ПравоЧтение, ПравоИзменение, ПравоДобавление, Контекст)
	
	Если ТипЗнч(ПравоИзменение) = Тип("Соответствие") И ПравоИзменение.Количество() = 0 Тогда
		ПравоИзменение  = "Ложь";
		ПравоДобавление = "Ложь";
		
	ИначеЕсли ТипЗнч(ПравоДобавление) = Тип("Соответствие") И ПравоДобавление.Количество() = 0 Тогда
		ПравоДобавление = "Ложь";
	КонецЕсли;
	
	Права = Новый Структура("Изменение, Добавление", ПравоИзменение = "Истина", ПравоДобавление = "Истина");
	
	Если ТипЗнч(ПравоЧтение) <> Тип("Соответствие") Тогда
		Если Не Контекст.БезЗаписиПраваЧтение Или Права.Изменение Или Права.Добавление Тогда
			ПраваНаКлюч.ДляГрупп.Вставить(Контекст.ГруппаДоступа,
				Новый Структура("Изменение, Добавление", Права.Изменение, Права.Добавление));
		КонецЕсли;
	Иначе
		ДобавитьПользователямПраваНаКлючДоступа(ПраваНаКлюч.ДляПользователей,
			ПравоЧтение, Права.Изменение, Права.Добавление, Контекст.БезЗаписиПраваЧтение);
	КонецЕсли;
	
	Если ТипЗнч(ПравоИзменение)  <> Тип("Соответствие")
	   И ТипЗнч(ПравоДобавление) <> Тип("Соответствие") Тогда
		Возврат;
	КонецЕсли;
	
	Право = ?(ТипЗнч(ПравоИзменение) = Тип("Соответствие"), ПравоИзменение, ПравоДобавление);
	ДобавитьПользователямПраваНаКлючДоступа(ПраваНаКлюч.ДляПользователей,
		Право, Истина, ПравоДобавление <> "Ложь", Контекст.БезЗаписиПраваЧтение);
	
КонецПроцедуры

// Для процедуры ДобавитьПраваПользователейНаКлючДоступа.
Процедура ДобавитьПользователямПраваНаКлючДоступа(ПраваНаКлючДляПользователей,
				СоставПользователей, Изменение, Добавление, БезЗаписиПраваЧтение)
	
	Если Изменение И Добавление Тогда
		Для Каждого КлючИЗначение Из СоставПользователей Цикл
			ПраваНаКлючДляПользователей.Вставить(КлючИЗначение.Ключ,
				Новый Структура("Изменение, Добавление", Истина, Истина));
		КонецЦикла;
		
	ИначеЕсли Не Изменение И Не Добавление Тогда
		Если Не БезЗаписиПраваЧтение Тогда
			Для Каждого КлючИЗначение Из СоставПользователей Цикл
				Права = ПраваНаКлючДляПользователей.Получить(КлючИЗначение.Ключ);
				Если Права = Неопределено Тогда
					Права = Новый Структура("Изменение, Добавление", Ложь, Ложь);
					ПраваНаКлючДляПользователей.Вставить(КлючИЗначение.Ключ, Права);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	Иначе
		Для Каждого КлючИЗначение Из СоставПользователей Цикл
			Права = ПраваНаКлючДляПользователей.Получить(КлючИЗначение.Ключ);
			Если Права = Неопределено Тогда
				Права = Новый Структура("Изменение, Добавление", Изменение, Добавление);
			Иначе
				Права.Изменение  = Права.Изменение  Или Изменение;
				Права.Добавление = Права.Добавление Или Добавление;
			КонецЕсли;
			ПраваНаКлючДляПользователей.Вставить(КлючИЗначение.Ключ, Права);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Для функций ПраваНаКлючДоступаСписка и РассчитанноеУсловие.
Функция РассчитанноеУсловиеДляСтрок(Контекст, Условие, УзелРеквизитов = Неопределено, ДляЛюбойИзСтрок = Истина)
	
	Если УзелРеквизитов = Неопределено Тогда
		Контекст.Вставить("ОписанияТребуемыхТаблицКлюча", Новый Массив);
		Если Условие.Узел = "ДляВсехСтрок" Или Условие.Узел = "ДляОднойИзСтрок" Тогда
			Возврат РассчитанноеУсловие(Контекст, Условие);
		КонецЕсли;
		УзелРеквизитов = Условие;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(УзелРеквизитов.ТребуемыеРеквизитыТабличныхЧастейКлюча) Тогда
		Контекст.Вставить("ТекущиеСтрокиТаблицКлюча", Контекст.ЗначенияТаблицКлюча);
		Возврат РассчитанноеУсловие(Контекст, Условие);
	КонецЕсли;
	РеквизитыТаблиц    = УзелРеквизитов.ТребуемыеРеквизитыТабличныхЧастейКлюча;
	ЗначенияТаблиц     = ТекущиеЗначенияТаблицКлюча(Контекст, РеквизитыТаблиц);
	ИндексыСтрокТаблиц = Новый Соответствие;
	
	Контекст.ОписанияТребуемыхТаблицКлюча.Добавить(
		Новый Структура("РеквизитыТаблиц, ЗначенияТаблиц, ИндексыСтрокТаблиц",
			РеквизитыТаблиц, ЗначенияТаблиц, ИндексыСтрокТаблиц));
	
	ТекущиеСтрокиТаблицКлюча = ?(Контекст.Свойство("ТекущиеСтрокиТаблицКлюча"),
		Контекст.ТекущиеСтрокиТаблицКлюча, Неопределено);
	
	Контекст.Вставить("ТекущиеСтрокиТаблицКлюча", Новый Структура);
	Для Каждого ОписаниеЗначений Из Контекст.ЗначенияТаблицКлюча Цикл
		Если СтрНачинаетсяС(ОписаниеЗначений.Ключ, "Шапка") Тогда
			Контекст.ТекущиеСтрокиТаблицКлюча.Вставить(ОписаниеЗначений.Ключ, ОписаниеЗначений.Значение);
		КонецЕсли;
	КонецЦикла;
	
	Результат = "Неопределено";
	
	Пока Истина Цикл
		ИндексИзменен = Ложь;
		Для Каждого ОписаниеТаблицы Из РеквизитыТаблиц Цикл
			ИмяТаблицыКлюча = ОписаниеТаблицы.Ключ;
			ИндексСтроки = ИндексыСтрокТаблиц.Получить(ИмяТаблицыКлюча);
			ЗначенияТаблицы = ЗначенияТаблиц[ИмяТаблицыКлюча];
			Если ИндексСтроки = Неопределено Тогда
				ИндексСтроки = 0;
			Иначе
				Если ИндексСтроки >= ЗначенияТаблицы.Количество() - 1 Тогда
					Продолжить;
				КонецЕсли;
				ИндексСтроки = ИндексСтроки + 1;
			КонецЕсли;
			ИндексИзменен = Истина;
			ИндексыСтрокТаблиц.Вставить(ИмяТаблицыКлюча, ИндексСтроки);
			Контекст.ТекущиеСтрокиТаблицКлюча.Вставить(ИмяТаблицыКлюча, ЗначенияТаблицы[ИндексСтроки]);
		КонецЦикла;
		Если Не ИндексИзменен Тогда
			Прервать;
		КонецЕсли; 
		ТекущийРезультат = РассчитанноеУсловие(Контекст, Условие);
		Если ТипЗнч(ТекущийРезультат) <> Тип("Соответствие") Тогда
			Если ДляЛюбойИзСтрок Тогда
				Если ТекущийРезультат = "Истина" Тогда
					Результат = "Истина";
					Прервать;
				ИначеЕсли ТекущийРезультат = "Ложь" Тогда
					Если Результат = "Неопределено" Тогда
						Результат = "Ложь";
					КонецЕсли;
				КонецЕсли;
			Иначе
				Если ТекущийРезультат = "Ложь" Тогда
					Результат = "Ложь";
					Прервать;
				ИначеЕсли ТекущийРезультат = "Истина" Тогда
					Если Результат = "Неопределено" Тогда
						Результат = "Истина";
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		Иначе
			Если Не ДляЛюбойИзСтрок И ТекущийРезультат.Количество() = 0 Тогда
				Результат = "Ложь";
				Прервать;
			КонецЕсли;
			Если ТипЗнч(Результат) = Тип("Строка") Тогда
				Результат = ТекущийРезультат;
			Иначе
				ДобавитьТекущийРезультат(Результат, ТекущийРезультат, ДляЛюбойИзСтрок, Контекст);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если Результат = "Неопределено" Тогда
		Результат = "Ложь";
	КонецЕсли;
	
	Контекст.ОписанияТребуемыхТаблицКлюча.Удалить(
		Контекст.ОписанияТребуемыхТаблицКлюча.Количество() - 1);
	
	Контекст.Вставить("ТекущиеСтрокиТаблицКлюча", ТекущиеСтрокиТаблицКлюча);
	
	Возврат Результат;
	
КонецФункции

// Для функции РассчитанноеУсловиеДляСтрок.
Процедура ДобавитьТекущийРезультат(Результат, ТекущийРезультат, ДляЛюбойИзСтрок, Контекст)
	
	Если ДляЛюбойИзСтрок Тогда
		Для Каждого КлючИЗначение Из ТекущийРезультат Цикл
			Результат.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		КонецЦикла;
	Иначе
		Если Результат.Количество() > ТекущийРезультат.Количество() Тогда
			МеньшийРезультат = ТекущийРезультат;
			БольшийРезультат = Результат;
		Иначе
			МеньшийРезультат = Результат;
			БольшийРезультат = ТекущийРезультат;
		КонецЕсли;
		Результат = Новый Соответствие;
		ТипГруппыПользователей = Неопределено;
		
		Для Каждого КлючИЗначение Из МеньшийРезультат Цикл
			Участник = КлючИЗначение.Ключ;
			Если БольшийРезультат.Получить(Участник) <> Неопределено Тогда
				Результат.Вставить(Участник, Истина);
			Иначе
				Если ТипГруппыПользователей = Неопределено Тогда
					ТипГруппыПользователей = Контекст.ТипГруппыПользователей;
					ПользователиГруппПользователей = Контекст.ПользователиГруппПользователей;
					БольшийРезультатПользователиГрупп = ПользователиГрупп(БольшийРезультат, Контекст);
				КонецЕсли;
				Если ТипЗнч(Участник) = ТипГруппыПользователей Тогда
					ПользователиГруппы = ПользователиГруппПользователей.Получить(Участник);
					Если ПользователиГруппы = Неопределено Тогда
						Продолжить;
					КонецЕсли;
					Для Каждого ОписаниеПользователя Из ПользователиГруппы Цикл
						Если БольшийРезультатПользователиГрупп.Получить(ОписаниеПользователя.Ключ) <> Неопределено Тогда
							Результат.Вставить(ОписаниеПользователя.Ключ, Истина);
						КонецЕсли;
					КонецЦикла;
				ИначеЕсли БольшийРезультатПользователиГрупп.Получить(Участник) <> Неопределено Тогда
					Результат.Вставить(Участник, Истина);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ДобавитьТекущийРезультат и УстановитьОбратныйРезультат.
Функция ПользователиГрупп(ПользователиИГруппы, Контекст)
	
	ПользователиГрупп = Новый Соответствие;
	
	ТипГруппыПользователей = Контекст.ТипГруппыПользователей;
	ПользователиГруппПользователей = Контекст.ПользователиГруппПользователей;
	
	Для Каждого КлючИЗначение Из ПользователиИГруппы Цикл
		Если ТипЗнч(КлючИЗначение.Ключ) = ТипГруппыПользователей Тогда
			ПользователиГруппы = ПользователиГруппПользователей.Получить(КлючИЗначение.Ключ);
			Если ПользователиГруппы <> Неопределено Тогда
				Для Каждого ОписаниеПользователя Из ПользователиГруппы Цикл
					ПользователиГрупп.Вставить(ОписаниеПользователя.Ключ, Истина);
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ПользователиГрупп;
	
КонецФункции

// Для функции РассчитанноеУсловие.
Процедура УстановитьОбратныйРезультат(Результат, Контекст)
	
	СписокИсключений = Результат;
	Результат = Новый Соответствие;
	
	УчастникиТекущейГруппыДоступа = Контекст.УчастникиГруппДоступа.Получить(Контекст.ГруппаДоступа);
	Если УчастникиТекущейГруппыДоступа = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ПользователиГруппПользователей = Контекст.ПользователиГруппПользователей;
	ТипГруппыПользователей         = Контекст.ТипГруппыПользователей;
	ТипПользователя                = Контекст.ТипПользователя;
	
	ПользователиИсключаемыхГрупп = ПользователиГрупп(СписокИсключений, Контекст);
	
	Для Каждого КлючИЗначение Из УчастникиТекущейГруппыДоступа Цикл
		Участник = КлючИЗначение.Ключ;
		Если СписокИсключений.Получить(Участник) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если ТипЗнч(Участник) = ТипПользователя Тогда
			Если СписокИсключений.Получить(Участник) = Неопределено
			   И ПользователиИсключаемыхГрупп.Получить(Участник) = Неопределено Тогда
				
				Результат.Вставить(Участник, Истина);
			КонецЕсли;
		ИначеЕсли ТипЗнч(Участник) = ТипГруппыПользователей Тогда
			ПользователиГруппы = ПользователиГруппПользователей.Получить(Участник);
			Если ПользователиГруппы = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			ВсяГруппаБезИсключений = Истина;
			Для Каждого ОписаниеПользователя Из ПользователиГруппы Цикл
				Если СписокИсключений.Получить(ОписаниеПользователя.Ключ) <> Неопределено
				 Или ПользователиИсключаемыхГрупп.Получить(ОписаниеПользователя.Ключ) <> Неопределено Тогда
					
					ВсяГруппаБезИсключений = Ложь;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если ВсяГруппаБезИсключений Тогда
				Результат.Вставить(Участник, Истина);
			Иначе
				Для Каждого ОписаниеПользователя Из ПользователиГруппы Цикл
					Если СписокИсключений.Получить(ОписаниеПользователя.Ключ) = Неопределено
					   И ПользователиИсключаемыхГрупп.Получить(ОписаниеПользователя.Ключ) = Неопределено Тогда
						
						Результат.Вставить(ОписаниеПользователя.Ключ, Истина);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для функции РассчитанноеУсловиеДляСтрок.
Функция ТекущиеЗначенияТаблицКлюча(Контекст, ТребуемыеРеквизитыТабличныхЧастейКлюча)
	
	ТекущиеЗначенияТаблицКлюча = Новый Структура;
	Для Каждого ОписаниеТаблицы Из ТребуемыеРеквизитыТабличныхЧастейКлюча Цикл
		ИмяТаблицыКлюча = ОписаниеТаблицы.Ключ;
		Реквизиты       = ОписаниеТаблицы.Значение;
		ЗначенияТаблицыКлюча = Контекст.ЗначенияТаблицКлюча[ИмяТаблицыКлюча];
		Отбор = Новый Структура;
		Для Каждого ТекущееОписание Из Контекст.ОписанияТребуемыхТаблицКлюча Цикл
			РеквизитыТаблицы    = ТекущееОписание.РеквизитыТаблиц.Получить(ИмяТаблицыКлюча);
			ЗначенияТаблицы     = ТекущееОписание.ЗначенияТаблиц[ИмяТаблицыКлюча];
			ИндексСтрокиТаблицы = ТекущееОписание.ИндексыСтрокТаблиц.Получить(ИмяТаблицыКлюча);
			СтрокаТаблицы = ЗначенияТаблицы[ИндексСтрокиТаблицы];
			Для Каждого ИмяРеквизита Из РеквизитыТаблицы Цикл
				Отбор.Вставить(ИмяРеквизита, СтрокаТаблицы[ИмяРеквизита]);
			КонецЦикла;
		КонецЦикла;
		ВсегоРеквизитовТаблицы = Контекст.РеквизитыТаблицКлюча.Получить(ИмяТаблицыКлюча).Количество();
		Если ВсегоРеквизитовТаблицы = Реквизиты.Количество() И Не ЗначениеЗаполнено(Отбор) Тогда
			ТекущиеЗначенияТаблицКлюча.Вставить(ИмяТаблицыКлюча, ЗначенияТаблицыКлюча);
			Продолжить;
		КонецЕсли;
		Строки = ЗначенияТаблицыКлюча;
		Если ЗначениеЗаполнено(Отбор) Тогда
			Строки = Строки.НайтиСтроки(Отбор);
		КонецЕсли;
		ЗначенияТаблицы = Новый ТаблицаЗначений;
		Для Каждого ИмяРеквизита Из Реквизиты Цикл
			ЗначенияТаблицы.Колонки.Добавить(ИмяРеквизита);
		КонецЦикла;
		Для Каждого Строка Из Строки Цикл
			ЗаполнитьЗначенияСвойств(ЗначенияТаблицы.Добавить(), Строка);
		КонецЦикла;
		Если Реквизиты.Количество() < ВсегоРеквизитовТаблицы Тогда
			РеквизитыСтрокой = СтрСоединить(Реквизиты, ", ");
			ЗначенияТаблицы.Свернуть(РеквизитыСтрокой);
		КонецЕсли;
		ТекущиеЗначенияТаблицКлюча.Вставить(ИмяТаблицыКлюча, ЗначенияТаблицы);
	КонецЦикла;
	
	Возврат ТекущиеЗначенияТаблицКлюча;
	
КонецФункции

// Для функции РассчитанноеУсловиеДляСтрок.
Функция РассчитанноеУсловие(Контекст, Условие)
	
	// Проверяемые типы уже учтены.
	
	Если Условие.Узел = "Поле" Тогда
		Значение = Контекст.ТекущиеСтрокиТаблицКлюча[Условие.Таблица][Условие.Реквизит];
		Результат = ?(Значение = Перечисления.ДополнительныеЗначенияДоступа.Истина
			Или Значение = Null И Условие.Свойство("ПроверкаЕстьNull"), "Истина", "Ложь");
		
	ИначеЕсли Условие.Узел = "Константа" Тогда
		Результат = ?(Условие.Значение = Истина, "Истина", "Ложь");
		
	ИначеЕсли Условие.Узел = "И" Тогда
		
		Результат = "Неопределено";
		Для Каждого Аргумент Из Условие.Аргументы Цикл
			ТекущийРезультат = РассчитанноеУсловие(Контекст, Аргумент);
			Если ТекущийРезультат = "Ложь" Тогда
				Результат = "Ложь";
				Прервать;
			КонецЕсли;
			Если ТекущийРезультат = "Истина" Тогда
				Если Результат = "Неопределено" Тогда
					Результат = "Истина";
				КонецЕсли;
			ИначеЕсли ТипЗнч(ТекущийРезультат) = Тип("Соответствие") Тогда
				Если ТекущийРезультат.Количество() = 0 Тогда
					Результат = "Ложь";
					Прервать;
				КонецЕсли;
				Если ТипЗнч(Результат) = Тип("Строка") Тогда
					Результат = ТекущийРезультат;
				Иначе
					ДобавитьТекущийРезультат(Результат, ТекущийРезультат, Ложь, Контекст);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		Если Результат = "Неопределено" Тогда
			Результат = "Ложь";
		КонецЕсли;
		
	ИначеЕсли Условие.Узел = "Или" Тогда
		
		Результат = "Неопределено";
		Для Каждого Аргумент Из Условие.Аргументы Цикл
			ТекущийРезультат = РассчитанноеУсловие(Контекст, Аргумент);
			Если ТекущийРезультат = "Истина" Тогда
				Результат = "Истина";
				Прервать;
			КонецЕсли;
			Если ТекущийРезультат = "Ложь" Тогда
				Если Результат = "Неопределено" Тогда
					Результат = "Ложь";
				КонецЕсли;
			ИначеЕсли ТипЗнч(ТекущийРезультат) = Тип("Соответствие") Тогда
				Если ТекущийРезультат.Количество() = 0 Тогда
					Если Результат = "Неопределено" Тогда
						Результат = "Ложь";
					КонецЕсли;
				ИначеЕсли ТипЗнч(Результат) = Тип("Строка") Тогда
					Результат = ТекущийРезультат;
				Иначе
					ДобавитьТекущийРезультат(Результат, ТекущийРезультат, Истина, Контекст);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		Если Результат = "Неопределено" Тогда
			Результат = "Ложь";
		КонецЕсли;
		
	ИначеЕсли Условие.Узел = "Не" Тогда
		Результат = РассчитанноеУсловие(Контекст, Условие.Аргумент);
		Если Результат = "Истина" Тогда
			Результат = "Ложь";
		ИначеЕсли Результат = "Ложь" Тогда
			Результат = "Истина";
		ИначеЕсли ТипЗнч(Результат) = Тип("Соответствие") Тогда
			Если Результат.Количество() = 0 Тогда
				Результат = "Истина";
			Иначе
				УстановитьОбратныйРезультат(Результат, Контекст);
			КонецЕсли;
		КонецЕсли;
		
	ИначеЕсли Условие.Узел = "ДляВсехСтрок"
	      Или Условие.Узел = "ДляОднойИзСтрок" Тогда
		
		Результат = РассчитанноеУсловиеДляСтрок(Контекст,
			Условие.Аргумент, Условие, Условие.Узел = "ДляОднойИзСтрок");
		
	ИначеЕсли Условие.Узел = "Выбор" Тогда
		Результат = Неопределено;
		Для Каждого Когда Из Условие.Когда Цикл
			Если РассчитанноеУсловие(Контекст, Когда.Условие) = "Истина" Тогда
				Результат = РассчитанноеУсловие(Контекст, Когда.Значение);
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если Результат = Неопределено Тогда
			Результат = РассчитанноеУсловие(Контекст, Условие.Иначе);
		КонецЕсли;
		
	ИначеЕсли Условие.Узел = "ЗначениеРазрешено"
	      Или Условие.Узел = "ЭтоАвторизованныйПользователь"
	      Или Условие.Узел = "ЧтениеОбъектаРазрешено"
	      Или Условие.Узел = "ИзменениеОбъектаРазрешено"
	      Или Условие.Узел = "ЧтениеСпискаРазрешено"
	      Или Условие.Узел = "ИзменениеСпискаРазрешено" Тогда
		
		Значение = Контекст.ТекущиеСтрокиТаблицКлюча[Условие.Поле.Таблица][Условие.Поле.Реквизит];
		Если Значение = Null Тогда
			Значение = Перечисления.ДополнительныеЗначенияДоступа.Null;
		КонецЕсли;
		
		Если Значение = Перечисления.ДополнительныеЗначенияДоступа.ТипРазрешенный Тогда
			ТекущийРезультат = "Истина";
			
		ИначеЕсли Значение = Перечисления.ДополнительныеЗначенияДоступа.ТипЗапрещенный Тогда
			ТекущийРезультат = "Ложь";
		Иначе
			ТекущийРезультат = Неопределено;
			Для Каждого УточнениеСравнения Из Условие.УточненияСравнения Цикл
				Если УточнениеСравнения.Ключ = "Null"
				 Или УточнениеСравнения.Ключ = "Неопределено" Тогда
					Если Значение = Перечисления.ДополнительныеЗначенияДоступа[УточнениеСравнения.Ключ] Тогда
						ТекущийРезультат = УточнениеСравнения.Значение;
						Прервать;
					КонецЕсли;
				ИначеЕсли УточнениеСравнения.Ключ = "ПустаяСсылка" Тогда
					Если Значение = Перечисления.ДополнительныеЗначенияДоступа.ПустаяСсылкаЛюбогоТипа
					 Или Значение.Пустая() Тогда
						ТекущийРезультат = УточнениеСравнения.Значение;
						Прервать;
					КонецЕсли;
				ИначеЕсли УточнениеСравнения.Ключ = ТипЗнч(Значение) Тогда
					ТекущийРезультат = УточнениеСравнения.Значение;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Если ТекущийРезультат <> Неопределено Тогда
			Результат = ТекущийРезультат;
			
		ИначеЕсли Условие.Узел = "ЗначениеРазрешено" Тогда
			Если Значение = Перечисления.ДополнительныеЗначенияДоступа.Null
			 Или Значение = Перечисления.ДополнительныеЗначенияДоступа.Неопределено Тогда
				Результат = "Ложь";
			Иначе
				Если Контекст.ЗначенияГруппыДоступа = Неопределено Тогда
					ЗначенияОдногоТипа = Неопределено;
				Иначе
					ТипЗначения = ТипЗнч(Значение);
					ЗначенияОдногоТипа = Контекст.ЗначенияГруппыДоступа.Получить(ТипЗначения);
				КонецЕсли;
				Если ЗначенияОдногоТипа = Неопределено Тогда
					Если Условие.УточненияСравнения.Получить("Отключено") = "Ложь" Тогда
						Результат = "Ложь";
					Иначе
						Результат = "Истина";
					КонецЕсли;
				Иначе
					ЗначениеУказано = ЗначенияОдногоТипа.Значения.Получить(Значение) <> Неопределено;
					Если Не ЗначениеУказано И ТипЗначения = Контекст.ТипПользователя Тогда
						ЗначениеУказано = ЗначениеУказаноВГруппеПользователей(Значение, Контекст);
					КонецЕсли;
					Результат = "Ложь";
					Если    ЗначениеУказано И Не ЗначенияОдногоТипа.ВсеРазрешены
					 Или Не ЗначениеУказано И    ЗначенияОдногоТипа.ВсеРазрешены Тогда
						Результат = "Истина";
						
					ИначеЕсли ТипЗначения = Контекст.ТипПользователя Тогда
						ЗаполнитьРезультатДляПользователя(Результат, Значение, Контекст);
						
					ИначеЕсли ТипЗначения = Контекст.ТипГруппыПользователей Тогда
						ЗаполнитьРезультатДляГруппыПользователей(Результат, Значение, Контекст);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
		ИначеЕсли Условие.Узел = "ЭтоАвторизованныйПользователь" Тогда
			Если ТипЗнч(Значение) = Контекст.ТипПользователя Тогда
				ЗаполнитьРезультатДляПользователя(Результат, Значение, Контекст);
			Иначе
				Результат = "Ложь";
			КонецЕсли;
			
		ИначеЕсли ТипЗнч(Значение) = Тип("СправочникСсылка.КлючиДоступа") Тогда
			ПраваНаСписок = Контекст.ПраваНаСпискиВедущихКлючейДоступа.Получить(Значение);
			Если ПраваНаСписок = Неопределено Тогда
				Результат = "Ложь";
			Иначе
				ПравоИзменение = ПраваНаСписок.ПоГруппамДоступа.Получить(Контекст.ГруппаДоступа);
				Если Условие.Узел =    "ЧтениеОбъектаРазрешено" И ПравоИзменение = Неопределено
				 Или Условие.Узел = "ИзменениеОбъектаРазрешено" И ПравоИзменение <> Истина Тогда
					Результат = "Ложь";
				
				ИначеЕсли Условие.Узел =    "ЧтениеОбъектаРазрешено" И ПраваНаСписок.ОграничениеЧтенияОтключено
					  Или Условие.Узел = "ИзменениеОбъектаРазрешено" И ПраваНаСписок.ОграничениеОтключено Тогда
					
					Результат = "Истина";
				Иначе
					ПраваНаВедущийКлючДоступа = Контекст.ПраваНаВедущиеКлючиДоступа.Получить(Значение);
					Если ПраваНаВедущийКлючДоступа = Неопределено Тогда
						Результат = "Ложь";
						
					ИначеЕсли Контекст.РассчитыватьПраваПользователей Тогда
						Если Условие.Узел = "ЧтениеОбъектаРазрешено" Тогда
							Результат = Новый Соответствие;
							Для Каждого КлючИЗначение Из ПраваНаВедущийКлючДоступа Цикл
								Если ТипЗнч(КлючИЗначение.Ключ) <> Контекст.ТипГруппыДоступа Тогда
									Результат.Вставить(КлючИЗначение.Ключ, Истина);
									
								ИначеЕсли КлючИЗначение.Ключ = Контекст.ГруппаДоступа
								      Или КлючИЗначение.Ключ = Контекст.ПустаяГруппаДоступа Тогда
									
									Результат.Вставить(Контекст.ГруппаДоступа, Истина);
								КонецЕсли;
							КонецЦикла;
							
						ИначеЕсли Условие.Узел = "ИзменениеОбъектаРазрешено" Тогда
							Результат = Новый Соответствие;
							Для Каждого КлючИЗначение Из ПраваНаВедущийКлючДоступа Цикл
								Если Не КлючИЗначение.Значение Тогда
									Продолжить;
								КонецЕсли;
								Если ТипЗнч(КлючИЗначение.Ключ) <> Контекст.ТипГруппыДоступа Тогда
									Результат.Вставить(КлючИЗначение.Ключ, Истина);
									
								ИначеЕсли КлючИЗначение.Ключ = Контекст.ГруппаДоступа
								      Или КлючИЗначение.Ключ = Контекст.ПустаяГруппаДоступа Тогда
									
									Результат.Вставить(Контекст.ГруппаДоступа, Истина);
								КонецЕсли;
							КонецЦикла;
						Иначе
							Результат = "Ложь";
						КонецЕсли;
					Иначе
						ПравоИзменение = ПраваНаВедущийКлючДоступа.Получить(Контекст.ГруппаДоступа);
						Если Условие.Узел =    "ЧтениеОбъектаРазрешено" И ПравоИзменение <> Неопределено
						 Или Условие.Узел = "ИзменениеОбъектаРазрешено" И ПравоИзменение = Истина Тогда
							Результат = "Истина";
						Иначе
							Результат = "Ложь";
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
		ИначеЕсли Контекст.ТипыВладельцевНастроекПрав.Получить(ТипЗнч(Значение)) <> Неопределено Тогда
			ПраваПоВладельцуНастроекПрав = Контекст.ПраваПоВладельцамНастроекПрав.Получить(Значение);
			Если ПраваПоВладельцуНастроекПрав = Неопределено Тогда
				Результат = "Ложь";
				
			ИначеЕсли Условие.Узел = "ЧтениеОбъектаРазрешено" Тогда
				Результат = Новый Соответствие(ПраваПоВладельцуНастроекПрав);
				
			ИначеЕсли Условие.Узел = "ИзменениеОбъектаРазрешено" Тогда
				Результат = Новый Соответствие;
				Для Каждого КлючИЗначение Из ПраваПоВладельцуНастроекПрав Цикл
					Если КлючИЗначение.Значение Тогда
						Результат.Вставить(КлючИЗначение.Ключ, Истина);
					КонецЕсли;
				КонецЦикла;
			Иначе
				Результат = "Ложь";
			КонецЕсли;
			
		Иначе // Проверка прав на список.
			ПраваНаВедущийСписок = Контекст.ПраваНаВедущиеСписки.Получить(Значение);
			Если ПраваНаВедущийСписок = Неопределено Тогда
				ПраваНаВедущийСписок = Контекст.ПраваНаВедущиеСписки.Получить(ТипЗнч(Значение));
			КонецЕсли;
			Если ПраваНаВедущийСписок = Неопределено Тогда
				Результат = "Ложь";
			ИначеЕсли Контекст.РассчитыватьПраваПользователей Тогда
				Если СтрНачинаетсяС(Условие.Узел, "Чтение") Тогда
					Результат = ПраваНаВедущийСписок;
					
				ИначеЕсли СтрНачинаетсяС(Условие.Узел, "Изменение") Тогда
					Результат = Новый Соответствие;
					Для Каждого КлючИЗначение Из ПраваНаВедущийСписок Цикл
						Если КлючИЗначение.Значение Тогда
							Результат.Вставить(КлючИЗначение.Ключ, Истина);
						КонецЕсли;
					КонецЦикла;
				Иначе
					Результат = "Ложь";
				КонецЕсли;
			Иначе
				ПравоИзменение = ПраваНаВедущийСписок.Получить(Контекст.ГруппаДоступа);
				Если СтрНачинаетсяС(Условие.Узел, "Чтение")    И ПравоИзменение <> Неопределено
				 Или СтрНачинаетсяС(Условие.Узел, "Изменение") И ПравоИзменение = Истина Тогда
					Результат = "Истина";
				Иначе
					Результат = "Ложь";
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	Иначе
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'При вычислении прав на ключ доступа узел не поддерживается ""%1"".'"),
			Условие.Узел);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Для функции РассчитанноеУсловие.
Функция ЗначениеУказаноВГруппеПользователей(Пользователь, Контекст)
	
	УказанныеГруппыПользователей = Контекст.ЗначенияГруппыДоступа.Получить(Контекст.ТипГруппыПользователей);
	Если УказанныеГруппыПользователей = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Каждого УказаннаяГруппаПользователей Из УказанныеГруппыПользователей.Значения Цикл
		ПользователиГруппы = Контекст.ГруппыПользователейКакЗначенияДоступа.Получить(УказаннаяГруппаПользователей.Ключ);
		Если ПользователиГруппы = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если ПользователиГруппы.Получить(Пользователь) <> Неопределено Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Для функции РассчитанноеУсловие.
Процедура ЗаполнитьРезультатДляПользователя(Результат, Пользователь, Контекст)
	
	Результат = "Ложь";
	
	УчастникиГруппыДоступа = Контекст.УчастникиГруппДоступа.Получить(Контекст.ГруппаДоступа);
	Если УчастникиГруппыДоступа = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если УчастникиГруппыДоступа.Получить(Пользователь) <> Неопределено Тогда
		Результат = Новый Соответствие;
		Результат.Вставить(Пользователь, Истина);
		Возврат;
	КонецЕсли;
	
	ГруппыПользователейГруппыДоступа = Контекст.ГруппыПользователейГруппДоступа.Получить(Контекст.ГруппаДоступа);
	Если ГруппыПользователейГруппыДоступа = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого ОписаниеПользователейГруппы Из ГруппыПользователейГруппыДоступа Цикл
		Если ОписаниеПользователейГруппы.Значение.Получить(Пользователь) <> Неопределено Тогда
			Результат = Новый Соответствие;
			Результат.Вставить(Пользователь, Истина);
			Возврат;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для функции РассчитанноеУсловие.
Процедура ЗаполнитьРезультатДляГруппыПользователей(Результат, ГруппаПользователей, Контекст)
	
	Результат = "Ложь";
	
	УчастникиГруппыДоступа = Контекст.УчастникиГруппДоступа.Получить(Контекст.ГруппаДоступа);
	Если УчастникиГруппыДоступа = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если УчастникиГруппыДоступа.Получить(ГруппаПользователей) = Неопределено Тогда
		Результат = Новый Соответствие;
		Результат.Вставить(ГруппаПользователей, Истина);
		Возврат;
	КонецЕсли;
	
	ГруппыПользователейГруппыДоступа = Контекст.ГруппыПользователейГруппДоступа.Получить(Контекст.ГруппаДоступа);
	Если ГруппыПользователейГруппыДоступа = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ПользователиГруппы = Контекст.ПользователиГруппПользователей.Получить(ГруппаПользователей);
	Если ПользователиГруппы = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Результат = Новый Соответствие;
	Для Каждого ОписаниеПользователя Из ПользователиГруппы Цикл
		Если УчастникиГруппыДоступа.Получить(ОписаниеПользователя.Ключ) <> Неопределено Тогда
			Результат.Вставить(ОписаниеПользователя.Ключ, Истина);
			Продолжить;
		КонецЕсли;
		Для Каждого ОписаниеПользователейГруппы Из ГруппыПользователейГруппыДоступа Цикл
			Если ОписаниеПользователейГруппы.Значение.Получить(ОписаниеПользователя.Ключ) <> Неопределено Тогда
				Результат.Вставить(ОписаниеПользователя.Ключ, Истина);
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Если Результат.Количество() = 0 Тогда
		Результат = "Ложь";
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ОбновитьПраваПорцииКлючейДоступаСписка.
Процедура ОбновитьПраваНаКлючДоступаСписка(КлючДоступа, ПраваНаКлюч, ОписаниеНовыхКлючей, ПараметрыОбновления)
	
	Если ПараметрыОбновления.РассчитыватьПраваПользователей Тогда
		ПраваНаКлючДляПользователей = Новый Соответствие;
		ТипПользователя = ПараметрыОбновления.ТипПользователя;
		Для Каждого КлючИЗначение Из ПраваНаКлюч.ДляПользователей Цикл
			Если ТипЗнч(КлючИЗначение.Ключ) = ТипПользователя Тогда
				Набор = Справочники.НаборыГруппДоступа.ПолучитьСсылку(КлючИЗначение.Ключ.УникальныйИдентификатор());
				ПраваНаКлючДляПользователей.Вставить(Набор, КлючИЗначение.Значение);
			Иначе
				ПраваНаКлюч.ДляГрупп.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Блокировка = Новый БлокировкаДанных;
	
	ЗапросГрупп = Новый Запрос;
	ЗапросГрупп.УстановитьПараметр("КлючДоступа", КлючДоступа);
	ЗапросГрупп.Текст =
	"ВЫБРАТЬ
	|	КлючиДоступаГруппДоступа.ГруппаДоступа КАК ГруппаДоступа,
	|	КлючиДоступаГруппДоступа.Изменение КАК Изменение,
	|	КлючиДоступаГруппДоступа.Добавление КАК Добавление
	|ИЗ
	|	РегистрСведений.КлючиДоступаГруппДоступа КАК КлючиДоступаГруппДоступа
	|ГДЕ
	|	КлючиДоступаГруппДоступа.КлючДоступа = &КлючДоступа
	|	И &УточнениеПланаЗапроса";
	УстановитьУточнениеПланаЗапроса(ЗапросГрупп.Текст);
	
	ЭлементБлокировкиГрупп = Блокировка.Добавить("РегистрСведений.КлючиДоступаГруппДоступа");
	ЭлементБлокировкиГрупп.УстановитьЗначение("КлючДоступа", КлючДоступа);
	НаборЗаписейГрупп = СлужебныйНаборЗаписей(РегистрыСведений.КлючиДоступаГруппДоступа);
	НаборЗаписейГрупп.Отбор.КлючДоступа.Установить(КлючДоступа);
	
	ЗапросНаборовГруппДоступа = Новый Запрос;
	ЗапросНаборовГруппДоступа.УстановитьПараметр("КлючДоступа", КлючДоступа);
	ЗапросНаборовГруппДоступа.УстановитьПараметр("РазрешенныйПустойНабор",
		УправлениеДоступомСлужебныйПовтИсп.РазрешенныйПустойНаборГруппДоступа());
	
	ЗапросНаборовГруппДоступа.Текст = ТекстЗапросаВыбораРазличийПроизводныхПравДляГруппДоступа();
	ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КлючиДоступаНаборовГруппДоступа");
	ЭлементБлокировки.УстановитьЗначение("КлючДоступа", КлючДоступа);
	НаборЗаписейНаборовГруппДоступа = СлужебныйНаборЗаписей(РегистрыСведений.КлючиДоступаНаборовГруппДоступа);
	НаборЗаписейНаборовГруппДоступа.Отбор.КлючДоступа.Установить(КлючДоступа);
	
	Если ПараметрыОбновления.РассчитыватьПраваПользователей Тогда
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("КлючДоступа", КлючДоступа);
		
		Если Не ПараметрыОбновления.ДляВнешнихПользователей Тогда
			Запрос.Текст = ТекстЗапросаВыбораРазличийПроизводныхПравДляПользователей();
			ИмяПоляВладельцаПрав = "Пользователь";
			ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КлючиДоступаПользователей");
			НаборЗаписей = СлужебныйНаборЗаписей(РегистрыСведений.КлючиДоступаПользователей);
		Иначе
			Запрос.Текст = ТекстЗапросаВыбораРазличийПроизводныхПравДляВнешнихПользователей();
			ИмяПоляВладельцаПрав = "ВнешнийПользователь";
			ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КлючиДоступаВнешнихПользователей");
			НаборЗаписей = СлужебныйНаборЗаписей(РегистрыСведений.КлючиДоступаВнешнихПользователей);
		КонецЕсли;
		ЭлементБлокировки.УстановитьЗначение("КлючДоступа", КлючДоступа);
		НаборЗаписей.Отбор.КлючДоступа.Установить(КлючДоступа);
	КонецЕсли;
	
	Если ОписаниеНовыхКлючей <> Неопределено Тогда
		ОписаниеНовогоКлюча = ОписаниеНовыхКлючей.ОписанияКлючейПоСсылке.Получить(КлючДоступа);
		КлючДоступаОбъект = ОписаниеНовогоКлюча.КлючДоступаОбъект;
		ЭлементБлокировкиКлюча = Блокировка.Добавить("Справочник.КлючиДоступа");
		ЭлементБлокировкиКлюча.УстановитьЗначение("Хеш",                     КлючДоступаОбъект.Хеш);
		ЭлементБлокировкиКлюча.УстановитьЗначение("Список",                  КлючДоступаОбъект.Список);
		ЭлементБлокировкиКлюча.УстановитьЗначение("ДляВнешнихПользователей", КлючДоступаОбъект.ДляВнешнихПользователей);
		ЭлементБлокировкиКлюча.УстановитьЗначение("СоставПолей",             КлючДоступаОбъект.СоставПолей);
	КонецЕсли;
	
	ОбновлениеВручную = ПараметрыОбновления.Свойство("ОбновитьПраваНаКлючи")
		И ПараметрыОбновления.ОбновитьПраваНаКлючи;
	
	Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		Если ОписаниеНовыхКлючей <> Неопределено Тогда
			ЭлементБлокировки = Блокировка.Добавить("Справочник.КлючиДоступа");
		КонецЕсли;
		ЭлементБлокировки = Блокировка.Добавить("Справочник.НаборыГруппДоступа");
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		Блокировка.Добавить("РегистрСведений.ОбновлениеКлючейДоступаКДанным");
		Блокировка.Добавить("РегистрСведений.ОбновлениеКлючейДоступаПользователей");
	КонецЕсли;
	
	НачатьТранзакцию();
	Попытка
		ПередБлокировкойДанных(ПараметрыОбновления);
		Блокировка.Заблокировать();
		ПослеБлокировкиДанных(ПараметрыОбновления);
		
		ЕстьИзмененияПрав = Ложь;
		
		Если ОписаниеНовыхКлючей = Неопределено
		 Или Не НовыйКлючДоступаУжеСуществует(ОписаниеНовыхКлючей, ОписаниеНовогоКлюча, ПараметрыОбновления) Тогда
			
			Если ОписаниеНовыхКлючей <> Неопределено Тогда
				ПередЗаписьюНовогоКлюча(ПараметрыОбновления);
				КлючДоступаОбъект.Записать();
				ПослеЗаписиНовогоКлюча(ПараметрыОбновления);
			КонецЕсли;
			
			ПередЗапросомПравГруппДоступа(ПараметрыОбновления);
			РезультатЗапросаГрупп = ЗапросГрупп.Выполнить();
			ПослеЗапросаПравГруппДоступа(ПараметрыОбновления);
			
			ЕстьИзменения = Новый Структура("ПраваГруппДоступа, ПраваГруппПользователей", Ложь, Ложь);
			ОбновитьИсходныеПраваГруппНаКлючДоступа(РезультатЗапросаГрупп, НаборЗаписейГрупп, "ГруппаДоступа",
				КлючДоступа, ПраваНаКлюч.ДляГрупп, ПараметрыОбновления, ЕстьИзменения);
			
			ЕстьИзмененияПрав = ЕстьИзменения.ПраваГруппДоступа Или ЕстьИзменения.ПраваГруппПользователей;
			
			Если ЕстьИзменения.ПраваГруппДоступа Или ОбновлениеВручную Тогда
				ПередЗапросомИзмененийПроизводныхПрав(ПараметрыОбновления);
				РезультатЗапросаНаборовГруппДоступа = ЗапросНаборовГруппДоступа.Выполнить();
				ПослеЗапросаИзмененийПроизводныхПрав(ПараметрыОбновления);
				ОбновитьПроизводныеПраваНаКлючДоступа(РезультатЗапросаНаборовГруппДоступа,
					НаборЗаписейНаборовГруппДоступа, "НаборГруппДоступа", КлючДоступа, , ПараметрыОбновления);
			КонецЕсли;
			
			Если ПараметрыОбновления.РассчитыватьПраваПользователей Тогда
				ЗапросыПакета = СтрРазделить(Запрос.Текст, ";", Ложь);
				Если ЕстьИзменения.ПраваГруппПользователей Или ОбновлениеВручную Тогда
					Запрос.Текст = ЗапросыПакета[1];
					ПередЗапросомИзмененийПроизводныхПрав(ПараметрыОбновления);
					РезультатЗапроса = Запрос.Выполнить();
					ПослеЗапросаИзмененийПроизводныхПрав(ПараметрыОбновления);
					ОбновитьПроизводныеПраваНаКлючДоступа(РезультатЗапроса,
						НаборЗаписей, ИмяПоляВладельцаПрав, КлючДоступа, , ПараметрыОбновления);
					НаборЗаписей.Очистить();
				КонецЕсли;
				Запрос.Текст = ЗапросыПакета[0];
				ПередЗапросомПравПользователей(ПараметрыОбновления);
				РезультатЗапросаПользователей = Запрос.Выполнить();
				ПослеЗапросаПравПользователей(ПараметрыОбновления);
				ОбновитьИсходныеПраваПользователейНаКлючДоступа(РезультатЗапросаПользователей, НаборЗаписей,
					ИмяПоляВладельцаПрав, КлючДоступа, ПраваНаКлючДляПользователей, ЕстьИзмененияПрав, ПараметрыОбновления);
			КонецЕсли;
			
			Если ОписаниеНовыхКлючей = Неопределено
			   И ЕстьИзмененияПрав
			   И ПараметрыОбновления.ЗависимыеСпискиПоКлючамДоступа.Количество() > 0 Тогда
				
				ПередПланированиемОбновления(ПараметрыОбновления);
				ЗапланироватьОбновлениеПользователейКлючейДоступа(ПараметрыОбновления.ЗависимыеСпискиПоКлючамДоступа,
					"ОбновитьПраваНаКлючДоступаСписка",
					Не ПараметрыОбновления.ДляВнешнихПользователей,
					ПараметрыОбновления.ДляВнешнихПользователей, ,
					Новый Структура("ПоКлючамДоступа", КлючДоступа));
				ПослеПланированияОбновления(ПараметрыОбновления);
			КонецЕсли;
		КонецЕсли;
		
		// АПК:330-выкл - №783.1.3 Допустимо указать вызов после ЗафиксироватьТранзакцию,
		// так как это вызов пустой процедуры в штатном режиме (то есть исключение невозможно),
		// а в режиме анализа производительности последствия учитываются и не являются критичными.
		ПередФиксациейТранзакции(ПараметрыОбновления);
		ЗафиксироватьТранзакцию();
		ПослеФиксацииТранзакции(ПараметрыОбновления);
		// АПК:330-вкл.
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	Если ЕстьИзмененияПрав И ПараметрыОбновления.Свойство("ЕстьИзмененияПрав") Тогда
		ПараметрыОбновления.ЕстьИзмененияПрав = Истина;
	КонецЕсли;
	
КонецПроцедуры

// Для процедур ОбновитьПраваНаКлючДоступаСписка, ОбновитьГруппыДоступаРазрешенногоКлючаДоступа.
Функция ТекстЗапросаВыбораРазличийПроизводныхПравДляГруппДоступа()
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ВсеСтроки.НаборГруппДоступа КАК НаборГруппДоступа,
	|	ВсеСтроки.Изменение КАК Изменение,
	|	ВсеСтроки.Добавление КАК Добавление,
	|	СУММА(ВсеСтроки.ВидИзмененияСтроки) КАК ВидИзмененияСтроки
	|ИЗ
	|	(ВЫБРАТЬ
	|		ГруппыВходящиеВНаборы.Ссылка КАК НаборГруппДоступа,
	|		МАКСИМУМ(КлючиДоступаГруппДоступа.Изменение) КАК Изменение,
	|		МАКСИМУМ(КлючиДоступаГруппДоступа.Добавление) КАК Добавление,
	|		1 КАК ВидИзмененияСтроки
	|	ИЗ
	|		РегистрСведений.КлючиДоступаГруппДоступа КАК КлючиДоступаГруппДоступа
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.НаборыГруппДоступа.Группы КАК ГруппыВходящиеВНаборы
	|			ПО (ГруппыВходящиеВНаборы.Группа = КлючиДоступаГруппДоступа.ГруппаДоступа)
	|				И (КлючиДоступаГруппДоступа.КлючДоступа = &КлючДоступа)
	|				И (&УточнениеПланаЗапроса)
	|	
	|	СГРУППИРОВАТЬ ПО
	|		ГруппыВходящиеВНаборы.Ссылка
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ВЫБРАТЬ
	|		&РазрешенныйПустойНабор,
	|		КлючиДоступаГруппДоступа.Изменение,
	|		КлючиДоступаГруппДоступа.Добавление,
	|		1
	|	ИЗ
	|		РегистрСведений.КлючиДоступаГруппДоступа КАК КлючиДоступаГруппДоступа
	|	ГДЕ
	|		КлючиДоступаГруппДоступа.ГруппаДоступа = ЗНАЧЕНИЕ(Справочник.ГруппыДоступа.ПустаяСсылка)
	|		И КлючиДоступаГруппДоступа.КлючДоступа = &КлючДоступа
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ВЫБРАТЬ
	|		СтарыеДанные.НаборГруппДоступа,
	|		СтарыеДанные.Изменение,
	|		СтарыеДанные.Добавление,
	|		-1
	|	ИЗ
	|		РегистрСведений.КлючиДоступаНаборовГруппДоступа КАК СтарыеДанные
	|	ГДЕ
	|		СтарыеДанные.КлючДоступа = &КлючДоступа) КАК ВсеСтроки
	|
	|СГРУППИРОВАТЬ ПО
	|	ВсеСтроки.НаборГруппДоступа,
	|	ВсеСтроки.Изменение,
	|	ВсеСтроки.Добавление
	|
	|ИМЕЮЩИЕ
	|	СУММА(ВсеСтроки.ВидИзмененияСтроки) <> 0
	|
	|УПОРЯДОЧИТЬ ПО
	|	ВидИзмененияСтроки";
	
	УстановитьУточнениеПланаЗапроса(ТекстЗапроса);
	
	Возврат ТекстЗапроса;
	
КонецФункции

// Для процедур ОбновитьПраваНаКлючДоступаСписка.
Функция ТекстЗапросаВыбораРазличийПроизводныхПравДляПользователей()
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	КлючиДоступаПользователей.Пользователь КАК Пользователь,
	|	КлючиДоступаПользователей.Изменение КАК Изменение,
	|	КлючиДоступаПользователей.Добавление КАК Добавление,
	|	КлючиДоступаПользователей.ЭтоПраваНабораГрупп КАК ЭтоПраваНабораГрупп
	|ИЗ
	|	РегистрСведений.КлючиДоступаПользователей КАК КлючиДоступаПользователей
	|ГДЕ
	|	КлючиДоступаПользователей.КлючДоступа = &КлючДоступа
	|	И НЕ КлючиДоступаПользователей.ЭтоПраваНабораГрупп
	|	И &УточнениеПланаЗапроса
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВсеСтроки.Пользователь КАК Пользователь,
	|	ВсеСтроки.Изменение КАК Изменение,
	|	ВсеСтроки.Добавление КАК Добавление,
	|	ИСТИНА КАК ЭтоПраваНабораГрупп,
	|	СУММА(ВсеСтроки.ВидИзмененияСтроки) КАК ВидИзмененияСтроки
	|ИЗ
	|	(ВЫБРАТЬ
	|		ГруппыВходящиеВНаборы.Ссылка КАК Пользователь,
	|		МАКСИМУМ(КлючиДоступаГруппДоступа.Изменение) КАК Изменение,
	|		МАКСИМУМ(КлючиДоступаГруппДоступа.Добавление) КАК Добавление,
	|		1 КАК ВидИзмененияСтроки
	|	ИЗ
	|		РегистрСведений.КлючиДоступаГруппДоступа КАК КлючиДоступаГруппДоступа
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.НаборыГруппДоступа.Группы КАК ГруппыВходящиеВНаборы
	|			ПО (ГруппыВходящиеВНаборы.Группа = КлючиДоступаГруппДоступа.ГруппаДоступа)
	|				И (ТИПЗНАЧЕНИЯ(КлючиДоступаГруппДоступа.ГруппаДоступа) = ТИП(Справочник.ГруппыПользователей))
	|				И (КлючиДоступаГруппДоступа.КлючДоступа = &КлючДоступа)
	|				И (&УточнениеПланаЗапроса)
	|	
	|	СГРУППИРОВАТЬ ПО
	|		ГруппыВходящиеВНаборы.Ссылка
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ВЫБРАТЬ
	|		СтарыеДанные.Пользователь,
	|		СтарыеДанные.Изменение,
	|		СтарыеДанные.Добавление,
	|		-1
	|	ИЗ
	|		РегистрСведений.КлючиДоступаПользователей КАК СтарыеДанные
	|	ГДЕ
	|		СтарыеДанные.ЭтоПраваНабораГрупп
	|		И СтарыеДанные.КлючДоступа = &КлючДоступа) КАК ВсеСтроки
	|
	|СГРУППИРОВАТЬ ПО
	|	ВсеСтроки.Пользователь,
	|	ВсеСтроки.Изменение,
	|	ВсеСтроки.Добавление
	|
	|ИМЕЮЩИЕ
	|	СУММА(ВсеСтроки.ВидИзмененияСтроки) <> 0
	|
	|УПОРЯДОЧИТЬ ПО
	|	ВидИзмененияСтроки";
	
	УстановитьУточнениеПланаЗапроса(ТекстЗапроса);
	
	Возврат ТекстЗапроса;
	
КонецФункции

// Для процедур ОбновитьПраваНаКлючДоступаСписка.
Функция ТекстЗапросаВыбораРазличийПроизводныхПравДляВнешнихПользователей()
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	КлючиДоступаВнешнихПользователей.ВнешнийПользователь КАК ВнешнийПользователь,
	|	КлючиДоступаВнешнихПользователей.Изменение КАК Изменение,
	|	КлючиДоступаВнешнихПользователей.Добавление КАК Добавление,
	|	КлючиДоступаВнешнихПользователей.ЭтоПраваНабораГрупп КАК ЭтоПраваНабораГрупп
	|ИЗ
	|	РегистрСведений.КлючиДоступаВнешнихПользователей КАК КлючиДоступаВнешнихПользователей
	|ГДЕ
	|	КлючиДоступаВнешнихПользователей.КлючДоступа = &КлючДоступа
	|	И НЕ КлючиДоступаВнешнихПользователей.ЭтоПраваНабораГрупп
	|	И &УточнениеПланаЗапроса
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВсеСтроки.ВнешнийПользователь КАК ВнешнийПользователь,
	|	ВсеСтроки.Изменение КАК Изменение,
	|	ВсеСтроки.Добавление КАК Добавление,
	|	ИСТИНА КАК ЭтоПраваНабораГрупп,
	|	СУММА(ВсеСтроки.ВидИзмененияСтроки) КАК ВидИзмененияСтроки
	|ИЗ
	|	(ВЫБРАТЬ
	|		ГруппыВходящиеВНаборы.Ссылка КАК ВнешнийПользователь,
	|		МАКСИМУМ(КлючиДоступаГруппДоступа.Изменение) КАК Изменение,
	|		МАКСИМУМ(КлючиДоступаГруппДоступа.Добавление) КАК Добавление,
	|		1 КАК ВидИзмененияСтроки
	|	ИЗ
	|		РегистрСведений.КлючиДоступаГруппДоступа КАК КлючиДоступаГруппДоступа
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.НаборыГруппДоступа.Группы КАК ГруппыВходящиеВНаборы
	|			ПО (ГруппыВходящиеВНаборы.Группа = КлючиДоступаГруппДоступа.ГруппаДоступа)
	|				И (ТИПЗНАЧЕНИЯ(КлючиДоступаГруппДоступа.ГруппаДоступа) = ТИП(Справочник.ГруппыВнешнихПользователей))
	|				И (КлючиДоступаГруппДоступа.КлючДоступа = &КлючДоступа)
	|				И (&УточнениеПланаЗапроса)
	|	
	|	СГРУППИРОВАТЬ ПО
	|		ГруппыВходящиеВНаборы.Ссылка
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ВЫБРАТЬ
	|		СтарыеДанные.ВнешнийПользователь,
	|		СтарыеДанные.Изменение,
	|		СтарыеДанные.Добавление,
	|		-1
	|	ИЗ
	|		РегистрСведений.КлючиДоступаВнешнихПользователей КАК СтарыеДанные
	|	ГДЕ
	|		СтарыеДанные.ЭтоПраваНабораГрупп
	|		И СтарыеДанные.КлючДоступа = &КлючДоступа) КАК ВсеСтроки
	|
	|СГРУППИРОВАТЬ ПО
	|	ВсеСтроки.ВнешнийПользователь,
	|	ВсеСтроки.Изменение,
	|	ВсеСтроки.Добавление
	|
	|ИМЕЮЩИЕ
	|	СУММА(ВсеСтроки.ВидИзмененияСтроки) <> 0
	|
	|УПОРЯДОЧИТЬ ПО
	|	ВидИзмененияСтроки";
	
	УстановитьУточнениеПланаЗапроса(ТекстЗапроса);
	
	Возврат ТекстЗапроса;
	
КонецФункции

// Для процедуры ОбновитьПраваНаКлючДоступаСписка.
Функция НовыйКлючДоступаУжеСуществует(ОписаниеНовыхКлючей, ОписаниеНовогоКлюча, ПараметрыОбновления)
	
	ЗапросСуществованияКлючей = ОписаниеНовыхКлючей.ЗапросСуществованияКлючей;
	ЗапросСуществованияКлючей.УстановитьПараметр("Хеш", ОписаниеНовогоКлюча.КлючДоступаОбъект.Хеш);
	
	Если ЗапросСуществованияКлючей.Выполнить().Пустой() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ЗапросЗначенийКлючей = ОписаниеНовыхКлючей.ЗапросЗначенийКлючей;
	ЗапросЗначенийКлючей.УстановитьПараметр("Хеши", ОписаниеНовогоКлюча.КлючДоступаОбъект.Хеш);
	
	РезультатыЗапросаЗначенийКлючей = ЗапросЗначенийКлючей.ВыполнитьПакет();
	
	ТаблицыКлюча = ПараметрыОбновления.ТаблицыКлюча;
	КлючиЗначенийСтрокКлючей = КлючиЗначенийСтрокОбъектов(РезультатыЗапросаЗначенийКлючей,
		?(СтрНачинаетсяС(ТаблицыКлюча[0], "Шапка"), 0, 1), ТаблицыКлюча);
	
	Для Каждого ОписаниеКлючаДоступа Из КлючиЗначенийСтрокКлючей Цикл
		СтрокаДляХеша = СтрокаДляХешаКлючаДоступа(ОписаниеКлючаДоступа.Значение, ТаблицыКлюча);
		Если ОписаниеНовогоКлюча.СтрокаДляХеша = СтрокаДляХеша Тогда
			Ссылка = ОписаниеКлючаДоступа.Ключ;
			ОписаниеНовогоКлюча.КлючДоступаОбъект = Новый Структура("Ссылка", Ссылка);
			НеИспользуетсяС = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, "НеИспользуетсяС");
			Если ЗначениеЗаполнено(НеИспользуетсяС) Тогда
				Объект = СлужебныйЭлемент(Неопределено, Ссылка);
				Объект.НеИспользуетсяС = '00010101';
				Объект.Записать();
			КонецЕсли;
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Для процедуры ОбновитьПраваНаКлючДоступаСписка.
Процедура ОбновитьИсходныеПраваГруппНаКлючДоступа(РезультатЗапроса, НаборЗаписей, ИмяПоляВладельцаПрав,
			 КлючДоступа, ПраваНаКлюч, ПараметрыОбновления, ЕстьИзменения)
	
	Выборка = РезультатЗапроса.Выбрать();
	ТипГруппыДоступа = ПараметрыОбновления.ТипГруппыДоступа;
	ЕстьИзмененияПравГруппДоступа = Ложь;
	ЕстьИзмененияПравГруппПользователей = Ложь;
	
	КоличествоЗаписанных = 0;
	ПередЗаписьюСтрок(ПараметрыОбновления);
	Пока Выборка.Следующий() Цикл
		ВладелецПрав = Выборка[ИмяПоляВладельцаПрав];
		Права = ПраваНаКлюч.Получить(ВладелецПрав);
		Если Права = Неопределено Тогда
			НаборЗаписей.Отбор[ИмяПоляВладельцаПрав].Установить(ВладелецПрав);
			НаборЗаписей.Записать();
			Если ТипЗнч(ВладелецПрав) = ТипГруппыДоступа Тогда
				ЕстьИзмененияПравГруппДоступа = Истина;
			Иначе
				ЕстьИзмененияПравГруппПользователей = Истина;
			КонецЕсли;
		ИначеЕсли Выборка.Изменение  = Права.Изменение
		        И Выборка.Добавление = Права.Добавление Тогда
			ПраваНаКлюч.Вставить(ВладелецПрав, Null);
		КонецЕсли;
	КонецЦикла;
	
	ОднаЗапись = НаборЗаписей.Добавить();
	ОднаЗапись.КлючДоступа = КлючДоступа;
	Для Каждого ОписаниеПрав Из ПраваНаКлюч Цикл
		Права = ОписаниеПрав.Значение;
		Если Права = Null Тогда
			Продолжить;
		КонецЕсли;
		ВладелецПрав = ОписаниеПрав.Ключ;
		НаборЗаписей.Отбор[ИмяПоляВладельцаПрав].Установить(ВладелецПрав);
		ОднаЗапись[ИмяПоляВладельцаПрав]        = ВладелецПрав;
		ОднаЗапись.Изменение                    = Права.Изменение;
		ОднаЗапись.Добавление                   = Права.Добавление;
		НаборЗаписей.Записать();
		Если ТипЗнч(ВладелецПрав) = ТипГруппыДоступа Тогда
			ЕстьИзмененияПравГруппДоступа = Истина;
		Иначе
			ЕстьИзмененияПравГруппПользователей = Истина;
		КонецЕсли;
		КоличествоЗаписанных = КоличествоЗаписанных + 1;
	КонецЦикла;
	ПослеЗаписиСтрок(ПараметрыОбновления, КоличествоЗаписанных);
	
	ЕстьИзменения.ПраваГруппДоступа       = ЕстьИзмененияПравГруппДоступа;
	ЕстьИзменения.ПраваГруппПользователей = ЕстьИзмененияПравГруппПользователей;
	
КонецПроцедуры

// Для процедуры ОбновитьПраваНаКлючДоступаСписка.
Процедура ОбновитьИсходныеПраваПользователейНаКлючДоступа(РезультатЗапроса, НаборЗаписей,
			ИмяПоляВладельцаПрав, КлючДоступа, ПраваНаКлюч, ЕстьИзмененияПрав, ПараметрыОбновления)
	
	Выборка = РезультатЗапроса.Выбрать();
	
	КоличествоЗаписанных = 0;
	ПередЗаписьюСтрок(ПараметрыОбновления);
	Пока Выборка.Следующий() Цикл
		ВладелецПрав = Выборка[ИмяПоляВладельцаПрав];
		Права = ПраваНаКлюч.Получить(ВладелецПрав);
		Если Права = Неопределено Тогда
			НаборЗаписей.Отбор[ИмяПоляВладельцаПрав].Установить(ВладелецПрав);
			НаборЗаписей.Записать();
			ЕстьИзмененияПрав = Истина;
		ИначеЕсли Выборка.Изменение  = Права.Изменение
		        И Выборка.Добавление = Права.Добавление
		        И Выборка.ЭтоПраваНабораГрупп = Ложь Тогда
			ПраваНаКлюч.Вставить(ВладелецПрав, Null);
		КонецЕсли;
	КонецЦикла;
	
	ОднаЗапись = НаборЗаписей.Добавить();
	ОднаЗапись.КлючДоступа = КлючДоступа;
	Для Каждого ОписаниеПрав Из ПраваНаКлюч Цикл
		Права = ОписаниеПрав.Значение;
		Если Права = Null Тогда
			Продолжить;
		КонецЕсли;
		ВладелецПрав = ОписаниеПрав.Ключ;
		НаборЗаписей.Отбор[ИмяПоляВладельцаПрав].Установить(ВладелецПрав);
		ОднаЗапись[ИмяПоляВладельцаПрав] = ВладелецПрав;
		ОднаЗапись.Изменение  = Права.Изменение;
		ОднаЗапись.Добавление = Права.Добавление;
		ОднаЗапись.ЭтоПраваНабораГрупп = Ложь;
		НаборЗаписей.Записать();
		ЕстьИзмененияПрав = Истина;
		КоличествоЗаписанных = КоличествоЗаписанных + 1;
	КонецЦикла;
	ПослеЗаписиСтрок(ПараметрыОбновления, КоличествоЗаписанных);
	
КонецПроцедуры

// Для процедуры ОбновитьПраваНаКлючДоступаСписка.
Процедура ОбновитьПроизводныеПраваНаКлючДоступа(РезультатЗапроса, НаборЗаписей, ИмяПоляВладельцаПрав,
			КлючДоступа, ЕстьИзменения = Ложь, ПараметрыОбновления = Неопределено)
	
	Выборка = РезультатЗапроса.Выбрать();
	УдалениеЗавершено = Ложь;
	
	КоличествоЗаписанных = 0;
	ПередЗаписьюСтрок(ПараметрыОбновления);
	Пока Выборка.Следующий() Цикл
		НаборЗаписей.Отбор[ИмяПоляВладельцаПрав].Установить(Выборка[ИмяПоляВладельцаПрав]);
		Если Не УдалениеЗавершено И Выборка.ВидИзмененияСтроки = 1 Тогда
			УдалениеЗавершено = Истина;
			ОднаЗапись = НаборЗаписей.Добавить();
			ОднаЗапись.КлючДоступа = КлючДоступа;
		КонецЕсли;
		Если УдалениеЗавершено Тогда
			ЗаполнитьЗначенияСвойств(ОднаЗапись, Выборка);
		КонецЕсли;
		НаборЗаписей.Записать();
		ЕстьИзменения = Истина;
		КоличествоЗаписанных = КоличествоЗаписанных + 1;
	КонецЦикла;
	ПослеЗаписиСтрок(ПараметрыОбновления, КоличествоЗаписанных);
	
КонецПроцедуры

// Создает служебный элемент справочника, который не участвует в подписках на события.
Функция СлужебныйЭлемент(МенеджерСправочника, Ссылка = Неопределено)
	
	Если Ссылка = Неопределено Тогда
		ЭлементСправочника = МенеджерСправочника.СоздатьЭлемент();
	Иначе
		ЭлементСправочника = Ссылка.ПолучитьОбъект();
		Если ЭлементСправочника = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	ЭлементСправочника.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
	ЭлементСправочника.ОбменДанными.Получатели.АвтоЗаполнение = Ложь;
	ЭлементСправочника.ОбменДанными.Загрузка = Истина;
	
	Возврат ЭлементСправочника;
	
КонецФункции

// Создает набор записей служебного регистра, который не участвует в подписках на события.
Функция СлужебныйНаборЗаписей(МенеджерРегистра)
	
	НаборЗаписей = МенеджерРегистра.СоздатьНаборЗаписей();
	НаборЗаписей.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
	НаборЗаписей.ОбменДанными.Получатели.АвтоЗаполнение = Ложь;
	НаборЗаписей.ОбменДанными.Загрузка = Истина;
	
	Возврат НаборЗаписей;
	
КонецФункции

// Для процедуры ЗаполнитьШаблоныЧастейЗапросаПроверкиОбъекта.
Функция МаркерРазмераПорции()
	
	Возврат "995";
	
КонецФункции

// Для процедуры ЗарегистрироватьПланированиеОбновленияДоступа.
Процедура ЗарегистрироватьПланированиеОбновленияДоступаВЖурнале(Списки, ПараметрыПланирования)
	
	КомментарийДляЖурнала = НСтр("ru = 'Источник'", ОбщегоНазначения.КодОсновногоЯзыка())
		+ ": " + ПараметрыПланирования.Описание + Символы.ПС;
	
	Если Списки.Количество() > 1 Тогда
		КомментарийДляЖурнала = КомментарийДляЖурнала
			+ НСтр("ru = 'Списки'", ОбщегоНазначения.КодОсновногоЯзыка()) + ":"
			+ Символы.ПС + Символы.Таб + СтрСоединить(Списки, Символы.ПС + Символы.Таб);
	Иначе
		КомментарийДляЖурнала = КомментарийДляЖурнала
			+ НСтр("ru = 'Список'", ОбщегоНазначения.КодОсновногоЯзыка());
		
		КомментарийДляЖурнала = КомментарийДляЖурнала + " = " + Списки[0];
	КонецЕсли;
	
	КомментарийДляЖурнала = КомментарийДляЖурнала + Символы.ПС + "ЭтоТочечноеЗадание"
		+ " = " + ?(ПараметрыПланирования.Свойство("ЭтоТочечноеЗадание"), "Да", "Нет");
	
	КомментарийДляЖурнала = КомментарийДляЖурнала + Символы.ПС + "КлючиДоступаКДанным"
		+ " = " + ?(ПараметрыПланирования.КлючиДоступаКДанным, "Да", "Нет");
	
	КомментарийДляЖурнала = КомментарийДляЖурнала + Символы.ПС + "РазрешенныеКлючиДоступа"
		+ " = " + ?(ПараметрыПланирования.РазрешенныеКлючиДоступа, "Да", "Нет");
	
	КомментарийДляЖурнала = КомментарийДляЖурнала + Символы.ПС + "ДляПользователей"
		+ " = " + ?(ПараметрыПланирования.ДляПользователей, "Да", "Нет");
	
	КомментарийДляЖурнала = КомментарийДляЖурнала + Символы.ПС + "ДляВнешнихПользователей"
		+ " = " + ?(ПараметрыПланирования.ДляВнешнихПользователей, "Да", "Нет");
	
	КомментарийДляЖурнала = КомментарийДляЖурнала + Символы.ПС + "ЭтоПродолжениеОбновления"
		+ " = " + ?(ПараметрыПланирования.ЭтоПродолжениеОбновления, "Да", "Нет");
	
	КомментарийДляЖурнала = КомментарийДляЖурнала + Символы.ПС + "ЭтоОбработкаУстаревшихЭлементов"
	 + " = " + ?(ПараметрыПланирования.ЭтоОбработкаУстаревшихЭлементов, "Да", "Нет");
	
	ВедущийОбъект = Неопределено;
	Если ТипЗнч(ПараметрыПланирования.ВедущийОбъект) = Тип("Структура") Тогда
		Если ПараметрыПланирования.ВедущийОбъект.Свойство("ПоЗначениямПолей") Тогда
			Указатели = ПараметрыПланирования.ВедущийОбъект.ПоЗначениямПолей.Описание;
			ВедущийОбъект = "ПоЗначениямПолей";
		ИначеЕсли ПараметрыПланирования.ВедущийОбъект.Свойство("ПоКлючамДоступа") Тогда
			Указатели = ПараметрыПланирования.ВедущийОбъект.ПоКлючамДоступа;
			ВедущийОбъект = "ПоКлючамДоступа";
		ИначеЕсли ПараметрыПланирования.ВедущийОбъект.Свойство("ПоЗначениямСГруппами") Тогда
			Указатели = ПараметрыПланирования.ВедущийОбъект.ПоЗначениямСГруппами;
			ВедущийОбъект = "ПоЗначениямСГруппами";
		КонецЕсли;
		Если ВедущийОбъект <> Неопределено Тогда
			Если ТипЗнч(Указатели) = Тип("Массив") И Указатели.Количество() > 1 Тогда
				ВедущийОбъект = ВедущийОбъект + ":";
				Для Каждого Указатель Из Указатели Цикл
					ВедущийОбъект = ВедущийОбъект + Символы.ПС + """" + Строка(Указатель) + """ "
						+ ОписаниеУказателяВедущегоОбъекта(Указатель, ПараметрыПланирования);
				КонецЦикла;
			Иначе
				Указатель = ?(ТипЗнч(Указатели) = Тип("Массив"), Указатели[0], Указатели);
				ВедущийОбъект = ВедущийОбъект + ": """ + Строка(Указатель) + """ "
					+ ОписаниеУказателяВедущегоОбъекта(Указатель, ПараметрыПланирования);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	ЗаписьЖурналаРегистрации(
		НСтр("ru = 'Управление доступом.Показатели.Планирование обновления доступа'",
		     ОбщегоНазначения.КодОсновногоЯзыка()),
		УровеньЖурналаРегистрации.Информация, ,
		ВедущийОбъект,
		КомментарийДляЖурнала,
		?(ТранзакцияАктивна(), РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная, Неопределено));
	
КонецПроцедуры

// Для процедуры ЗарегистрироватьПланированиеОбновленияДоступаВЖурнале.
Функция ОписаниеУказателяВедущегоОбъекта(Указатель, ПараметрыПланирования)
	
	Если ПараметрыПланирования.Свойство("ТиповСсылокВедущихОбъектов") Тогда
		ТипыСсылок = ПараметрыПланирования.ТиповСсылокВедущихОбъектов;
	Иначе
		ТипыСсылок = УправлениеДоступомСлужебныйПовтИсп.ТиповСсылокВедущихОбъектов();
		ПараметрыПланирования.Вставить("ТиповСсылокВедущихОбъектов", ТипыСсылок);
	КонецЕсли;
	
	Если ТипыСсылок.Получить(ТипЗнч(Указатель)) <> Неопределено Тогда
		Возврат ПолучитьНавигационнуюСсылку(Указатель);
	КонецЕсли;
	
	Описание = "";
	Для Каждого ЭлементОтбора Из Указатель Цикл
		Если Не ЭлементОтбора.Использование Тогда
			Продолжить;
		КонецЕсли;
		Если ТипыСсылок.Получить(ТипЗнч(ЭлементОтбора.Значение)) <> Неопределено Тогда
			ОписаниеЗначения = ПолучитьНавигационнуюСсылку(ЭлементОтбора.Значение);
		ИначеЕсли ТипЗнч(ЭлементОтбора.Значение) = Тип("Неопределено") Тогда
			ОписаниеЗначения = НСтр("ru = 'Неопределено'");
		Иначе
			ОписаниеЗначения = Формат(ЭлементОтбора.Значение, "ЧН=0; ДП='01.01.0001 00:00:00'");
		КонецЕсли;
		Описание = Описание + ?(Описание = "", "", ", ")
			+ ЭлементОтбора.Имя + " = " + ОписаниеЗначения;
	КонецЦикла;
	
	Возврат Описание;
	
КонецФункции

// Для вызова из мест планирования обновления доступа.
Процедура ЗарегистрироватьПланированиеОбновленияДоступа(СпискиПоИдентификаторам, ПараметрыПланирования, ВсеСписки = Ложь)
	
	Если Не РегистрироватьПоказателиПланированияОбновленияДоступа() Тогда
		Возврат;
	КонецЕсли;
	
	Если ПараметрыПланирования = Неопределено Тогда
		ПараметрыПланирования = ПараметрыПланированияОбновленияДоступа();
	КонецЕсли;
	
	Списки = Новый Массив;
	
	Если Не ВсеСписки Тогда
		Для Каждого ОписаниеСписка Из СпискиПоИдентификаторам Цикл
			Если ЗначениеЗаполнено(ОписаниеСписка.Значение) Тогда
				Списки.Добавить(ОписаниеСписка.Значение);
			Иначе
				Списки.Добавить(ПолноеИмяСписка(ОписаниеСписка.Ключ));
			КонецЕсли;
		КонецЦикла;
	Иначе
		Списки.Добавить("Все");
	КонецЕсли;
	
	ЗарегистрироватьПланированиеОбновленияДоступаВЖурнале(Списки, ПараметрыПланирования);
	
КонецПроцедуры

// Для процедуры ЗарегистрироватьПланированиеОбновленияДоступа.
Функция ПолноеИмяСписка(ОписаниеСписка)
	
	Если ТипЗнч(ОписаниеСписка) = Тип("СправочникСсылка.ИдентификаторыОбъектовМетаданных")
	 Или ТипЗнч(ОписаниеСписка) = Тип("СправочникСсылка.ИдентификаторыОбъектовРасширений") Тогда
		
		ОбъектМетаданных = ОбщегоНазначения.ОбъектМетаданныхПоИдентификатору(ОписаниеСписка, Ложь);
		
		Если ТипЗнч(ОбъектМетаданных) = Тип("ОбъектМетаданных") Тогда
			Возврат ОбъектМетаданных.ПолноеИмя();
		Иначе
			Возврат ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ОписаниеСписка, "ПолноеИмя");
		КонецЕсли;
	Иначе
		Возврат Строка(ОписаниеСписка);
	КонецЕсли;
	
КонецФункции

// Для процедуры УправлениеДоступом.ОтключитьОбновлениеКлючейДоступа.
Процедура ДобавитьЗависимыеСписки(Списки, ДобавленныеСписки, НедоступныеСписки) Экспорт
	
	ИсходныеСписки = Новый ФиксированныйМассив(Списки);
	ДействующиеПараметры = ДействующиеПараметрыОграниченияДоступа(Неопределено, Неопределено, Ложь);
	
	НенайденныеСписки = Новый Массив;
	
	Для Каждого ИсходныйСписок Из ИсходныеСписки Цикл
		Свойства = ДействующиеПараметры.ВедущиеСписки.Получить(ИсходныйСписок);
		Если Свойства = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Для Каждого КлючИЗначение Из Свойства.ЗависимыеСписки Цикл
			Если ДобавленныеСписки.Получить(КлючИЗначение.Ключ) = Неопределено Тогда
				ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(КлючИЗначение.Ключ);
				Если ОбъектМетаданных = Неопределено Тогда
					НенайденныеСписки.Добавить(КлючИЗначение.Ключ);
				Иначе
					ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
					Списки.Добавить(ПолноеИмя);
					ДобавленныеСписки.Вставить(ПолноеИмя, Истина);
				КонецЕсли;
				ДобавленныеСписки.Вставить(КлючИЗначение.Ключ, Истина);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Если НенайденныеСписки.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	НедоступныеСписки = ВсеИдентификаторыСПодобнымиПолнымиИменами(НенайденныеСписки);
	
КонецПроцедуры

Функция ОписаниеОграниченийДанных() Экспорт
	
	ОбщийКонтекст = Новый Структура;
	ОбщийКонтекст.Вставить("СпискиСОграничением", УправлениеДоступомСлужебныйПовтИсп.СпискиСОграничением());
	
	Результат = Новый Соответствие;
	
	Для Каждого ОписаниеСписка Из ОбщийКонтекст.СпискиСОграничением Цикл
		ПолноеИмя = ОписаниеСписка.Ключ;
		ОписаниеОграничения = ОписаниеОграниченияДанных(ОбщийКонтекст, ПолноеИмя);
		Результат.Вставить(ПолноеИмя, ОписаниеОграничения);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#Область ПараметрыДляПереопределенияЧерезРасширениеКонфигурации

Функция КоличествоЧасовУстареванияНеиспользуемыхЭлементов()
	
	Возврат 47;
	
КонецФункции

Функция КоличествоЧасовМеждуПланированиемОбработкиУстаревшихЭлементов()
	
	Возврат 48;
	
КонецФункции

Функция МаксимальноеКоличествоМинутВыполненияФоновогоЗаданияОбновленияДоступа()
	
	Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		Возврат 2;
	Иначе
		Возврат 15;
	КонецЕсли;
	
КонецФункции

Функция МаксимальноеКоличествоСекундОжиданияВыполненияОдногоЗаданияВПотоке()
	
	Возврат 900; // 15 минут (например, избыточно длительный запрос SQL).
	
КонецФункции

Функция МинимальноеКоличествоСекундОбработкиПорцииВОтдельномПотоке()
	
	Возврат 1;
	
КонецФункции

Функция МинимальноеКоличествоСекундВыполненияТочечногоЗадания()
	
	Возврат 15;
	
КонецФункции

Функция ЗагружатьСвободныеПотокиСледующимиЗаданиямиПриДлительныхЗапросах()
	
	Возврат Ложь;
	
КонецФункции

Функция МаксимальныйПериодПолученияПорцийЗапросом()
	
	Возврат "Год"; // Год, Квартал, Месяц, Неделя.
	
КонецФункции

Функция ЗапускатьОбновлениеПолученныхПорцийПриПолученииНовыхПорций()
	
	Возврат Ложь;
	
КонецФункции

Функция КоличествоЭлементовДанныхВЗапросе()
	
	Возврат 1000;
	
КонецФункции

Функция КоличествоЭлементовДанныхВПорции()
	
	Возврат 1000;
	
КонецФункции

Функция КоличествоКлючейДоступаВЗапросе()
	
	Возврат 1000;
	
КонецФункции

Функция КоличествоКлючейДоступаВПорции()
	
	Возврат 200;
	
КонецФункции

Функция ЗаписыватьТолькоИзмененныеКлючиДоступаЭлементовДанных()
	
	Возврат Ложь;
	
КонецФункции

Функция МаксимальноеКоличествоКомбинацийЗначенийВедущихПолейПриВычисленииСоставаИзмененных()
	
	Возврат 100;
	
КонецФункции

Функция РегистрироватьПоказателиОбновленияДоступа()
	
	Возврат Истина;
	
КонецФункции

Функция РегистрироватьПоказателиПланированияОбновленияДоступа()
	
	Возврат Ложь;
	
КонецФункции

Функция РегистрироватьСтрокуВерсииПараметровОграниченияДоступа()
	
	Возврат Ложь;
	
КонецФункции

#КонецОбласти

#Область ТочкиПодключенияДляАнализаПроизводительностиЧерезРасширениеКонфигурации

Процедура ПередБлокировкойДанных(ПараметрыОбновления)
	Возврат;
КонецПроцедуры

Процедура ПослеБлокировкиДанных(ПараметрыОбновления)
	Возврат;
КонецПроцедуры

Процедура ПередЗапросомТекущихКлючейДоступа(ПараметрыОбновления)
	Возврат;
КонецПроцедуры

Процедура ПослеЗапросаТекущихКлючейДоступа(ПараметрыОбновления)
	Возврат;
КонецПроцедуры

Процедура ПередЗаписьюСтрок(ПараметрыОбновления)
	Возврат;
КонецПроцедуры

Процедура ПослеЗаписиСтрок(ПараметрыОбновления, КоличествоЗаписанных)
	Возврат;
КонецПроцедуры

Процедура ПередФиксациейТранзакции(ПараметрыОбновления)
	Возврат;
КонецПроцедуры

Процедура ПослеФиксацииТранзакции(ПараметрыОбновления)
	Возврат;
КонецПроцедуры

Процедура ПередПланированиемОбновления(ПараметрыОбновления)
	Возврат;
КонецПроцедуры

Процедура ПослеПланированияОбновления(ПараметрыОбновления)
	Возврат;
КонецПроцедуры

Процедура ПередЗаписьюНовогоКлюча(ПараметрыОбновления)
	Возврат;
КонецПроцедуры

Процедура ПослеЗаписиНовогоКлюча(ПараметрыОбновления)
	Возврат;
КонецПроцедуры

Процедура ПередЗапросомПравГруппДоступа(ПараметрыОбновления)
	Возврат;
КонецПроцедуры

Процедура ПослеЗапросаПравГруппДоступа(ПараметрыОбновления)
	Возврат;
КонецПроцедуры

Процедура ПередЗапросомИзмененийПроизводныхПрав(ПараметрыОбновления)
	Возврат;
КонецПроцедуры

Процедура ПослеЗапросаИзмененийПроизводныхПрав(ПараметрыОбновления)
	Возврат;
КонецПроцедуры

Процедура ПередЗапросомПравПользователей(ПараметрыОбновления)
	Возврат;
КонецПроцедуры

Процедура ПослеЗапросаПравПользователей(ПараметрыОбновления)
	Возврат;
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область ПараметрыОграниченияДоступа

#Область ПараметрыОграниченияДоступаОбщаяЧасть

// Основная функция, возвращающая параметры, необходимые для регистрации
// необходимости обновления ключей доступа к элементам данных.
Функция СвойстваСпискаКакВедущего(ПолноеИмя, ИдентификаторТранзакции = Неопределено, ПовторныйВызов = Ложь)
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	ДействующиеПараметры = ДействующиеПараметрыОграниченияДоступа(ИдентификаторТранзакции, Неопределено, ПовторныйВызов);
	ХранимыеСвойстваСпискаКакВедущего = ДействующиеПараметры.ВедущиеСписки.Получить(ПолноеИмя);
	
	Если ХранимыеСвойстваСпискаКакВедущего = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Кэш = КэшПараметровОграничения();
	
	СвойстваСпискаКакВедущего = Кэш.ВедущиеСпискиПроверенные.Получить(ПолноеИмя);
	Если СвойстваСпискаКакВедущего <> Неопределено Тогда
		Возврат СвойстваСпискаКакВедущего;
	КонецЕсли;
	
	СвойстваСпискаКакВедущего = Новый Структура(ХранимыеСвойстваСпискаКакВедущего);
	Отказ = Ложь;
	ЗаполнитьТекстЗапросаСтарыхЗначенийДляПроверкиИзмененияПолейВедущегоСписка(ПолноеИмя,
		СвойстваСпискаКакВедущего, Отказ);
	
	Если Не Отказ Тогда
		Кэш.ВедущиеСпискиПроверенные.Вставить(ПолноеИмя,
			Новый ФиксированнаяСтруктура(СвойстваСпискаКакВедущего));
		
		Возврат СвойстваСпискаКакВедущего;
	КонецЕсли;
	
	Если ПовторныйВызов Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось подготовить свойства списка ""%1"" как ведущего,
			           |из-за некорректного состояния параметров ограничения доступа.'"),
			ПолноеИмя);
	КонецЕсли;
	
	Возврат СвойстваСпискаКакВедущего(ПолноеИмя, ИдентификаторТранзакции, Истина);
	
КонецФункции

// Для функции СвойстваСпискаКакВедущего и процедур ЗаполнитьПараметрыОграничения,
// ОбновитьИдентификаторыТранзакции, УстановитьВерсиюПараметров.
//
Функция КэшПараметровОграничения()
	
	КлючДанныхПовторногоИспользования = Строка(ПараметрыСеанса.КлючДанныхПовторногоИспользования);
	
	Возврат УправлениеДоступомСлужебныйПовтИсп.КэшПараметровОграничения(КлючДанныхПовторногоИспользования);
	
КонецФункции

// Для функции СвойстваСпискаКакВедущего.
Процедура ЗаполнитьТекстЗапросаСтарыхЗначенийДляПроверкиИзмененияПолейВедущегоСписка(ПолноеИмя, Свойства, Отказ)
	
	Свойства.Удалить("ЗависимыеСписки");
	Если Свойства.ПоЗначениямПолей = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ПоЗначениямПолей = Новый Структура(Свойства.ПоЗначениямПолей);
	ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ПолноеИмя);
	
	Если ПоЗначениямПолей.ЭтоСсылочныйТип Тогда
		Если ЗначениеЗаполнено(ПоЗначениямПолей.ПоляШапки.ВсеПоля) Тогда
			ТекстЗапроса =
			"ВЫБРАТЬ
			|	ТекущаяТаблица.Поле1 КАК Поле1
			|ИЗ
			|	(ВЫБРАТЬ
			|		ИСТИНА КАК ЗначениеИстина) КАК ЗначениеИстина
			|		ЛЕВОЕ СОЕДИНЕНИЕ ТекущаяТаблицаЭлементовДанных КАК ТекущаяТаблица
			|		ПО (ТекущаяТаблица.Ссылка = &СсылкаНаОбъект)";
			ЗаполнитьПоляВыбораТекущейТаблицы(ТекстЗапроса,
				ПолноеИмя, ПоЗначениямПолей.ПоляШапки.ВсеПоля, ОбъектМетаданных, Отказ);
		Иначе
			ТекстЗапроса = "";
		КонецЕсли;
		
		Для Каждого ТабличнаяЧасть Из ПоЗначениямПолей.ТабличныеЧасти Цикл
			Коллекции = Новый Структура("СтандартныеТабличныеЧасти, ТабличныеЧасти");
			ЗаполнитьЗначенияСвойств(Коллекции, ОбъектМетаданных);
			МетаданныеТаблицы = Неопределено;
			Если ТипЗнч(Коллекции.ТабличныеЧасти) = Тип("КоллекцияОбъектовМетаданных") Тогда
				МетаданныеТаблицы = ОбъектМетаданных.ТабличныеЧасти.Найти(ТабличнаяЧасть.Имя);
			КонецЕсли;
			Если МетаданныеТаблицы = Неопределено
			   И ТипЗнч(Коллекции.СтандартныеТабличныеЧасти) = Тип("ОписанияСтандартныхТабличныхЧастей") Тогда
				Для Каждого СтандартнаяТабличнаяЧасть Из Коллекции.СтандартныеТабличныеЧасти Цикл
					Если СтандартнаяТабличнаяЧасть.Имя = ТабличнаяЧасть.Имя Тогда
						МетаданныеТаблицы = СтандартнаяТабличнаяЧасть;
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			Если МетаданныеТаблицы = Неопределено Тогда
				Отказ = Истина;
				Прервать;
			КонецЕсли;
			
			ТекстЗапросаТабличнойЧасти =
			"ВЫБРАТЬ РАЗЛИЧНЫЕ ПЕРВЫЕ 100
			|	ТекущаяТаблица.Поле1 КАК Поле1
			|ИЗ
			|	ТекущаяТаблицаЭлементовДанных КАК ТекущаяТаблица
			|ГДЕ
			|	ТекущаяТаблица.Ссылка = &СсылкаНаОбъект";
			ЗаполнитьПоляВыбораТекущейТаблицы(ТекстЗапросаТабличнойЧасти,
				ПолноеИмя + "." + ТабличнаяЧасть.Имя, ТабличнаяЧасть.ВсеПоля, МетаданныеТаблицы, Отказ, Истина);
			
			ТекстЗапроса = ТекстЗапроса + ?(ТекстЗапроса = "", "",
				ОбщегоНазначения.РазделительПакетаЗапросов()) + ТекстЗапросаТабличнойЧасти;
		КонецЦикла;
		
	ИначеЕсли ЗначениеЗаполнено(ПоЗначениямПолей.ПоляШапки.ВсеПоля) Тогда
		ТекстЗапроса =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ ПЕРВЫЕ 100
		|	ТекущаяТаблица.Поле1 КАК Поле1
		|ИЗ
		|	ТекущаяТаблицаЭлементовДанных КАК ТекущаяТаблица
		|ГДЕ
		|	&ОтборПоИзмерениям";
		ЗаполнитьПоляВыбораТекущейТаблицы(ТекстЗапроса,
			ПолноеИмя, ПоЗначениямПолей.ПоляШапки.ВсеПоля, ОбъектМетаданных, Отказ);
	Иначе
		ТекстЗапроса = "";
	КонецЕсли;
	
	ПоЗначениямПолей.Вставить("ТекстЗапроса", ТекстЗапроса);
	Свойства.ПоЗначениямПолей = Новый ФиксированнаяСтруктура(ПоЗначениямПолей);
	
КонецПроцедуры

// Для процедуры ЗаполнитьТекстЗапросаСтарыхЗначенийДляПроверкиИзмененияПолейВедущегоСписка.
Процедура ЗаполнитьПоляВыбораТекущейТаблицы(ТекстЗапроса, ПолноеИмя, ОписаниеПолей,
			МетаданныеТаблицы, Отказ, ЭтоТабличнаяЧасть = Ложь)
	
	КоллекцииПолей = Новый Структура("Реквизиты, Измерения, Ресурсы, СтандартныеРеквизиты");
	ЗаполнитьЗначенияСвойств(КоллекцииПолей, МетаданныеТаблицы);
	
	ПоляВыбора = "";
	Для Каждого ОписаниеПоля Из ОписаниеПолей Цикл
		ИмяПоля = ?(ТипЗнч(ОписаниеПолей) = Тип("ФиксированныйМассив"), ОписаниеПоля, ОписаниеПоля.Ключ);
		
		Если Не ПолеСуществует(КоллекцииПолей.Реквизиты, ИмяПоля)
		   И Не ПолеСуществует(КоллекцииПолей.Измерения, ИмяПоля)
		   И Не ПолеСуществует(КоллекцииПолей.Ресурсы, ИмяПоля)
		   И Не ПолеСуществует(КоллекцииПолей.СтандартныеРеквизиты, ИмяПоля)
		   И Не (ЭтоТабличнаяЧасть
		         И (ВРег(ИмяПоля) = ВРег("Ссылка")
		            Или ВРег(ИмяПоля) = ВРег("Ref"))) Тогда
			
			Отказ = Истина;
			Прервать;
		КонецЕсли;
		
		ПоляВыбора = ПоляВыбора + ?(ПоляВыбора = "", "", "," + Символы.ПС)
			+ "ТекущаяТаблица." + ИмяПоля + " КАК " + ИмяПоля;
	КонецЦикла;
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса,
		"ТекущаяТаблица.Поле1 КАК Поле1", ТекстСОтступом(СокрЛ(ПоляВыбора), "	"));
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ТекущаяТаблицаЭлементовДанных", ПолноеИмя);
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ПЕРВЫЕ 100", "ПЕРВЫЕ " + Формат(
		МаксимальноеКоличествоКомбинацийЗначенийВедущихПолейПриВычисленииСоставаИзмененных() * 10, "ЧГ="));
	
КонецПроцедуры

// Для процедуры ЗаполнитьПоляВыбораТекущейТаблицы.
Функция ПолеСуществует(Коллекция, ИмяПоля)
	
	Если ТипЗнч(Коллекция) = Тип("КоллекцияОбъектовМетаданных") Тогда
		Возврат Коллекция.Найти(ИмяПоля) <> Неопределено;
		
	ИначеЕсли ТипЗнч(Коллекция) = Тип("ОписанияСтандартныхРеквизитов") Тогда
		Для Каждого СтандартныйРеквизит Из Коллекция Цикл
			Если СтандартныйРеквизит.Имя = ИмяПоля Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Основная функция, возвращающая параметры, необходимые для проверки прав в момент записи элементов данных.
Функция ПараметрыОграничения(ПолноеИмя, ИдентификаторТранзакции = Неопределено, ДляВнешнихПользователей = Неопределено) Экспорт
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	ДействующиеПараметрыОграниченияДоступа(ИдентификаторТранзакции, Неопределено, Ложь);
	Параметры = КэшПараметровОграничения().ОграниченияСписков.Получить(ПолноеИмя);
	
	Если Параметры = Неопределено Тогда
		ЗаполнитьПараметрыОграничения(ПолноеИмя, ИдентификаторТранзакции, Ложь);
		
		ДействующиеПараметрыОграниченияДоступа(ИдентификаторТранзакции, Неопределено, Ложь);
		Параметры = КэшПараметровОграничения().ОграниченияСписков.Получить(ПолноеИмя);
	КонецЕсли;
	
	Если ДляВнешнихПользователей = Null Тогда
		Возврат Параметры;
	КонецЕсли;
	
	Если ДляВнешнихПользователей = Неопределено Тогда
		ДляВнешнихПользователей = Пользователи.ЭтоСеансВнешнегоПользователя();
	КонецЕсли;
	
	Если ДляВнешнихПользователей Тогда
		Возврат Параметры.ДляВнешнихПользователей;
	КонецЕсли;
	
	Возврат Параметры.ДляПользователей;
	
КонецФункции

// Для функций СвойстваСпискаКакВедущего, ПараметрыОграничения.
Процедура ЗаполнитьПараметрыОграничения(ПолноеИмя, ИдентификаторТранзакции, ДействующиеПараметрыОбновлены,
			ДобавляемыеОграниченияСписков = Неопределено, ОбщийКонтекст = Неопределено, ПовторныйВызов = Ложь)
	
	Если ОбщийКонтекст = Неопределено Тогда
		ОбщийКонтекст = ОбщийКонтекстРасчетаПараметровОграничения();
		ОбщийКонтекст.Вставить("ОписанияОграничений", Новый Соответствие);
	КонецЕсли;
	
	ПараметрыОграниченияСписков = Новый Соответствие;
	ДействующиеПараметры = ДействующиеПараметрыОграниченияДоступа(ИдентификаторТранзакции, ОбщийКонтекст, Ложь);
	ПолноеИмяПриЗацикливании = "";
	
	ДобавитьПараметрыОграниченияСписка(ПолноеИмя, ПараметрыОграниченияСписков,
		ДействующиеПараметры, ДействующиеПараметрыОбновлены, ИдентификаторТранзакции, ОбщийКонтекст);
	
	Если ДействующиеПараметрыОбновлены Тогда
		Если ПовторныйВызов Тогда
			ПолноеИмяПриЗацикливании = ПолноеИмя;
		Иначе
			ЗаполнитьПараметрыОграничения(ПолноеИмя,
				ИдентификаторТранзакции, Ложь, ДобавляемыеОграниченияСписков, ОбщийКонтекст, Истина);
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПолноеИмяПриЗацикливании) Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось обновить параметры ограничения доступа списка ""%1""
			           |из-за нестабильной строки свойств версии параметров для вычисления хеш-суммы.'"),
			ПолноеИмяПриЗацикливании);
	КонецЕсли;
	
	Если ПараметрыОграниченияСписков.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ДобавляемыеОграниченияСписков <> Неопределено Тогда
		ДобавляемыеОграниченияСписков = ПараметрыОграниченияСписков;
		Возврат;
	КонецЕсли;
	
	Кэш = КэшПараметровОграничения();
	
	Для Каждого КлючИЗначение Из ПараметрыОграниченияСписков Цикл
		Кэш.ОграниченияСписков.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ЗаполнитьПараметрыОграничения и функций
// ХранимыеПараметрыОграниченияДоступа, ОшибкиОграниченийДоступа.
//
Функция ОбщийКонтекстРасчетаПараметровОграничения(ВсеВидыДоступаИспользуются = Неопределено, ЗаполнитьСпискиСОграничением = Истина)
	
	ТипыПользователя = Новый Массив;
	ТипыПользователя.Добавить(Тип("СправочникСсылка.Пользователи"));
	ТипыПользователя.Добавить(Тип("СправочникСсылка.ГруппыПользователей"));
	ТипыПользователя.Добавить(Тип("СправочникСсылка.ВнешниеПользователи"));
	ТипыПользователя.Добавить(Тип("СправочникСсылка.ГруппыВнешнихПользователей"));
	
	ОграничениеДоступаВключено = Константы.ОграничиватьДоступНаУровнеЗаписей.Получить();
	Если УправлениеДоступом.ОграничиватьДоступНаУровнеЗаписей() <> ОграничениеДоступаВключено Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	СвойстваВидовДоступа = УправлениеДоступомСлужебныйПовтИсп.СвойстваВидовДоступа();
	
	Если ТипЗнч(ВсеВидыДоступаИспользуются) = Тип("Булево") Тогда
		ОграничениеДоступаВключено  = ВсеВидыДоступаИспользуются;
		ВнешниеПользователиВключены = ВсеВидыДоступаИспользуются;
		Если ВсеВидыДоступаИспользуются Тогда
			ИспользуемыеТипыЗначений = ИспользуемыеТипыЗначений(СвойстваВидовДоступа, Истина);
		Иначе
			ИспользуемыеТипыЗначений = Новый Соответствие;
		КонецЕсли;
	Иначе
		ВнешниеПользователиВключены = Константы.ИспользоватьВнешнихПользователей.Получить();
		ИспользуемыеТипыЗначений    = ИспользуемыеТипыЗначений(СвойстваВидовДоступа, Ложь);
	КонецЕсли;
	
	ВозможныеПрава = УправлениеДоступомСлужебныйПовтИсп.ВозможныеПраваДляНастройкиПравОбъектов();
	
	ОбщийКонтекст = Новый Структура;
	ОбщийКонтекст.Вставить("СвойстваВидовДоступа",         СвойстваВидовДоступа);
	ОбщийКонтекст.Вставить("ТипыПользователя",             ТипыПользователя);
	ОбщийКонтекст.Вставить("ТипыВладельцевНастроекПрав",   ВозможныеПрава.ПоТипамСсылок);
	ОбщийКонтекст.Вставить("ОтдельныеТаблицыНастроекПрав", ВозможныеПрава.ОтдельныеТаблицы);
	ОбщийКонтекст.Вставить("ВнешниеПользователиВключены",  ВнешниеПользователиВключены);
	ОбщийКонтекст.Вставить("ОграничениеДоступаВключено",   ОграничениеДоступаВключено);
	ОбщийКонтекст.Вставить("ИспользуемыеТипыЗначений",     ИспользуемыеТипыЗначений);
	
	Если ЗаполнитьСпискиСОграничением Тогда
		ОбщийКонтекст.Вставить("СпискиСОграничением", УправлениеДоступомСлужебныйПовтИсп.СпискиСОграничением());
	КонецЕсли;
	
	Возврат ОбщийКонтекст;
	
КонецФункции

// Для функций ОбщийКонтекстРасчетаПараметровОграничения и ИспользованиеВидовДоступаИзменено.
Функция ИспользуемыеТипыЗначений(СвойстваВидовДоступа, ВсеВидыДоступаИспользуются = Ложь)
	
	ИспользуемыеТипыЗначений = Новый Соответствие;
	
	Для Каждого СвойстваВидаДоступа Из СвойстваВидовДоступа.Массив Цикл
		Если Не ВсеВидыДоступаИспользуются
		   И Не ВидДоступаИспользуется(СвойстваВидаДоступа.Ссылка) Тогда
			Продолжить;
		КонецЕсли;
		ИспользуемыеТипыЗначений.Вставить(СвойстваВидаДоступа.ТипЗначений, Истина);
		Для Каждого ОписаниеДополнительногоТипа Из СвойстваВидаДоступа.ДополнительныеТипы Цикл
			ИспользуемыеТипыЗначений.Вставить(ОписаниеДополнительногоТипа.ТипЗначений, Истина);
		КонецЦикла;
	КонецЦикла;
	
	Возврат ИспользуемыеТипыЗначений;
	
КонецФункции

// Для процедуры ЗаполнитьПараметрыОграничения.
Процедура ДобавитьПараметрыОграниченияСписка(ПолноеИмя, ПараметрыОграниченияСписков, ДействующиеПараметры,
			ДействующиеПараметрыОбновлены, ИдентификаторТранзакции, ОбщийКонтекст)
	
	Если КэшПараметровОграничения().ОграниченияСписков.Получить(ПолноеИмя) <> Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ВерсияОграничений = ДействующиеПараметры.ВерсииОграниченийСписков.Получить(ПолноеИмя);
	РассчитанныеПараметры = РассчитанныеПараметрыОграничения(ПолноеИмя, ОбщийКонтекст, ДействующиеПараметры);
	
	Если ВерсияОграничений <> РассчитанныеПараметры.Версия Тогда
		ДействующиеПараметры = ДействующиеПараметрыОграниченияДоступа(ИдентификаторТранзакции, ОбщийКонтекст, Истина);
		ДействующиеПараметрыОбновлены = Истина;
		Возврат;
	КонецЕсли;
	
	ПараметрыОграниченияСписков.Вставить(ПолноеИмя,
		ОбщегоНазначения.ФиксированныеДанные(РассчитанныеПараметры));
	
КонецПроцедуры

// Для процедуры ДобавитьПараметрыОграниченияСписка.
Функция РассчитанныеПараметрыОграничения(ПолноеИмя, ОбщийКонтекст, ДействующиеПараметры)
	
	ОписаниеОграничения = ОписаниеОграниченияДанных(ОбщийКонтекст, ПолноеИмя);
	
	// Для пользователей.
	СтруктураОграниченияДляПользователей = РассчитаннаяСтруктураОграничения(ПолноеИмя,
		ОписаниеОграничения.Текст, ОписаниеОграничения.ТекстВМодулеМенеджера, Ложь);
	
	ДополнительныйКонтекст = НовыйДополнительныйКонтекст();
	ЗаполнитьЗначенияСвойств(ДополнительныйКонтекст, ДействующиеПараметры.ДополнительныйКонтекст.ДляПользователей);
	ДобавитьДополнительныйКонтекст(ПолноеИмя, ДополнительныйКонтекст, ОписаниеОграничения, Ложь);
	
	РезультатДляПользователей = ПараметрыОграниченияПоСтруктуреОграничения(ПолноеИмя,
		СтруктураОграниченияДляПользователей, Ложь, ОбщийКонтекст, ДополнительныйКонтекст);
	
	// Для внешних пользователей.
	СтруктураОграниченияДляВнешнихПользователей = РассчитаннаяСтруктураОграничения(ПолноеИмя,
		ОписаниеОграничения.ТекстДляВнешнихПользователей, ОписаниеОграничения.ТекстВМодулеМенеджера, Истина);
	
	ДополнительныйКонтекст = НовыйДополнительныйКонтекст();
	ЗаполнитьЗначенияСвойств(ДополнительныйКонтекст, ДействующиеПараметры.ДополнительныйКонтекст.ДляВнешнихПользователей);
	ДобавитьДополнительныйКонтекст(ПолноеИмя, ДополнительныйКонтекст, ОписаниеОграничения, Истина);
	
	РезультатДляВнешнихПользователей = ПараметрыОграниченияПоСтруктуреОграничения(ПолноеИмя,
		СтруктураОграниченияДляВнешнихПользователей, Истина, ОбщийКонтекст, ДополнительныйКонтекст);
	
	// Заполнение параметров на основе параметров обоих видов пользователей.
	Версия = ОбщаяВерсия(ОбщийКонтекст, ПолноеИмя, РезультатДляПользователей.Версия, РезультатДляВнешнихПользователей.Версия);
	УстановитьСвойстваЗаписиКлючейДоступа(РезультатДляПользователей);
	УстановитьСвойстваЗаписиКлючейДоступа(РезультатДляВнешнихПользователей);
	СЗаписьюДвухКлючей = Не РезультатДляПользователей.БезЗаписиКлючейДоступа И Не РезультатДляВнешнихПользователей.БезЗаписиКлючейДоступа;
	БезЗаписиКлючей    =    РезультатДляПользователей.БезЗаписиКлючейДоступа И    РезультатДляВнешнихПользователей.БезЗаписиКлючейДоступа;
	РезультатДляПользователей.Вставить(       "СЗаписьюКлючейДоступаДляПользователейИВнешнихПользователей", СЗаписьюДвухКлючей);
	РезультатДляВнешнихПользователей.Вставить("СЗаписьюКлючейДоступаДляПользователейИВнешнихПользователей", СЗаписьюДвухКлючей);
	РезультатДляПользователей.Вставить(       "БезЗаписиКлючейДоступаДляПользователейИВнешнихПользователей", БезЗаписиКлючей);
	РезультатДляВнешнихПользователей.Вставить("БезЗаписиКлючейДоступаДляПользователейИВнешнихПользователей", БезЗаписиКлючей);
	
	// Формирование текстов запросов.
	ДобавитьТекстыЗапросовВПараметрыОграничения(РезультатДляПользователей);
	ДобавитьТекстыЗапросовВПараметрыОграничения(РезультатДляВнешнихПользователей);
	
	ВедущиеСписки = Новый Структура;
	ВедущиеСписки.Вставить("ДляПользователей",        РезультатДляПользователей.ВедущиеСписки);
	ВедущиеСписки.Вставить("ДляВнешнихПользователей", РезультатДляВнешнихПользователей.ВедущиеСписки);
	
	Параметры = Новый Структура;
	Параметры.Вставить("Версия",                  Версия);
	Параметры.Вставить("ВедущиеСписки",           ВедущиеСписки);
	Параметры.Вставить("ДляПользователей",        РезультатДляПользователей);
	Параметры.Вставить("ДляВнешнихПользователей", РезультатДляВнешнихПользователей);
	
	Возврат Параметры;
	
КонецФункции

// Для функции ОшибкиОграниченийДоступа.
Функция ОшибкаОграниченияДоступа(ОбщийКонтекст, ПолноеИмя)
	
	ТекстОшибкиДляПользователей = "";
	ТекстОшибкиДляВнешнихПользователей = "";
	
	Попытка
		ОписаниеОграничения = ОписаниеОграниченияДанных(ОбщийКонтекст, ПолноеИмя, Истина);
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Возврат ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
	КонецПопытки;
	Если ТипЗнч(ОписаниеОграничения) = Тип("Строка") Тогда
		Возврат ОписаниеОграничения;
	КонецЕсли;
	
	// Для пользователей.
	СтруктураОграниченияДляПользователей = РассчитаннаяСтруктураОграничения(ПолноеИмя,
		ОписаниеОграничения.Текст, ОписаниеОграничения.ТекстВМодулеМенеджера, Ложь, Истина);
	
	Если СтруктураОграниченияДляПользователей <> Неопределено
	   И СтруктураОграниченияДляПользователей.ОписаниеОшибок.ЕстьОшибки Тогда
		
		ТекстОшибкиДляПользователей = ТекстОшибокДляВызоваИсключения(ПолноеИмя,
			СтруктураОграниченияДляПользователей.ОписаниеОшибок, Ложь, ОписаниеОграничения.ТекстВМодулеМенеджера);
	Иначе
		ДополнительныйКонтекст = НовыйДополнительныйКонтекст();
		ДобавитьДополнительныйКонтекст(ПолноеИмя, ДополнительныйКонтекст, ОписаниеОграничения, Ложь);
		
		ОшибкаПриВызовеИсключения = Новый Структура("Текст", Неопределено);
		ДополнительныйКонтекст.Вставить("ОшибкаПриВызовеИсключения", ОшибкаПриВызовеИсключения);
		Попытка
			РезультатДляПользователей = ПараметрыОграниченияПоСтруктуреОграничения(ПолноеИмя,
				СтруктураОграниченияДляПользователей, Ложь, ОбщийКонтекст, ДополнительныйКонтекст);
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			Если ЗначениеЗаполнено(ОшибкаПриВызовеИсключения.Текст) Тогда
				ТекстОшибкиДляПользователей = ОшибкаПриВызовеИсключения.Текст;
			Иначе
				ТекстОшибкиДляПользователей = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Не удалось сформировать параметры ограничения доступа для пользователей по причине:
					           |%1'"), ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
			КонецЕсли;
		КонецПопытки;
		
		Если Не ЗначениеЗаполнено(ТекстОшибкиДляПользователей) Тогда
			РезультатДляПользователей.Контекст.СпискиСЗаписьюКлючейДляЗависимыхСписковБезКлючей = Новый Соответствие;
			УстановитьСвойстваЗаписиКлючейДоступа(РезультатДляПользователей);
			РезультатДляПользователей.Вставить("БезЗаписиКлючейДоступаДляПользователейИВнешнихПользователей", Ложь);
			РезультатДляПользователей.Контекст.Вставить("ПропуститьПроверкуОпределяемыхТипов");
			Попытка
				ДобавитьТекстыЗапросовВПараметрыОграничения(РезультатДляПользователей);
			Исключение
				ИнформацияОбОшибке = ИнформацияОбОшибке();
				Если ЗначениеЗаполнено(ОшибкаПриВызовеИсключения.Текст) Тогда
					ТекстОшибкиДляПользователей = ОшибкаПриВызовеИсключения.Текст;
				Иначе
					ТекстОшибкиДляПользователей = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Не удалось сформировать тексты запросов на основе параметров ограничения доступа
						           |для пользователей по причине:
						           |%1'"), ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
				КонецЕсли;
			КонецПопытки;
		КонецЕсли;
	КонецЕсли;
	
	// Для внешних пользователей.
	СтруктураОграниченияДляВнешнихПользователей = РассчитаннаяСтруктураОграничения(ПолноеИмя,
		ОписаниеОграничения.ТекстДляВнешнихПользователей, ОписаниеОграничения.ТекстВМодулеМенеджера, Истина, Истина);
	
	Если СтруктураОграниченияДляВнешнихПользователей <> Неопределено
	   И СтруктураОграниченияДляВнешнихПользователей.ОписаниеОшибок.ЕстьОшибки Тогда
		
		ТекстОшибкиДляВнешнихПользователей = ТекстОшибокДляВызоваИсключения(ПолноеИмя,
			СтруктураОграниченияДляВнешнихПользователей.ОписаниеОшибок, Истина, ОписаниеОграничения.ТекстВМодулеМенеджера);
	Иначе
		ДополнительныйКонтекст = НовыйДополнительныйКонтекст();
		ДобавитьДополнительныйКонтекст(ПолноеИмя, ДополнительныйКонтекст, ОписаниеОграничения, Истина);
		
		ОшибкаПриВызовеИсключения = Новый Структура("Текст", Неопределено);
		ДополнительныйКонтекст.Вставить("ОшибкаПриВызовеИсключения", ОшибкаПриВызовеИсключения);
		Попытка
			РезультатДляВнешнихПользователей = ПараметрыОграниченияПоСтруктуреОграничения(ПолноеИмя,
				СтруктураОграниченияДляВнешнихПользователей, Истина, ОбщийКонтекст, ДополнительныйКонтекст);
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			Если ЗначениеЗаполнено(ОшибкаПриВызовеИсключения.Текст) Тогда
				ТекстОшибкиДляВнешнихПользователей = ОшибкаПриВызовеИсключения.Текст;
			Иначе
				ТекстОшибкиДляВнешнихПользователей = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Не удалось сформировать параметры ограничения доступа для внешних пользователей по причине:
					           |%1'"), ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
			КонецЕсли;
		КонецПопытки;
		
		Если Не ЗначениеЗаполнено(ТекстОшибкиДляВнешнихПользователей) Тогда
			РезультатДляВнешнихПользователей.Контекст.СпискиСЗаписьюКлючейДляЗависимыхСписковБезКлючей = Новый Соответствие;
			УстановитьСвойстваЗаписиКлючейДоступа(РезультатДляВнешнихПользователей);
			РезультатДляВнешнихПользователей.Вставить("БезЗаписиКлючейДоступаДляПользователейИВнешнихПользователей", Ложь);
			Попытка
				ДобавитьТекстыЗапросовВПараметрыОграничения(РезультатДляВнешнихПользователей);
			Исключение
				ИнформацияОбОшибке = ИнформацияОбОшибке();
				Если ЗначениеЗаполнено(ОшибкаПриВызовеИсключения.Текст) Тогда
					ТекстОшибкиДляВнешнихПользователей = ОшибкаПриВызовеИсключения.Текст;
				Иначе
					ТекстОшибкиДляВнешнихПользователей = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Не удалось сформировать тексты запросов на основе параметров ограничения доступа
						           |для внешних пользователей по причине:
						           |%1'"), ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
				КонецЕсли;
			КонецПопытки;
		КонецЕсли;
	КонецЕсли;
	
	Возврат СокрЛП(ТекстОшибкиДляПользователей
		+ Символы.ПС + Символы.ПС + ТекстОшибкиДляВнешнихПользователей);
	
КонецФункции

// Для функции РезультатПроверкиОграниченияДоступа.
Функция РезультатПроверкиОграниченияДоступаОбъекта(ПолноеИмя, ДополнительныеПараметры)
	
	Параметры = Новый Структура;
	Параметры.Вставить("Текст", Неопределено);
	Параметры.Вставить("ТекстДляВнешнихПользователей", Неопределено);
	Параметры.Вставить("УчитыватьЗависимости", Ложь);
	Параметры.Вставить("ВсеВидыДоступаИспользуются", Истина);
	
	Если ТипЗнч(ДополнительныеПараметры) = Тип("Структура") Тогда
		ЗаполнитьЗначенияСвойств(Параметры, ДополнительныеПараметры);
	КонецЕсли;
	
	ДляПользователей        = СтруктураРезультатаПроверкиОграниченияДляВидаПользователей();
	ДляВнешнихПользователей = СтруктураРезультатаПроверкиОграниченияДляВидаПользователей();
	
	Результат = Новый Структура;
	Результат.Вставить("ОшибкаОписанияОграничения", "");
	Результат.Вставить("ТекстВМодулеМенеджера",     Неопределено);
	Результат.Вставить("ДляПользователей",          ДляПользователей);
	Результат.Вставить("ДляВнешнихПользователей",   ДляВнешнихПользователей);
	Результат.Вставить("НастройкиВнедрения",        Новый Структура);
	
	ОбщийКонтекст = Неопределено;
	Попытка
		ОбщийКонтекст = ОбщийКонтекстРасчетаПараметровОграничения(Параметры.ВсеВидыДоступаИспользуются, Ложь);
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Результат.ОшибкаОписанияОграничения = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
	КонецПопытки;
	
	Если ОбщийКонтекст = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;
	
	УчетЗависимостейДоступен = Истина;
	СпискиСОграничением = Неопределено;
	Попытка
		СпискиСОграничением = УправлениеДоступомСлужебныйПовтИсп.СпискиСОграничением();
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Результат.ОшибкаОписанияОграничения = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		УчетЗависимостейДоступен = Ложь;
	КонецПопытки;
	
	Если СпискиСОграничением <> Неопределено Тогда
		СпискиСОграничением = Новый Соответствие(СпискиСОграничением);
	Иначе
		СпискиСОграничением = Новый Соответствие;
		УчетЗависимостейДоступен = Ложь;
	КонецЕсли;
	ОбщийКонтекст.Вставить("СпискиСОграничением", СпискиСОграничением);
	
	ОписаниеОграничения = Неопределено;
	Попытка
		ОписаниеОграничения = ОписаниеОграниченияДанных(ОбщийКонтекст, ПолноеИмя, Истина);
	Исключение
		Результат.ОшибкаОписанияОграничения = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		УчетЗависимостейДоступен = Ложь;
	КонецПопытки;
	Если ТипЗнч(ОписаниеОграничения) = Тип("Строка") Тогда
		Результат.ОшибкаОписанияОграничения = ОписаниеОграничения;
		ОписаниеОграничения = Неопределено;
	КонецЕсли;
	
	Если ОписаниеОграничения <> Неопределено Тогда
		Результат.ТекстВМодулеМенеджера                    = ОписаниеОграничения.ТекстВМодулеМенеджера;
		ДляПользователей.ОграничениеВМодуле                = ОписаниеОграничения.Текст;
		ДляПользователей.ПоВладельцуБезЗаписиКлючейДоступа = ОписаниеОграничения.ПоВладельцуБезЗаписиКлючейДоступа;
		ДляВнешнихПользователей.ОграничениеВМодуле         = ОписаниеОграничения.ТекстДляВнешнихПользователей;
		ДляВнешнихПользователей.ПоВладельцуБезЗаписиКлючейДоступа =
			ОписаниеОграничения.ПоВладельцуБезЗаписиКлючейДоступаДляВнешнихПользователей;
		
		Если Параметры.Текст = Неопределено Тогда
			ДляПользователей.ПроверяемоеОграничение = ДляПользователей.ОграничениеВМодуле;
		Иначе
			ДляПользователей.ПроверяемоеОграничение = Параметры.Текст;
			ОписаниеОграничения.Текст               = Параметры.Текст;
		КонецЕсли;
		
		Если Параметры.ТекстДляВнешнихПользователей = Неопределено Тогда
			ДляВнешнихПользователей.ПроверяемоеОграничение = ДляВнешнихПользователей.ОграничениеВМодуле;
		Иначе
			ДляВнешнихПользователей.ПроверяемоеОграничение   = Параметры.ТекстДляВнешнихПользователей;
			ОписаниеОграничения.ТекстДляВнешнихПользователей = Параметры.ТекстДляВнешнихПользователей;
		КонецЕсли;
	КонецЕсли;
	
	Если СпискиСОграничением.Получить(ПолноеИмя) = Неопределено Тогда
		СпискиСОграничением.Вставить(ПолноеИмя, Истина);
		Результат.ТекстВМодулеМенеджера = Неопределено;
	КонецЕсли;
	
	Контекст = Новый Структура;
	Контекст.Вставить("ПолноеИмя",                ПолноеИмя);
	Контекст.Вставить("ОбщийРезультат",           Результат);
	Контекст.Вставить("ОбщийКонтекст",            ОбщийКонтекст);
	Контекст.Вставить("ОписаниеОграничения",      ОписаниеОграничения);
	Контекст.Вставить("УчитыватьЗависимости",     Параметры.УчитыватьЗависимости);
	Контекст.Вставить("УчетЗависимостейДоступен", УчетЗависимостейДоступен);
	Контекст.Вставить("ВерсииОграниченийСписков", Новый Соответствие);
	Контекст.Вставить("ВедущиеСписки",            Новый Соответствие);
	Контекст.Вставить("ДополнительныйКонтекст",   Новый Структура("ДляПользователей, ДляВнешнихПользователей"));
	
	ПроверитьОграничениеДляВидаПользователей(Контекст, ДляПользователей, Ложь,
		Контекст.ДополнительныйКонтекст.ДляПользователей);
	
	ПроверитьОграничениеДляВидаПользователей(Контекст, ДляВнешнихПользователей, Истина,
		Контекст.ДополнительныйКонтекст.ДляВнешнихПользователей);
	
	Если Не Контекст.УчетЗависимостейДоступен Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если Параметры.УчитыватьЗависимости Тогда
		ОбщийКонтекст.Вставить("СпециальноеПолноеИмя", ПолноеИмя);
		ОбщийКонтекст.Вставить("СпециальноеОписаниеОграничения", ОписаниеОграничения);
		ОбщийКонтекст.Вставить("СпискиСОграничением", Новый ФиксированноеСоответствие(СпискиСОграничением));
		НовыеХранимыеПараметры = ХранимыеПараметрыОграниченияДоступа(ОбщийКонтекст);
		ДействующиеПараметры = Новый Структура(НовыеХранимыеПараметры.ДляЗаписиОбъектовИПроверкиПрав.Получить());
		Если ДействующиеПараметры.ВерсииОграниченийСписков.Получить(ПолноеИмя) = Неопределено Тогда
			Контекст.ВерсииОграниченийСписков.Вставить(ПолноеИмя, Истина);
		Иначе
			Контекст.ВерсииОграниченийСписков.Вставить(ПолноеИмя,
				ДействующиеПараметры.ВерсииОграниченийСписков.Получить(ПолноеИмя));
		КонецЕсли;
	Иначе
		Контекст.ВерсииОграниченийСписков.Вставить(ПолноеИмя, Истина);
		ДействующиеПараметры = Новый Структура;
		ДействующиеПараметры.Вставить("ДополнительныйКонтекст", Контекст.ДополнительныйКонтекст);
	КонецЕсли;
	ДействующиеПараметры.Вставить("ВерсииОграниченийСписков", Контекст.ВерсииОграниченийСписков);
	ДействующиеПараметры.Вставить("ВедущиеСписки",            Контекст.ВедущиеСписки);
	
	Настройки = НастройкиВнедрения(ДействующиеПараметры);
	
	ТипыТаблицПоИменам = УправлениеДоступомСлужебныйПовтИсп.СинтаксисЯзыка().ТипыТаблиц.ПоИменам;
	УстановитьНастройкиВнедрения(Результат.НастройкиВнедрения, Настройки, ТипыТаблицПоИменам);
	
	Результат.ДляПользователей.ОграничениеВРолях = Настройки.ОграниченияВРолях.ДляПользователей.Получить(
		ПолноеИмяXML(ПолноеИмя, ТипыТаблицПоИменам));
	
	Результат.ДляВнешнихПользователей.ОграничениеВРолях = Настройки.ОграниченияВРолях.ДляВнешнихПользователей.Получить(
		ПолноеИмяXML(ПолноеИмя, ТипыТаблицПоИменам));
	
	Возврат Результат;
	
КонецФункции

// Для функции РезультатПроверкиОграниченияДоступаОбъекта.
Процедура УстановитьНастройкиВнедрения(НастройкиВнедрения, Данные, ТипыТаблицПоИменам)
	
	ДобавитьТипыТребуемыеВОпределяемомТипе(НастройкиВнедрения, ТипыТаблицПоИменам, Истина,
		Данные.ЗначенияДоступа, "ЗначениеДоступа");
	
	ДобавитьТипыТребуемыеВОпределяемомТипе(НастройкиВнедрения, ТипыТаблицПоИменам, Истина,
		Данные.ВладельцыЗначенийКлючейДоступа.Ссылки, "ВладелецЗначенийКлючейДоступа");
	
	ДобавитьТипыТребуемыеВОпределяемомТипе(НастройкиВнедрения, ТипыТаблицПоИменам, Ложь,
		Данные.ВладельцыЗначенийКлючейДоступа.Объекты, "ВладелецЗначенийКлючейДоступаОбъект");
	
	ДобавитьТипыТребуемыеВОпределяемомТипе(НастройкиВнедрения, ТипыТаблицПоИменам, Ложь,
		Данные.ВладельцыЗначенийКлючейДоступа.Документы, "ВладелецЗначенийКлючейДоступаДокумент");
	
	ДобавитьТипыТребуемыеВОпределяемомТипе(НастройкиВнедрения, ТипыТаблицПоИменам, Ложь,
		Данные.ВладельцыЗначенийКлючейДоступа.НаборыЗаписей, "ВладелецЗначенийКлючейДоступаНаборЗаписей");
	
	ДобавитьТипыТребуемыеВОпределяемомТипе(НастройкиВнедрения, ТипыТаблицПоИменам, Ложь,
		Данные.ВладельцыЗначенийКлючейДоступа.НаборыЗаписейРегистраРасчета,
			"ВладелецЗначенийКлючейДоступаНаборЗаписейРегистраРасчета");
	
	ДобавитьТипыТребуемыеВОпределяемомТипе(НастройкиВнедрения, ТипыТаблицПоИменам, Ложь,
		Данные.ВладельцыЗначенийКлючейДоступа.НаборыЗаписейРегистраРасчета,
			"ВладелецЗначенийКлючейДоступаНаборЗаписейРегистраРасчета");
	
	НастройкиВнедрения.Вставить("ПолеРегистраКлючейДоступаКРегистрам", "");
	НастройкиВнедрения.Вставить("ТипыИзмеренийОтдельногоРегистраКлючей", Неопределено);
	Для Каждого КлючИЗначение Из Данные.ТипыИзмеренийРегистровКлючей Цикл
		Если СтрНайти(КлючИЗначение.Ключ, ".") > 0 Тогда
			Продолжить;
		КонецЕсли;
		ИмяРегистраКлючей = КлючИЗначение.Ключ;
		
		Если ИмяРегистраКлючей = "КлючиДоступаКРегистрам" Тогда
			ДобавитьТипыТребуемыеВОпределяемомТипе(НастройкиВнедрения, ТипыТаблицПоИменам, Истина,
				КлючИЗначение.Значение.ИменаТипов, "ПолеРегистраКлючейДоступаКРегистрам");
		Иначе
			ИзмеренияРегистра = Метаданные.РегистрыСведений[ИмяРегистраКлючей].Измерения;
			СписокТипов = "";
			НомерПоля = 1;
			Для Каждого ОписаниеПолейРегистра Из КлючИЗначение.Значение.ПоляРегистров Цикл
				Прервать;
			КонецЦикла;
			Для Каждого ОписаниеПоля Из ОписаниеПолейРегистра.Значение Цикл
				ПолеРегистра = ИзмеренияРегистра.Найти("Поле" + НомерПоля);
				ОписаниеТипов = ?(ПолеРегистра = Неопределено, Новый ОписаниеТипов, ПолеРегистра.Тип);
				СписокТипов = СписокТипов + ?(СписокТипов = "", "", Символы.ПС)
					+ НСтр("ru = '- для измерения'") + " " + "Поле" + НомерПоля + ":" + Символы.ПС
					+ "	" + ТекстСОтступом(СписокТиповИзМассива(ОписаниеПоля.Тип.Типы(),
						Истина, ТипыТаблицПоИменам, ОписаниеТипов), "	");
				НомерПоля = НомерПоля + 1;
			КонецЦикла;
			НастройкиВнедрения.Вставить("ТипыИзмеренийОтдельногоРегистраКлючей",
				Новый Структура("ИмяРегистраСведений, ТипыИзмерений", ИмяРегистраКлючей, СписокТипов));
		КонецЕсли;
	КонецЦикла;
	
	НастройкиВнедрения.Вставить("ПредопределенныйИдентификатор", Неопределено);
	Для Каждого КлючИЗначение Из Данные.ПредопределенныеИдентификаторы Цикл
		ЧастиИмени = СтрРазделить(КлючИЗначение.Ключ, ".", Ложь);
		УжеДобавлен = Метаданные.Справочники[ЧастиИмени[0]].ПолучитьИменаПредопределенных().Найти(ЧастиИмени[1]) <> Неопределено;
		НастройкиВнедрения.Вставить("ПредопределенныйИдентификатор",
			Новый Структура("ИмяСправочника, ИмяПредопределенного", ЧастиИмени[0],
				 "- " + ЧастиИмени[1] + ?(УжеДобавлен, " (" + НСтр("ru = 'уже добавлен'") + ")", "")));
		Прервать;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры УстановитьНастройкиВнедрения.
Процедура ДобавитьТипыТребуемыеВОпределяемомТипе(НастройкиВнедрения, ТипыТаблицПоИменам, ТипыСсылок, ИменаТипов, ИмяОпределяемогоТипа)
	
	НастройкиВнедрения.Вставить(ИмяОпределяемогоТипа, "");
	Если ИменаТипов.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	НастройкиВнедрения[ИмяОпределяемогоТипа] = СписокТиповИзМассива(ИменаТипов,
		ТипыСсылок, ТипыТаблицПоИменам, Метаданные.ОпределяемыеТипы[ИмяОпределяемогоТипа].Тип);
	
КонецПроцедуры

// Для процедур УстановитьНастройкиВнедрения, ДобавитьТипыТребуемыеВОпределяемомТипе.
Функция СписокТиповИзМассива(ИменаТипов, ТипыСсылок, ТипыТаблицПоИменам, ОписаниеТипов)
	
	СписокТипов = "";
	Для Каждого ИмяТипа Из ИменаТипов Цикл
		Если ТипЗнч(ИмяТипа) = Тип("Тип") Тогда
			Тип = ИмяТипа;
		Иначе
			Тип = Тип(ИмяТипа);
		КонецЕсли;
		ОбъектМетаданных = Метаданные.НайтиПоТипу(Тип);
		ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
		
		СписокТипов = СписокТипов + ?(СписокТипов = "", "", Символы.ПС)
			+ "- " + ?(ТипыСсылок, ИмяТипаСсылки(ПолноеИмя, ТипыТаблицПоИменам),
				ИмяТипаОбъектаИлиНабораЗаписей(ПолноеИмя, ТипыТаблицПоИменам));
		
		Если ОписаниеТипов.СодержитТип(Тип) Тогда
			СписокТипов = СписокТипов + " (" + НСтр("ru = 'уже добавлен'") + ")";
		КонецЕсли;
	КонецЦикла;
	
	Возврат СписокТипов;
	
КонецФункции

// Для функции РезультатПроверкиОграниченияДоступаОбъекта.
Функция СтруктураРезультатаПроверкиОграниченияДляВидаПользователей()
	
	Свойства = Новый Структура;
	Свойства.Вставить("ПроверяемоеОграничение");
	Свойства.Вставить("ОписаниеОшибок");
	Свойства.Вставить("ОшибкаФормированияПараметровОграничения");
	Свойства.Вставить("ОшибкаФормированияТекстовЗапросов");
	Свойства.Вставить("ОграничениеПоВладельцуВозможно");
	Свойства.Вставить("ОграничениеВРолях");
	Свойства.Вставить("ОграничениеВМодуле");
	Свойства.Вставить("ПоВладельцуБезЗаписиКлючейДоступа");
	
	Возврат Свойства;
	
КонецФункции

// Для функции РезультатПроверкиОграниченияДоступаОбъекта.
Процедура ПроверитьОграничениеДляВидаПользователей(Контекст, Результат, ДляВнешнихПользователей, ДополнительныйКонтекст)
	
	ТекстОграничения = ?(ДляВнешнихПользователей, Контекст.ОбщийРезультат.ДляВнешнихПользователей,
		Контекст.ОбщийРезультат.ДляПользователей).ПроверяемоеОграничение;
	
	СтруктураОграничения = РассчитаннаяСтруктураОграничения(Контекст.ПолноеИмя,
		ТекстОграничения, Контекст.ОбщийРезультат.ТекстВМодулеМенеджера, ДляВнешнихПользователей, Истина);
	
	Если СтруктураОграничения <> Неопределено
	   И СтруктураОграничения.ОписаниеОшибок.ЕстьОшибки Тогда
		
		Результат.ОписаниеОшибок = СтруктураОграничения.ОписаниеОшибок;
		Контекст.УчетЗависимостейДоступен = Ложь;
		Возврат;
	КонецЕсли;
	
	ДополнительныйКонтекст = НовыйДополнительныйКонтекст();
	ДобавитьДополнительныйКонтекст(Контекст.ПолноеИмя,
		ДополнительныйКонтекст, Контекст.ОписаниеОграничения, ДляВнешнихПользователей);
	
	ОшибкаПриВызовеИсключения = Новый Структура("Текст", Неопределено);
	ДополнительныйКонтекст.Вставить("ОшибкаПриВызовеИсключения", ОшибкаПриВызовеИсключения);
	
	Попытка
		ПараметрыОграничения = ПараметрыОграниченияПоСтруктуреОграничения(Контекст.ПолноеИмя,
			СтруктураОграничения, ДляВнешнихПользователей, Контекст.ОбщийКонтекст, ДополнительныйКонтекст);
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ПараметрыОграничения = Неопределено;
		Если ЗначениеЗаполнено(ОшибкаПриВызовеИсключения.Текст) Тогда
			Результат.ОшибкаФормированияПараметровОграничения = ОшибкаПриВызовеИсключения.Текст;
		Иначе
			Результат.ОшибкаФормированияПараметровОграничения =
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Не удалось сформировать параметры ограничения доступа по причине:
					           |%1'"), ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
		КонецЕсли;
		Контекст.УчетЗависимостейДоступен = Ложь;
	КонецПопытки;
	
	Если ПараметрыОграничения <> Неопределено Тогда
		Результат.ОграничениеПоВладельцуВозможно = ПараметрыОграничения.ПолеВладельца <> Неопределено;
		ПараметрыОграничения.Контекст.СпискиСЗаписьюКлючейДляЗависимыхСписковБезКлючей = Новый Соответствие;
		УстановитьСвойстваЗаписиКлючейДоступа(ПараметрыОграничения);
		ПараметрыОграничения.Вставить("БезЗаписиКлючейДоступаДляПользователейИВнешнихПользователей", Ложь);
		Для Каждого КлючИЗначение Из ПараметрыОграничения.ВедущиеСписки.ПоЗначениямПолей Цикл
			Контекст.ВедущиеСписки.Вставить(КлючИЗначение.Ключ, Неопределено);
		КонецЦикла;
		Для Каждого КлючИЗначение Из ПараметрыОграничения.ВедущиеСписки.ПоКлючамДоступа Цикл
			Контекст.ВерсииОграниченийСписков.Вставить(КлючИЗначение.Ключ, Неопределено);
		КонецЦикла;
		ПараметрыОграничения.Контекст.Вставить("ПропуститьПроверкуОпределяемыхТипов");
		Попытка
			ДобавитьТекстыЗапросовВПараметрыОграничения(ПараметрыОграничения);
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			Если ЗначениеЗаполнено(ОшибкаПриВызовеИсключения.Текст) Тогда
				Результат.ОшибкаФормированияТекстовЗапросов = ОшибкаПриВызовеИсключения.Текст;
			Иначе
				Результат.ОшибкаФормированияТекстовЗапросов =
					СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Не удалось сформировать тексты запросов на основе параметров ограничения доступа по причине:
						           |%1'"), ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
			КонецЕсли;
			Контекст.УчетЗависимостейДоступен = Ложь;
		КонецПопытки;
	КонецЕсли;
	
	Если Контекст.УчитыватьЗависимости Тогда
		Возврат;
	КонецЕсли;
	
	СокращенныеСвойства = Новый Структура;
	СокращенныеСвойства.Вставить("ДоступЗапрещен", Ложь);
	СокращенныеСвойства.Вставить("ПолеВладельца", Неопределено);
	СокращенныеСвойства.Вставить("ОпорныеПоля", Неопределено);
	СокращенныеСвойства.Вставить("ИмяОтдельногоРегистраКлючей", Неопределено);
	ДополнительныйКонтекст.СвойстваОграниченияСписков.Вставить(Контекст.ПолноеИмя, СокращенныеСвойства);
	
	Если Не Контекст.УчетЗависимостейДоступен Тогда
		Возврат;
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(СокращенныеСвойства, ПараметрыОграничения);
	
КонецПроцедуры

// Для функций ХранимыеПараметрыОграниченияДоступа, РассчитанныеПараметрыОграничения.
Функция ОбщаяВерсия(ОбщийКонтекст, ПолноеИмя, ВерсияДляПользователей, ВерсияДляВнешнихПользователей)
	
	Если ОбщийКонтекст.СпискиСОграничением.Получить(ПолноеИмя) = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Строка(ВерсияДляПользователей) + Символы.ПС + Строка(ВерсияДляВнешнихПользователей);
	
КонецФункции

// Для функции РассчитанныеПараметрыОграничения.
Процедура УстановитьСвойстваЗаписиКлючейДоступа(Результат)
	
	БезЗаписиКлючей = Ложь;
	СЗаписьюВсегдаРазрешенногоКлюча = Ложь;
	
	Если Результат.ОграничениеОтключено
	 Или Результат.ДоступЗапрещен
	 Или Результат.ИспользуетсяОграничениеПоВладельцу Тогда
		
		Если Результат.ИспользуетсяОграничениеПоВладельцу
		 Или Результат.Контекст.СпискиСЗаписьюКлючейДляЗависимыхСписковБезКлючей.Получить(
		 		Результат.Список) = Неопределено Тогда
			
			БезЗаписиКлючей = Истина;
		Иначе
			СЗаписьюВсегдаРазрешенногоКлюча = Истина;
		КонецЕсли;
	КонецЕсли;
	
	Результат.Вставить("БезЗаписиКлючейДоступа", БезЗаписиКлючей);
	Результат.Вставить("СЗаписьюВсегдаРазрешенногоКлючаДоступа", СЗаписьюВсегдаРазрешенногоКлюча);
	
КонецПроцедуры

// Для функций РассчитанныеПараметрыОграничения, ХранимыеПараметрыОграниченияДоступа.
Функция ОписаниеОграниченияДанных(ОбщийКонтекст, ПолноеИмя, БезВызоваИсключения = Ложь)
	
	Ограничение = Новый Структура;
	Ограничение.Вставить("Текст", "");
	Ограничение.Вставить("ТекстДляВнешнихПользователей", "");
	Ограничение.Вставить("ПоВладельцуБезЗаписиКлючейДоступа", Неопределено);
	Ограничение.Вставить("ПоВладельцуБезЗаписиКлючейДоступаДляВнешнихПользователей", Неопределено);
	Ограничение.Вставить("ТекстВМодулеМенеджера", Ложь);
	
	ТекстВМодулеМенеджера = ОбщийКонтекст.СпискиСОграничением.Получить(ПолноеИмя);
	Если ТекстВМодулеМенеджера = Неопределено Тогда
		Возврат Ограничение;
	КонецЕсли;
	
	Ограничение.ТекстВМодулеМенеджера = ТекстВМодулеМенеджера;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
		МодульРаботаСФайламиСлужебный = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебный");
		ЭтоСправочникФайлов = МодульРаботаСФайламиСлужебный.ЭтоСправочникФайловИлиВерсийФайлов(ПолноеИмя);
	Иначе
		ЭтоСправочникФайлов = Ложь;
	КонецЕсли;
	
	Если ЭтоЖурналДокументов(ПолноеИмя) Или ЭтоСправочникФайлов Тогда
		// Для журналов документов ограничение должно быть
		// по документу-владельцу без записи ключей доступа, если не требуется другое.
		// Аналогично (по умолчанию) для справочников файлов и версий файлов.
		Ограничение.ПоВладельцуБезЗаписиКлючейДоступа = Истина;
		Ограничение.ПоВладельцуБезЗаписиКлючейДоступаДляВнешнихПользователей = Истина;
	КонецЕсли;
	
	Если ТекстВМодулеМенеджера Тогда
		Менеджер = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмя);
		
		Попытка
			Менеджер.ПриЗаполненииОграниченияДоступа(Ограничение);
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = '""%1"" указан, как список с ограничением доступа в процедуре
				           |ПриЗаполненииСписковСОграничениемДоступа общего модуля УправлениеДоступомПереопределяемый.
				           |
				           |Некорректно указано ограничение доступа этого списка в модуле менеджера
				           |в процедуре ПриЗаполненииОграниченияДоступа по причине:
				           |
				           |%2'"),
				ПолноеИмя,
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
			
			Если БезВызоваИсключения Тогда
				Возврат ТекстОшибки;
			КонецЕсли;
			ВызватьИсключение ТекстОшибки;
		КонецПопытки;
	Иначе
		ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ПолноеИмя);
		Попытка
			УправлениеДоступомПереопределяемый.ПриЗаполненииОграниченияДоступа(ОбъектМетаданных, Ограничение);
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = '""%1"" указан, как список с ограничением доступа в процедуре
				           |ПриЗаполненииСписковСОграничениемДоступа общего модуля УправлениеДоступомПереопределяемый.
				           |
				           |Некорректно указано ограничение доступа этого списка в общем модуле УправлениеДоступомПереопределяемый
				           |в процедуре ПриЗаполненииОграниченияДоступа по причине:
				           |
				           |%2'"),
				ПолноеИмя,
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
			
			Если БезВызоваИсключения Тогда
				Возврат ТекстОшибки;
			КонецЕсли;
			ВызватьИсключение ТекстОшибки;
		КонецПопытки;
	КонецЕсли;
	
	Если ЭтоЖурналДокументов(ПолноеИмя)
	   И (    Ограничение.ПоВладельцуБезЗаписиКлючейДоступа <> Истина
		  Или Ограничение.ПоВладельцуБезЗаписиКлючейДоступаДляВнешнихПользователей <> Истина) Тогда
		
		Если ТекстВМодулеМенеджера Тогда
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = '""%1"" указан, как список с ограничением доступа в процедуре
				           |ПриЗаполненииСписковСОграничениемДоступа общего модуля УправлениеДоступомПереопределяемый.
				           |
				           |Некорректно указано ограничение доступа этого списка в модуле менеджера
				           |в процедуре ПриЗаполненииОграниченияДоступа по причине:
				           |
				           |Для журналов документов не поддерживается ограничение, как для регистров,
				           |то есть, кроме варианта ограничения по владельцу без записи ключей доступа:
				           |
				           |РазрешитьЧтениеИзменение
				           |ГДЕ
				           |	ЧтениеОбъектаРазрешено(Ссылка)'"),
				ПолноеИмя);
		Иначе
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = '""%1"" указан, как список с ограничением доступа в процедуре
				           |ПриЗаполненииСписковСОграничениемДоступа общего модуля УправлениеДоступомПереопределяемый.
				           |
				           |Некорректно указано ограничение доступа этого списка в общем модуле УправлениеДоступомПереопределяемый
				           |в процедуре ПриЗаполненииОграниченияДоступа по причине:
				           |
				           |Для журналов документов не поддерживается ограничение, как для регистров,
				           |то есть, кроме варианта ограничения по владельцу без записи ключей доступа:
				           |
				           |РазрешитьЧтениеИзменение
				           |ГДЕ
				           |	ЧтениеОбъектаРазрешено(Ссылка)'"),
				ПолноеИмя);
		КонецЕсли;
		Если БезВызоваИсключения Тогда
			Возврат ТекстОшибки;
		КонецЕсли;
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Возврат Ограничение;
	
КонецФункции

// Для функции ОписаниеОграниченияДанных.
Функция ЭтоЖурналДокументов(ПолноеИмя)
	
	Возврат СтрНачинаетсяС(ВРег(ПолноеИмя), ВРег("ЖурналДокументов."))
	    Или СтрНачинаетсяС(ВРег(ПолноеИмя), ВРег("DocumentJournal."));
	
КонецФункции

// Для функций РассчитанныеПараметрыОграничения и ПараметрыОграниченияДляВидаПользователей.
//
// Возвращаемое значение:
//  см. УправлениеДоступом.СтруктураОграничения
//
Функция РассчитаннаяСтруктураОграничения(ПолноеИмя, ТекстОграничения, ТекстВМодулеМенеджера, ДляВнешнихПользователей, БезИсключения = Ложь)
	
	Если Не ЗначениеЗаполнено(ТекстОграничения) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	РазобранноеОграничение = РазобранноеОграничение(ПолноеИмя, ТекстОграничения);
	
	ПроверитьТаблицыПоляИТипыПолей(РазобранноеОграничение);
	
	СтруктураОграничения = СтруктураОграничения(РазобранноеОграничение);
	
	Если БезИсключения Или Не СтруктураОграничения.ОписаниеОшибок.ЕстьОшибки Тогда
		Возврат СтруктураОграничения;
	КонецЕсли;
	
	ТекстОшибок = ТекстОшибокДляВызоваИсключения(ПолноеИмя,
		СтруктураОграничения.ОписаниеОшибок, ДляВнешнихПользователей, ТекстВМодулеМенеджера);
	
	ВызватьИсключение ТекстОшибок;
	
КонецФункции

// Для функций СвойстваСпискаКакВедущего, ПараметрыОграничения и процедур УстановкаПараметровСеанса,
// ЗаполнитьПараметрыОграничения, ДобавитьПараметрыОграниченияСписка.
//
Функция ДействующиеПараметрыОграниченияДоступа(ИдентификаторТранзакции, ОбщийКонтекст,
			Обновить, УстановкаПараметровСеансаДляШаблонов = Ложь,
			УстановкаПараметровДляОтчетаПраваДоступа = Ложь, ЕстьИзменения = Ложь) Экспорт
	
	Если Обновить Тогда
		ВерсияПараметров = НоваяВерсияПараметровОграниченияДоступа(ОбщийКонтекст, ЕстьИзменения);
		УстановитьВерсиюПараметров(ВерсияПараметров, ИдентификаторТранзакции, ОбщийКонтекст);
		Возврат ПараметрыСеанса.ПараметрыОграниченияДоступа.Параметры;
	КонецЕсли;
	
	ТекущиеПараметры = ПараметрыСеанса.ПараметрыОграниченияДоступа;
	
	Если Не ЗначениеЗаполнено(ТекущиеПараметры) Или ТекущиеПараметры.Параметры = Неопределено Тогда
		ТекущиеПараметры = Новый Структура("Версия, ХешСумма", "", "");
		ИдентификаторыТранзакции = Новый Соответствие;
	Иначе
		ИдентификаторыТранзакции = КэшПараметровОграничения().ИдентификаторыТранзакции;
	КонецЕсли;
	
	Если ТранзакцияАктивна() Тогда
		Если ИдентификаторыТранзакции.Получить(ИдентификаторТранзакции) <> Неопределено Тогда
			Возврат ТекущиеПараметры.Параметры;
		КонецЕсли;
		
		ОписаниеВерсии = Новый Структура("Версия, ХешСумма", "", "");
		Если ЗначениеЗаполнено(ТекущиеПараметры.Версия) Тогда
			ОписаниеВерсии.Версия   = ТекущиеПараметры.Версия;
			ОписаниеВерсии.ХешСумма = ТекущиеПараметры.ХешСумма;
		КонецЕсли;
		
		Пока Истина Цикл
			Если Не ЗначениеЗаполнено(ОписаниеВерсии.Версия) Тогда
				ОписаниеВерсии = ОписаниеПоследнейВерсии();
			КонецЕсли;
			Если Не ЗначениеЗаполнено(ОписаниеВерсии.Версия) Тогда
				Прервать;
			КонецЕсли;
			БлокировкаДанных = Новый БлокировкаДанных;
			ЭлементБлокировки = БлокировкаДанных.Добавить("РегистрСведений.ПараметрыОграниченияДоступа");
			ЭлементБлокировки.УстановитьЗначение("Версия", ОписаниеВерсии.Версия);
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
			БлокировкаДанных.Заблокировать();
			НовоеОписаниеВерсии = ОписаниеПоследнейВерсии();
			Если Не ЗначениеЗаполнено(НовоеОписаниеВерсии.Версия) Тогда
				ОписаниеВерсии = НовоеОписаниеВерсии;
				Прервать;
			КонецЕсли;
			Если ОписаниеВерсии.Версия   = НовоеОписаниеВерсии.Версия
			   И ОписаниеВерсии.ХешСумма = НовоеОписаниеВерсии.ХешСумма Тогда
				Прервать;
			КонецЕсли;
			ОписаниеВерсии = НовоеОписаниеВерсии;
		КонецЦикла;
	Иначе
		ОписаниеВерсии = ОписаниеПоследнейВерсии();
	КонецЕсли;
	
	Если Не УстановкаПараметровСеансаДляШаблонов
	   И Не УстановкаПараметровДляОтчетаПраваДоступа
	   И ТекущиеПараметры.Версия   = ОписаниеВерсии.Версия
	   И ТекущиеПараметры.ХешСумма = ОписаниеВерсии.ХешСумма Тогда
		
		ОбновитьИдентификаторыТранзакции(ИдентификаторТранзакции);
		Возврат ТекущиеПараметры.Параметры;
	КонецЕсли;
	
	// Параметры в базе данных отличаются от параметров в памяти.
	Если ЗначениеЗаполнено(ОписаниеВерсии.Версия) Тогда
		ВерсияПараметров = ВерсияПараметров(ОписаниеВерсии.Версия,
			УстановкаПараметровСеансаДляШаблонов, УстановкаПараметровДляОтчетаПраваДоступа);
	Иначе
		ВерсияПараметров = НоваяВерсияПараметровОграниченияДоступа(ОбщийКонтекст);
	КонецЕсли;
	
	УстановитьВерсиюПараметров(ВерсияПараметров, ИдентификаторТранзакции, ОбщийКонтекст);
	
	Возврат ПараметрыСеанса.ПараметрыОграниченияДоступа.Параметры;
	
КонецФункции

// Для отчета ПраваДоступа.
Функция ВсеВидыОграниченийПравДляОтчетаПраваДоступа() Экспорт
	
	Кэш = КэшПараметровОграничения();
	
	Если Кэш.ВсеВидыОграниченийПрав <> Неопределено Тогда
		Возврат Кэш.ВсеВидыОграниченийПрав;
	КонецЕсли;
	
	ДействующиеПараметрыОграниченияДоступа(Неопределено, Неопределено, Ложь, Ложь, Истина);
	
	Возврат ВсеВидыОграниченийПравДляОтчетаПраваДоступа();
	
КонецФункции

// Для функций ДействующиеПараметрыОграниченияДоступа, НоваяВерсияПараметровОграниченияДоступа.
Функция ОписаниеПоследнейВерсии()
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ПараметрыОграниченияДоступа.Версия КАК Версия,
	|	ПараметрыОграниченияДоступа.ХешСумма КАК ХешСумма,
	|	ПараметрыОграниченияДоступа.ДатаСоздания КАК ДатаСоздания
	|ИЗ
	|	РегистрСведений.ПараметрыОграниченияДоступа КАК ПараметрыОграниченияДоступа
	|
	|УПОРЯДОЧИТЬ ПО
	|	ПараметрыОграниченияДоступа.Версия УБЫВ";
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Возврат Выборка;
	
КонецФункции

// Для функции ДействующиеПараметрыОграниченияДоступа.
Функция ВерсияПараметров(Версия, УстановкаПараметровСеансаДляШаблонов, УстановкаПараметровДляОтчетаПраваДоступа)
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ПараметрыОграниченияДоступа.Версия КАК Версия,
	|	ПараметрыОграниченияДоступа.ХешСумма КАК ХешСумма,
	|	ПараметрыОграниченияДоступа.ДатаСоздания КАК ДатаСоздания,
	|	ПараметрыОграниченияДоступа.ДляШаблоновВСеансахПользователей КАК ДляШаблоновВСеансахПользователей,
	|	ПараметрыОграниченияДоступа.ДляШаблоновВСеансахВнешнихПользователей КАК ДляШаблоновВСеансахВнешнихПользователей,
	|	ПараметрыОграниченияДоступа.ДляЗаписиОбъектовИПроверкиПрав КАК ДляЗаписиОбъектовИПроверкиПрав,
	|	ПараметрыОграниченияДоступа.ДляОтчетаПоПравамДоступа КАК ДляОтчетаПоПравамДоступа
	|ИЗ
	|	РегистрСведений.ПараметрыОграниченияДоступа КАК ПараметрыОграниченияДоступа
	|ГДЕ
	|	ПараметрыОграниченияДоступа.Версия = &Версия";
	
	Если УстановкаПараметровСеансаДляШаблонов Или УстановкаПараметровДляОтчетаПраваДоступа Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст,
			"ПараметрыОграниченияДоступа.ДляЗаписиОбъектовИПроверкиПрав", "Неопределено");
	КонецЕсли;
	Если Не УстановкаПараметровДляОтчетаПраваДоступа Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст,
			"ПараметрыОграниченияДоступа.ДляОтчетаПоПравамДоступа", "Неопределено");
	КонецЕсли;
		
	Запрос.Текст = СтрЗаменить(Запрос.Текст, ?(Пользователи.ЭтоСеансВнешнегоПользователя(),
		"ПараметрыОграниченияДоступа.ДляШаблоновВСеансахПользователей",
		"ПараметрыОграниченияДоступа.ДляШаблоновВСеансахВнешнихПользователей"), "Неопределено");
	
	Запрос.УстановитьПараметр("Версия", Версия);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Возврат Выборка;
	
КонецФункции

// Для функции ДействующиеПараметрыОграниченияДоступа.
Функция НоваяВерсияПараметровОграниченияДоступа(ОбщийКонтекст, ЕстьИзменения = Ложь)
	
	Если РегистрироватьСтрокуВерсииПараметровОграниченияДоступа() Тогда
		Если ТипЗнч(ОбщийКонтекст) <> Тип("Структура") Тогда
			ОбновитьПовторноИспользуемыеЗначения();
			ОбщийКонтекст = ОбщийКонтекстРасчетаПараметровОграничения();
		КонецЕсли;
		Если ОбщийКонтекст.Свойство("СтрокиВерсииХранимыхПараметров") Тогда
			УдалитьСтрокиВерсииХранимыхПараметров = Ложь;
		Иначе
			ОбщийКонтекст.Вставить("СтрокиВерсииХранимыхПараметров");
			УдалитьСтрокиВерсииХранимыхПараметров = Истина;
		КонецЕсли;
	КонецЕсли;
	
	ВерсииОграниченийСписков = Новый Соответствие;
	ХранимыеПараметры = ХранимыеПараметрыОграниченияДоступа(ОбщийКонтекст, ВерсииОграниченийСписков);
	ВерсииОграниченийСписков.Вставить("Справочник.НаборыГруппДоступа", "1");
	
	Если РегистрироватьСтрокуВерсииПараметровОграниченияДоступа() Тогда
		СтрокиВерсии = ОбщийКонтекст.СтрокиВерсииХранимыхПараметров;
		Если УдалитьСтрокиВерсииХранимыхПараметров Тогда
			ОбщийКонтекст.Удалить("СтрокиВерсииХранимыхПараметров");
		КонецЕсли;
	КонецЕсли;
	
	НаборЗаписей = СлужебныйНаборЗаписей(РегистрыСведений.ПараметрыОграниченияДоступа);
	Запись = НаборЗаписей.Добавить();
	ЗаполнитьЗначенияСвойств(Запись, ХранимыеПараметры);
	
	БлокировкаДанных = Новый БлокировкаДанных;
	ЭлементБлокировки = БлокировкаДанных.Добавить("РегистрСведений.ПараметрыОграниченияДоступа");
	ЗаблокированнаяВерсия = 0;
	
	НачатьТранзакцию();
	Попытка
		ОписаниеВерсии = ОписаниеПоследнейВерсии();
		Пока Истина Цикл
			Если ОписаниеВерсии.ХешСумма = ХранимыеПараметры.ХешСумма Тогда
				Если ОписаниеВерсии.Версия = ЗаблокированнаяВерсия Тогда
					Прервать;
				КонецЕсли;
				ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
				ЭлементБлокировки.УстановитьЗначение("Версия", ОписаниеВерсии.Версия);
				БлокировкаДанных.Заблокировать();
				ЭлементБлокировки = БлокировкаДанных.Добавить("РегистрСведений.ПараметрыОграниченияДоступа");
				ЗаблокированнаяВерсия = ОписаниеВерсии.Версия;
				ОписаниеВерсии = ОписаниеПоследнейВерсии();
				Продолжить;
			КонецЕсли;
			Если ЗначениеЗаполнено(ОписаниеВерсии.Версия) Тогда
				НоваяВерсия = ОписаниеВерсии.Версия + 1;
			Иначе
				НоваяВерсия = 1;
			КонецЕсли;
			ЭлементБлокировки.УстановитьЗначение("Версия", НоваяВерсия);
			БлокировкаДанных.Заблокировать();
			НовоеОписаниеВерсии = ОписаниеПоследнейВерсии();
			
			Если ОписаниеВерсии.Версия <> НовоеОписаниеВерсии.Версия
			 Или НовоеОписаниеВерсии.Версия = НоваяВерсия Тогда
				
				ОписаниеВерсии = НовоеОписаниеВерсии;
				Продолжить;
			КонецЕсли;
			
			ХранимыеПараметры.Вставить("Версия", НоваяВерсия);
			
			Запись.Версия = НоваяВерсия;
			НаборЗаписей.Отбор.Версия.Установить(НоваяВерсия);
			
			Если КонфигурацияБазыДанныхИзмененаДинамически()
			 Или Справочники.ВерсииРасширений.РасширенияИзмененыДинамически() Тогда
				
				СтандартныеПодсистемыСервер.ПотребоватьПерезапускСеансаПоПричинеДинамическогоОбновленияВерсииПрограммы();
			КонецЕсли;
			НедоступныеСписки = Новый Массив;
			Списки = СпискиСИзменениемВерсий(ВерсииОграниченийСписков, НедоступныеСписки);
			ПараметрыПланирования = ПараметрыПланированияОбновленияДоступа();
			ПараметрыПланирования.ВерсииОграниченийСписков = ВерсииОграниченийСписков;
			ПараметрыПланирования.ЭтоПродолжениеОбновления = Истина;
			ПараметрыПланирования.Описание = "НоваяВерсияПараметровОграниченияДоступа";
			ЗапланироватьОбновлениеДоступа(Списки, ПараметрыПланирования);
			Если НедоступныеСписки.Количество() > 0 Тогда
				ЗапланироватьОбновлениеДоступа(НедоступныеСписки, ПараметрыПланирования);
			КонецЕсли;
			
			НаборЗаписей.Записать();
			ЕстьИзменения = Истина;
			Если РегистрироватьСтрокуВерсииПараметровОграниченияДоступа() Тогда
				ЗарегистрироватьСтрокуВерсииПараметровОграниченияДоступа(НаборЗаписей[0], СтрокиВерсии);
			КонецЕсли;
			Прервать;
		КонецЦикла;
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	Если Не ХранимыеПараметры.Свойство("Версия") Тогда
		ХранимыеПараметры.Вставить("Версия",       ОписаниеВерсии.Версия);
		ХранимыеПараметры.Вставить("ДатаСоздания", ОписаниеВерсии.ДатаСоздания);
	КонецЕсли;
	
	Если ЕстьИзменения <> Истина И Не ТранзакцияАктивна() Тогда
		ИмяПараметра = "СтандартныеПодсистемы.УправлениеДоступом.ДатаПроверкиПараметровОграниченияДоступа";
		СтандартныеПодсистемыСервер.УстановитьПараметрРаботыРасширения(ИмяПараметра, ТекущаяДатаСеанса(), Истина);
		УстановитьОбновлениеДоступа(Истина);
	КонецЕсли;
	
	Возврат ХранимыеПараметры;
	
КонецФункции

// Для функции НоваяВерсияПараметровОграниченияДоступа.
Процедура ЗарегистрироватьСтрокуВерсииПараметровОграниченияДоступа(Запись, СтрокиВерсии)
	
	Состав = Новый Массив;
	Состав.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		"Версия = %1
		|ДатаСоздания = %2
		|ХешСумма = %3
		|",
		Запись.Версия,
		Формат(Запись.ДатаСоздания, "ДЛФ=DT"),
		Запись.ХешСумма));
		
	Для Каждого Строка Из СтрокиВерсии.СтрокиВерсийСписков Цикл
		Состав.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			"[Список = %1, ДляВнешнихПользователей = %2, Версия = %3]
			|%4",
			Строка.Список,
			?(Строка.ДляВнешнихПользователей, "Да", "Нет"),
			Строка.Версия,
			Строка.СтрокаВерсии));
	КонецЦикла;
	
	Состав.Добавить("[ВсеВерсииСтрокой]
	|" + СтрокиВерсии.ВсеВерсииСтрокой);
	
	Состав.Добавить("[ВсеВидыОграниченийСтрокой]
	|" + СтрокиВерсии.ВсеВидыОграниченийСтрокой);
	
	Комментарий = СтрСоединить(Состав, Символы.ПС);
	
	ЗаписьЖурналаРегистрации(
		НСтр("ru = 'Управление доступом.Строка версии параметров ограничения доступа'",
		     ОбщегоНазначения.КодОсновногоЯзыка()),
		УровеньЖурналаРегистрации.Информация,
		Метаданные.РегистрыСведений.ПараметрыОграниченияДоступа,,
		Комментарий);
	
КонецПроцедуры

// Для функции НоваяВерсияПараметровОграниченияДоступа.
Функция СпискиСИзменениемВерсий(НовыеВерсииОграниченийСписков, НедоступныеСписки)
	
	ОписаниеВерсии = ОписаниеПоследнейВерсии();
	Если Не ЗначениеЗаполнено(ОписаниеВерсии.Версия) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ВерсияПараметров = ВерсияПараметров(ОписаниеВерсии.Версия, Ложь, Ложь);
	ПараметрыЗаписиХранилище = ВерсияПараметров.ДляЗаписиОбъектовИПроверкиПрав;
	
	Если ТипЗнч(ПараметрыЗаписиХранилище) <> Тип("ХранилищеЗначения") Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПараметрыЗаписи = ПараметрыЗаписиХранилище.Получить();
	
	Если ТипЗнч(ПараметрыЗаписи) <> Тип("ФиксированнаяСтруктура")
	 Или Не ПараметрыЗаписи.Свойство("ВерсииОграниченийСписков")
	 Или ТипЗнч(ПараметрыЗаписи.ВерсииОграниченийСписков) <> Тип("ФиксированноеСоответствие") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Список",       Новый ОписаниеТипов("Строка"));
	Таблица.Колонки.Добавить("Версия",       Новый ОписаниеТипов("Строка"));
	Таблица.Колонки.Добавить("ВидИзменения", Новый ОписаниеТипов("Число"));
	
	Для Каждого КлючИЗначение Из ПараметрыЗаписи.ВерсииОграниченийСписков Цикл
		Строка = Таблица.Добавить();
		Строка.Список = КлючИЗначение.Ключ;
		Строка.Версия = СтрПолучитьСтроку(КлючИЗначение.Значение, 1)
			+ Символы.ПС + СтрПолучитьСтроку(КлючИЗначение.Значение, 2);
		Строка.ВидИзменения = -1;
	КонецЦикла;
	
	Для Каждого КлючИЗначение Из НовыеВерсииОграниченийСписков Цикл
		Строка = Таблица.Добавить();
		Строка.Список = КлючИЗначение.Ключ;
		Строка.Версия = СтрПолучитьСтроку(КлючИЗначение.Значение, 1)
			+ Символы.ПС + СтрПолучитьСтроку(КлючИЗначение.Значение, 2);
		Строка.ВидИзменения = 1;
	КонецЦикла;
	
	Таблица.Свернуть("Список, Версия", "ВидИзменения");
	Списки = Новый Массив;
	НенайденныеСписки = Новый Массив;
	
	Для Каждого Строка Из Таблица Цикл
		Если Строка.ВидИзменения = 0 Тогда
			Продолжить;
		КонецЕсли;
		ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(Строка.Список);
		Если ОбъектМетаданных = Неопределено Тогда
			НенайденныеСписки.Добавить(Строка.Список);
			Продолжить;
		КонецЕсли;
		ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
		Если Списки.Найти(ПолноеИмя) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Списки.Добавить(ПолноеИмя);
	КонецЦикла;
	
	Если НенайденныеСписки.Количество() > 0 Тогда
		НедоступныеСписки = ВсеИдентификаторыСПодобнымиПолнымиИменами(НенайденныеСписки);
	КонецЕсли;
	
	Возврат Списки;
	
КонецФункции

// Для функции СпискиСИзменениемВерсий и для процедуры ДобавитьЗависимыеСписки.
Функция ВсеИдентификаторыСПодобнымиПолнымиИменами(ПолныеИмена)
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Идентификаторы.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.ИдентификаторыОбъектовМетаданных КАК Идентификаторы
	|ГДЕ
	|	&УсловияОтбораИОМ
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	Идентификаторы.Идентификатор
	|ИЗ
	|	РегистрСведений.ИдентификаторыОбъектовВерсийРасширений КАК Идентификаторы
	|ГДЕ
	|	&УсловияОтбораИОР";
	
	УсловияОтбораИОМ = Новый Массив;
	УсловияОтбораИОР = Новый Массив;
	
	НомерПараметра = 1;
	Для Каждого ПолноеИмя Из ПолныеИмена Цикл
		ИмяПараметра = "ПолноеИмя" + Формат(НомерПараметра, "ЧГ=");
		Запрос.УстановитьПараметр(ИмяПараметра, ПолноеИмя);
		УсловияОтбораИОМ.Добавить("Идентификаторы.ПолноеИмя ПОДОБНО &" + ИмяПараметра);
		УсловияОтбораИОР.Добавить("Идентификаторы.ПолноеИмяОбъекта ПОДОБНО &" + ИмяПараметра);
		НомерПараметра = НомерПараметра + 1;
	КонецЦикла;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловияОтбораИОМ",
		СтрСоединить(УсловияОтбораИОМ, Символы.ПС + "	ИЛИ "));
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловияОтбораИОР",
		СтрСоединить(УсловияОтбораИОР, Символы.ПС + "	ИЛИ "));
	
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
КонецФункции

// Для процедуры ХранимыеПараметрыОграниченияДоступа.
Функция ВерсияСтруктурыКэша()
	
	// Число нужно увеличивать при внесении изменений в состав параметров кэша
	// (в том числе при изменении версии шаблонов).
	Возврат "17";
	
КонецФункции

// Для процедур УстановкаПараметровСеанса, УточнитьВерсииШаблоновОграниченияДоступа и
// для функции СтруктураХранимыхПараметровШаблонов.
Функция ВерсииШаблоновОграниченияДоступа()
	
	Возврат
	",ДляОбъекта6,
	|,ДляРегистра6,
	|,ПоЗначениям17,
	|,ПоЗначениямРасширенный17,
	|,ПоЗначениямИНаборамРасширенный17,
	|,ПоНаборамЗначений17,";
	
КонецФункции

// Для функции ДействующиеПараметрыОграниченияДоступа.
Процедура ОбновитьИдентификаторыТранзакции(ИдентификаторТранзакции)
	
	Кэш = КэшПараметровОграничения();
	
	Если Не ТранзакцияАктивна() И Кэш.ИдентификаторыТранзакции.Количество() = 0
	 Или    ТранзакцияАктивна() И ИдентификаторТранзакции = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если ИдентификаторТранзакции <> Неопределено И ТранзакцияАктивна() Тогда
		Кэш.ИдентификаторыТранзакции.Вставить(ИдентификаторТранзакции, Истина);
	Иначе
		Кэш.ИдентификаторыТранзакции.Очистить();
	КонецЕсли;
	
КонецПроцедуры

// Для функции ДействующиеПараметрыОграниченияДоступа.
Процедура УстановитьВерсиюПараметров(ВерсияПараметров, ИдентификаторТранзакции, ОбщийКонтекст, ПовторныйВызов = Ложь)
	
	Если Не ПовторныйВызов Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
	Если ИдентификаторТранзакции <> Неопределено И ТранзакцияАктивна() Тогда
		Кэш = КэшПараметровОграничения();
		Кэш.ИдентификаторыТранзакции.Вставить(ИдентификаторТранзакции, Истина);
	КонецЕсли;
	
	Если ТипЗнч(ВерсияПараметров.ДляЗаписиОбъектовИПроверкиПрав) = Тип("ХранилищеЗначения") Тогда
		ДляЗаписиОбъектовИПроверкиПрав = СтруктураХранимыхПараметровЗаписи(
			ВерсияПараметров.ДляЗаписиОбъектовИПроверкиПрав.Получить());
		
		Если ДляЗаписиОбъектовИПроверкиПрав.ВерсияСтруктурыКэша <> ВерсияСтруктурыКэша() Тогда
			ВерсияПараметров = НоваяВерсияПараметровОграниченияДоступа(ОбщийКонтекст);
			УстановитьВерсиюПараметров(ВерсияПараметров, ИдентификаторТранзакции, ОбщийКонтекст, Истина);
			Возврат;
		КонецЕсли;
	Иначе
		ДляЗаписиОбъектовИПроверкиПрав = Неопределено;
	КонецЕсли;
	
	Если ТипЗнч(ВерсияПараметров.ДляОтчетаПоПравамДоступа) = Тип("ХранилищеЗначения") Тогда
		ДляОтчетаПоПравамДоступа = СтруктураХранимыхПараметровОтчета(
			ВерсияПараметров.ДляОтчетаПоПравамДоступа.Получить());
		
		Если ДляОтчетаПоПравамДоступа.ВерсияСтруктурыКэша <> ВерсияСтруктурыКэша() Тогда
			ВерсияПараметров = НоваяВерсияПараметровОграниченияДоступа(ОбщийКонтекст);
			УстановитьВерсиюПараметров(ВерсияПараметров, ИдентификаторТранзакции, ОбщийКонтекст, Истина);
			Возврат;
		КонецЕсли;
		Кэш = КэшПараметровОграничения();
		Кэш.ВсеВидыОграниченийПрав = ДляОтчетаПоПравамДоступа.ВсеВидыОграниченийПрав;
	КонецЕсли;
	
	ХранилищеДляШаблоновОграниченияДоступа = ?(Пользователи.ЭтоСеансВнешнегоПользователя(),
		ВерсияПараметров.ДляШаблоновВСеансахВнешнихПользователей,
		ВерсияПараметров.ДляШаблоновВСеансахПользователей);
	
	Если ТипЗнч(ХранилищеДляШаблоновОграниченияДоступа) = Тип("ХранилищеЗначения") Тогда
		ДляШаблоновОграниченияДоступа = СтруктураХранимыхПараметровШаблонов(
			ХранилищеДляШаблоновОграниченияДоступа.Получить());
		
		Если ДляШаблоновОграниченияДоступа.ВерсияСтруктурыКэша <> ВерсияСтруктурыКэша() Тогда
			ВерсияПараметров = НоваяВерсияПараметровОграниченияДоступа(ОбщийКонтекст);
			УстановитьВерсиюПараметров(ВерсияПараметров, ИдентификаторТранзакции, ОбщийКонтекст, Истина);
			Возврат;
		КонецЕсли;
	Иначе
		ДляШаблоновОграниченияДоступа = СтруктураХранимыхПараметровШаблонов();
	КонецЕсли;
	
	ПараметрыСеанса.ВерсииШаблоновОграниченияДоступа = СтрСоединить(СтрРазделить(
		ДляШаблоновОграниченияДоступа.ВерсииШаблонов, Символы.ПС + Символы.ВК, Ложь), Символы.ПС);
	
	ПараметрыШаблонов = СтруктураПараметровШаблонов(ДляШаблоновОграниченияДоступа.ПараметрыШаблонов);
	ЗаполнитьЗначенияСвойств(ПараметрыСеанса, ПараметрыШаблонов);
	
	УточнитьВерсииШаблоновОграниченияДоступа();
	
	ОбновитьРазрешенныеНаборыВПараметрахСеанса(Истина);
	
	ПараметрыОграничения = Новый Структура;
	ПараметрыОграничения.Вставить("Версия",       ВерсияПараметров.Версия);
	ПараметрыОграничения.Вставить("ХешСумма",     ВерсияПараметров.ХешСумма);
	ПараметрыОграничения.Вставить("ДатаСоздания", ВерсияПараметров.ДатаСоздания);
	ПараметрыОграничения.Вставить("Параметры",    ДляЗаписиОбъектовИПроверкиПрав);
	
	ФиксированныеПараметрыОграничения = Новый ФиксированнаяСтруктура(ПараметрыОграничения);
	ПараметрыСеанса.ПараметрыОграниченияДоступа = ФиксированныеПараметрыОграничения;
	
КонецПроцедуры

// Для процедуры УстановитьВерсиюПараметров.
Процедура УточнитьВерсииШаблоновОграниченияДоступа()
	
	Если ПараметрыСеанса.ВерсииШаблоновОграниченияДоступа = ВерсииШаблоновОграниченияДоступа() Тогда
		Возврат;
	КонецЕсли;
	
	ПараметрыСеанса.ВерсииШаблоновОграниченияДоступа = ВерсииШаблоновОграниченияДоступа() + "
	|,ТребуетсяПерезапуститьСеанс,";
	
КонецПроцедуры

// Для процедуры УстановитьВерсиюПараметров, ПроверитьДоступКОбъекту,
// ПроверитьДоступКНаборуЗаписей и функции ДоступРазрешен.
//
Процедура ОбновитьРазрешенныеНаборыВПараметрахСеанса(ЭтоУстановкаПараметровСеанса = Ложь)
	
	ПоследняяПроверка = УправлениеДоступомСлужебныйПовтИсп.ПоследняяПроверкаВерсииРазрешенныхНаборов();
	
	Если Не ЭтоУстановкаПараметровСеанса И ПоследняяПроверка.Дата + 3 > ТекущаяДатаСеанса() Тогда
		Возврат;
	КонецЕсли;
	
	ПоследняяПроверка.Дата = ТекущаяДатаСеанса();
	ПустойНаборГруппДоступа = Справочники.НаборыГруппДоступа.ПустаяСсылка();
	РазрешенныйПустойНаборГруппДоступа = УправлениеДоступомСлужебныйПовтИсп.РазрешенныйПустойНаборГруппДоступа();
	
	Если Пользователи.ЭтоПолноправныйПользователь(,, Ложь) Тогда
		РазрешенныйПользователь            = ПустойНаборГруппДоступа;
		РазрешенныйНаборГруппДоступа       = ПустойНаборГруппДоступа;
		РазрешенныйНаборГруппПользователей = ПустойНаборГруппДоступа;
	Иначе
		РазрешенныйПользователь = Справочники.НаборыГруппДоступа.ПолучитьСсылку(
			Пользователи.АвторизованныйПользователь().УникальныйИдентификатор());
		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("РазрешенныйПользователь", РазрешенныйПользователь);
		Запрос.Текст =
		"ВЫБРАТЬ
		|	НаборыГруппДоступа.РазрешенныйНаборГруппДоступа КАК РазрешенныйНаборГруппДоступа,
		|	НаборыГруппДоступа.РазрешенныйНаборГруппПользователей КАК РазрешенныйНаборГруппПользователей
		|ИЗ
		|	Справочник.НаборыГруппДоступа КАК НаборыГруппДоступа
		|ГДЕ
		|	НаборыГруппДоступа.Ссылка = &РазрешенныйПользователь";
		
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			РазрешенныйНаборГруппДоступа       = Выборка.РазрешенныйНаборГруппДоступа;
			РазрешенныйНаборГруппПользователей = Выборка.РазрешенныйНаборГруппПользователей;
		Иначе
			РазрешенныйНаборГруппДоступа       = ПустойНаборГруппДоступа;
			РазрешенныйНаборГруппПользователей = ПустойНаборГруппДоступа;
		КонецЕсли;
	КонецЕсли;
	
	Если Не ЭтоУстановкаПараметровСеанса
	   И ПараметрыСеанса.РазрешенныйПользователь            = РазрешенныйПользователь
	   И ПараметрыСеанса.РазрешенныйНаборГруппДоступа       = РазрешенныйНаборГруппДоступа
	   И ПараметрыСеанса.РазрешенныйНаборГруппПользователей = РазрешенныйНаборГруппПользователей
	   И ПараметрыСеанса.РазрешенныйНаборГруппПользователей = РазрешенныйПустойНаборГруппДоступа  Тогда
		
		Возврат;
	КонецЕсли;
	
	ПараметрыСеанса.РазрешенныйПользователь            = РазрешенныйПользователь;
	ПараметрыСеанса.РазрешенныйНаборГруппДоступа       = РазрешенныйНаборГруппДоступа;
	ПараметрыСеанса.РазрешенныйНаборГруппПользователей = РазрешенныйНаборГруппПользователей;
	ПараметрыСеанса.РазрешенныйПустойНаборГруппДоступа = РазрешенныйПустойНаборГруппДоступа;
	
	ОбщиеПараметры = "";
	УчестьНастройкиПравПриПостроенииПланаВыполненияЗапроса(ОбщиеПараметры);
	ПараметрыСеанса.ОбщиеПараметрыШаблоновОграниченияДоступа = ОбщиеПараметры;
	
КонецПроцедуры

// Для процедуры ОбновитьРазрешенныеНаборыВПараметрахСеанса.
Процедура УчестьНастройкиПравПриПостроенииПланаВыполненияЗапроса(ОбщиеПараметры)
	
	Если Не УправлениеДоступомСлужебныйПовтИсп.ТребуетсяУточнениеПланаЗапроса() Тогда
		Возврат;
	КонецЕсли;
	
	ОбщиеПараметры = ";УчестьНастройкиПравПриПостроенииПланаВыполненияЗапроса;"
		+ ОписаниеХешСуммыНастроекПрав(ПараметрыСеанса.РазрешенныйНаборГруппДоступа)
		+ ОписаниеХешСуммыНастроекПрав(ПараметрыСеанса.РазрешенныйПользователь, "^");
	
КонецПроцедуры

// Для процедуры УчестьНастройкиПравПриПостроенииПланаВыполненияЗапроса.
Функция ОписаниеХешСуммыНастроекПрав(НаборГруппДоступа, Символ = "")
	
	ХешированиеДанных = Новый ХешированиеДанных(ХешФункция.CRC32);
	ХешированиеДанных.Добавить(ПолучитьДвоичныеДанныеИзHexСтроки(СтрЗаменить(
		НаборГруппДоступа.УникальныйИдентификатор(), "-", "")));
	Остаток = ХешированиеДанных.ХешСумма;
	
	Результат = "";
	Для Счетчик = 1 По 32 Цикл
		Целое = Цел(Остаток / 2);
		Результат = ?(Остаток - Целое * 2 = 0, "", Строка(Счетчик) + Символ + ";") + Результат;
		Остаток = Целое;
	КонецЦикла;
	
	Возврат Символы.ПС + ";" + Результат;
	
КонецФункции

// Для функции ДоступРазрешен и процедур ПроверитьДоступКОбъекту, ПроверитьДоступКНаборуЗаписей.
Процедура УстановитьРазрешенныеНаборыВПараметрыЗапроса(Запрос)
	
	Запрос.УстановитьПараметр("РазрешенныйНаборГруппДоступа",       ПараметрыСеанса.РазрешенныйНаборГруппДоступа);
	Запрос.УстановитьПараметр("РазрешенныйПустойНаборГруппДоступа", ПараметрыСеанса.РазрешенныйПустойНаборГруппДоступа);
	Запрос.УстановитьПараметр("РазрешенныйНаборГруппПользователей", ПараметрыСеанса.РазрешенныйНаборГруппПользователей);
	Запрос.УстановитьПараметр("РазрешенныйПользователь",            ПараметрыСеанса.РазрешенныйПользователь);
	Запрос.УстановитьПараметр("АвторизованныйПользователь",         Пользователи.АвторизованныйПользователь());
	
КонецПроцедуры

// Для функции НоваяВерсияПараметровОграниченияДоступа.
Функция ХранимыеПараметрыОграниченияДоступа(ОбщийКонтекст, ВерсииОграниченийСписков = Неопределено)
	
	Если ОбщийКонтекст = Неопределено Тогда
		ОбновитьПовторноИспользуемыеЗначения();
		ОбщийКонтекст = ОбщийКонтекстРасчетаПараметровОграничения();
		
	ИначеЕсли ОбщийКонтекст.Свойство("СпециальноеПолноеИмя") Тогда
		СпециальноеПолноеИмя           = ОбщийКонтекст.СпециальноеПолноеИмя;
		СпециальноеОписаниеОграничения = ОбщийКонтекст.СпециальноеОписаниеОграничения;
	КонецЕсли;
	
	ДополнительныйКонтекстДляПользователей        = НовыйДополнительныйКонтекст();
	ДополнительныйКонтекстДляВнешнихПользователей = НовыйДополнительныйКонтекст();
	
	ПолныеИменаСписков = Новый Массив;
	Для Каждого ОписаниеСписка Из ОбщийКонтекст.СпискиСОграничением Цикл
		ПолноеИмя = ОписаниеСписка.Ключ;
		ПолныеИменаСписков.Добавить(ПолноеИмя);
		Если ПолноеИмя = СпециальноеПолноеИмя Тогда
			ОписаниеОграничения = СпециальноеОписаниеОграничения;
		Иначе
			ОписаниеОграничения = ОписаниеОграниченияДанных(ОбщийКонтекст, ПолноеИмя);
		КонецЕсли;
		
		ДобавитьДополнительныйКонтекст(ПолноеИмя,
			ДополнительныйКонтекстДляПользователей, ОписаниеОграничения, Ложь);
		
		ДобавитьДополнительныйКонтекст(ПолноеИмя,
			ДополнительныйКонтекстДляВнешнихПользователей, ОписаниеОграничения, Истина);
	КонецЦикла;
	
	СпискиСДатой = Новый Соответствие;
	ИдентификаторыСписков = ОбщегоНазначения.ИдентификаторыОбъектовМетаданных(ПолныеИменаСписков);
	
	ВсеВидыОграниченийПрав = Новый Соответствие;
	ДобавитьНестандартныеВидыОграниченийПрав(ВсеВидыОграниченийПрав);
	
	Если ОбщийКонтекст.Свойство("СтрокиВерсииХранимыхПараметров") Тогда
		СтрокиВерсийСписков = Новый ТаблицаЗначений;
		СтрокиВерсийСписков.Колонки.Добавить("Список",                  Новый ОписаниеТипов("Строка"));
		СтрокиВерсийСписков.Колонки.Добавить("ДляВнешнихПользователей", Новый ОписаниеТипов("Булево"));
		СтрокиВерсийСписков.Колонки.Добавить("Версия",                  Новый ОписаниеТипов("Строка"));
		СтрокиВерсийСписков.Колонки.Добавить("СтрокаВерсии",            Новый ОписаниеТипов("Строка"));
		ОбщийКонтекст.СтрокиВерсииХранимыхПараметров =
			Новый Структура("ВсеВерсииСтрокой, ВсеВидыОграниченийСтрокой, СтрокиВерсийСписков",
				"", "", СтрокиВерсийСписков);
	КонецЕсли;
	
	// Заполнение для пользователей.
	КонтекстДляПользователей = Новый Структура;
	КонтекстДляПользователей.Вставить("ДляВнешнихПользователей",  Ложь);
	КонтекстДляПользователей.Вставить("ОбщийКонтекст",            ОбщийКонтекст);
	КонтекстДляПользователей.Вставить("ДополнительныйКонтекст",   ДополнительныйКонтекстДляПользователей);
	КонтекстДляПользователей.Вставить("ВедущиеСписки",            Новый Соответствие);
	КонтекстДляПользователей.Вставить("ВерсииОграниченийСписков", Новый Соответствие);
	КонтекстДляПользователей.Вставить("ПараметрыШаблонов",        СтруктураПараметровШаблонов());
	КонтекстДляПользователей.Вставить("СпискиСДатой",             СпискиСДатой);
	КонтекстДляПользователей.Вставить("ИдентификаторыСписков",    ИдентификаторыСписков);
	КонтекстДляПользователей.Вставить("ВсеВидыОграниченийПрав",   ВсеВидыОграниченийПрав);
	
	ДобавитьХранимыеПараметрыОграниченияДляВидаПользователей(КонтекстДляПользователей);
	
	// Заполнение для внешних пользователей.
	КонтекстДляВнешнихПользователей = Новый Структура;
	КонтекстДляВнешнихПользователей.Вставить("ДляВнешнихПользователей",  Истина);
	КонтекстДляВнешнихПользователей.Вставить("ОбщийКонтекст",            ОбщийКонтекст);
	КонтекстДляВнешнихПользователей.Вставить("ДополнительныйКонтекст",   ДополнительныйКонтекстДляВнешнихПользователей);
	КонтекстДляВнешнихПользователей.Вставить("ВедущиеСписки",            Новый Соответствие);
	КонтекстДляВнешнихПользователей.Вставить("ВерсииОграниченийСписков", Новый Соответствие);
	КонтекстДляВнешнихПользователей.Вставить("ПараметрыШаблонов",        СтруктураПараметровШаблонов());
	КонтекстДляВнешнихПользователей.Вставить("СпискиСДатой",             СпискиСДатой);
	КонтекстДляВнешнихПользователей.Вставить("ИдентификаторыСписков",    ИдентификаторыСписков);
	КонтекстДляВнешнихПользователей.Вставить("ВсеВидыОграниченийПрав",   ВсеВидыОграниченийПрав);
	
	ДобавитьХранимыеПараметрыОграниченияДляВидаПользователей(КонтекстДляВнешнихПользователей);
	
	// Заполнение общей и отдельной частей ведущих списков для пользователей и внешних пользователей.
	ВедущиеСписки = Новый Соответствие;
	Для Каждого ОписаниеВедущихСписков Из КонтекстДляПользователей.ВедущиеСписки Цикл
		ДобавитьВедущиеСписки(ВедущиеСписки,
			"ДляПользователей", ОписаниеВедущихСписков.Ключ, ОписаниеВедущихСписков.Значение);
	КонецЦикла;
	Для Каждого ОписаниеВедущихСписков Из КонтекстДляВнешнихПользователей.ВедущиеСписки Цикл
		ДобавитьВедущиеСписки(ВедущиеСписки,
			"ДляВнешнихПользователей", ОписаниеВедущихСписков.Ключ, ОписаниеВедущихСписков.Значение);
	КонецЦикла;
	Для Каждого ВедущийСписок Из ВедущиеСписки Цикл
		Свойства = ВедущийСписок.Значение;
		Если Свойства.ПоЗначениямПолей <> Неопределено Тогда
			ПоЗначениямПолей = Свойства.ПоЗначениямПолей;
			Если ПоЗначениямПолей.ЭтоСсылочныйТип Тогда
				ТабличныеЧасти = Новый Массив;
				Для Каждого ОписаниеТабличнойЧасти Из ПоЗначениямПолей.ТабличныеЧасти Цикл
					ТабличныеЧасти.Добавить(ОписаниеТабличнойЧасти.Значение);
				КонецЦикла;
				ПоЗначениямПолей.ТабличныеЧасти = ТабличныеЧасти;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	// Расчет версий ограничения доступа.
	ВерсииОграниченийСписков = Новый Соответствие;
	Версии = Новый СписокЗначений;
	Версии.Добавить(ВерсияСтруктурыКэша());
	Для Каждого ОписаниеВерсии Из КонтекстДляПользователей.ВерсииОграниченийСписков Цикл
		ОбщаяВерсия = ОбщаяВерсия(ОбщийКонтекст, ОписаниеВерсии.Ключ, ОписаниеВерсии.Значение,
			КонтекстДляВнешнихПользователей.ВерсииОграниченийСписков.Получить(ОписаниеВерсии.Ключ));
		ВерсииОграниченийСписков.Вставить(ОписаниеВерсии.Ключ, ОбщаяВерсия);
		Версии.Добавить(ОбщаяВерсия);
	КонецЦикла;
	Версии.СортироватьПоЗначению();
	ВерсииСтрокой = СтрСоединить(Версии.ВыгрузитьЗначения(), Символы.ПС);
	ХешированиеДанных = Новый ХешированиеДанных(ХешФункция.SHA256);
	ХешированиеДанных.Добавить(ВерсииСтрокой);
	Если ОбщийКонтекст.Свойство("СтрокиВерсииХранимыхПараметров") Тогда
		ОбщийКонтекст.СтрокиВерсииХранимыхПараметров.ВсеВерсииСтрокой = ВерсииСтрокой;
	КонецЕсли;
	
	// Подготовка дополнительного контекста для расчета параметров ограничения отдельного списка.
	ХранимыеСвойства = "СпискиСОтключеннымОграничением, СпискиСОтключеннымОграничениемЧтения,
		|СвойстваОграниченияСписков, СпискиСЗаписьюКлючейДляЗависимыхСписковБезКлючей";
	ДляПользователей = Новый Структура(ХранимыеСвойства);
	ЗаполнитьЗначенияСвойств(ДляПользователей, КонтекстДляПользователей.ДополнительныйКонтекст);
	ДляВнешнихПользователей = Новый Структура(ХранимыеСвойства);
	ЗаполнитьЗначенияСвойств(ДляВнешнихПользователей, КонтекстДляВнешнихПользователей.ДополнительныйКонтекст);
	ДополнительныйКонтекст = Новый Структура;
	ДополнительныйКонтекст.Вставить("ДляПользователей", ДляПользователей);
	ДополнительныйКонтекст.Вставить("ДляВнешнихПользователей", ДляВнешнихПользователей);
	
	ПараметрыЗаписи = СтруктураХранимыхПараметровЗаписи();
	ПараметрыЗаписи.ВерсииОграниченийСписков = ВерсииОграниченийСписков;
	ПараметрыЗаписи.ВедущиеСписки            = ВедущиеСписки;
	ПараметрыЗаписи.ДополнительныйКонтекст   = ДополнительныйКонтекст;
	ПараметрыЗаписи.СпискиСДатой             = СпискиСДатой;
	ПараметрыЗаписи.ИспользуемыеТипыЗначений = Новый ХранилищеЗначения(ОбщийКонтекст.ИспользуемыеТипыЗначений);
	ПараметрыЗаписи.ВнешниеПользователиВключены = ОбщийКонтекст.ВнешниеПользователиВключены;
	ПараметрыЗаписи.ОграничениеДоступаВключено  = ОбщийКонтекст.ОграничениеДоступаВключено;
	
	ХранимыеПараметры = Новый Структура;
	
	ХранимыеПараметрыШаблоновДляПользователей = СтруктураХранимыхПараметровШаблонов();
	ХранимыеПараметрыШаблоновДляПользователей.ПараметрыШаблонов = КонтекстДляПользователей.ПараметрыШаблонов;
	ХранимыеПараметры.Вставить("ДляШаблоновВСеансахПользователей",
		Новый ХранилищеЗначения(ОбщегоНазначения.ФиксированныеДанные(ХранимыеПараметрыШаблоновДляПользователей)));
	
	ХранимыеПараметрыШаблоновДляВнешнихПользователей = СтруктураХранимыхПараметровШаблонов();
	ХранимыеПараметрыШаблоновДляВнешнихПользователей.ПараметрыШаблонов = КонтекстДляВнешнихПользователей.ПараметрыШаблонов;
	ХранимыеПараметры.Вставить("ДляШаблоновВСеансахВнешнихПользователей",
		Новый ХранилищеЗначения(ОбщегоНазначения.ФиксированныеДанные(ХранимыеПараметрыШаблоновДляВнешнихПользователей)));
	
	ХранимыеПараметры.Вставить("ДляЗаписиОбъектовИПроверкиПрав",
		Новый ХранилищеЗначения(ОбщегоНазначения.ФиксированныеДанные(ПараметрыЗаписи)));
	
	ВсеВидыОграничений = Новый СписокЗначений;
	Для Каждого КлючИЗначение Из ВсеВидыОграниченийПрав Цикл
		ВсеВидыОграничений.Добавить(КлючИЗначение.Ключ);
	КонецЦикла;
	ВсеВидыОграничений.СортироватьПоЗначению();
	ВсеВидыОграниченийСтрокой = СтрСоединить(ВсеВидыОграничений.ВыгрузитьЗначения(), Символы.ПС);
	
	ХранимыеПараметрыОтчета = СтруктураХранимыхПараметровОтчета();
	ХранимыеПараметрыОтчета.ВсеВидыОграниченийПрав = ВсеВидыОграниченийСтрокой;
	ХешированиеДанных.Добавить(ВсеВидыОграниченийСтрокой);
	Если ОбщийКонтекст.Свойство("СтрокиВерсииХранимыхПараметров") Тогда
		ОбщийКонтекст.СтрокиВерсииХранимыхПараметров.ВсеВидыОграниченийСтрокой = ВсеВидыОграниченийСтрокой;
	КонецЕсли;
	
	ХранимыеПараметры.Вставить("ДляОтчетаПоПравамДоступа",
		Новый ХранилищеЗначения(ОбщегоНазначения.ФиксированныеДанные(ХранимыеПараметрыОтчета)));
	
	ХранимыеПараметры.Вставить("ХешСумма", Base64Строка(ХешированиеДанных.ХешСумма));
	ХранимыеПараметры.Вставить("ДатаСоздания", ТекущаяДатаСеанса());
	
	Если ОбщийКонтекст.Свойство("СтрокиВерсииХранимыхПараметров") Тогда
		СтрокиВерсийСписков.Сортировать("Список, ДляВнешнихПользователей");
	КонецЕсли;
	
	Возврат ХранимыеПараметры;
	
КонецФункции

// Для функции ХранимыеПараметрыОграниченияДоступа.
Процедура ДобавитьНестандартныеВидыОграниченийПрав(ВсеВидыОграниченийПрав)
	
	ВсеВидыОграниченийПрав.Вставить("Справочник.ВнешниеПользователи.Чтение.ВнешниеПользователи");
	ВсеВидыОграниченийПрав.Вставить("Справочник.ВнешниеПользователи.Изменение.ВнешниеПользователи");
	ВсеВидыОграниченийПрав.Вставить("Справочник.ГруппыВнешнихПользователей.Чтение.ВнешниеПользователи");
	ВсеВидыОграниченийПрав.Вставить("Справочник.ГруппыПользователей.Чтение.Пользователи");
	ВсеВидыОграниченийПрав.Вставить("Справочник.Пользователи.Чтение.Пользователи");
	ВсеВидыОграниченийПрав.Вставить("Справочник.Пользователи.Изменение.Пользователи");
	ВсеВидыОграниченийПрав.Вставить("РегистрСведений.СоставыГруппПользователей.Чтение.ВнешниеПользователи");
	ВсеВидыОграниченийПрав.Вставить("РегистрСведений.СоставыГруппПользователей.Чтение.Пользователи");
	
КонецПроцедуры

// Для функций РассчитанныеПараметрыОграничения и ХранимыеПараметрыОграниченияДоступа.
Функция НовыйДополнительныйКонтекст()
	
	ДополнительныйКонтекст = Новый Структура;
	ДополнительныйКонтекст.Вставить("ОписанияОграничений",                  Новый Соответствие);
	ДополнительныйКонтекст.Вставить("СвойстваОграниченияСписков",           Новый Соответствие);
	ДополнительныйКонтекст.Вставить("СпискиСОграничениемПоВладельцу",       Новый Соответствие);
	ДополнительныйКонтекст.Вставить("СпискиСОтключеннымОграничением",       Новый Соответствие);
	ДополнительныйКонтекст.Вставить("СпискиСОтключеннымОграничениемЧтения", Новый Соответствие);
	ДополнительныйКонтекст.Вставить("СпискиСЗаписьюКлючейДляЗависимыхСписковБезКлючей", Неопределено);
	
	Возврат ДополнительныйКонтекст;
	
КонецФункции

// Для функций РассчитанныеПараметрыОграничения и ХранимыеПараметрыОграниченияДоступа.
Процедура ДобавитьДополнительныйКонтекст(ПолноеИмя, ДополнительныйКонтекст,
				ОписаниеОграничения, ДляВнешнихПользователей)
	
	Если ДляВнешнихПользователей Тогда
		Текст               = ОписаниеОграничения.ТекстДляВнешнихПользователей;
		ПоВладельцу         = ОписаниеОграничения.ПоВладельцуБезЗаписиКлючейДоступаДляВнешнихПользователей;
	Иначе
		Текст               = ОписаниеОграничения.Текст;
		ПоВладельцу         = ОписаниеОграничения.ПоВладельцуБезЗаписиКлючейДоступа;
	КонецЕсли;
	ВМодулеМенеджера = ОписаниеОграничения.ТекстВМодулеМенеджера;
	
	СокращенноеОписаниеОграничения = Новый Структура;
	СокращенноеОписаниеОграничения.Вставить("Текст",               Текст);
	СокращенноеОписаниеОграничения.Вставить("ВМодулеМенеджера",    ВМодулеМенеджера);
	
	ДополнительныйКонтекст.ОписанияОграничений.Вставить(ПолноеИмя, СокращенноеОписаниеОграничения);
	
	Если ПоВладельцу <> Неопределено Тогда
		ДополнительныйКонтекст.СпискиСОграничениемПоВладельцу.Вставить(ПолноеИмя, ПоВладельцу);
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ХранимыеПараметрыОграниченияДоступа.
Процедура ДобавитьХранимыеПараметрыОграниченияДляВидаПользователей(Контекст)
	
	// Подготовка параметров с учетом зависимостей только по ключам доступа.
	ТаблицаСвойств = Новый ТаблицаЗначений;
	ТаблицаСвойств.Колонки.Добавить("ПолноеИмя", Новый ОписаниеТипов("Строка"));
	ТаблицаСвойств.Колонки.Добавить("Зависимый", Новый ОписаниеТипов("Булево"));
	ТаблицаСвойств.Колонки.Добавить("Ведущие",   Новый ОписаниеТипов("Массив"));
	ТаблицаСвойств.Колонки.Добавить("Уровень",   Новый ОписаниеТипов("Число"));
	ТаблицаСвойств.Колонки.Добавить("Ведущий",   Новый ОписаниеТипов("Булево"));
	ТаблицаСвойств.Колонки.Добавить("Зависимые", Новый ОписаниеТипов("Массив"));
	ТаблицаСвойств.Колонки.Добавить("Параметры", Новый ОписаниеТипов("Структура"));
	ТаблицаСвойств.Колонки.Добавить("Обработан", Новый ОписаниеТипов("Булево"));
	ТаблицаСвойств.Колонки.Добавить("ОграничениеПоВладельцуВозможно",  Новый ОписаниеТипов("Булево"));
	ТаблицаСвойств.Колонки.Добавить("ОграничениеПоВладельцуВключено",  Новый ОписаниеТипов("Булево"));
	ТаблицаСвойств.Колонки.Добавить("ОграничениеПоВладельцуОтключено", Новый ОписаниеТипов("Булево"));
	ТаблицаСвойств.Колонки.Добавить("КлючиДоступаПользователей",       Новый ОписаниеТипов("Булево"));
	ТаблицаСвойств.Колонки.Добавить("ЕстьЗависимыеСпискиБезЗаписиКлючейДоступа", Новый ОписаниеТипов("Булево"));
	ТаблицаСвойств.Колонки.Добавить("КлючиДоступаПользователейИГруппДоступа",    Новый ОписаниеТипов("Булево"));
	
	СпискиСОграничением = Новый Соответствие(Контекст.ОбщийКонтекст.СпискиСОграничением);
	СпискиСОтключеннымОграничением       = Новый Соответствие;
	СпискиСОтключеннымОграничениемЧтения = Новый Соответствие;
	
	Для Каждого ОписаниеСписка Из СпискиСОграничением Цикл
		ПолноеИмя = ОписаниеСписка.Ключ;
		
		Если ТипЗнч(ОписаниеСписка.Значение) = Тип("Булево") Тогда
			Свойства = ТаблицаСвойств.Добавить();
			Свойства.ПолноеИмя = ПолноеИмя;
			СпискиСОграничением.Вставить(ПолноеИмя, Свойства);
			Параметры = ПараметрыОграниченияДляВидаПользователей(ПолноеИмя, Контекст);
			Свойства.Параметры = Параметры;
		Иначе
			Свойства = ОписаниеСписка.Значение;
			Параметры = Свойства.Параметры;
		КонецЕсли;
		
		Если Параметры.ОграничениеЧтенияОтключено Тогда
			СпискиСОтключеннымОграничениемЧтения.Вставить(ПолноеИмя, Истина);
		КонецЕсли;
		Если Параметры.ОграничениеОтключено Тогда
			СпискиСОтключеннымОграничением.Вставить(ПолноеИмя, Истина);
		КонецЕсли;
		Если Параметры.ЕстьОграничениеПоПользователям Тогда
			Свойства.КлючиДоступаПользователей = Истина;
			УстановитьСвойствоОграничения(ПолноеИмя, "РассчитыватьПраваПользователей", Истина, Контекст);
		КонецЕсли;
		Если Параметры.ИспользуетсяОграничениеПоВладельцу Тогда
			УстановитьСвойствоОграничения(ПолноеИмя, "ПолеВладельца", Параметры.ПолеВладельца, Контекст);
		КонецЕсли;
		
		ВедущиеСписки = Параметры.ВедущиеСписки;
		Если ВедущиеСписки.ПоКлючамДоступа.Количество() > 0 Тогда
			Свойства.Зависимый = Истина;
			Для Каждого КлючИЗначение Из ВедущиеСписки.ПоКлючамДоступа Цикл
				ВедущийСписок = КлючИЗначение.Ключ;
				Свойства.Ведущие.Добавить(ВедущийСписок);
				СвойстваВедущего = СпискиСОграничением.Получить(ВедущийСписок);
				Если СвойстваВедущего = Неопределено Или ТипЗнч(СвойстваВедущего) = Тип("Булево") Тогда
					СвойстваВедущего = ТаблицаСвойств.Добавить();
					СвойстваВедущего.ПолноеИмя = ВедущийСписок;
					СпискиСОграничением.Вставить(ВедущийСписок, СвойстваВедущего);
					ПараметрыВедущего = ПараметрыОграниченияДляВидаПользователей(ВедущийСписок, Контекст);
					СвойстваВедущего.Параметры = ПараметрыВедущего;
					Если ПараметрыВедущего.ОграничениеЧтенияОтключено Тогда
						СпискиСОтключеннымОграничениемЧтения.Вставить(ВедущийСписок, Истина);
					КонецЕсли;
					Если ПараметрыВедущего.ОграничениеОтключено Тогда
						СпискиСОтключеннымОграничением.Вставить(ВедущийСписок, Истина);
					КонецЕсли;
					Если ПараметрыВедущего.ЕстьОграничениеПоПользователям Тогда
						СвойстваВедущего.КлючиДоступаПользователей = Истина;
						УстановитьСвойствоОграничения(ВедущийСписок, "РассчитыватьПраваПользователей", Истина, Контекст);
					КонецЕсли;
					Если ПараметрыВедущего.ИспользуетсяОграничениеПоВладельцу Тогда
						УстановитьСвойствоОграничения(ВедущийСписок, "ПолеВладельца", ПараметрыВедущего.ПолеВладельца, Контекст);
					КонецЕсли;
				КонецЕсли;
				СвойстваВедущего.Ведущий = Истина;
				СвойстваВедущего.Зависимые.Добавить(ПолноеИмя);
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	МаксимальныйУровень = 0;
	Строки = ТаблицаСвойств.НайтиСтроки(Новый Структура("Зависимый, Ведущий", Ложь, Истина));
	Для Каждого Строка Из Строки Цикл
		УстановитьУровеньЗависимыхСписков(Строка, СпискиСОграничением, Новый Массив, МаксимальныйУровень);
	КонецЦикла;
	// Обработка зависимых списков, ведущих для самих себя (зацикленных на себя).
	Строки = ТаблицаСвойств.НайтиСтроки(Новый Структура("Обработан", Ложь));
	Для Каждого Строка Из Строки Цикл
		УстановитьУровеньЗависимыхСписков(Строка, СпискиСОграничением, Новый Массив, МаксимальныйУровень);
	КонецЦикла;
	
	Строки = ТаблицаСвойств.НайтиСтроки(Новый Структура("Зависимый, Ведущий", Истина, Ложь));
	Для Каждого Строка Из Строки Цикл
		НастроитьОптимизациюПоПолюВладельцу(Строка, СпискиСОграничением, Контекст);
	КонецЦикла;
	
	// Сокращение зависимостей по ключам доступа зависимых объектов.
	СпискиСЗаписьюКлючейДляЗависимыхСписковБезКлючей = Новый Соответствие;
	Отбор = Новый Структура("ЕстьЗависимыеСпискиБезЗаписиКлючейДоступа", Истина);
	Строки = ТаблицаСвойств.НайтиСтроки(Отбор);
	Для Каждого Строка Из Строки Цикл
		СпискиСЗаписьюКлючейДляЗависимыхСписковБезКлючей.Вставить(Строка.ПолноеИмя, Истина);
	КонецЦикла;
	ДополнительныйКонтекст = Контекст.ДополнительныйКонтекст;
	ДополнительныйКонтекст.СпискиСОтключеннымОграничениемЧтения = СпискиСОтключеннымОграничениемЧтения;
	ДополнительныйКонтекст.СпискиСОтключеннымОграничением       = СпискиСОтключеннымОграничением;
	ДополнительныйКонтекст.СпискиСЗаписьюКлючейДляЗависимыхСписковБезКлючей
		= СпискиСЗаписьюКлючейДляЗависимыхСписковБезКлючей;
	
	Отбор = Новый Структура("Уровень, ЕстьЗависимыеСпискиБезЗаписиКлючейДоступа", 0, Истина);
	Строки = ТаблицаСвойств.НайтиСтроки(Отбор);
	Для Каждого Строка Из Строки Цикл
		Строка.Параметры = ПараметрыОграниченияДляВидаПользователей(Строка.ПолноеИмя, Контекст);
	КонецЦикла;
	
	СвойстваСписковПоУровням = Новый Массив;
	Для Уровень = 1 По МаксимальныйУровень Цикл
		СвойстваСписков = ТаблицаСвойств.НайтиСтроки(Новый Структура("Уровень", Уровень));
		СвойстваСписковПоУровням.Добавить(СвойстваСписков);
	КонецЦикла;
	
	ОбщийКонтекстСпискиСОграничением = Контекст.ОбщийКонтекст.СпискиСОграничением;
	
	Для Каждого СвойстваСписков Из СвойстваСписковПоУровням Цикл
		Для Каждого СвойстваСписка Из СвойстваСписков Цикл
			
			ВсеВедущиеСпискиСОграничением = Истина;
			ИзмененоСвойствоРассчитыватьПраваПользователей = Ложь;
			КлючиДоступаПользователей = Ложь;
			КлючиДоступаГруппДоступа = Ложь;
			
			Для Каждого Ведущий Из СвойстваСписка.Ведущие Цикл
				СвойстваВедущего = СпискиСОграничением.Получить(Ведущий);
				Если СвойстваВедущего.КлючиДоступаПользователей Тогда
					КлючиДоступаПользователей = Истина;
				Иначе
					КлючиДоступаГруппДоступа = Истина;
				КонецЕсли;
				Если ОбщийКонтекстСпискиСОграничением.Получить(Ведущий) = Неопределено
				 Или СпискиСОтключеннымОграничением.Получить(Ведущий) <> Неопределено Тогда
					ВсеВедущиеСпискиСОграничением = Ложь;
				КонецЕсли;
			КонецЦикла;
			
			Если КлючиДоступаПользователей Тогда
				Если Не СвойстваСписка.ОграничениеПоВладельцуВключено
				   И Не СвойстваСписка.КлючиДоступаПользователей Тогда
					
					ИзмененоСвойствоРассчитыватьПраваПользователей = Истина;
					УстановитьСвойствоОграничения(СвойстваСписка.ПолноеИмя,
						"РассчитыватьПраваПользователей", Истина, Контекст);
				КонецЕсли;
				СвойстваСписка.КлючиДоступаПользователей = Истина;
				Если КлючиДоступаГруппДоступа Тогда
					СвойстваСписка.КлючиДоступаПользователейИГруппДоступа = Истина;
				КонецЕсли;
			КонецЕсли;
			
			Если СвойстваСписка.ОграничениеПоВладельцуВключено
			   И ВсеВедущиеСпискиСОграничением
			   И Не ИзмененоСвойствоРассчитыватьПраваПользователей Тогда
				Продолжить;
			КонецЕсли;
			
			СвойстваСписка.Параметры =
				ПараметрыОграниченияДляВидаПользователей(СвойстваСписка.ПолноеИмя, Контекст);
		КонецЦикла;
	КонецЦикла;
	
	// Заполнение хранимых свойств списков.
	Для Каждого СвойстваСписка Из ТаблицаСвойств Цикл
		ПолноеИмя = СвойстваСписка.ПолноеИмя;
		ОбновитьВерсиюПараметров = Ложь;
		
		Если СвойстваСписка.Параметры.ДоступЗапрещен Тогда
			УстановитьСвойствоОграничения(ПолноеИмя, "ДоступЗапрещен", Истина, Контекст);
		КонецЕсли;
		Если ЗначениеЗаполнено(СвойстваСписка.Параметры.ИмяОтдельногоРегистраКлючей) Тогда
			УстановитьСвойствоОграничения(ПолноеИмя,
				"ИмяОтдельногоРегистраКлючей", СвойстваСписка.Параметры.ИмяОтдельногоРегистраКлючей, Контекст);
		КонецЕсли;
		Если ЗначениеЗаполнено(СвойстваСписка.Параметры.ОпорныеПоля) Тогда
			ОпорныеПоля = Новый Структура("Все, ТипыВсех, Используемые");
			ЗаполнитьЗначенияСвойств(ОпорныеПоля, СвойстваСписка.Параметры.ОпорныеПоля);
			УстановитьСвойствоОграничения(ПолноеИмя, "ОпорныеПоля", ОпорныеПоля, Контекст);
		КонецЕсли;
		Если СвойстваСписка.КлючиДоступаПользователейИГруппДоступа Тогда
			УстановитьСвойствоОграничения(ПолноеИмя,
				"ОграничениеВШаблонахЧерезКлючиДоступаПользователейИГруппДоступа", Истина, Контекст);
		ИначеЕсли СвойстваСписка.КлючиДоступаПользователей Тогда
			УстановитьСвойствоОграничения(ПолноеИмя,
				"ОграничениеВШаблонахЧерезКлючиДоступаПользователей", Истина, Контекст);
		КонецЕсли;
		Если СвойстваСписка.Параметры.ОграничениеЧтенияОтключено Тогда
			СпискиСОтключеннымОграничениемЧтения.Вставить(ПолноеИмя, Истина);
		КонецЕсли;
		Если СвойстваСписка.Параметры.ОграничениеОтключено Тогда
			СпискиСОтключеннымОграничением.Вставить(ПолноеИмя, Истина);
		КонецЕсли;
		УстановитьСвойствоОграничения(ПолноеИмя, "ИспользуемыеТипыЗначенийДоступа",
			Новый ХранилищеЗначения(СвойстваСписка.Параметры.ИспользуемыеТипыЗначенийДоступа), Контекст);
		
		Контекст.ВерсииОграниченийСписков.Вставить(ПолноеИмя, СвойстваСписка.Параметры.Версия);
		Если Контекст.ОбщийКонтекст.Свойство("СтрокиВерсииХранимыхПараметров") Тогда
			НоваяСтрока = Контекст.ОбщийКонтекст.СтрокиВерсииХранимыхПараметров.СтрокиВерсийСписков.Добавить();
			НоваяСтрока.Список = СвойстваСписка.ПолноеИмя;
			НоваяСтрока.ДляВнешнихПользователей = Контекст.ДляВнешнихПользователей;
			НоваяСтрока.Версия = СвойстваСписка.Параметры.Версия;
			НоваяСтрока.СтрокаВерсии = СвойстваСписка.Параметры.Контекст.СтрокаСвойствВерсии;
		КонецЕсли;
		
		ВедущиеСписки = СвойстваСписка.Параметры.ВедущиеСписки;
		
		Если ВедущиеСписки.ПоЗначениямПолей.Количество() > 0
		 Или ВедущиеСписки.ПоКлючамДоступа.Количество() > 0
		 Или ВедущиеСписки.ПоЗначениямСГруппами.Количество() > 0 Тогда
			
			Контекст.ВедущиеСписки.Вставить(ПолноеИмя, ВедущиеСписки);
		КонецЕсли;
		
		НастроитьПараметрыШаблонов(СвойстваСписка, Контекст.ПараметрыШаблонов);
		
		Если СвойстваСписка.Параметры.СписокСДатой Тогда
			Контекст.СпискиСДатой.Вставить(СвойстваСписка.ПолноеИмя, Истина);
		КонецЕсли;
		
		Для Каждого КлючИЗначение Из СвойстваСписка.Параметры.ВсеВидыОграниченийПрав Цикл
			Контекст.ВсеВидыОграниченийПрав.Вставить(СвойстваСписка.ПолноеИмя + "." + КлючИЗначение.Ключ, Истина);
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ХранимыеПараметрыОграниченияДляВидаПользователей.
Функция ПараметрыОграниченияДляВидаПользователей(ПолноеИмя, Контекст)
	
	ОписаниеОграничения = Контекст.ДополнительныйКонтекст.ОписанияОграничений.Получить(ПолноеИмя);
	
	Если ОписаниеОграничения = Неопределено Тогда
		СтруктураОграничения = Неопределено;
	Иначе
		СтруктураОграничения = РассчитаннаяСтруктураОграничения(ПолноеИмя,
			ОписаниеОграничения.Текст, ОписаниеОграничения.ВМодулеМенеджера, Контекст.ДляВнешнихПользователей);
	КонецЕсли;
	
	Возврат ПараметрыОграниченияПоСтруктуреОграничения(ПолноеИмя,
		СтруктураОграничения,
		Контекст.ДляВнешнихПользователей,
		Контекст.ОбщийКонтекст,
		Контекст.ДополнительныйКонтекст);
	
КонецФункции

// Для процедуры ДобавитьХранимыеПараметрыОграниченияДляВидаПользователей.
Процедура УстановитьУровеньЗависимыхСписков(СвойстваВедущегоСписка, СвойстваСписков, ПредыдущиеВедущие,
			МаксимальныйУровень)
	
	ПредыдущиеВедущие.Добавить(СвойстваВедущегоСписка.ПолноеИмя);
	
	Для Каждого ЗависимыйСписок Из СвойстваВедущегоСписка.Зависимые Цикл
		Если ПредыдущиеВедущие.Найти(ЗависимыйСписок) <> Неопределено Тогда
			УчастникиЦикла = "";
			Индекс = ПредыдущиеВедущие.Количество() - 1;
			Пока Истина Цикл
				УчастникиЦикла = "- " + ПредыдущиеВедущие[Индекс] + Символы.ПС + УчастникиЦикла;
				Если ПредыдущиеВедущие[Индекс] = ЗависимыйСписок Тогда
					Прервать;
				КонецЕсли;
				Индекс = Индекс - 1;
			КонецЦикла;
			УчастникиЦикла = УчастникиЦикла + "(!) " + ЗависимыйСписок;
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ограничения доступа, заполненные в процедурах ПриЗаполненииОграниченияДоступа
				           |модулей менеджеров или общем модуле УправлениеДоступомПереопределяемый,
				           |содержат недопустимую циклическую зависимость при использовании функции
				           |ЧтениеОбъектаРазрешено или ИзменениеОбъектаРазрешено в одном или нескольких
				           |списках-участниках цикла:
				           |%1'"), УчастникиЦикла);
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
		СвойстваЗависимогоСписка = СвойстваСписков.Получить(ЗависимыйСписок);
		Если СвойстваЗависимогоСписка.Уровень < СвойстваВедущегоСписка.Уровень + 1 Тогда
			СвойстваЗависимогоСписка.Уровень = СвойстваВедущегоСписка.Уровень + 1;
			Если МаксимальныйУровень < СвойстваЗависимогоСписка.Уровень Тогда
				МаксимальныйУровень = СвойстваЗависимогоСписка.Уровень;
			КонецЕсли;
		КонецЕсли;
		Если Не СвойстваЗависимогоСписка.Ведущий Тогда
			СвойстваЗависимогоСписка.Обработан = Истина;
			Продолжить;
		КонецЕсли;
		УстановитьУровеньЗависимыхСписков(СвойстваЗависимогоСписка, СвойстваСписков, ПредыдущиеВедущие, МаксимальныйУровень);
	КонецЦикла;
	
	ПредыдущиеВедущие.Удалить(ПредыдущиеВедущие.Количество() - 1);
	СвойстваВедущегоСписка.Обработан = Истина;
	
КонецПроцедуры

// Для процедуры ДобавитьХранимыеПараметрыОграниченияДляВидаПользователей.
Процедура НастроитьОптимизациюПоПолюВладельцу(СвойстваЗависимогоСписка, СвойстваСписков, Контекст)
	
	СвойстваЗависимогоСписка.ОграничениеПоВладельцуВозможно =
		СвойстваЗависимогоСписка.Параметры.ПолеВладельца <> Неопределено;
	
	СвойстваЗависимогоСписка.ОграничениеПоВладельцуВключено =
		     СвойстваЗависимогоСписка.ОграничениеПоВладельцуВозможно
		И Не СвойстваЗависимогоСписка.ОграничениеПоВладельцуОтключено;
	
	ЗависимыйСписокСОптимизацией = СвойстваЗависимогоСписка.ОграничениеПоВладельцуВключено;
	
	Для Каждого ВедущийСписок Из СвойстваЗависимогоСписка.Ведущие Цикл
		СвойстваВедущегоСписка = СвойстваСписков.Получить(ВедущийСписок);
		Если СвойстваВедущегоСписка.Параметры.ДоступЗапрещен Тогда
			Продолжить;
		КонецЕсли;
		Если Не СвойстваВедущегоСписка.Зависимый Тогда
			Если ЗависимыйСписокСОптимизацией Тогда
				СвойстваВедущегоСписка.ЕстьЗависимыеСпискиБезЗаписиКлючейДоступа = Истина;
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		Если ЗависимыйСписокСОптимизацией Тогда
			Если СвойстваВедущегоСписка.Параметры.ПолеВладельца <> Неопределено Тогда
				Если СвойстваВедущегоСписка.Параметры.ТребуетсяОграничениеПоВладельцу Тогда
					ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Установлен признак оптимизации ограничения %1, но такая
						           |оптимизация невозможна, так как она требуется для зависимого списка ""%2"".'"),
						"ПоВладельцуБезЗаписиКлючейДоступа" + ?(Контекст.ДляВнешнихПользователей, "ДляВнешнихПользователей", ""),
						СвойстваЗависимогоСписка.ПолноеИмя);
					КонтекстОшибки = Новый Структура("СпискиСОграничением, ОписанияОграничений");
					КонтекстОшибки.Вставить("Список",                  СвойстваВедущегоСписка.ПолноеИмя);
					КонтекстОшибки.Вставить("ОписанияОграничений",     Контекст.ДополнительныйКонтекст.ОписанияОграничений);
					КонтекстОшибки.Вставить("ДляВнешнихПользователей", Контекст.ДляВнешнихПользователей);
					ТекстОшибки = ТекстОшибкиСЗаголовком(ТекстОшибки, КонтекстОшибки);
					ВызватьИсключение ТекстОшибки;
				Иначе
					СвойстваВедущегоСписка.ОграничениеПоВладельцуОтключено = Истина;
					УстановитьСвойствоОграничения(СвойстваВедущегоСписка.ПолноеИмя, "ПолеВладельца", Неопределено, Контекст);
				КонецЕсли;
			КонецЕсли;
			СвойстваВедущегоСписка.ЕстьЗависимыеСпискиБезЗаписиКлючейДоступа = Истина;
		КонецЕсли;
		НастроитьОптимизациюПоПолюВладельцу(СвойстваВедущегоСписка, СвойстваСписков, Контекст);
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ДобавитьХранимыеПараметрыОграниченияДляВидаПользователей.
Процедура УстановитьСвойствоОграничения(ПолноеИмя, ИмяСвойства, ЗначениеСвойства, Контекст)
	
	Свойства = СвойстваОграниченияСписка(ПолноеИмя, Контекст.ДополнительныйКонтекст, Истина);
	
	Свойства[ИмяСвойства] = ЗначениеСвойства;
	
КонецПроцедуры

// Для процедур УстановитьСвойствоОграничения, ЗаполнитьЗапросыПроверкиПравЧтениеИзменение.
Функция СвойстваОграниченияСписка(ПолноеИмя, Контекст, ДобавлятьВКоллекцию = Ложь)
	
	Свойства = Контекст.СвойстваОграниченияСписков.Получить(ПолноеИмя);
	
	Если Свойства = Неопределено Тогда
		Свойства = Новый Структура;
		Свойства.Вставить("ДоступЗапрещен", Ложь);
		Свойства.Вставить("ПолеВладельца",  Неопределено);
		Свойства.Вставить("ОпорныеПоля",    Неопределено);
		Свойства.Вставить("ИмяОтдельногоРегистраКлючей", "");
		Свойства.Вставить("РассчитыватьПраваПользователей", Ложь);
		Свойства.Вставить("ОграничениеВШаблонахЧерезКлючиДоступаПользователей", Ложь);
		Свойства.Вставить("ОграничениеВШаблонахЧерезКлючиДоступаПользователейИГруппДоступа", Ложь);
		Свойства.Вставить("ИспользуемыеТипыЗначенийДоступа", Неопределено);
		Если ДобавлятьВКоллекцию Тогда
			Контекст.СвойстваОграниченияСписков.Вставить(ПолноеИмя, Свойства);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Свойства;
	
КонецФункции

// Для функции ХранимыеПараметрыОграниченияДоступа.
Процедура ДобавитьВедущиеСписки(ВедущиеСписки, ИмяСвойстваВидаПользователей, ЗависимыйСписок,
			ВедущиеСпискиЗависимогоСписка)
	
	Для Каждого ОписаниеВедущегоСписка Из ВедущиеСпискиЗависимогоСписка.ПоЗначениямПолей Цикл
		ВедущийСписок = ТекущиеСвойстваВедущегоСписка(ВедущиеСписки, ОписаниеВедущегоСписка.Ключ);
		ВедущийСписок.ЗависимыеСписки.Вставить(ЗависимыйСписок, Истина);
		ДобавляемыеПоля = ОписаниеВедущегоСписка.Значение;
		
		Если ВедущийСписок.ПоЗначениямПолей = Неопределено Тогда
			ПоЗначениямПолей = Новый Структура;
			ПоЗначениямПолей.Вставить("ЭтоСсылочныйТип", ДобавляемыеПоля.ЭтоСсылочныйТип);
			ПоЗначениямПолей.Вставить("ПоляШапки", ОписаниеПолейВедущегоСписка());
			Если ПоЗначениямПолей.ЭтоСсылочныйТип Тогда
				ПоЗначениямПолей.Вставить("ТабличныеЧасти", Новый Соответствие);
			КонецЕсли;
			ВедущийСписок.ПоЗначениямПолей = ПоЗначениямПолей;
		Иначе
			ПоЗначениямПолей = ВедущийСписок.ПоЗначениямПолей;
		КонецЕсли;
		
		ДобавитьПоляВедущегоСписка(ПоЗначениямПолей.ПоляШапки, ДобавляемыеПоля.ДляОтслеживания.ПоляШапки,
			ДобавляемыеПоля.ДляОтбора.ПоляШапки, ЗависимыйСписок, ИмяСвойстваВидаПользователей);
		
		Для Каждого ТабличнаяЧасть Из ДобавляемыеПоля.ДляОтслеживания.ТабличныеЧасти Цикл
			ОписаниеТабличнойЧасти = ПоЗначениямПолей.ТабличныеЧасти.Получить(ТабличнаяЧасть.Ключ);
			Если ОписаниеТабличнойЧасти = Неопределено Тогда
				ОписаниеТабличнойЧасти = ОписаниеПолейВедущегоСписка();
				ОписаниеТабличнойЧасти.Вставить("Имя", ТабличнаяЧасть.Ключ);
				ПоЗначениямПолей.ТабличныеЧасти.Вставить(ТабличнаяЧасть.Ключ, ОписаниеТабличнойЧасти);
			КонецЕсли;
			ТабличнаяЧастьПоляОтбора = ДобавляемыеПоля.ДляОтбора.ТабличныеЧасти.Получить(ТабличнаяЧасть.Ключ);
			ДобавитьПоляВедущегоСписка(ОписаниеТабличнойЧасти, ТабличнаяЧасть.Значение,
				ТабличнаяЧастьПоляОтбора, ЗависимыйСписок, ИмяСвойстваВидаПользователей);
		КонецЦикла;
	КонецЦикла;
	
	ДобавитьВедущиеСпискиПоВидуЗависимости(ВедущиеСписки,
		ИмяСвойстваВидаПользователей, ЗависимыйСписок, ВедущиеСпискиЗависимогоСписка, "ПоКлючамДоступа");
	
	ДобавитьВедущиеСпискиПоВидуЗависимости(ВедущиеСписки,
		ИмяСвойстваВидаПользователей, ЗависимыйСписок, ВедущиеСпискиЗависимогоСписка, "ПоЗначениямСГруппами");
	
КонецПроцедуры

// Для процедуры ДобавитьВедущиеСписки.
Функция ОписаниеПолейВедущегоСписка()
	
	Описание = Новый Структура;
	Описание.Вставить("ВсеПоля",       Новый Массив);
	Описание.Вставить("ТипыВсехПолей", Новый Соответствие);
	Описание.Вставить("НаборыПолей",   Новый Структура("ДляПользователей, ДляВнешнихПользователей"));
	
	Возврат Описание;
	
КонецФункции

// Для процедуры ДобавитьВедущиеСписки.
Процедура ДобавитьВедущиеСпискиПоВидуЗависимости(ВедущиеСписки, ИмяСвойстваВидаПользователей,
			ЗависимыйСписок, ВедущиеСпискиЗависимогоСписка, ВидЗависимости)
	
	Для Каждого ОписаниеВедущегоСписка Из ВедущиеСпискиЗависимогоСписка[ВидЗависимости] Цикл
		ВедущийСписок = ТекущиеСвойстваВедущегоСписка(ВедущиеСписки, ОписаниеВедущегоСписка.Ключ);
		ВедущийСписок.ЗависимыеСписки.Вставить(ЗависимыйСписок, Истина);
		
		Если ВедущийСписок[ВидЗависимости] = Неопределено Тогда
			Свойства = Новый Структура;
			Свойства.Вставить("ДляПользователей",        Неопределено);
			Свойства.Вставить("ДляВнешнихПользователей", Неопределено);
			ВедущийСписок[ВидЗависимости] = Свойства;
		Иначе
			Свойства = ВедущийСписок[ВидЗависимости];
		КонецЕсли;
		
		Если Свойства[ИмяСвойстваВидаПользователей] = Неопределено Тогда
			Свойства[ИмяСвойстваВидаПользователей] = Новый Массив;
		КонецЕсли;
		
		Свойства[ИмяСвойстваВидаПользователей].Добавить(ЗависимыйСписок);
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ДобавитьВедущиеСписки.
Функция ТекущиеСвойстваВедущегоСписка(ВедущиеСписки, ПолноеИмя)
	
	ВедущийСписок = ВедущиеСписки.Получить(ПолноеИмя);
	Если ВедущийСписок = Неопределено Тогда
		ВедущийСписок = Новый Структура;
		ВедущийСписок.Вставить("ЗависимыеСписки",      Новый Соответствие);
		ВедущийСписок.Вставить("ПоЗначениямПолей",     Неопределено);
		ВедущийСписок.Вставить("ПоКлючамДоступа",      Неопределено);
		ВедущийСписок.Вставить("ПоЗначениямСГруппами", Неопределено);
		ВедущиеСписки.Вставить(ПолноеИмя, ВедущийСписок)
	КонецЕсли;
	
	Возврат ВедущийСписок;
	
КонецФункции

// Для процедуры ДобавитьВедущиеСписки.
Процедура ДобавитьПоляВедущегоСписка(ТекущиеПоля, ОписаниеПолей, ОписаниеПолейОтбора, ЗависимыйСписок,
			ИмяСвойстваВидаПользователей)
	
	СписокПолей = Новый СписокЗначений;
	Для Каждого ОписаниеПоля Из ОписаниеПолей Цикл
		Если ТекущиеПоля.ВсеПоля.Найти(ОписаниеПоля.Ключ) = Неопределено Тогда
			ТекущиеПоля.ВсеПоля.Добавить(ОписаниеПоля.Ключ);
			ТекущиеПоля.ТипыВсехПолей.Вставить(ОписаниеПоля.Ключ, ОписаниеПоля.Значение);
		КонецЕсли;
		СписокПолей.Добавить(ОписаниеПоля.Ключ);
	КонецЦикла;
	СписокПолей.СортироватьПоЗначению();
	НаборПолей = СтрСоединить(СписокПолей.ВыгрузитьЗначения(), ", ");
	
	НаборыПолей = ТекущиеПоля.НаборыПолей[ИмяСвойстваВидаПользователей];
	Если НаборыПолей = Неопределено Тогда
		НаборыПолей = Новый Соответствие;
		ТекущиеПоля.НаборыПолей[ИмяСвойстваВидаПользователей] = НаборыПолей;
	КонецЕсли;
	ЗависимыеСпискиПоПолямОтбора = НаборыПолей.Получить(НаборПолей);
	Если ЗависимыеСпискиПоПолямОтбора = Неопределено Тогда
		ЗависимыеСпискиПоПолямОтбора = Новый Соответствие;
		НаборыПолей.Вставить(НаборПолей, ЗависимыеСпискиПоПолямОтбора);
	КонецЕсли;
	
	СписокПолей = Новый СписокЗначений;
	Для Каждого ОписаниеПоля Из ОписаниеПолейОтбора Цикл
		СписокПолей.Добавить(ОписаниеПоля.Ключ);
	КонецЦикла;
	СписокПолей.СортироватьПоЗначению();
	НаборПолейОтбора = СтрСоединить(СписокПолей.ВыгрузитьЗначения(), ", ");
	
	ЗависимыеСписки = ЗависимыеСпискиПоПолямОтбора.Получить(НаборПолейОтбора);
	Если ЗависимыеСписки = Неопределено Тогда
		ЗависимыеСписки = Новый Массив;
		ЗависимыеСпискиПоПолямОтбора.Вставить(НаборПолейОтбора, ЗависимыеСписки);
	КонецЕсли;
	ЗависимыеСписки.Добавить(ЗависимыйСписок);
	
КонецПроцедуры

// Для процедуры ДобавитьХранимыеПараметрыОграниченияДляВидаПользователей.
Процедура НастроитьПараметрыШаблонов(СвойстваСписка, ПараметрыШаблонов)
	
	Параметры = СвойстваСписка.Параметры;
	Если Параметры.ДоступЗапрещен Тогда
		Возврат;
	КонецЕсли;
	
	Если Параметры.ОграничениеЧтенияОтключено Тогда
		ПараметрыШаблонов.СпискиСОтключеннымОграничениемЧтения =
			ПараметрыШаблонов.СпискиСОтключеннымОграничениемЧтения
				+ СвойстваСписка.ПолноеИмя + Символы.ПС;
		Возврат;
	КонецЕсли;
	
	Если Параметры.ПолеВладельца <> Неопределено Тогда
		Поля = ":" + Параметры.ПолеВладельца.Имя;
		
	ИначеЕсли Параметры.ЭтоСсылочныйТип Тогда
		Поля = ":";
	Иначе
		ОпорныеПоля = Параметры.ОпорныеПоля;
		Если ЗначениеЗаполнено(Параметры.ИмяОтдельногоРегистраКлючей) Тогда
			Поля = "КлючиДоступаКРегистру" + СтрРазделить(СвойстваСписка.ПолноеИмя, ".")[1];
		Иначе
			Поля = УправлениеДоступомСлужебныйПовтИсп.ОписаниеПредопределенногоИдентификатораОбъектаМетаданных(
				СвойстваСписка.ПолноеИмя);
		КонецЕсли;
		Поля = ":[" + Поля + "]";
		Номер = 1;
		НомерИспользуемого = 1;
		Для Каждого ИмяПоля Из ОпорныеПоля.Все Цикл
			Поля = Поля + ":" + ИмяПоля;
			Если ОпорныеПоля.Используемые.Найти(ИмяПоля) <> Неопределено Тогда
				ПараметрыШаблонов.СпискиСОграничениемПоПолям = ПараметрыШаблонов.СпискиСОграничениемПоПолям
					+ СвойстваСписка.ПолноеИмя + ":Поле" + НомерИспользуемого + "=Поле" + Номер + ";" + Символы.ПС;
				НомерИспользуемого = НомерИспользуемого + 1;
			КонецЕсли;
			Номер = Номер + 1;
		КонецЦикла;
		Для Номер = НомерИспользуемого По ОпорныеПоля.МаксимальноеКоличество Цикл
			ПараметрыШаблонов.СпискиСОграничениемПоПолям = ПараметрыШаблонов.СпискиСОграничениемПоПолям
				+ СвойстваСписка.ПолноеИмя + ":Поле" + Номер + "=Null;" + Символы.ПС;
		КонецЦикла;
		НомерПустогоПоля = ОпорныеПоля.Все.Количество() + 1;
		Для Номер = НомерПустогоПоля По ОпорныеПоля.МаксимальноДопустимоеКоличество Цикл
			Поля = Поля + ":";
		КонецЦикла;
	КонецЕсли;
	
	ПараметрыШаблонов.СпискиСОграничениемЧерезКлючиДоступаГруппДоступа =
		ПараметрыШаблонов.СпискиСОграничениемЧерезКлючиДоступаГруппДоступа
			+ СвойстваСписка.ПолноеИмя + Поля + ";*" + Символы.ПС;
	
	Если СвойстваСписка.КлючиДоступаПользователейИГруппДоступа
	 Или СвойстваСписка.КлючиДоступаПользователей Тогда
		
		ПараметрыШаблонов.СпискиСОграничениемЧерезКлючиДоступаПользователей =
			ПараметрыШаблонов.СпискиСОграничениемЧерезКлючиДоступаПользователей
				+ СвойстваСписка.ПолноеИмя + Поля + ";+" + Символы.ПС;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры УстановитьВерсиюПараметров, и для функции ХранимыеПараметрыОграниченияДоступа.
Функция СтруктураХранимыхПараметровЗаписи(Значения = "Создать")
	
	ХранимыеПараметрыЗаписи = Новый Структура;
	ХранимыеПараметрыЗаписи.Вставить("ВерсияСтруктурыКэша",         ?(Значения = "Создать", ВерсияСтруктурыКэша(), ""));
	ХранимыеПараметрыЗаписи.Вставить("ВерсииОграниченийСписков",    Новый Соответствие);
	ХранимыеПараметрыЗаписи.Вставить("ВедущиеСписки",               Новый Соответствие);
	ХранимыеПараметрыЗаписи.Вставить("ДополнительныйКонтекст",      Новый Структура);
	ХранимыеПараметрыЗаписи.Вставить("СпискиСДатой",                Новый Соответствие);
	ХранимыеПараметрыЗаписи.Вставить("ВнешниеПользователиВключены", Ложь);
	ХранимыеПараметрыЗаписи.Вставить("ОграничениеДоступаВключено",  Ложь);
	ХранимыеПараметрыЗаписи.Вставить("ИспользуемыеТипыЗначений",    Новый ХранилищеЗначения(Новый Соответствие));
	
	Если ТипЗнч(Значения)                             = Тип("ФиксированнаяСтруктура")
	   И Значения.Свойство("ВерсияСтруктурыКэша")
	   И ТипЗнч(Значения.ВерсияСтруктурыКэша)         = Тип("Строка")
	   И Значения.Свойство("ВерсииОграниченийСписков")
	   И ТипЗнч(Значения.ВерсииОграниченийСписков)    = Тип("ФиксированноеСоответствие")
	   И Значения.Свойство("ВедущиеСписки")
	   И ТипЗнч(Значения.ВедущиеСписки)               = Тип("ФиксированноеСоответствие")
	   И Значения.Свойство("ДополнительныйКонтекст")
	   И ТипЗнч(Значения.ДополнительныйКонтекст)      = Тип("ФиксированнаяСтруктура")
	   И Значения.Свойство("СпискиСДатой")
	   И ТипЗнч(Значения.СпискиСДатой)                = Тип("ФиксированноеСоответствие")
	   И Значения.Свойство("ВнешниеПользователиВключены")
	   И ТипЗнч(Значения.ВнешниеПользователиВключены) = Тип("Булево")
	   И Значения.Свойство("ОграничениеДоступаВключено")
	   И ТипЗнч(Значения.ОграничениеДоступаВключено)  = Тип("Булево")
	   И Значения.Свойство("ИспользуемыеТипыЗначений")
	   И ТипЗнч(Значения.ИспользуемыеТипыЗначений)    = Тип("ХранилищеЗначения") Тогда
		
		ЗаполнитьЗначенияСвойств(ХранимыеПараметрыЗаписи, Значения);
	КонецЕсли;
	
	Возврат ?(Значения = "Создать", ХранимыеПараметрыЗаписи,
		Новый ФиксированнаяСтруктура(ХранимыеПараметрыЗаписи));
	
КонецФункции

// Для процедуры УстановитьВерсиюПараметров, и для функции ХранимыеПараметрыОграниченияДоступа.
Функция СтруктураХранимыхПараметровШаблонов(Значения = "Создать")
	
	ХранимыеПараметрыШаблонов = Новый Структура;
	ХранимыеПараметрыШаблонов.Вставить("ВерсияСтруктурыКэша", ?(Значения = "Создать", ВерсияСтруктурыКэша(), ""));
	ХранимыеПараметрыШаблонов.Вставить("ВерсииШаблонов",      ВерсииШаблоновОграниченияДоступа());
	ХранимыеПараметрыШаблонов.Вставить("ПараметрыШаблонов",   СтруктураПараметровШаблонов());
	
	Если ТипЗнч(Значения)                     = Тип("ФиксированнаяСтруктура")
	   И Значения.Свойство("ВерсияСтруктурыКэша")
	   И ТипЗнч(Значения.ВерсияСтруктурыКэша) = Тип("Строка")
	   И Значения.Свойство("ВерсииШаблонов")
	   И ТипЗнч(Значения.ВерсииШаблонов)      = Тип("Строка")
	   И Значения.Свойство("ПараметрыШаблонов")
	   И ТипЗнч(Значения.ПараметрыШаблонов)   = Тип("ФиксированнаяСтруктура") Тогда
		
		ЗаполнитьЗначенияСвойств(ХранимыеПараметрыШаблонов, Значения);
	КонецЕсли;
	
	Возврат ?(Значения = "Создать", ХранимыеПараметрыШаблонов,
		Новый ФиксированнаяСтруктура(ХранимыеПараметрыШаблонов));
	
КонецФункции

// Для процедуры УстановитьВерсиюПараметров и для функций ХранимыеПараметрыОграниченияДоступа,
// СтруктураХранимыхПараметровШаблонов.
Функция СтруктураПараметровШаблонов(Значения = Неопределено)
	
	ПараметрыШаблонов = Новый Структура;
	ПараметрыШаблонов.Вставить("СпискиСОграничениемЧерезКлючиДоступаГруппДоступа", "");
	ПараметрыШаблонов.Вставить("СпискиСОграничениемЧерезКлючиДоступаПользователей", "");
	ПараметрыШаблонов.Вставить("СпискиСОграничениемПоПолям", "");
	ПараметрыШаблонов.Вставить("СпискиСОтключеннымОграничениемЧтения", "");
	
	Если ТипЗнч(Значения) <> Тип("ФиксированнаяСтруктура")
	 Или Значения.Количество() <> ПараметрыШаблонов.Количество() Тогда
		
		Возврат ПараметрыШаблонов;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из ПараметрыШаблонов Цикл
		Если Не Значения.Свойство(КлючИЗначение.Ключ)
		 Или Не ТипЗнч(Значения[КлючИЗначение.Ключ]) = ТипЗнч(КлючИЗначение.Значение) Тогда
			Возврат ПараметрыШаблонов;
		КонецЕсли;
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(ПараметрыШаблонов, Значения);
	
	Возврат ПараметрыШаблонов;
	
КонецФункции

// Для процедуры УстановитьВерсиюПараметров, и для функции ХранимыеПараметрыОграниченияДоступа.
Функция СтруктураХранимыхПараметровОтчета(Значения = "Создать")
	
	ХранимыеПараметрыОтчета = Новый Структура;
	ХранимыеПараметрыОтчета.Вставить("ВерсияСтруктурыКэша", ?(Значения = "Создать", ВерсияСтруктурыКэша(), ""));
	ХранимыеПараметрыОтчета.Вставить("ВсеВидыОграниченийПрав", "");
	
	Если ТипЗнч(Значения)                        = Тип("ФиксированнаяСтруктура")
	   И Значения.Свойство("ВерсияСтруктурыКэша")
	   И ТипЗнч(Значения.ВерсияСтруктурыКэша)    = Тип("Строка")
	   И Значения.Свойство("ВсеВидыОграниченийПрав")
	   И ТипЗнч(Значения.ВсеВидыОграниченийПрав) = Тип("Строка") Тогда
		
		ЗаполнитьЗначенияСвойств(ХранимыеПараметрыОтчета, Значения);
	КонецЕсли;
	
	Возврат ?(Значения = "Создать", ХранимыеПараметрыОтчета,
		Новый ФиксированнаяСтруктура(ХранимыеПараметрыОтчета));
	
КонецФункции

#КонецОбласти

#Область ПараметрыОграниченияДоступаДляСпискаОтдельно

// Основная функция области, возвращающая параметры ограничения доступа
// для вида пользователей списка без учета зависимости от других списков,
// как по ключам доступа, так и по наличию видов доступа Пользователи и ВнешниеПользователи.
//
Функция ПараметрыОграниченияПоСтруктуреОграничения(Список, СтруктураОграничения,
			ДляВнешнихПользователей, ОбщийКонтекст, ДополнительныйКонтекст)
	
	ВедущиеСписки = Новый Структура;
	// Списки с полями, от которых зависит ограничение доступа (для регистрации заданий обновления).
	ВедущиеСписки.Вставить("ПоЗначениямПолей", Новый Соответствие);
	// Списки от ключей доступа которых зависит ограничение доступа (для установки параметров сеанса и
	// регистрации заданий обновления).
	ВедущиеСписки.Вставить("ПоКлючамДоступа",  Новый Соответствие);
	// Списки значений доступа с группами, от которых зависит ограничение доступа (для регистрации заданий обновления).
	ВедущиеСписки.Вставить("ПоЗначениямСГруппами", Новый Соответствие);
	
	Результат = Новый Структура;
	// Полное имя таблицы объекта метаданных.
	Результат.Вставить("Список", Список);
	// Вид пользователей, для которых предназначены параметры.
	Результат.Вставить("ДляВнешнихПользователей", ДляВнешнихПользователей);
	// Хеш-сумма параметров ограничения доступа для отслеживания их изменения.
	Результат.Вставить("Версия", "");
	// Списки с полями от которых зависит ограничение доступа.
	Результат.Вставить("ВедущиеСписки", ВедущиеСписки);
	// Истина, если текст ограничения "ГДЕ ЛОЖЬ", а также не указан для внешних пользователей.
	Результат.Вставить("ДоступЗапрещен", ДляВнешнихПользователей);
	// Истина, если текст ограничения не указан или указан, но ограничение отключено
	// из-за отключения использования видов доступа, задействованных в нем.
	Результат.Вставить("ОграничениеОтключено", Не ДляВнешнихПользователей);
	// Истина, если текст ограничения чтения не указан или указан, но ограничение отключено
	// из-за отключения использования видов доступа, задействованных в нем.
	Результат.Вставить("ОграничениеЧтенияОтключено", Не ДляВнешнихПользователей);
	
	// Поле владельца, когда возможно ограничение только по объекту-владельцу.
	Результат.Вставить("ПолеВладельца");
	// Признак оптимизации, указанный разработчиком рядом с текстом ограничения.
	Результат.Вставить("ТребуетсяОграничениеПоВладельцу", Ложь);
	
	// Признак использования оптимизации, вычисленный на втором проходе графа.
	Результат.Вставить("ИспользуетсяОграничениеПоВладельцу", Ложь);
	// Признак расчета прав на ключи доступа для пользователей, а не для групп доступа, вычисленный на втором
	// проходе графа. Имеет смысл только, когда признак ИспользуетсяОграничениеПоВладельцу = Ложь.
	Результат.Вставить("РассчитыватьПраваПользователей", Ложь);
	// Признак того, что ведущий список должен записывать ключи для зависимых списков,
	// которые не записывают своих ключей. Признак вычисляется на втором проходе графа.
	Результат.Вставить("ЕстьЗависимыеСпискиБезЗаписиКлючейДоступа", Ложь);
	// Признак, вычисленный на втором проходе графа. Когда ЕстьЗависимыеСпискиБезЗаписиКлючейДоступа = Истина, тогда
	// показывает наличие права Чтение в одной из ролей БазовыеПрава* или БазовыеПраваВнешнихПользователей*.
	Результат.Вставить("ЧтениеРазрешеноДляВсехПользователей", Ложь);
	// Признак, вычисленный на втором проходе графа. Когда ЕстьЗависимыеСпискиБезЗаписиКлючейДоступа = Истина, тогда
	// показывает наличие права Изменение в одной из ролей БазовыеПрава* или БазовыеПраваВнешнихПользователей*.
	Результат.Вставить("ИзменениеРазрешеноДляВсехПользователей", Ложь);
	
	// Признак наличия ведущих ключей доступа в ограничении.
	Результат.Вставить("ЕстьВедущиеКлючиДоступа", Ложь);
	// Признак наличия ведущих списков по правам в ограничении.
	Результат.Вставить("ЕстьВедущиеСпискиПоПравам", Ложь);
	
	// Типы владельцев настроек прав, используемые при расчете прав на ключи доступа.
	Результат.Вставить("ТипыВладельцевНастроекПрав", ОбщийКонтекст.ТипыВладельцевНастроекПрав);
	// Идентификатор списка, если для него используются отдельные настройки прав или пустой идентификатор.
	Результат.Вставить("ИдентификаторТаблицыНастроекПрав", Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка());
	// Признак наличия ограничения по владельцу настроек прав.
	Результат.Вставить("ЕстьВладельцыНастроекПрав", Ложь);
	// Описание типов значений доступа, которые используются в ограничении доступа.
	Результат.Вставить("ИспользуемыеТипыЗначенийДоступа", Новый Массив);
	// Все виды ограничений прав (без учета использования).
	Результат.Вставить("ВсеВидыОграниченийПрав", Новый Соответствие);
	
	Результат.Вставить("ИмяОтдельногоРегистраКлючей", ""); // Для регистров.
	Результат.Вставить("ОпорныеПоля"); // Для регистров.
	
	// Число, описывающее реквизиты, используемые в ключе.
	Результат.Вставить("СоставПолей");
	
	// Установлено, если ограничение чтения отличается от "ГДЕ ИСТИНА".
	Результат.Вставить("ЕстьОграничениеЧтения", Ложь);
	// Установлено, если ограничение изменения отличается от "ГДЕ ИСТИНА".
	Результат.Вставить("ЕстьОграничениеИзменения", Ложь);
	
	// Установлено, если проверяются значения Пользователь или ГруппаПользователей
	// или ВнешнийПользователь или ГруппаВнешнихПользователей
	// для функций ЗначениеРазрешено или ЭтоАвторизованныйПользователь.
	Результат.Вставить("ЕстьОграничениеПоПользователям", Ложь);
	
	
	// Содержит структуру ограничения, приведенную к формату размещения значений в ключах доступа.
	Результат.Вставить("СтруктураРасчетаПраваЧтение",    Новый Структура);
	Результат.Вставить("СтруктураРасчетаПраваИзменение", Новый Структура);
	
	ИмяКоллекцииТипа = "";
	Результат.Вставить("ЭтоСсылочныйТип", ?(ЗначениеЗаполнено(Список),
		ЭтоСсылочныйТипТаблицы(Список, ИмяКоллекцииТипа), Ложь));
	
	Результат.Вставить("СписокСДатой",
		    ИмяКоллекцииТипа = "Документы"
		Или ИмяКоллекцииТипа = "БизнесПроцессы"
		Или ИмяКоллекцииТипа = "Задачи");
	
	Если ИмяКоллекцииТипа = "РегистрыСведений" Тогда
		МетаданныеРегистра = Метаданные.РегистрыСведений[СтрРазделить(Список, ".")[1]];
		Результат.Вставить("СписокСПериодом",
			МетаданныеРегистра.ПериодичностьРегистраСведений
				<> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический);
	Иначе
		Результат.Вставить("СписокСПериодом",
			    ИмяКоллекцииТипа = "РегистрыНакопления"
			Или ИмяКоллекцииТипа = "РегистрыБухгалтерии"
			Или ИмяКоллекцииТипа = "РегистрыРасчета");
	КонецЕсли;
	
	Контекст = Новый Структура("СтрокаСвойствВерсии", "");
	Результат.Вставить("Контекст", Контекст);
	
	Для Каждого КлючИЗначение Из ОбщийКонтекст Цикл
		Контекст.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	Для Каждого КлючИЗначение Из ДополнительныйКонтекст Цикл
		Контекст.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	
	Контекст.Вставить("Список",                  Список);
	Контекст.Вставить("ДляВнешнихПользователей", ДляВнешнихПользователей);
	Контекст.Вставить("ЭтоСсылочныйТип",         Результат.ЭтоСсылочныйТип);
	Контекст.Вставить("СписокСДатой",            Результат.СписокСДатой);
	Контекст.Вставить("СписокСПериодом",         Результат.СписокСПериодом);
	Контекст.Вставить("ИмяКоллекцииТипа",        ИмяКоллекцииТипа);
	Контекст.Вставить("СвойстваВерсии",          Новый Массив);
	
	ДобавитьСвойствоВерсии(Контекст, Контекст, "Список");
	ДобавитьСвойствоВерсии(Контекст, Контекст, "ДляВнешнихПользователей");
	
	ОписаниеОграничения = Контекст.ОписанияОграничений.Получить(Контекст.Список);
	Если ОписаниеОграничения = Неопределено Тогда
		ОписаниеОграничения = Новый Структура("Текст", "");
	КонецЕсли;
	ДобавитьСвойствоВерсии(Контекст, ОписаниеОграничения, "Текст");
	
	ДобавитьСвойствоВерсии(Контекст, Контекст, "ЭтоСсылочныйТип");
	ДобавитьСвойствоВерсии(Контекст, Контекст, "СписокСДатой");
	
	// Опорные поля не требуется для ссылочных типов данных (всегда Ссылка).
	ЗаполнитьНовоеОписаниеОпорныхПолей(Результат, Контекст);
	
	Если Контекст.СпискиСЗаписьюКлючейДляЗависимыхСписковБезКлючей <> Неопределено Тогда
		Свойства = СвойстваОграниченияСписка(Контекст.Список, Контекст);
		Результат.ИспользуетсяОграничениеПоВладельцу        = Свойства.ПолеВладельца <> Неопределено;
		Результат.РассчитыватьПраваПользователей            = Свойства.РассчитыватьПраваПользователей;
		Если Контекст.СпискиСЗаписьюКлючейДляЗависимыхСписковБезКлючей.Получить(Список) <> Неопределено Тогда
			Результат.ЕстьЗависимыеСпискиБезЗаписиКлючейДоступа = Истина;
			ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(Список);
			Результат.ЧтениеРазрешеноДляВсехПользователей =
				ПравоРазрешеноДляВсехПользователей("Чтение",    ОбъектМетаданных, ДляВнешнихПользователей);
			Результат.ИзменениеРазрешеноДляВсехПользователей =
				ПравоРазрешеноДляВсехПользователей("Изменение", ОбъектМетаданных, ДляВнешнихПользователей);
		КонецЕсли;
	КонецЕсли;
	Контекст.Вставить("ИспользуетсяОграничениеПоВладельцу",        Результат.ИспользуетсяОграничениеПоВладельцу);
	Контекст.Вставить("РассчитыватьПраваПользователей",            Результат.РассчитыватьПраваПользователей);
	Контекст.Вставить("ЕстьЗависимыеСпискиБезЗаписиКлючейДоступа", Результат.ЕстьЗависимыеСпискиБезЗаписиКлючейДоступа);
	Контекст.Вставить("ЧтениеРазрешеноДляВсехПользователей",       Результат.ЧтениеРазрешеноДляВсехПользователей);
	Контекст.Вставить("ИзменениеРазрешеноДляВсехПользователей",    Результат.ИзменениеРазрешеноДляВсехПользователей);
	
	Если СтруктураОграничения = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;
	
	Контекст.Вставить("СтруктураОграничения",                    СтруктураОграничения);
	Контекст.Вставить("ВедущиеСпискиПоЗначениямПолей",           ОписаниеВедущихСписковПоЗначениямПолей());
	Контекст.Вставить("ВедущиеСпискиПоКлючамДоступа",            ОписаниеВедущихСписковПоПолюСсылка());
	Контекст.Вставить("ВедущиеСпискиПоЗначениямСГруппами",       ОписаниеВедущихСписковПоПолюСсылка());
	Контекст.Вставить("ЕстьПроверкаАвторизованногоПользователя", Ложь);
	Контекст.Вставить("НеиспользуемыеТипыЗначенийДоступа",       Новый Массив);
	Контекст.Вставить("ВсеВидыОграниченийПрав",                  Результат.ВсеВидыОграниченийПрав);
	
	ЗаполнитьСвойстваПолей(Контекст);
	
	Если ДляВнешнихПользователей И Не ОбщийКонтекст.ВнешниеПользователиВключены Тогда
		Возврат Результат;
	КонецЕсли;
	
	Результат.ДоступЗапрещен = Ложь;
	Результат.ОграничениеОтключено = Истина;
	Результат.ОграничениеЧтенияОтключено = Истина;
	
	ЗаполнитьНаличиеОграниченияПоПравам(Контекст, Результат);
	ЗаполнитьОграничениеПоОбъектуВладельцу(Результат, Контекст);
	ЗаполнитьНаличиеВедущихКлючейИСписковИВладельцевНастроекПрав(Результат, Контекст);
	УдалитьПоляНеиспользуемыхВидовДоступа(Результат, Контекст);
	ЗаполнитьНаличиеОграниченияПоВидуДоступаПользователи(Результат, Контекст);
	ЗаполнитьНаличиеОграниченияЧтения(Результат, Контекст);
	
	Контекст.Вставить("ЕстьОграничениеПоПользователям", Результат.ЕстьОграничениеПоПользователям);
	
	Если Контекст.СпискиСЗаписьюКлючейДляЗависимыхСписковБезКлючей = Неопределено Тогда
		Результат.ИспользуетсяОграничениеПоВладельцу = Результат.ПолеВладельца <> Неопределено;
		Результат.РассчитыватьПраваПользователей     = Результат.ЕстьОграничениеПоПользователям;
		
		Контекст.Вставить("ИспользуетсяОграничениеПоВладельцу", Результат.ИспользуетсяОграничениеПоВладельцу);
		Контекст.Вставить("РассчитыватьПраваПользователей",     Результат.РассчитыватьПраваПользователей);
	КонецЕсли;
	ДобавитьСвойствоВерсии(Контекст, Контекст, "ИспользуетсяОграничениеПоВладельцу");
	ДобавитьСвойствоВерсии(Контекст, Контекст, "РассчитыватьПраваПользователей");
	ДобавитьСвойствоВерсии(Контекст, Контекст, "ЕстьЗависимыеСпискиБезЗаписиКлючейДоступа");
	ДобавитьСвойствоВерсии(Контекст, Контекст, "ЧтениеРазрешеноДляВсехПользователей");
	ДобавитьСвойствоВерсии(Контекст, Контекст, "ИзменениеРазрешеноДляВсехПользователей");
	
	Контекст.Вставить("ГруппыПолей");
	Контекст.Вставить("ПсевдонимыТабличныхЧастейОбъекта");
	Контекст.Вставить("ГруппыДополнительныхТаблиц");
	Контекст.Вставить("КоличествоТабличныхЧастейКлюча");
	
	ЗаполнитьГруппыПолейИДополнительныхТаблиц(Контекст);
	
	Если Контекст.СвойстваПолей.Количество() = 0 Тогда // Ограничение отключено.
		Возврат Результат;
	КонецЕсли;
	
	Результат.ОграничениеОтключено = Ложь;
	
	Результат.СоставПолей = Контекст.СоставПолей;
	
	Контекст.Вставить("ИмяПрава", "Чтение");
	ЗаполнитьСтруктуруРасчетаПрава(Результат.СтруктураРасчетаПраваЧтение,
		Контекст.СтруктураОграничения.ОграничениеЧтения, Контекст);
	
	Контекст.Вставить("ИмяПрава", "Изменение");
	ЗаполнитьСтруктуруРасчетаПрава(Результат.СтруктураРасчетаПраваИзменение,
		Контекст.СтруктураОграничения.ОграничениеИзменения, Контекст);
	
	Контекст.Удалить("ИмяПрава");
	
	Если Не Контекст.ЭтоСсылочныйТип Тогда
		Результат.ИмяОтдельногоРегистраКлючей = Контекст.ИмяОтдельногоРегистраКлючей;
	КонецЕсли;
	
	Если Результат.ИспользуетсяОграничениеПоВладельцу Тогда
		Контекст.ВедущиеСпискиПоЗначениямПолей = ОписаниеВедущихСписковПоЗначениямПолей();
	КонецЕсли;
	ВедущиеСписки.ПоЗначениямПолей     = Контекст.ВедущиеСпискиПоЗначениямПолей.Поля;
	ВедущиеСписки.ПоКлючамДоступа      = Контекст.ВедущиеСпискиПоКлючамДоступа.Списки;
	ВедущиеСписки.ПоЗначениямСГруппами = Контекст.ВедущиеСпискиПоЗначениямСГруппами.Списки;
	
	ХешированиеДанных = Новый ХешированиеДанных(ХешФункция.SHA256);
	СтрокаСвойствВерсии = СтрСоединить(Контекст.СвойстваВерсии, Символы.ПС);
	Контекст.СтрокаСвойствВерсии = СтрокаСвойствВерсии;
	ХешированиеДанных.Добавить(СтрокаСвойствВерсии);
	Результат.Версия = Base64Строка(ХешированиеДанных.ХешСумма);
	
	Возврат Результат;
	
КонецФункции

// Для процедуры ПараметрыОграниченияПоСтруктуреОграничения.
Функция ПравоРазрешеноДляВсехПользователей(ИмяПрава, ОбъектМетаданных, ДляВнешнихПользователей)
	
	Если ОбъектМетаданных = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ИменаРолейБазовыеПрава = УправлениеДоступомСлужебныйПовтИсп.ИменаРолейБазовыеПрава(ДляВнешнихПользователей);
	МетаданныеРоли = Метаданные.Роли;
	
	Для Каждого ИмяРоли Из ИменаРолейБазовыеПрава Цикл
		Если ПравоДоступа(ИмяПрава, ОбъектМетаданных, МетаданныеРоли[ИмяРоли]) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Для процедуры УдалитьПоляНеиспользуемыхВидовДоступа и функции ГруппыДополнительныхТаблиц.
Процедура ДобавитьСвойстваВерсии(Контекст, Структура, ИменаПолей = "")
	
	Если ЗначениеЗаполнено(ИменаПолей) Тогда
		СохраняемаяСтруктура = Новый Структура(ИменаПолей);
		ЗаполнитьЗначенияСвойств(СохраняемаяСтруктура, Структура);
	Иначе
		СохраняемаяСтруктура = Структура;
	КонецЕсли;
	
	СписокЗначений = Новый СписокЗначений;
	Для Каждого КлючИЗначение Из СохраняемаяСтруктура Цикл
		СписокЗначений.Добавить(КлючИЗначение.Значение, КлючИЗначение.Ключ)
	КонецЦикла;
	СписокЗначений.СортироватьПоПредставлению();
	
	Для Каждого ЭлементСписка Из СписокЗначений Цикл
		ДобавитьЭлементВерсии(Контекст, ЭлементСписка.Представление, ЭлементСписка.Значение);
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ПараметрыОграниченияПоСтруктуреОграничения.
Процедура ДобавитьСвойствоВерсии(Контекст, Структура, ИмяПоля)
	
	ДобавитьЭлементВерсии(Контекст, ИмяПоля, Структура[ИмяПоля]);
	
КонецПроцедуры

// Для процедур ДобавитьСвойстваВерсии, ДобавитьСвойствоВерсии.
Процедура ДобавитьЭлементВерсии(Контекст, ИмяПоля, Значение)
	
	Если ТипЗнч(Значение) = Тип("Строка") Тогда
		Контекст.СвойстваВерсии.Добавить(ИмяПоля + " = " + Значение);
		
	ИначеЕсли ТипЗнч(Значение) = Тип("Число") Тогда
		
		Контекст.СвойстваВерсии.Добавить(ИмяПоля + " = " + Формат(Значение, "ЧГ="));
		
	ИначеЕсли ТипЗнч(Значение) = Тип("Булево")
	      Или ТипЗнч(Значение) = Тип("Неопределено") Тогда
		
		Контекст.СвойстваВерсии.Добавить(ИмяПоля + " = " + Строка(Значение));
		
	ИначеЕсли ТипЗнч(Значение) = Тип("ФиксированныйМассив") Тогда
		Контекст.СвойстваВерсии.Добавить(ИмяПоля + " = " + СтрокаДанныхДляХеширования(Новый Массив(Значение)));
		
	ИначеЕсли ТипЗнч(Значение) = Тип("ОписаниеТипов")
	      Или ТипЗнч(Значение) = Тип("Массив") Тогда
		
		Контекст.СвойстваВерсии.Добавить(ИмяПоля + " = " + СтрокаДанныхДляХеширования(Значение));
	Иначе
		ТекстОшибки = НСтр("ru = 'Некорректный тип данных для версии ограничения доступа.'");
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
КонецПроцедуры

// Для функции ПараметрыОграниченияПоСтруктуреОграничения и формы ОбновлениеДоступаРучноеУправление.
Функция ЭтоСсылочныйТипТаблицы(ПолноеИмя, ИмяКоллекцииТипа = "") Экспорт
	
	СинтаксисЯзыка = УправлениеДоступомСлужебныйПовтИсп.СинтаксисЯзыка();
	СоставИмени = СтрРазделить(ПолноеИмя, ".", Ложь);
	
	ТипТаблицы = СинтаксисЯзыка.ТипыТаблиц.ПоИменам.Получить(ВРег(СоставИмени[0]));
	Если ТипТаблицы = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ИмяКоллекцииТипа = ТипТаблицы.ИмяКоллекции;
	
	Возврат ТипТаблицы.ЭтоСсылочныйТип;
	
КонецФункции

// Для функции ПараметрыОграниченияПоСтруктуреОграничения.
Процедура ЗаполнитьНовоеОписаниеОпорныхПолей(Результат, Контекст)
	
	ОпорныеПоля = Новый Структура;
	ОпорныеПоля.Вставить("Список",           Новый СписокЗначений);
	ОпорныеПоля.Вставить("Все",              Новый Массив);
	ОпорныеПоля.Вставить("ТипыВсех",         Новый Массив);
	ОпорныеПоля.Вставить("Используемые",     Новый Массив);
	ОпорныеПоля.Вставить("ТипыИспользуемых", Новый Массив);
	ОпорныеПоля.Вставить("МаксимальноеКоличество", 0);
	ОпорныеПоля.Вставить("МаксимальноДопустимоеКоличество", 0);
	
	Контекст.Вставить("ОпорныеПоля", ОпорныеПоля);
	
	Если Контекст.ЭтоСсылочныйТип Тогда
		Возврат;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Контекст.Список) Тогда
		ИмяОтдельногоРегистраКлючей = "КлючиДоступаКРегистру" + СтрРазделить(Контекст.Список, ".")[1];
		Если Метаданные.РегистрыСведений.Найти(ИмяОтдельногоРегистраКлючей) = Неопределено Тогда
			ИмяОтдельногоРегистраКлючей = "";
		КонецЕсли;
	Иначе
		ИмяОтдельногоРегистраКлючей = "";
	КонецЕсли;
	Контекст.Вставить("ИмяОтдельногоРегистраКлючей", ИмяОтдельногоРегистраКлючей);
	
	ОпорныеПоля.МаксимальноеКоличество =
		УправлениеДоступомСлужебныйПовтИсп.КоличествоОпорныхПолейРегистра(ИмяОтдельногоРегистраКлючей);
	
	ОпорныеПоля.МаксимальноДопустимоеКоличество =
		УправлениеДоступомСлужебныйПовтИсп.МаксимальноеКоличествоОпорныхПолейРегистра();
	
	Если ОпорныеПоля.МаксимальноеКоличество > ОпорныеПоля.МаксимальноДопустимоеКоличество Тогда
		// Превышение количества опорных полей в отдельном регистре.
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Количество опорных полей в регистре сведений %1
			           |превышает максимально допустимое количество: %2'"),
			?(ИмяОтдельногоРегистраКлючей = "", "КлючиДоступаКРегистрам", ИмяОтдельногоРегистраКлючей),
			ОпорныеПоля.МаксимальноДопустимоеКоличество);
		
		Если Контекст.Свойство("ОшибкаПриВызовеИсключения") Тогда
			Контекст.ОшибкаПриВызовеИсключения.Текст = ТекстОшибки;
		КонецЕсли;
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	ДобавитьСвойствоВерсии(Контекст, ОпорныеПоля, "МаксимальноеКоличество");
	
	Результат.ОпорныеПоля = Новый Структура("Все, ТипыВсех, Используемые, ТипыИспользуемых,
	|МаксимальноеКоличество, МаксимальноДопустимоеКоличество");
	ЗаполнитьЗначенияСвойств(Результат.ОпорныеПоля, Контекст.ОпорныеПоля);
	
КонецПроцедуры

// Для функции ПараметрыОграниченияДоступа.
Процедура ЗаполнитьНаличиеОграниченияПоПравам(Контекст, Результат)
	
	СтруктураОграничения = Контекст.СтруктураОграничения;
	
	Результат.ЕстьОграничениеЧтения =
		ЗначениеЗаполнено(СтруктураОграничения.ОграничениеЧтения)
		И (    СтруктураОграничения.ОграничениеЧтения.Узел <> "Константа"
		   Или СтруктураОграничения.ОграничениеЧтения.Значение <> Истина);
	
	Результат.ЕстьОграничениеИзменения =
		ЗначениеЗаполнено(СтруктураОграничения.ОграничениеИзменения)
		И (    СтруктураОграничения.ОграничениеИзменения.Узел <> "Константа"
		   Или СтруктураОграничения.ОграничениеИзменения.Значение <> Истина);
	
	ДобавитьСвойствоВерсии(Контекст, Результат, "ЕстьОграничениеЧтения");
	ДобавитьСвойствоВерсии(Контекст, Результат, "ЕстьОграничениеИзменения");
	
КонецПроцедуры

// Для функции ПараметрыОграниченияДоступа.
Процедура ЗаполнитьОграничениеПоОбъектуВладельцу(Результат, Контекст)
	
	ОграничениеПоВладельцу = Контекст.СпискиСОграничениемПоВладельцу.Получить(Контекст.Список);
	Если ТипЗнч(ОграничениеПоВладельцу) = Тип("Булево") И Не ОграничениеПоВладельцу Тогда
		Возврат;
	КонецЕсли;

	ТребуетсяОграничениеПоВладельцу = ?(ТипЗнч(ОграничениеПоВладельцу) = Тип("Булево"),
		ОграничениеПоВладельцу, Ложь);
	
	Результат.ТребуетсяОграничениеПоВладельцу = ТребуетсяОграничениеПоВладельцу;
	ПолеВладельца = Новый Структура("Имя, ИзменениеКакЧтение", "", Ложь);
	
	ОграничениеЧтения    = Контекст.СтруктураОграничения.ОграничениеЧтения;
	ОграничениеИзменения = Контекст.СтруктураОграничения.ОграничениеИзменения;
	
	Если Результат.ЕстьОграничениеЧтения Тогда
		
		Если ОграничениеЧтения.Узел <> "ЧтениеОбъектаРазрешено" Тогда
			Если ТребуетсяОграничениеПоВладельцу Тогда
				Если ЗначениеЗаполнено(ОграничениеИзменения) Тогда
					ШаблонОшибки =
						НСтр("ru = 'Установлен признак оптимизации ограничения %1,
						           |но указанное ограничение чтения изменения не представлено одной функцией ЧтениеОбъектаРазрешено.'");
				Иначе
					ШаблонОшибки =
						НСтр("ru = 'Установлен признак оптимизации ограничения %1,
						           |но указанное ограничение чтения не представлено одной функцией ЧтениеОбъектаРазрешено.'");
				КонецЕсли;
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонОшибки,
					"ПоВладельцуБезЗаписиКлючейДоступа" + ?(Контекст.ДляВнешнихПользователей, "ДляВнешнихПользователей", ""));
				ТекстОшибки = ТекстОшибкиСЗаголовком(ТекстОшибки, Контекст);
				Если Контекст.Свойство("ОшибкаПриВызовеИсключения") Тогда
					Контекст.ОшибкаПриВызовеИсключения.Текст = ТекстОшибки;
				КонецЕсли;
				ВызватьИсключение ТекстОшибки;
			Иначе
				Возврат;
			КонецЕсли;
		КонецЕсли;
		Если Не ФункцияБезУточненийТиповСПолемБезВложений(ОграничениеЧтения) Тогда
			Если ТребуетсяОграничениеПоВладельцу Тогда
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Установлен признак оптимизации ограничения %1,
					           |но параметры функции ЧтениеОбъектаРазрешено не представлены
					           |только одним параметром - полем владельцем без других параметров.'"),
					"ПоВладельцуБезЗаписиКлючейДоступа" + ?(Контекст.ДляВнешнихПользователей, "ДляВнешнихПользователей", ""));
				ТекстОшибки = ТекстОшибкиСЗаголовком(ТекстОшибки, Контекст);
				Если Контекст.Свойство("ОшибкаПриВызовеИсключения") Тогда
					Контекст.ОшибкаПриВызовеИсключения.Текст = ТекстОшибки;
				КонецЕсли;
				ВызватьИсключение ТекстОшибки;
			Иначе
				Возврат;
			КонецЕсли;
		КонецЕсли;
		ПолеВладельца.Имя = ОграничениеЧтения.Поле.Имя;
	КонецЕсли;
	
	Если Результат.ЕстьОграничениеИзменения Тогда
		
		Если ОграничениеИзменения.Узел <> "ЧтениеОбъектаРазрешено"
		   И ОграничениеИзменения.Узел <> "ИзменениеОбъектаРазрешено" Тогда
			
			Если ТребуетсяОграничениеПоВладельцу Тогда
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Установлен признак оптимизации ограничения %1,
					           |но указанное ограничение изменения не представлено одной функцией
					           |ЧтениеОбъектаРазрешено или ИзменениеОбъектаРазрешено.'"),
					"ПоВладельцуБезЗаписиКлючейДоступа" + ?(Контекст.ДляВнешнихПользователей, "ДляВнешнихПользователей", ""));
				ТекстОшибки = ТекстОшибкиСЗаголовком(ТекстОшибки, Контекст);
				Если Контекст.Свойство("ОшибкаПриВызовеИсключения") Тогда
					Контекст.ОшибкаПриВызовеИсключения.Текст = ТекстОшибки;
				КонецЕсли;
				ВызватьИсключение ТекстОшибки;
			Иначе
				Возврат;
			КонецЕсли;
		КонецЕсли;
		Если Не ФункцияБезУточненийТиповСПолемБезВложений(ОграничениеИзменения) Тогда
			Если ТребуетсяОграничениеПоВладельцу Тогда
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Установлен признак оптимизации ограничения %1,
					           |но параметры функции %2 не представлены
					           |только одним параметром - полем владельцем без других параметров.'"),
					"ПоВладельцуБезЗаписиКлючейДоступа" + ?(Контекст.ДляВнешнихПользователей, "ДляВнешнихПользователей", ""),
					ОграничениеИзменения.Узел);
				ТекстОшибки = ТекстОшибкиСЗаголовком(ТекстОшибки, Контекст);
				Если Контекст.Свойство("ОшибкаПриВызовеИсключения") Тогда
					Контекст.ОшибкаПриВызовеИсключения.Текст = ТекстОшибки;
				КонецЕсли;
				ВызватьИсключение ТекстОшибки;
			Иначе
				Возврат;
			КонецЕсли;
		КонецЕсли;
		
		Если ПолеВладельца.Имя = "" Тогда
			ПолеВладельца.Имя = ОграничениеИзменения.Поле.Имя;
			
		ИначеЕсли ПолеВладельца.Имя <> ОграничениеИзменения.Поле.Имя Тогда
			Если ТребуетсяОграничениеПоВладельцу Тогда
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Установлен признак оптимизации ограничения %1,
					           |но поле владельца не совпадает в ограничениях чтения и изменения.'"),
					"ПоВладельцуБезЗаписиКлючейДоступа" + ?(Контекст.ДляВнешнихПользователей, "ДляВнешнихПользователей", ""),
					ОграничениеИзменения.Узел);
				ТекстОшибки = ТекстОшибкиСЗаголовком(ТекстОшибки, Контекст);
				Если Контекст.Свойство("ОшибкаПриВызовеИсключения") Тогда
					Контекст.ОшибкаПриВызовеИсключения.Текст = ТекстОшибки;
				КонецЕсли;
				ВызватьИсключение ТекстОшибки;
			Иначе
				Возврат;
			КонецЕсли;
		КонецЕсли;
		ПолеВладельца.ИзменениеКакЧтение =
			ОграничениеИзменения.Узел <> "ИзменениеОбъектаРазрешено";
	Иначе
		ПолеВладельца.ИзменениеКакЧтение = Истина;
	КонецЕсли;
	
	СвойстваПолей = Контекст.СвойстваПолей;
	
	Если СвойстваПолей.Количество() <> 1 Тогда
		Если ТребуетсяОграничениеПоВладельцу И СвойстваПолей.Количество() <> 0 Тогда
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Установлен признак оптимизации ограничения %1,
				           |но количество полей, используемых в ограничении, более одного.'"),
				"ПоВладельцуБезЗаписиКлючейДоступа" + ?(Контекст.ДляВнешнихПользователей, "ДляВнешнихПользователей", ""));
			ТекстОшибки = ТекстОшибкиСЗаголовком(ТекстОшибки, Контекст);
			Если Контекст.Свойство("ОшибкаПриВызовеИсключения") Тогда
				Контекст.ОшибкаПриВызовеИсключения.Текст = ТекстОшибки;
			КонецЕсли;
			ВызватьИсключение ТекстОшибки;
		Иначе
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	СвойстваПоля = СвойстваПолей[0];
	
	ТипИОМ = Тип("СправочникСсылка.ИдентификаторыОбъектовМетаданных");
	ТипИОР = Тип("СправочникСсылка.ИдентификаторыОбъектовРасширений");
	
	КоличествоТиповИдентификаторовВКонечномПоле = 0;
	Если СвойстваПоля.ТипКонечногоПоля.СодержитТип(ТипИОМ) Тогда
		КоличествоТиповИдентификаторовВКонечномПоле = 1;
	КонецЕсли;
	Если СвойстваПоля.ТипКонечногоПоля.СодержитТип(ТипИОР) Тогда
		КоличествоТиповИдентификаторовВКонечномПоле = КоличествоТиповИдентификаторовВКонечномПоле + 1;
	КонецЕсли;
	
	Если СвойстваПоля.ТипКонечногоПоля.Типы().Количество() - КоличествоТиповИдентификаторовВКонечномПоле
	  <> СвойстваПоля.ТипыСохраненияКлючейДоступа.Количество() Тогда
		
		НекорректныеТипы = Новый Массив;
		Для Каждого Тип Из СвойстваПоля.ТипКонечногоПоля.Типы() Цикл
			Если СвойстваПоля.ТипыСохраненияКлючейДоступа.Найти(Тип) <> Неопределено
			 Или Тип = ТипИОМ
			 Или Тип = ТипИОР Тогда
				Продолжить;
			КонецЕсли;
			НекорректныеТипы.Добавить(ИмяТипаНаЯзыкеЗапросов(Тип));
		КонецЦикла;
		Если ТребуетсяОграничениеПоВладельцу Тогда
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Установлен признак оптимизации ограничения %1,
				           |но для следующих таблиц невозможно записать ключи доступа:
				           |%2'"),
				"ПоВладельцуБезЗаписиКлючейДоступа" + ?(Контекст.ДляВнешнихПользователей, "ДляВнешнихПользователей", ""),
				СтрСоединить(НекорректныеТипы, Символы.ПС));
			ТекстОшибки = ТекстОшибкиСЗаголовком(ТекстОшибки, Контекст);
			Если Контекст.Свойство("ОшибкаПриВызовеИсключения") Тогда
				Контекст.ОшибкаПриВызовеИсключения.Текст = ТекстОшибки;
			КонецЕсли;
			ВызватьИсключение ТекстОшибки;
		Иначе
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	Результат.ПолеВладельца = ПолеВладельца;
	
	ДобавитьСвойствоВерсии(Контекст, ПолеВладельца, "ИзменениеКакЧтение");
	ДобавитьСвойствоВерсии(Контекст, ПолеВладельца, "Имя");
	
КонецПроцедуры

// Для функции ЗаполнитьОграничениеПоОбъектуВладельцу и процедуры НастроитьОптимизациюПоПолюВладельцу.
Функция ТекстОшибкиСЗаголовком(ТекстОшибки, Контекст)
	
	ОписаниеОшибок = Новый Структура;
	ОписаниеОшибок.Вставить("ЕстьОшибки", Истина);
	ОписаниеОшибок.Вставить("Ошибки", Новый Массив(1));
	ОписаниеОшибок.Вставить("ТекстОшибок", ТекстОшибки);
	ОписаниеОшибок.Вставить("Ограничение", "");
	ОписаниеОшибок.Вставить("Дополнение", "");
	
	ОписаниеОграничения = Контекст.ОписанияОграничений.Получить(Контекст.Список);
	
	ОписаниеОшибок.Ограничение =
		ПронумерованныйТекстОграниченияСОтметкамиОшибок(ОписаниеОграничения.Текст,
			Новый Массив, СтрДлина(Формат(СтрЧислоСтрок(ОписаниеОграничения.Текст), "ЧГ=")));
	
	Возврат СокрЛП(ТекстОшибокДляВызоваИсключения(Контекст.Список,
		ОписаниеОшибок, Контекст.ДляВнешнихПользователей, ОписаниеОграничения.ВМодулеМенеджера));
	
КонецФункции

// Для процедуры ЗаполнитьОграничениеПоОбъектуВладельцу.
Функция ФункцияБезУточненийТиповСПолемБезВложений(Ограничение)
	
	Если Ограничение.Типы.Количество() <> 0
	 Или Ограничение.УточненияСравнения.Количество() <> 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Поле = Ограничение.Поле;
	
	Возврат Не ЗначениеЗаполнено(Поле.Выразить)
	      И Не ЗначениеЗаполнено(Поле.Вложение)
	      И Не ЗначениеЗаполнено(Поле.ЕстьNull);
	
КонецФункции

// Для функции ПараметрыОграниченияДоступа.
Процедура ЗаполнитьНаличиеВедущихКлючейИСписковИВладельцевНастроекПрав(Результат, Контекст)
	
	Для Каждого СвойстваПоля Из Контекст.СвойстваПолей Цикл
		Если СвойстваПоля.ТипыСохраненияКлючейДоступа.Количество() > 0 Тогда
			Результат.ЕстьВедущиеКлючиДоступа = Истина;
		КонецЕсли;
		Если СвойстваПоля.ЕстьТипВедущегоСписка Тогда
			Результат.ЕстьВедущиеСпискиПоПравам = Истина;
		КонецЕсли;
		Если СвойстваПоля.ЕстьТипВладельцаНастроекПрав Тогда
			Результат.ЕстьВладельцыНастроекПрав = Истина;
		КонецЕсли;
		Если СвойстваПоля.ЕстьПроверкаАвторизованногоПользователя Тогда
			Контекст.ЕстьПроверкаАвторизованногоПользователя = Истина;
		КонецЕсли;
		Для Каждого Тип Из СвойстваПоля.ИспользуемыеТипыЗначенийДоступа Цикл
			Если Результат.ИспользуемыеТипыЗначенийДоступа.Найти(Тип) = Неопределено Тогда
				Результат.ИспользуемыеТипыЗначенийДоступа.Добавить(Тип);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Для Каждого КлючИЗначение Из Контекст.ОтдельныеТаблицыНастроекПрав Цикл
		Если КлючИЗначение.Значение = Контекст.Список Тогда
			Результат.ИдентификаторТаблицыНастроекПрав = КлючИЗначение.Ключ;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	ДобавитьСвойствоВерсии(Контекст, Результат, "ЕстьВедущиеКлючиДоступа");
	ДобавитьСвойствоВерсии(Контекст, Результат, "ЕстьВедущиеСпискиПоПравам");
	ДобавитьСвойствоВерсии(Контекст, Результат, "ЕстьВладельцыНастроекПрав");
	ДобавитьСвойствоВерсии(Контекст, Результат, "ИспользуемыеТипыЗначенийДоступа");
	ДобавитьСвойствоВерсии(Контекст, Контекст,  "НеиспользуемыеТипыЗначенийДоступа");
	
	СохраняемыеСвойства = Новый Структура("ОтдельнаяТаблицаНастроекПрав",
		ЗначениеЗаполнено(Результат.ИдентификаторТаблицыНастроекПрав));
	
	ДобавитьСвойствоВерсии(Контекст, СохраняемыеСвойства, "ОтдельнаяТаблицаНастроекПрав");
	
КонецПроцедуры

// Для функции ПараметрыОграниченияДоступа.
Процедура УдалитьПоляНеиспользуемыхВидовДоступа(Результат, Контекст)
	
	СвойстваПолей = Контекст.СвойстваПолей;
	
	Если Не Результат.ЕстьВедущиеКлючиДоступа
	   И Не Результат.ЕстьВедущиеСпискиПоПравам
	   И Не Результат.ЕстьВладельцыНастроекПрав
	   И Не Контекст.ЕстьПроверкаАвторизованногоПользователя
	   И Результат.ИспользуемыеТипыЗначенийДоступа.Количество() = 0
	   И Контекст.НеиспользуемыеТипыЗначенийДоступа.Количество() > 0 Тогда
		
		СвойстваПолей.Очистить();
		Возврат;
	КонецЕсли;
	
	Индекс = СвойстваПолей.Количество();
	Пока Индекс > 0 Цикл
		Индекс = Индекс - 1;
		СвойстваПоля = СвойстваПолей.Получить(Индекс);
		УстановитьИспользованиеОпорногоПоля(Контекст.ОпорныеПоля, СвойстваПоля);
		ДобавитьСвойстваВерсии(Контекст, СвойстваПоля,
		"ЕстьУточнениеNull,
		|ЕстьУточнениеНеопределено,
		|ИмяПоляДляЗапроса,
		|НесколькоГруппЗначений,
		|ТипКонечногоПоля,
		|ТипыСохраненияГруппЗначений,
		|ТипыСохраненияЗначений,
		|ТипыСохраненияКлючейДоступа,
		|ТипыСохраненияПустойСсылки,
		|ТипыСохраненияТипаРазрешенный,
		|ТипыСохраненияТипаЗапрещенный,
		|ТипыСохраненияТипов,
		|ТипыСохраненияТиповКонфигурации,
		|ТипыСохраненияТиповПростых,
		|ТипыСохраненияТиповРасширений,
		|ТипыСтрокой");
	КонецЦикла;
	
КонецПроцедуры

// Для функции ПараметрыОграниченияДоступа.
Процедура ЗаполнитьНаличиеОграниченияПоВидуДоступаПользователи(Результат, Контекст)
	
	Если Результат.ЕстьВладельцыНастроекПрав Тогда
		Результат.ЕстьОграничениеПоПользователям = Истина;
	Иначе
		Для Каждого СвойстваПоля Из Контекст.СвойстваПолей Цикл
			Если СвойстваПоля.ТипыСохраненияЗначений.Количество() = 0 Тогда
				Продолжить;
			КонецЕсли;
			ОписаниеТипов = Новый ОписаниеТипов(СвойстваПоля.ТипыСохраненияЗначений);
			Если Не Результат.ДляВнешнихПользователей
			   И (    ОписаниеТипов.СодержитТип(Тип("СправочникСсылка.Пользователи"))
			      Или ОписаниеТипов.СодержитТип(Тип("СправочникСсылка.ГруппыПользователей")) ) Тогда
				
				Результат.ЕстьОграничениеПоПользователям = Истина;
				Прервать;
			КонецЕсли;
			Если Результат.ДляВнешнихПользователей
			   И (    ОписаниеТипов.СодержитТип(Тип("СправочникСсылка.ВнешниеПользователи"))
			      Или ОписаниеТипов.СодержитТип(Тип("СправочникСсылка.ГруппыВнешнихПользователей")) ) Тогда
				
				Результат.ЕстьОграничениеПоПользователям = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ДобавитьСвойствоВерсии(Контекст, Результат, "ЕстьОграничениеПоПользователям");
	
КонецПроцедуры

// Для функции ПараметрыОграниченияДоступа.
Процедура ЗаполнитьНаличиеОграниченияЧтения(Результат, Контекст)
	
	Для Каждого СвойстваПоля Из Контекст.СвойстваПолей Цикл
		Если СвойстваПоля.Чтение Тогда
			Результат.ОграничениеЧтенияОтключено = Ложь;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	ДобавитьСвойствоВерсии(Контекст, Результат, "ОграничениеЧтенияОтключено");
	
КонецПроцедуры

// Для функции ПараметрыОграниченияДоступа.
Процедура ЗаполнитьГруппыПолейИДополнительныхТаблиц(Контекст)
	
	// Поля шапки (начинаются от шапки - группировка по пустому псевдониму, если нет имени табличной части).
	// Поля каждой ТЧ (начинаются от табличной части - группировка по имени табличной части).
	// Поля группы связанных дополнительных таблиц (начинаются от экземпляра доп. таблицы - группировка
	// по псевдониму, но если одна таблица ссылается на другую в соединении, тогда образуется группа таблиц).
	
	НомерПоследнегоРеквизитаШапкиСНесколькимиГруппамиЗначенийДоступа = 0;
	НомерПоследнейТабличнойЧастиОбъекта = 0;
	НомераТабличныхЧастейОбъекта = Новый Соответствие;
	
	Для Каждого СвойстваПоля Из Контекст.СвойстваПолей Цикл
		Если СвойстваПоля.ПсевдонимТаблицы = "ТекущийСписок"
		   И СвойстваПоля.НесколькоГруппЗначений Тогда
			
			НомерПоследнегоРеквизитаШапкиСНесколькимиГруппамиЗначенийДоступа =
				НомерПоследнегоРеквизитаШапкиСНесколькимиГруппамиЗначенийДоступа + 1;
			
		ИначеЕсли СвойстваПоля.ПсевдонимТаблицы <> "ТекущийСписок"
		        И СтрНачинаетсяС(СвойстваПоля.ПсевдонимТаблицы, "ТекущийСписок")
			    И НомераТабличныхЧастейОбъекта.Получить(СвойстваПоля.ПсевдонимТаблицы) = Неопределено Тогда
			
			НомерПоследнейТабличнойЧастиОбъекта = НомерПоследнейТабличнойЧастиОбъекта + 1;
			НомераТабличныхЧастейОбъекта.Вставить(СвойстваПоля.ПсевдонимТаблицы, НомерПоследнейТабличнойЧастиОбъекта);
		КонецЕсли;
	КонецЦикла;
	
	РазмерностьКлючаДоступа = УправлениеДоступомСлужебныйПовтИсп.РазмерностьКлючаДоступа();
	
	КоличествоТабличныхЧастейКлючаДляРеквизитовШапкиОбъекта = Цел(
		(НомерПоследнегоРеквизитаШапкиСНесколькимиГруппамиЗначенийДоступа
			+ РазмерностьКлючаДоступа.КоличествоРеквизитовТабличнойЧасти - 1)
		/ РазмерностьКлючаДоступа.КоличествоРеквизитовТабличнойЧасти);
	
	ГруппыДополнительныхТаблиц = ГруппыДополнительныхТаблиц(Контекст);
	КоличествоТабличныхЧастейКлюча = НомерПоследнейТабличнойЧастиОбъекта
		+ ГруппыДополнительныхТаблиц.ТаблицыПоГруппам.Количество()
		+ КоличествоТабличныхЧастейКлючаДляРеквизитовШапкиОбъекта;
	
	ЗавершитьПодготовкуОпорныхПолей(Контекст);
	
	Если КоличествоТабличныхЧастейКлюча > РазмерностьКлючаДоступа.КоличествоТабличныхЧастей Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В ограничении доступа списка %1
			           |количество полей, требующих отдельных табличных частей в ключе доступа,
			           |более, чем количество доступных табличных частей в ключе доступа.
			           |
			           |К таким полям относятся:
			           |- поля табличных частей,
			           |- поля дополнительных таблиц, присоединенных к списку,
			           |- поля шапки, у которых значение доступа может иметь более одной группы значений доступа.'"),
			Контекст.Список);
		
		Если Контекст.Свойство("ОшибкаПриВызовеИсключения") Тогда
			Контекст.ОшибкаПриВызовеИсключения.Текст = ТекстОшибки;
		КонецЕсли;
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Если Не Контекст.ЭтоСсылочныйТип
	   И Контекст.ОпорныеПоля.Все.Количество() > Контекст.ОпорныеПоля.МаксимальноеКоличество Тогда
		
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В ограничении доступа списка %1
			           |количество полей списка, используемых в ограничении доступа,
			           |превышает максимально допустимое количество опорных полей: %2.'"),
			Контекст.Список,
			Контекст.ОпорныеПоля.МаксимальноеКоличество);
		
		Если Контекст.Свойство("ОшибкаПриВызовеИсключения") Тогда
			Контекст.ОшибкаПриВызовеИсключения.Текст = ТекстОшибки;
		КонецЕсли;
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	ГруппыПолей = Новый Соответствие;
	ПсевдонимыТабличныхЧастейОбъекта = Новый Соответствие;
	НомерПоследнегоРеквизитаШапки = 0;
	НомерПоследнегоРеквизитаШапкиСНесколькимиГруппамиЗначенийДоступа = 0;
	
	Для Каждого СвойстваПоля Из Контекст.СвойстваПолей Цикл
		Если СвойстваПоля.ПсевдонимТаблицы = "ТекущийСписок" Тогда
			
			Если СвойстваПоля.НесколькоГруппЗначений Тогда
				НомерПоследнегоРеквизитаШапкиСНесколькимиГруппамиЗначенийДоступа =
					НомерПоследнегоРеквизитаШапкиСНесколькимиГруппамиЗначенийДоступа + 1;
				
				НомерТабличнойЧастиКлюча = Цел(НомерПоследнегоРеквизитаШапкиСНесколькимиГруппамиЗначенийДоступа
					/ РазмерностьКлючаДоступа.КоличествоРеквизитовТабличнойЧасти) + 1;
				
				ИмяГруппыПолей = "ТабличнаяЧасть" + НомерТабличнойЧастиКлюча;
			Иначе
				НомерПоследнегоРеквизитаШапки = НомерПоследнегоРеквизитаШапки + 1;
				Если НомерПоследнегоРеквизитаШапки < 6 Тогда
					ИмяГруппыПолей = "Шапка0";
				ИначеЕсли НомерПоследнегоРеквизитаШапки < 11 Тогда
					ИмяГруппыПолей = "Шапка1";
				ИначеЕсли НомерПоследнегоРеквизитаШапки < 16 Тогда
					ИмяГруппыПолей = "Шапка2";
				Иначе
					ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'В ограничении доступа списка %1
						           |количество полей списка, используемых в ограничении доступа,
						           |превышает максимально допустимое количество: 15.'"),
						Контекст.Список);
					Если Контекст.Свойство("ОшибкаПриВызовеИсключения") Тогда
						Контекст.ОшибкаПриВызовеИсключения.Текст = ТекстОшибки;
					КонецЕсли;
					ВызватьИсключение ТекстОшибки;
				КонецЕсли;
			КонецЕсли;
		Иначе
			Если СвойстваПоля.ПсевдонимТаблицы <> "ТекущийСписок"
			   И СтрНачинаетсяС(СвойстваПоля.ПсевдонимТаблицы, "ТекущийСписок") Тогда
				
				НомерТабличнойЧастиКлюча = КоличествоТабличныхЧастейКлючаДляРеквизитовШапкиОбъекта
					+ НомераТабличныхЧастейОбъекта.Получить(СвойстваПоля.ПсевдонимТаблицы);
				
				Если ПсевдонимыТабличныхЧастейОбъекта.Получить(НомерТабличнойЧастиКлюча) = Неопределено Тогда
					ПсевдонимыТабличныхЧастейОбъекта.Вставить(НомерТабличнойЧастиКлюча, СвойстваПоля.ПсевдонимТаблицы)
				КонецЕсли;
			Иначе
				НомерТабличнойЧастиКлюча = КоличествоТабличныхЧастейКлючаДляРеквизитовШапкиОбъекта
					+ НомераТабличныхЧастейОбъекта.Количество()
					+ ГруппыДополнительныхТаблиц.НомераПоПсевдонимам.Получить(СвойстваПоля.ПсевдонимТаблицы);
			КонецЕсли;
			ИмяГруппыПолей = "ТабличнаяЧасть" + НомерТабличнойЧастиКлюча;
		КонецЕсли;
		ГруппаПолей = ГруппыПолей.Получить(ИмяГруппыПолей);
		Если ГруппаПолей = Неопределено Тогда
			ГруппаПолей = Новый Массив;
			ГруппыПолей.Вставить(ИмяГруппыПолей, ГруппаПолей);
		КонецЕсли;
		ГруппаПолей.Добавить(СвойстваПоля);
		СвойстваПоля.Вставить("ИмяГруппыПолейКлючаДоступа", ИмяГруппыПолей);
		СвойстваПоля.Вставить("ИмяРеквизитаГруппыПолейКлючаДоступа", "Значение" + Строка(
			ГруппаПолей.Количество() + ?(ИмяГруппыПолей = "Шапка1" Или ИмяГруппыПолей = "Шапка2", 5, 0)));
		
		Если Не СтрНачинаетсяС(ИмяГруппыПолей, "Шапка")
		   И ГруппаПолей.Количество() > РазмерностьКлючаДоступа.КоличествоРеквизитовТабличнойЧасти Тогда
			
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'В ограничении доступа списка %1
				           |количество полей одной табличной части, используемых в ограничении доступа,
				           |превышает максимально допустимое количество: %2.'"),
				Контекст.Список,
				РазмерностьКлючаДоступа.КоличествоРеквизитовТабличнойЧасти);
			
			Если Контекст.Свойство("ОшибкаПриВызовеИсключения") Тогда
				Контекст.ОшибкаПриВызовеИсключения.Текст = ТекстОшибки;
			КонецЕсли;
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
	КонецЦикла;
	
	Контекст.Вставить("ГруппыПолей",                      ГруппыПолей);
	Контекст.Вставить("ПсевдонимыТабличныхЧастейОбъекта", ПсевдонимыТабличныхЧастейОбъекта);
	Контекст.Вставить("ГруппыДополнительныхТаблиц",       ГруппыДополнительныхТаблиц);
	Контекст.Вставить("КоличествоТабличныхЧастейКлюча",   КоличествоТабличныхЧастейКлюча);
	
	// Расчет числа СоставПолей.
	
	// Шапка и табличные части:    ТЧ4  ТЧ3  ТЧ2  ТЧ1    Ш.
	// Двоичный формат:           0000 0000 0000 0000 0000.
	// Шестнадцатеричный формат:    x0   x0   x0   x0   x0.
	//
	// Например: Ш0=1, ТЧ1=1.
	// Двоичный формат:           0000 0000 0000 0001 0001.
	// Шестнадцатеричный формат:    x0   x0   x0   x1   x1.
	// Число = 1*16^0 + 1*16^1 = 1 + 16 = 17.
	
	СоставПолей = НомерПоследнегоРеквизитаШапки;
	
	Для НомерТабличнойЧастиКлюча = 1 По КоличествоТабличныхЧастейКлюча Цикл
		ИмяТабличнойЧастиКлюча = "ТабличнаяЧасть" + НомерТабличнойЧастиКлюча;
		ГруппаПолей = ГруппыПолей.Получить(ИмяТабличнойЧастиКлюча);
		СоставПолей = СоставПолей + ГруппаПолей.Количество() * Степень16(НомерТабличнойЧастиКлюча);
	КонецЦикла;
	
	Контекст.Вставить("СоставПолей", СоставПолей);
	
КонецПроцедуры

// Для функции ПараметрыОграниченияДоступа.
Процедура ЗаполнитьСтруктуруРасчетаПрава(УсловиеРасчета, Условие, Контекст, КореньУсловия = Истина)
	
	Если Не ЗначениеЗаполнено(Условие) Тогда
		Возврат;
	КонецЕсли;
	
	Если КореньУсловия Тогда
		Контекст.Вставить("ТребуемыеРеквизитыТабличныхЧастейКлюча", Новый Соответствие);
		Контекст.Вставить("СтруктураРасчетаПраваСвойстваВерсии", Новый Массив);
	КонецЕсли;
	
	СвойстваПоля = Неопределено;
	ДобавитьСвойствоВерсииСтруктурыРасчета(Контекст, "Узел", Условие.Узел);
	
	Если Условие.Узел = "Поле" Тогда
		СвойстваПоля = Контекст.СвойстваПолейКлючаДоступа.Получить(Условие);
		
	ИначеЕсли Условие.Узел = "И"
	      Или Условие.Узел = "Или" Тогда
		
		УсловиеРасчета = Новый Структура("Узел, Аргументы", Условие.Узел, Новый Массив);
		Индекс = 0;
		Для Каждого Аргумент Из Условие.Аргументы Цикл
			УсловиеРасчета.Аргументы.Добавить(Неопределено);
			ЗаполнитьСтруктуруРасчетаПрава(УсловиеРасчета.Аргументы[Индекс], Аргумент, Контекст, Ложь);
			Индекс = Индекс + 1;
		КонецЦикла;
		СвойстваПоля = Null;
		
	ИначеЕсли Условие.Узел = "Не" Тогда
		УсловиеРасчета = Новый Структура("Узел, Аргумент", Условие.Узел, Неопределено);
		ЗаполнитьСтруктуруРасчетаПрава(УсловиеРасчета.Аргумент, Условие.Аргумент, Контекст, Ложь);
		СвойстваПоля = Null;
		
	ИначеЕсли Условие.Узел = "ДляВсехСтрок"
	      Или Условие.Узел = "ДляОднойИзСтрок" Тогда
		
		Если Не КореньУсловия Тогда
			ТребуемыеРеквизитыТабличныхЧастейКлюча = Контекст.ТребуемыеРеквизитыТабличныхЧастейКлюча;
			Контекст.Вставить("ТребуемыеРеквизитыТабличныхЧастейКлюча", Новый Соответствие);
		КонецЕсли;
		
		УсловиеРасчета = Новый Структура("Узел, Аргумент", Условие.Узел, Неопределено);
		ЗаполнитьСтруктуруРасчетаПрава(УсловиеРасчета.Аргумент, Условие.Аргумент, Контекст, Ложь);
		
		Если Не КореньУсловия Тогда
			УсловиеРасчета.Вставить("ТребуемыеРеквизитыТабличныхЧастейКлюча", Контекст.ТребуемыеРеквизитыТабличныхЧастейКлюча);
			Контекст.Вставить("ТребуемыеРеквизитыТабличныхЧастейКлюча", ТребуемыеРеквизитыТабличныхЧастейКлюча);
		КонецЕсли;
		СвойстваПоля = Null;
		
	ИначеЕсли Условие.Узел = "ЕстьNull" Тогда
		СвойстваПоля = Контекст.СвойстваПолейКлючаДоступа.Получить(Условие.Аргумент);
		
	ИначеЕсли Условие.Узел = "="
	      Или Условие.Узел = "<>" Тогда
		
		СвойстваПоля = Контекст.СвойстваПолейКлючаДоступа.Получить(Условие.ПервыйАргумент);
		Если СвойстваПоля = Неопределено Тогда
			СвойстваПоля = Контекст.СвойстваПолейКлючаДоступа.Получить(Условие.ВторойАргумент);
		КонецЕсли;
		
	ИначеЕсли Условие.Узел = "В" Тогда
		СвойстваПоля = Контекст.СвойстваПолейКлючаДоступа.Получить(Условие.Искомое);
		
	ИначеЕсли Условие.Узел = "Выбор" Тогда
		УсловиеРасчета = Новый Структура("Узел, Когда, Иначе", Условие.Узел, Новый Массив, Неопределено);
		Для Каждого Когда Из Условие.Когда Цикл
			СтруктураКогда = Новый Структура("Условие, Значение");
			УсловиеРасчета.Когда.Добавить(СтруктураКогда);
			Если Условие.Выбор = Неопределено Тогда
				ЗаполнитьСтруктуруРасчетаПрава(СтруктураКогда.Условие, Когда.Условие, Контекст, Ложь);
			Иначе
				Свойства = Контекст.СвойстваПолейКлючаДоступа.Получить(Когда.Условие);
				ДобавитьСвойствоВерсииСтруктурыРасчета(Контекст, "Узел", "Поле");
				УсловиеРасчетаПоле(СтруктураКогда.Условие, Свойства, Контекст);
			КонецЕсли;
			ЗаполнитьСтруктуруРасчетаПрава(СтруктураКогда.Значение, Когда.Значение, Контекст, Ложь);
		КонецЦикла;
		ЗаполнитьСтруктуруРасчетаПрава(УсловиеРасчета.Иначе, Условие.Иначе, Контекст, Ложь);
		СвойстваПоля = Null;
		
	ИначеЕсли Условие.Узел = "ЗначениеРазрешено"
	      Или Условие.Узел = "ЭтоАвторизованныйПользователь"
	      Или Условие.Узел = "ЧтениеОбъектаРазрешено"
	      Или Условие.Узел = "ИзменениеОбъектаРазрешено"
	      Или Условие.Узел = "ЧтениеСпискаРазрешено"
	      Или Условие.Узел = "ИзменениеСпискаРазрешено" Тогда
		
		УсловиеРасчета = Новый Структура("Узел, Поле", Условие.Узел, Неопределено);
		УсловиеРасчета.Вставить("УточненияСравнения", Новый Соответствие);
		Для Каждого КлючИЗначение Из Условие.УточненияСравнения Цикл
			Если КлючИЗначение.Ключ = "Null"
			 Или КлючИЗначение.Ключ = "Неопределено"
			 Или КлючИЗначение.Ключ = "ПустаяСсылка"
			 Или КлючИЗначение.Ключ = "Отключено" Тогда
			 	УсловиеРасчета.УточненияСравнения.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
			Иначе
				ИмяТипа = СтрЗаменить(КлючИЗначение.Ключ, ".", "Ссылка.");
				УсловиеРасчета.УточненияСравнения.Вставить(Тип(ИмяТипа), КлючИЗначение.Значение);
			КонецЕсли;
		КонецЦикла;
		ДобавитьСвойствоВерсииСтруктурыРасчета(Контекст, "УточненияСравнения", Условие.УточненияСравнения);
		ЗаполнитьСтруктуруРасчетаПрава(УсловиеРасчета.Поле, Условие.Поле, Контекст, Ложь);
		
		Если УсловиеРасчета.Поле = Null Тогда
			УсловиеРасчета = Новый Структура("Узел, Значение", "Константа", Истина);
		КонецЕсли;
		СвойстваПоля = Null;
		
	ИначеЕсли Условие.Узел = "Константа" Тогда
		УсловиеРасчета = Новый Структура("Узел, Значение", Условие.Узел, Условие.Значение);
		ДобавитьСвойствоВерсииСтруктурыРасчета(Контекст, "Значение", Условие.Значение);
		СвойстваПоля = Null;
	Иначе
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'При заполнении структуры расчета права %1 на ключи доступа
			           |списка ""%2""
			           |узел не поддерживается ""%3"".'"),
			Контекст.ИмяПрава,
			Контекст.Список,
			Условие.Узел);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Если СвойстваПоля = Неопределено Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'При заполнении структуры расчета права %1 на ключи доступа
			           |списка ""%2""
			           |свойства поля не определены для узла ""%3"".'"),
			Контекст.ИмяПрава,
			Контекст.Список,
			Условие.Узел);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Если СвойстваПоля <> Null Тогда
		УсловиеРасчетаПоле(УсловиеРасчета, СвойстваПоля, Контекст);
	КонецЕсли;
	
	Если КореньУсловия Тогда
		УсловиеРасчета.Вставить("ТребуемыеРеквизитыТабличныхЧастейКлюча",
			Контекст.ТребуемыеРеквизитыТабличныхЧастейКлюча);
		
		ДобавитьЭлементВерсии(Контекст, "СтруктураРасчетаПрава" + Контекст.ИмяПрава,
			Контекст.СтруктураРасчетаПраваСвойстваВерсии);
		
		Контекст.Удалить("СтруктураРасчетаПраваСвойстваВерсии");
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ЗаполнитьСтруктуруРасчетаПрава.
Процедура УсловиеРасчетаПоле(УсловиеРасчета, СвойстваПоля, Контекст)
	
	Если Контекст.СвойстваПолей.Найти(СвойстваПоля) = Неопределено Тогда
		УсловиеРасчета = Null; // Поле удалено из-за неиспользуемых типов значений доступа.
	Иначе
		УсловиеРасчета = Новый Структура("Узел", "Поле");
		УсловиеРасчета.Вставить("Таблица",  СвойстваПоля.ИмяГруппыПолейКлючаДоступа);
		УсловиеРасчета.Вставить("Реквизит", СвойстваПоля.ИмяРеквизитаГруппыПолейКлючаДоступа);
		Если СтрНачинаетсяС(УсловиеРасчета.Таблица, "ТабличнаяЧасть") Тогда
			Реквизиты = Контекст.ТребуемыеРеквизитыТабличныхЧастейКлюча.Получить(УсловиеРасчета.Таблица);
			Если Реквизиты = Неопределено Тогда
				Реквизиты = Новый Массив;
				Контекст.ТребуемыеРеквизитыТабличныхЧастейКлюча.Вставить(УсловиеРасчета.Таблица, Реквизиты);
			КонецЕсли;
			Если Реквизиты.Найти(УсловиеРасчета.Реквизит) = Неопределено Тогда
				Реквизиты.Добавить(УсловиеРасчета.Реквизит);
			КонецЕсли;
		КонецЕсли;
		ДобавитьСвойствоВерсииСтруктурыРасчета(Контекст, "Таблица",  УсловиеРасчета.Таблица);
		ДобавитьСвойствоВерсииСтруктурыРасчета(Контекст, "Реквизит", УсловиеРасчета.Реквизит);
		Если СвойстваПоля.Свойство("ПроверкаЕстьNull") Тогда
			УсловиеРасчета.Вставить("ПроверкаЕстьNull");
			ДобавитьСвойствоВерсииСтруктурыРасчета(Контекст, "ПроверкаЕстьNull", Истина);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Для процедур ЗаполнитьСтруктуруРасчетаПрава, УсловиеРасчетаПоле.
Процедура ДобавитьСвойствоВерсииСтруктурыРасчета(Контекст, Имя, Значение);
	
	Если ТипЗнч(Значение) = Тип("Соответствие") Тогда
		СписокЗначений = Новый СписокЗначений;
		Для Каждого КлючИЗначение Из Значение Цикл
			СписокЗначений.Добавить(КлючИЗначение.Значение, КлючИЗначение.Ключ);
		КонецЦикла;
		СписокЗначений.СортироватьПоПредставлению();
		Для Каждого ЭлементСписка Из СписокЗначений Цикл
			Контекст.СтруктураРасчетаПраваСвойстваВерсии.Добавить(ЭлементСписка.Представление);
			Контекст.СтруктураРасчетаПраваСвойстваВерсии.Добавить(ЭлементСписка.Значение);
		КонецЦикла;
	Иначе
		Контекст.СтруктураРасчетаПраваСвойстваВерсии.Добавить(Имя);
		Контекст.СтруктураРасчетаПраваСвойстваВерсии.Добавить(Значение);
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ЗаполнитьГруппыПолейИДополнительныхТаблиц.
Функция Степень16(Степень)
	
	Степень16 = 1;
	
	Для Счетчик = 1 По Степень Цикл
		Степень16 = Степень16 * 16;
	КонецЦикла;
	
	Возврат Степень16;
	
КонецФункции

// Для функции ЗаполнитьГруппыПолейИДополнительныхТаблиц.
Функция ГруппыДополнительныхТаблиц(Контекст)
	
	ДополнительныеТаблицы = Контекст.СтруктураОграничения.ДополнительныеТаблицы;
	НомераГруппПоПсевдонимам = Новый Соответствие;
	
	ОпорныеПоля = Контекст.ОпорныеПоля;
	ОпорныеПоля.Вставить("ПоДополнительнымТаблицам", Новый Соответствие);
	
	Контекст.Вставить("ПоляУсловияСоединенияДополнительныхТаблиц", Новый Массив);
	
	ПоследняяГруппа = 0;
	Для Каждого ДополнительнаяТаблица Из ДополнительныеТаблицы Цикл
		ДополнительнаяТаблица.Вставить("ПсевдонимыТребуемыхТаблиц", Новый Массив);
		ДополнительнаяТаблица.Вставить("ПоляУсловияСоединения", Новый Массив);
		ДополнительнаяТаблица.Вставить("ПолеПроверкиСоединения", "");
		
		ТекстУсловияСоединения = ТекстУсловияСоединения(ДополнительнаяТаблица, Контекст);
		ДополнительнаяТаблица.Вставить("ТекстУсловияСоединения", ?(Лев(ТекстУсловияСоединения, 1) = "(",
			ТекстУсловияСоединения, "(" + ТекстУсловияСоединения + ")"));
		
		Если Не ЗначениеЗаполнено(ДополнительнаяТаблица.ПолеПроверкиСоединения) Тогда
			ПоляКлючаДоступа = Контекст.ПоляКлючаДоступаПослеУпрощения;
			Для Каждого ОписаниеПоля Из ПоляКлючаДоступа Цикл
				Если ОписаниеПоля.Поле.Псевдоним = ДополнительнаяТаблица.Псевдоним Тогда
					ДополнительнаяТаблица.ПолеПроверкиСоединения =
						ДополнительнаяТаблица.Псевдоним + "." + ОписаниеПоля.Поле.Имя;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		ТекущаяГруппа = НомераГруппПоПсевдонимам.Получить(ДополнительнаяТаблица.Псевдоним);
		Если ТекущаяГруппа = Неопределено Тогда
			ПоследняяГруппа = ПоследняяГруппа + 1;
			ТекущаяГруппа = ПоследняяГруппа;
			НомераГруппПоПсевдонимам.Вставить(ДополнительнаяТаблица.Псевдоним, ТекущаяГруппа);
		КонецЕсли;
		
		Для Каждого Псевдоним Из ДополнительнаяТаблица.ПсевдонимыТребуемыхТаблиц Цикл
			ГруппаТребуемойТаблицы = НомераГруппПоПсевдонимам.Получить(Псевдоним);
			Если ГруппаТребуемойТаблицы = Неопределено Тогда
				НомераГруппПоПсевдонимам.Вставить(Псевдоним, ТекущаяГруппа);
				Продолжить;
			КонецЕсли;
			Если ГруппаТребуемойТаблицы = ТекущаяГруппа Тогда
				Продолжить;
			КонецЕсли;
			ПсевдонимыЗаменяемойГруппы = Новый Массив;
			Для Каждого КлючИЗначение Из НомераГруппПоПсевдонимам Цикл
				Если КлючИЗначение.Значение <> ГруппаТребуемойТаблицы Тогда
					Продолжить;
				КонецЕсли;
				ПсевдонимыЗаменяемойГруппы.Добавить(КлючИЗначение.Ключ);
			КонецЦикла;
			Для Каждого Псевдоним Из ПсевдонимыЗаменяемойГруппы Цикл
				НомераГруппПоПсевдонимам.Вставить(Псевдоним, ТекущаяГруппа);
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
	ПсевдонимыТаблицСПолями = Новый Соответствие;
	Для Каждого СвойстваПоля Из Контекст.СвойстваПолей Цикл
		Если СвойстваПоля.ПсевдонимТаблицы = "ТекущийСписок" Тогда
			Продолжить;
		КонецЕсли;
		ПсевдонимыТаблицСПолями.Вставить(СвойстваПоля.ПсевдонимТаблицы, Истина);
	КонецЦикла;
	
	ИспользованиеГрупп = Новый Соответствие;
	Для Группа = 1 По ПоследняяГруппа Цикл
		Для Каждого КлючИЗначение Из НомераГруппПоПсевдонимам Цикл
			Если КлючИЗначение.Значение <> Группа Тогда
				Продолжить;
			КонецЕсли;
			Если ИспользованиеГрупп.Получить(Группа) = Неопределено Тогда
				ИспользованиеГрупп.Вставить(Группа, Ложь);
			КонецЕсли;
			Если ПсевдонимыТаблицСПолями.Получить(КлючИЗначение.Ключ) <> Неопределено Тогда
				ИспользованиеГрупп.Вставить(Группа, Истина);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	НоваяГруппа = 1;
	НовыеГруппы = Новый Соответствие;
	Для Каждого ДополнительнаяТаблица Из ДополнительныеТаблицы Цикл
		СтараяГруппа = НомераГруппПоПсевдонимам.Получить(ДополнительнаяТаблица.Псевдоним);
		Если Не ИспользованиеГрупп.Получить(СтараяГруппа) Тогда
			Продолжить;
		КонецЕсли;
		Если НовыеГруппы.Получить(СтараяГруппа) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		НовыеГруппы.Вставить(СтараяГруппа, НоваяГруппа);
		НоваяГруппа = НоваяГруппа + 1;
	КонецЦикла;
	
	Группы = Новый Структура;
	Группы.Вставить("НомераПоПсевдонимам",     Новый Соответствие);
	Группы.Вставить("ТаблицыПоГруппам",        Новый Соответствие);
	Группы.Вставить("ПсевдонимыТаблицСПолями", ПсевдонимыТаблицСПолями);
	
	Для Каждого ДополнительнаяТаблица Из ДополнительныеТаблицы Цикл
		СтараяГруппа = НомераГруппПоПсевдонимам.Получить(ДополнительнаяТаблица.Псевдоним);
		Если Не ИспользованиеГрупп.Получить(СтараяГруппа) Тогда
			Продолжить;
		КонецЕсли;
		УстановитьИспользованиеОпорногоПоля(ОпорныеПоля, , ДополнительнаяТаблица);
		Группа = НовыеГруппы.Получить(СтараяГруппа);
		Группы.НомераПоПсевдонимам.Вставить(ДополнительнаяТаблица.Псевдоним, Группа);
		ГруппаТаблиц = Группы.ТаблицыПоГруппам.Получить(Группа);
		Если ГруппаТаблиц = Неопределено Тогда
			ГруппаТаблиц = Новый Массив;
			Группы.ТаблицыПоГруппам.Вставить(Группа, ГруппаТаблиц);
		КонецЕсли;
		ГруппаТаблиц.Добавить(ДополнительнаяТаблица);
	КонецЦикла;
	
	Для Каждого СвойстваПоля Из Контекст.СвойстваПолей Цикл
		ТекущиеСвойства = СвойстваПоля;
		Пока ТекущиеСвойства <> Неопределено Цикл
			ДобавитьВедущиеСпискиПоЗначениямПолей(Контекст,
				ТекущиеСвойства.УзелПоле,
				ТекущиеСвойства.СвойстваВложения,
				?(ТекущиеСвойства.ЭтоПолеСписка, Неопределено, ТекущиеСвойства.ПсевдонимТаблицы));
			ТекущиеСвойства = ТекущиеСвойства.СвойстваВложения;
		КонецЦикла;
	КонецЦикла;
	
	Для Каждого ОписаниеПоляУсловия Из Контекст.ПоляУсловияСоединенияДополнительныхТаблиц Цикл
		Группа = Группы.НомераПоПсевдонимам.Получить(ОписаниеПоляУсловия.ПсевдонимТаблицыУсловия);
		Если Группа <> Неопределено Тогда
			УзелПоле = ОписаниеПоляУсловия.УзелПоле;
			ДобавитьСвойстваВерсии(Контекст, УзелПоле, "Псевдоним, Имя, ТипыСтрокой");
			ДобавитьВедущиеСпискиПоЗначениямПолей(Контекст, УзелПоле,,
				Группы.ТаблицыПоГруппам.Получить(Группа), ОписаниеПоляУсловия.ПсевдонимТаблицыУсловия);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого Описание Из Контекст.ВедущиеСпискиПоЗначениямПолей.СоединенияОтборов Цикл
		ЗаполнитьОтборыПоЗначениямПолейВедущегоСписка(Описание.Ключ,
			Описание.Значение, Группы, Контекст);
	КонецЦикла;
	ЗаполнитьОтборыВедущихСписковПоПолюСсылка(Контекст.ВедущиеСпискиПоКлючамДоступа, Группы, Контекст);
	ЗаполнитьОтборыВедущихСписковПоПолюСсылка(Контекст.ВедущиеСпискиПоЗначениямСГруппами, Группы, Контекст);
	
	Возврат Группы;
	
КонецФункции

// Для функции ГруппыДополнительныхТаблиц.
Функция ТекстУсловияСоединения(ДополнительнаяТаблица, Контекст,
			Условие = Null, Поле = Неопределено, Псевдоним = Неопределено)
	
	Если Условие = Null Тогда
		Условие = ДополнительнаяТаблица.УсловиеСоединения;
	КонецЕсли;
	
	// Возможные узлы: "Поле", "Значение", "Константа", "И", "=".
	
	Если Условие.Узел = "Поле" Тогда
		Контекст.ПоляУсловияСоединенияДополнительныхТаблиц.Добавить(Новый Структура(
			"УзелПоле, ПсевдонимТаблицыУсловия", Условие, ДополнительнаяТаблица.Псевдоним));
		Если Условие.Псевдоним = Контекст.СтруктураОграничения.ПсевдонимОсновнойТаблицы Тогда
			ДобавитьОпорноеПоле(Контекст, Условие, , ДополнительнаяТаблица);
			Псевдоним = "ТекущийСписок";
			Поле = Псевдоним + "." + Условие.Имя;
			Возврат ИмяПоляСРазверткойОпорногоПоляПоТипам(Псевдоним, Условие);
		КонецЕсли;
		Псевдоним = Условие.Псевдоним;
		Если Псевдоним = ДополнительнаяТаблица.Псевдоним Тогда
			Если ДополнительнаяТаблица.ПолеПроверкиСоединения = "" Тогда
				ДополнительнаяТаблица.ПолеПроверкиСоединения = Псевдоним + "." + Условие.Имя;
			КонецЕсли;
		ИначеЕсли ДополнительнаяТаблица.ПсевдонимыТребуемыхТаблиц.Найти(Псевдоним) = Неопределено Тогда
			ДополнительнаяТаблица.ПсевдонимыТребуемыхТаблиц.Добавить(Псевдоним);
		КонецЕсли;
		Поле = Псевдоним + "." + Условие.Имя;
		Возврат Поле;
	КонецЕсли;
	
	Если Условие.Узел = "Значение"
	 Или Условие.Узел = "Константа" Тогда
		
		Поле = ВыражениеУзлаЗначениеИлиКонстанта(Условие);
		Возврат Поле;
	КонецЕсли;
	
	Если Условие.Узел = "И" Тогда
		Текст = "";
		Для Каждого Аргумент Из Условие.Аргументы Цикл
			Текст = Текст + ?(Текст = "", "", Символы.ПС + "И ");
			Текст = Текст + ТекстУсловияСоединения(ДополнительнаяТаблица, Контекст, Аргумент);
		КонецЦикла;
		Возврат Текст;
	КонецЕсли;
	
	Если Условие.Узел = "=" Тогда
		ПервоеПоле = Новый Структура("Поле, Псевдоним");
		ВтороеПоле = Новый Структура("Поле, Псевдоним");
		
		ПервыйАргумент = ТекстУсловияСоединения(ДополнительнаяТаблица,
			Контекст, Условие.ПервыйАргумент, ПервоеПоле.Поле, ПервоеПоле.Псевдоним);
		
		ВторойАргумент = ТекстУсловияСоединения(ДополнительнаяТаблица,
			Контекст, Условие.ВторойАргумент, ВтороеПоле.Поле, ВтороеПоле.Псевдоним);
		
		Если ПервоеПоле.Псевдоним = ДополнительнаяТаблица.Псевдоним
		 Или Не ЗначениеЗаполнено(ВтороеПоле.Псевдоним) Тогда
			ТекстУсловия = "(" + ПервыйАргумент + " = " + ВторойАргумент + ")";
			ПоляУсловия = Новый Структура("ПервоеПоле, ВтороеПоле", ПервоеПоле, ВтороеПоле);
		Иначе
			ТекстУсловия = "(" + ВторойАргумент + " = " + ПервыйАргумент + ")";
			ПоляУсловия = Новый Структура("ПервоеПоле, ВтороеПоле", ВтороеПоле, ПервоеПоле);
		КонецЕсли;
		ДополнительнаяТаблица.ПоляУсловияСоединения.Добавить(ПоляУсловия);
		Возврат ТекстУсловия;
	КонецЕсли;
	
	ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Не определена обработка узла ""%1""'"), Условие.Узел);
	
	ВызватьИсключение ТекстОшибки;
	
КонецФункции

// Для функций СвойстваПоля, ТекстУсловияСоединения.
Процедура ДобавитьОпорноеПоле(Контекст, УзелПоле, СвойстваПоля = Неопределено, ДополнительнаяТаблица = Неопределено)
	
	Если Не УзелПоле.Свойство("ОсновнойПорядок") Тогда
		Возврат;
	КонецЕсли;
	
	Позиция = СтрНайти(УзелПоле.Имя, ".");
	Если Позиция = 0 Тогда
		ИмяОпорногоПоля = УзелПоле.Имя;
	Иначе
		ИмяОпорногоПоля = Лев(УзелПоле.Имя, Позиция - 1);
	КонецЕсли;
	
	ОпорныеПоля = Контекст.ОпорныеПоля;
	
	Если СвойстваПоля <> Неопределено Тогда
		ОпорныеПоля.ПоСвойствамПолей.Вставить(СвойстваПоля, ИмяОпорногоПоля);
	КонецЕсли;
	
	Если ДополнительнаяТаблица <> Неопределено Тогда
		ИменаОпорныхПолей = ОпорныеПоля.ПоДополнительнымТаблицам.Получить(ДополнительнаяТаблица);
		Если ИменаОпорныхПолей = Неопределено Тогда
			ИменаОпорныхПолей = Новый Массив;
			ОпорныеПоля.ПоДополнительнымТаблицам.Вставить(ДополнительнаяТаблица, ИменаОпорныхПолей);
		КонецЕсли;
		ИменаОпорныхПолей.Добавить(ИмяОпорногоПоля);
	КонецЕсли;
	
	Если ОпорныеПоля.Список.НайтиПоЗначению(ИмяОпорногоПоля) = Неопределено Тогда
		ОпорныеПоля.Список.Добавить(ИмяОпорногоПоля, УзелПоле.ОсновнойПорядок);
		ТипыОпорногоПоля = УзелПоле.ТипыПоля[0];
		ОпорныеПоля.ТипыПоИменамПолей.Вставить(ИмяОпорногоПоля, ТипыОпорногоПоля);
		Если Не ЗначениеЗаполнено(Контекст.ИмяОтдельногоРегистраКлючей) Тогда
			ЗапрещенныеТипы = Новый Массив;
			Если ЕстьПростойТип(ТипыОпорногоПоля) Тогда
				Для Каждого Тип Из ТипыОпорногоПоля.Типы() Цикл
					Если ЭтоПростойТип(Тип) Тогда
						ЗапрещенныеТипы.Добавить(Строка(Тип));
					КонецЕсли;
				КонецЦикла;
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'В ограничении доступа списка %1
					           |опорное поле %2 содержит простые типы: %3.
					           |
					           |Это недопустимо при использовании общего регистра сведений КлючиДоступаКРегистрам.
					           |Требуется либо исключить простые типы из состава типов опорного поля,
					           |либо создать отдельный регистр ключей доступа для этого списка.'"),
					Контекст.Список,
					ИмяОпорногоПоля,
					СтрСоединить(ЗапрещенныеТипы, ", "));
				
				Если Контекст.Свойство("ОшибкаПриВызовеИсключения") Тогда
					Контекст.ОшибкаПриВызовеИсключения.Текст = ТекстОшибки;
				КонецЕсли;
				ВызватьИсключение ТекстОшибки;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Для процедур УдалитьПоляНеиспользуемыхВидовДоступа, ГруппыДополнительныхТаблиц.
Процедура УстановитьИспользованиеОпорногоПоля(ОпорныеПоля, СвойстваПоля = Неопределено, ДополнительнаяТаблица = Неопределено)
	
	Если СвойстваПоля <> Неопределено Тогда
		ИмяОпорногоПоля = ОпорныеПоля.ПоСвойствамПолей.Получить(СвойстваПоля);
		Если ИмяОпорногоПоля <> Неопределено Тогда
			ОпорныеПоля.Список.НайтиПоЗначению(ИмяОпорногоПоля).Пометка = Истина;
		КонецЕсли;
	Иначе
		ИменаОпорныхПолей = ОпорныеПоля.ПоДополнительнымТаблицам.Получить(ДополнительнаяТаблица);
		Если ИменаОпорныхПолей <> Неопределено Тогда
			Для Каждого ИмяОпорногоПоля Из ИменаОпорныхПолей Цикл
				ОпорныеПоля.Список.НайтиПоЗначению(ИмяОпорногоПоля).Пометка = Истина;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ЗаполнитьГруппыПолейИДополнительныхТаблиц.
Процедура ЗавершитьПодготовкуОпорныхПолей(Контекст)
	
	ОпорныеПоля = Контекст.ОпорныеПоля;
	ОпорныеПоля.Список.СортироватьПоПредставлению();
	
	Для Каждого ЭлементСписка Из ОпорныеПоля.Список Цикл
		ОпорныеПоля.Все.Добавить(ЭлементСписка.Значение);
		ОпорныеПоля.ТипыВсех.Добавить(Новый ХранилищеЗначения(
			ОпорныеПоля.ТипыПоИменамПолей.Получить(ЭлементСписка.Значение)));
		
		Если ЭлементСписка.Пометка Тогда
			ОпорныеПоля.Используемые.Добавить(ЭлементСписка.Значение);
			ОпорныеПоля.ТипыИспользуемых.Добавить(Новый ХранилищеЗначения(
				ОпорныеПоля.ТипыПоИменамПолей.Получить(ЭлементСписка.Значение)));
		КонецЕсли;
	КонецЦикла;
	
	ОпорныеПоля.Удалить("Список");
	ОпорныеПоля.Удалить("ТипыПоИменамПолей");
	ОпорныеПоля.Удалить("ПоСвойствамПолей");
	ОпорныеПоля.Удалить("ПоДополнительнымТаблицам");
	
КонецПроцедуры

// Для функций ТекстУсловияСоединения, СвойстваПоля.
Функция ИмяПоляСРазверткойОпорногоПоляПоТипам(Псевдоним, УзелПоле)
	
	Если Не УзелПоле.Свойство("ОсновнойПорядок")
	 Или Не УзелПоле.Свойство("ТаблицыСледующегоПоля") Тогда
		
		Возврат Псевдоним + "." + УзелПоле.Имя;
	КонецЕсли;
	
	Позиция = СтрНайти(УзелПоле.Имя, ".");
	ОпорноеПоле = Псевдоним + "." + Лев(УзелПоле.Имя, Позиция - 1);
	ОстальныеПоля = Сред(УзелПоле.Имя, Позиция + 1);
	
	ИмяПоля = "";
	Для Каждого ИмяТипа Из УзелПоле.ТаблицыСледующегоПоля[0] Цикл
		ТекущееИмяПоля = "ВЫРАЗИТЬ(" + ОпорноеПоле + " КАК " + ИмяТипа + ")." + ОстальныеПоля;
		Если ЗначениеЗаполнено(ИмяПоля) Тогда
			ИмяПоля =
				"ЕСТЬNULL(" + ТекущееИмяПоля + ",
				|	" + ТекстСОтступом(ИмяПоля, "	") + ")";
		Иначе
			ИмяПоля = ТекущееИмяПоля;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ИмяПоля;
	
КонецФункции

// Для функции ПараметрыОграниченияДоступа.
Процедура ЗаполнитьСвойстваПолей(Контекст)
	
	// 1. Для полей-аргументов узлов сравнения  =, <>, В, ЕстьNull
	// вычисляется результат сравнения и сохраняется в ключе.
	
	// 2. Для значений типа Булево сохраняются значения:
	// - Перечисления.ДополнительныеЗначенияДоступа.ЗначениеИстина,
	// - Перечисления.ДополнительныеЗначенияДоступа.ЗначениеЛожь.
	
	// 3. Для значений типов Число, Дата, Строка сохраняется результат
	//    сравнения со значением Истина, как указано в пункте 2.
	
	Контекст.ОпорныеПоля.Вставить("ТипыПоИменамПолей", Новый Соответствие);
	Контекст.ОпорныеПоля.Вставить("ПоСвойствамПолей",  Новый Соответствие);
	
	СвойстваВсехПолей = Новый Соответствие;
	ПоляКлючаДоступаДоУпрощения = Контекст.СтруктураОграничения.ВнутренниеДанные.ПоляКлючаДоступа;
	Для Каждого ОписаниеПоля Из ПоляКлючаДоступаДоУпрощения Цикл
		СвойстваПоля = СвойстваПоля(ОписаниеПоля.Поле, Контекст);
		СвойстваВсехПолей.Вставить(ОписаниеПоля.Поле, СвойстваПоля);
	КонецЦикла;
	Контекст.Вставить("СвойстваВсехПолей", СвойстваВсехПолей);
	
	ОставшиесяПоляПослеУпрощения = Новый Соответствие;
	Контекст.Вставить("ОставшиесяПоляПослеУпрощения", ОставшиесяПоляПослеУпрощения);
	Контекст.Вставить("ИсходнаяСтруктураОграничения", Контекст.СтруктураОграничения);
	
	СтруктураОграничения = Новый Структура(Новый ФиксированнаяСтруктура(Контекст.СтруктураОграничения)); // см. УправлениеДоступом.СтруктураОграничения
	Контекст.Вставить("ИмяПрава", "Чтение");
	СтруктураОграничения.ОграничениеЧтения = УпрощенноеУсловиеОграничения(
		СтруктураОграничения.ОграничениеЧтения, Контекст, Истина);
	Контекст.Вставить("ИмяПрава", "Изменение");
	СтруктураОграничения.ОграничениеИзменения = УпрощенноеУсловиеОграничения(
		СтруктураОграничения.ОграничениеИзменения, Контекст, Истина);
	Контекст.Вставить("СтруктураОграничения", СтруктураОграничения);
	
	ПоляКлючаДоступаПослеУпрощения = Новый Массив;
	Для Каждого ОписаниеПоля Из ПоляКлючаДоступаДоУпрощения Цикл
		РодителиПоля = ОставшиесяПоляПослеУпрощения.Получить(ОписаниеПоля.Поле);
		Если РодителиПоля = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		РодителиПоля.Добавить(Новый Структура("Узел", ""));
		ОписаниеПоля.Вставить("Родители", РодителиПоля);
		ПоляКлючаДоступаПослеУпрощения.Добавить(ОписаниеПоля);
	КонецЦикла;
	Контекст.Вставить("ПоляКлючаДоступаПослеУпрощения", ПоляКлючаДоступаПослеУпрощения);
	
	Контекст.Вставить("СвойстваПолейКлючаДоступа", Новый Соответствие);
	ДобавленныеПоля = Новый Соответствие;
	ИменаПолейДляЗапроса = Новый Массив;
	Для Каждого ОписаниеПоля Из ПоляКлючаДоступаПослеУпрощения Цикл
		СвойстваПоля = СвойстваВсехПолей.Получить(ОписаниеПоля.Поле);
		СвойстваПоля.Вставить("Чтение", ОписаниеПоля.Чтение);
		УточнитьСвойстваПоляСравнения(СвойстваПоля, ОписаниеПоля, Контекст);
		НаборПолей = НаборПолейУсловияКогда(СвойстваПоля, ОписаниеПоля, Контекст);
		Для Каждого СвойстваПоля Из НаборПолей Цикл
			ДобавитьСвойстваТиповПоля(СвойстваПоля, ОписаниеПоля, Контекст);
			ОдинаковыеПоля = ДобавленныеПоля.Получить(ВРег(СвойстваПоля.ИмяПоляДляЗапроса));
			Если ОдинаковыеПоля = Неопределено Тогда
				ОдинаковыеПоля = Новый Массив;
				ДобавленныеПоля.Вставить(ВРег(СвойстваПоля.ИмяПоляДляЗапроса), ОдинаковыеПоля);
				ИменаПолейДляЗапроса.Добавить(СвойстваПоля.ИмяПоляДляЗапроса);
			КонецЕсли;
			ОдинаковыеПоля.Добавить(СвойстваПоля);
		КонецЦикла;
	КонецЦикла;
	
	СвойстваПолей = Новый Массив;
	СовмещенныеПоля = Новый Соответствие;
	Для Каждого ИмяПоляДляЗапроса Из ИменаПолейДляЗапроса Цикл
		ОдинаковыеПоля = ДобавленныеПоля.Получить(ВРег(ИмяПоляДляЗапроса));
		ОбработанныеОдинаковыеПоля = Новый Массив;
		Для Каждого СвойстваПоля Из ОдинаковыеПоля Цикл
			СовмещенноеПоле = ОбработанноеСовмещенноеПоле(ОбработанныеОдинаковыеПоля, СвойстваПоля);
			Если СовмещенноеПоле <> Неопределено Тогда
				СовмещенныеПоля.Вставить(СвойстваПоля, СовмещенноеПоле);
				Продолжить;
			КонецЕсли;
			ОбработанныеОдинаковыеПоля.Добавить(СвойстваПоля);
		КонецЦикла;
		Для Каждого СвойстваПоля Из ОбработанныеОдинаковыеПоля Цикл
			СвойстваПолей.Добавить(СвойстваПоля);
		КонецЦикла;
	КонецЦикла;
	
	Для Каждого Описание Из Контекст.СвойстваПолейКлючаДоступа Цикл
		СовмещенноеПоле = СовмещенныеПоля.Получить(Описание.Значение);
		Если СовмещенноеПоле <> Неопределено Тогда
			Контекст.СвойстваПолейКлючаДоступа[Описание.Ключ] = СовмещенноеПоле;
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого СвойстваПоля Из СвойстваПолей Цикл
		СвойстваПоля.Вставить("ТипыСохраненияТиповКонфигурации", Новый Массив);
		СвойстваПоля.Вставить("ТипыСохраненияТиповРасширений",   Новый Массив);
		СвойстваПоля.Вставить("ТипыСохраненияТиповПростых",      Новый Массив);
		
		Для Каждого Тип Из СвойстваПоля.ТипыСохраненияТипов Цикл
			ОбъектМетаданных = Неопределено;
			ИмяТипа = ИмяТипаНаЯзыкеЗапросов(Тип, ОбъектМетаданных);
			
			Если СтрНайти(ИмяТипа, ".") = 0 Тогда
				СвойстваПоля.ТипыСохраненияТиповПростых.Добавить(Тип);
				
			ИначеЕсли ОбъектМетаданных.РасширениеКонфигурации() = Неопределено Тогда
				СвойстваПоля.ТипыСохраненияТиповКонфигурации.Добавить(Тип);
			Иначе
				СвойстваПоля.ТипыСохраненияТиповРасширений.Добавить(Тип);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Контекст.Вставить("СвойстваПолей", СвойстваПолей);
	
КонецПроцедуры

// Для процедуры ЗаполнитьСвойстваПолей.
Функция УпрощенноеУсловиеОграничения(Знач Условие, Контекст, КореньУсловия = Ложь, ДобавитьОставшиесяПоля = Истина)
	
	Если Не ЗначениеЗаполнено(Условие) Тогда
		Возврат Условие;
	КонецЕсли;
	
	ОставшиесяПоляПослеУпрощения = Контекст.ОставшиесяПоляПослеУпрощения;
	Контекст.ОставшиесяПоляПослеУпрощения = Новый Соответствие;
	
	Если Условие.Узел = "Поле" Тогда
		Контекст.ОставшиесяПоляПослеУпрощения.Вставить(Условие, Новый Массив);
		
	ИначеЕсли Условие.Узел = "И"
	      Или Условие.Узел = "Или" Тогда
		
		БезусловныйРезультат = ?(Условие.Узел = "И", Ложь, Истина);
		ЕстьБезусловныйРезультат = Ложь;
		Аргументы = Новый Массив;
		Для Каждого ТекущийАргумент Из Условие.Аргументы Цикл
			Аргумент = УпрощенноеУсловиеОграничения(ТекущийАргумент, Контекст);
			Если Аргумент.Узел <> "Константа" Тогда
				Аргументы.Добавить(Аргумент);
			ИначеЕсли Аргумент.Значение = БезусловныйРезультат Тогда
				ЕстьБезусловныйРезультат = Истина;
			КонецЕсли;
		КонецЦикла;
		Если ЕстьБезусловныйРезультат Или Аргументы.Количество() = 0 Тогда
			Условие = Новый Структура("Узел, Значение", "Константа", БезусловныйРезультат);
		ИначеЕсли Аргументы.Количество() = 1 Тогда
			Условие = Аргументы[0];
		Иначе
			Условие = Новый Структура("Узел, Аргументы", Условие.Узел, Аргументы);
		КонецЕсли;
		
	ИначеЕсли Условие.Узел = "Не" Тогда
		Аргумент = УпрощенноеУсловиеОграничения(Условие.Аргумент, Контекст);
		Если Аргумент.Узел = "Константа" Тогда
			Условие = Новый Структура("Узел, Значение", "Константа", Не Аргумент.Значение);
		Иначе
			Условие = Новый Структура("Узел, Аргумент", Условие.Узел, Аргумент);
		КонецЕсли;
		
	ИначеЕсли Условие.Узел = "ДляВсехСтрок"
	      Или Условие.Узел = "ДляОднойИзСтрок"
	      Или Условие.Узел = "ЕстьNull"
	      Или Условие.Узел = "ТипЗначения" Тогда
		
		Аргумент = УпрощенноеУсловиеОграничения(Условие.Аргумент, Контекст);
		Если Аргумент.Узел = "Константа" Тогда
			Условие = Аргумент;
		Иначе
			Условие = Новый Структура("Узел, Аргумент", Условие.Узел, Аргумент);
		КонецЕсли;
		
	ИначеЕсли Условие.Узел = "="
	      Или Условие.Узел = "<>" Тогда
		
		ПервыйАргумент = УпрощенноеУсловиеОграничения(Условие.ПервыйАргумент, Контекст);
		ВторойАргумент = УпрощенноеУсловиеОграничения(Условие.ВторойАргумент, Контекст);
		
		Если ПервыйАргумент.Узел = "Константа"
		   И ВторойАргумент.Узел = "Константа" Тогда
			
			Условие = Новый Структура("Узел, Значение", "Константа", ?(Условие.Узел = "=",
				ПервыйАргумент.Значение =  ВторойАргумент.Значение,
				ПервыйАргумент.Значение <> ВторойАргумент.Значение));
		Иначе
			Условие = Новый Структура("Узел, ПервыйАргумент, ВторойАргумент",
				Условие.Узел, ПервыйАргумент, ВторойАргумент);
		КонецЕсли;
		
	ИначеЕсли Условие.Узел = "В" Тогда
		Условие = Новый Структура("Узел, Искомое, Значения",
			Условие.Узел,
			УпрощенноеУсловиеОграничения(Условие.Искомое, Контекст),
			Условие.Значения);
		
	ИначеЕсли Условие.Узел = "Выбор" Тогда
		ВсеЗначенияВыбораИстина = Истина;
		ВсеЗначенияВыбораЛожь   = Истина;
		Выбор = Новый Структура("Узел, Выбор, Когда, Иначе", Условие.Узел, Условие.Выбор, Новый Массив);
		НовоеУсловиеИначе = Неопределено;
		Для Каждого Когда Из Условие.Когда Цикл
			Если Условие.Выбор = Неопределено Тогда
				УсловиеКогда = УпрощенноеУсловиеОграничения(Когда.Условие, Контекст);
				Если УсловиеКогда.Узел = "Константа" Тогда
					Если УсловиеКогда.Значение Тогда
						НовоеУсловиеИначе = ?(НовоеУсловиеИначе = Неопределено, Когда.Значение, НовоеУсловиеИначе);
					КонецЕсли;
					ЗначениеКогда = УпрощенноеУсловиеОграничения(Когда.Значение, Контекст, , Ложь);
					Продолжить;
				КонецЕсли;
			Иначе
				УсловиеКогда = Когда.Условие;
			КонецЕсли;
			ЗначениеКогда = УпрощенноеУсловиеОграничения(Когда.Значение, Контекст);
			ОбработатьУпрощенноеЗначениеВыбора(ЗначениеКогда, ВсеЗначенияВыбораИстина, ВсеЗначенияВыбораЛожь);
			СтруктураКогда = Новый Структура("Условие, Значение", УсловиеКогда, ЗначениеКогда);
			Выбор.Когда.Добавить(СтруктураКогда);
		КонецЦикла;
		УсловиеИначе = ?(НовоеУсловиеИначе = Неопределено, Условие.Иначе, НовоеУсловиеИначе);
		Выбор.Иначе = УпрощенноеУсловиеОграничения(УсловиеИначе, Контекст);
		ОбработатьУпрощенноеЗначениеВыбора(Выбор.Иначе, ВсеЗначенияВыбораИстина, ВсеЗначенияВыбораЛожь);
		Если ВсеЗначенияВыбораИстина Или ВсеЗначенияВыбораЛожь Тогда
			Условие = Новый Структура("Узел, Значение", "Константа", ВсеЗначенияВыбораИстина);
		ИначеЕсли Выбор.Когда.Количество() = 0 Тогда
			Условие = Выбор.Иначе;
		Иначе
			Условие = Выбор;
		КонецЕсли;
		
	ИначеЕсли Условие.Узел = "ЗначениеРазрешено"
	      Или Условие.Узел = "ЧтениеОбъектаРазрешено"
	      Или Условие.Узел = "ИзменениеОбъектаРазрешено" Тогда
		
		СвойстваПоля = Контекст.СвойстваВсехПолей.Получить(Условие.Поле);
		Если СвойстваПоля = Неопределено Тогда
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'При упрощении условия ограничения права %1
				           |списка ""%2""
				           |свойства поля не определены для узла ""%3"".'"),
				Контекст.ИмяПрава,
				Контекст.Список,
				Условие.Узел);
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
		ТипыКонечногоПоля = СвойстваПоля.ТипКонечногоПоля.Типы();
		
		Если Условие.Узел = "ЗначениеРазрешено" Тогда
			Результат = РезультатФункцииЗначениеРазрешено(Условие, ТипыКонечногоПоля, Контекст);
		Иначе
			Результат = РезультатФункцииПравоОбъектаРазрешено(Условие, ТипыКонечногоПоля, Контекст);
		КонецЕсли;
		
		Если Результат <> Неопределено Тогда
			Условие = Новый Структура("Узел, Значение", "Константа", Результат);
		Иначе
			Контекст.ОставшиесяПоляПослеУпрощения.Вставить(Условие.Поле, Новый Массив);
		КонецЕсли;
		
	ИначеЕсли Условие.Узел = "ЭтоАвторизованныйПользователь"
	      Или Условие.Узел = "ЧтениеСпискаРазрешено"
	      Или Условие.Узел = "ИзменениеСпискаРазрешено" Тогда
		
		Контекст.ОставшиесяПоляПослеУпрощения.Вставить(Условие.Поле, Новый Массив);
		
	ИначеЕсли Условие.Узел <> "Константа"
	        И Условие.Узел <> "Значение"
	        И Условие.Узел <> "Тип" Тогда
		
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'При упрощении условия ограничения права %1
			           |списка ""%2""
			           |узел не поддерживается ""%3"".'"),
			Контекст.ИмяПрава,
			Контекст.Список,
			Условие.Узел);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Если Условие.Узел <> "Константа" И ДобавитьОставшиесяПоля Тогда
		Для Каждого КлючИЗначение Из Контекст.ОставшиесяПоляПослеУпрощения Цикл
			Если Условие.Узел <> "Поле" Тогда
				КлючИЗначение.Значение.Добавить(Условие);
			КонецЕсли;
			ОставшиесяПоляПослеУпрощения.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	Контекст.ОставшиесяПоляПослеУпрощения = ОставшиесяПоляПослеУпрощения;
	
	Возврат Условие;
	
КонецФункции

// Для функции УпрощенноеУсловиеОграничения.
Процедура ОбработатьУпрощенноеЗначениеВыбора(Условие, ВсеЗначенияВыбораИстина, ВсеЗначенияВыбораЛожь)
	
	Если Условие.Узел <> "Константа" Тогда
		ВсеЗначенияВыбораИстина = Ложь;
		ВсеЗначенияВыбораЛожь   = Ложь;
		
	ИначеЕсли Условие.Значение Тогда
		ВсеЗначенияВыбораЛожь = Ложь;
	Иначе
		ВсеЗначенияВыбораИстина = Ложь;
	КонецЕсли;
	
КонецПроцедуры

// Для функции УпрощенноеУсловиеОграничения.
Функция РезультатФункцииЗначениеРазрешено(Условие, ТипыКонечногоПоля, Контекст)

	СвойстваВидовДоступаПоТипам = Контекст.СвойстваВидовДоступа.ПоТипамГруппИЗначений;
	ОтключеноКакЛожь = УточнениеТипа(Условие, "Отключено") = "Ложь";
	
	РезультатВсегдаЛожь   = Истина;
	РезультатВсегдаИстина = Истина;
	
	Для Каждого Тип Из ТипыКонечногоПоля Цикл
		ИмяТипа = ИмяТипаНаЯзыкеЗапросов(Тип);
		
		Уточнение = УточнениеТипа(Условие, ИмяТипа);
		Если Уточнение = "Истина" Тогда
			РезультатВсегдаЛожь = Ложь;
			Продолжить;
		ИначеЕсли Уточнение = "Ложь" Тогда
			РезультатВсегдаИстина = Ложь;
			Продолжить;
		КонецЕсли;
		
		Если Не ТипПроверяется(Условие, ИмяТипа) Тогда
			РезультатВсегдаИстина = Ложь;
			Продолжить;
		КонецЕсли;
		
		СвойстваВидаДоступа = СвойстваВидовДоступаПоТипам.Получить(Тип);
		Если СвойстваВидаДоступа = Неопределено Тогда
			РезультатВсегдаЛожь = Ложь;
			Продолжить;
		КонецЕсли;
		
		Если Контекст.ИспользуемыеТипыЗначений.Получить(СвойстваВидаДоступа.ТипЗначений) = Неопределено Тогда
			Если Контекст.НеиспользуемыеТипыЗначенийДоступа.Найти(СвойстваВидаДоступа.ТипЗначений) = Неопределено Тогда
				Контекст.НеиспользуемыеТипыЗначенийДоступа.Добавить(СвойстваВидаДоступа.ТипЗначений);
			КонецЕсли;
			Если ОтключеноКакЛожь Тогда
				РезультатВсегдаИстина = Ложь;
			Иначе
				РезультатВсегдаЛожь = Ложь;
			КонецЕсли;
		Иначе
			РезультатВсегдаИстина = Ложь;
			РезультатВсегдаЛожь = Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Если РезультатВсегдаИстина Тогда
		Возврат Истина;
	ИначеЕсли РезультатВсегдаЛожь Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Для функции УпрощенноеУсловиеОграничения.
Функция РезультатФункцииПравоОбъектаРазрешено(Условие, ТипыКонечногоПоля, Контекст)

	Если Контекст.ОграничениеДоступаВключено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	РезультатВсегдаИстина = Истина;
	
	Для Каждого Тип Из ТипыКонечногоПоля Цикл
		ИмяТипа = ИмяТипаНаЯзыкеЗапросов(Тип);
		
		Уточнение = УточнениеТипа(Условие, ИмяТипа);
		Если Уточнение = "Истина" Тогда
			Продолжить;
		ИначеЕсли Уточнение = "Ложь" Тогда
			РезультатВсегдаИстина = Ложь;
			Прервать;
		КонецЕсли;
		
		Если Не ТипПроверяется(Условие, ИмяТипа) Тогда
			РезультатВсегдаИстина = Ложь;
			Прервать;
		КонецЕсли;
		
		Значение = Контекст.ТипыВладельцевНастроекПрав.Получить(Тип);
		Если Значение = Неопределено
		 Или ВРег(Контекст.Список) <> ВРег(Значение[0].ВладелецПрав) Тогда
		
			РезультатВсегдаИстина = Ложь;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если РезультатВсегдаИстина Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Для процедуры ЗаполнитьСвойстваПолей.
Функция ОбработанноеСовмещенноеПоле(ОбработанныеОдинаковыеПоля, СвойстваПоля)
	
	Для Каждого Поле Из ОбработанныеОдинаковыеПоля Цикл
		Совместимо = Истина;
		Если Поле.ПсевдонимТаблицы = "ТекущийСписок"
		   И Поле.НесколькоГруппЗначений <> СвойстваПоля.НесколькоГруппЗначений Тогда
			Продолжить;
		КонецЕсли;
		// По пустой ссылке на ключ доступа или значению Null невозможно определить тип значения,
		// поэтому сохранение ключа доступа несовместимо с остальными вариантами.
		Для Каждого Тип Из СвойстваПоля.ТипыСохраненияКлючейДоступа Цикл
			Если Поле.ТипыСохраненияЗначений.Найти(Тип)        <> Неопределено
			 Или Поле.ТипыСохраненияГруппЗначений.Найти(Тип)   <> Неопределено
			 Или Поле.ТипыСохраненияТипов.Найти(Тип)           <> Неопределено
			 Или Поле.ТипыСохраненияТипаЗапрещенный.Найти(Тип) <> Неопределено
			 Или Поле.ТипыСохраненияТипаРазрешенный.Найти(Тип) <> Неопределено Тогда
				Совместимо = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Для Каждого Тип Из Поле.ТипыСохраненияКлючейДоступа Цикл
			Если СвойстваПоля.ТипыСохраненияЗначений.Найти(Тип)        <> Неопределено
			 Или СвойстваПоля.ТипыСохраненияГруппЗначений.Найти(Тип)   <> Неопределено
			 Или СвойстваПоля.ТипыСохраненияТипов.Найти(Тип)           <> Неопределено
			 Или СвойстваПоля.ТипыСохраненияТипаЗапрещенный.Найти(Тип) <> Неопределено
			 Или СвойстваПоля.ТипыСохраненияТипаРазрешенный.Найти(Тип) <> Неопределено Тогда
				Совместимо = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если Не Совместимо Тогда
			Продолжить;
		КонецЕсли;
		// По значению Null вместо группы значений невозможно определить тип значения,
		// поэтому сохранение группы значений несовместимо с остальными вариантами.
		Для Каждого Тип Из СвойстваПоля.ТипыСохраненияГруппЗначений Цикл
			Если Поле.ТипыСохраненияЗначений.Найти(Тип)        <> Неопределено
			 Или Поле.ТипыСохраненияТипов.Найти(Тип)           <> Неопределено
			 Или Поле.ТипыСохраненияТипаЗапрещенный.Найти(Тип) <> Неопределено
			 Или Поле.ТипыСохраненияТипаРазрешенный.Найти(Тип) <> Неопределено Тогда
				Совместимо = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Для Каждого Тип Из Поле.ТипыСохраненияГруппЗначений Цикл
			Если СвойстваПоля.ТипыСохраненияЗначений.Найти(Тип)        <> Неопределено
			 Или СвойстваПоля.ТипыСохраненияТипов.Найти(Тип)           <> Неопределено
			 Или СвойстваПоля.ТипыСохраненияТипаЗапрещенный.Найти(Тип) <> Неопределено
			 Или СвойстваПоля.ТипыСохраненияТипаРазрешенный.Найти(Тип) <> Неопределено Тогда
				Совместимо = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		// Вместо простых типов сохраняется значения ТипРазрешенный или ТипЗапрещенный,
		// поэтому сохранение запрещенного простого типа несовместимо с остальными вариантами.
		Для Каждого Тип Из СвойстваПоля.ТипыСохраненияТипаЗапрещенный Цикл
			Если Не ЭтоПростойТип(Тип) Тогда
				Продолжить;
			КонецЕсли;
			Если Поле.ТипыСохраненияТипов.Найти(Тип)           <> Неопределено
			 Или Поле.ТипыСохраненияТипаРазрешенный.Найти(Тип) <> Неопределено Тогда
				Совместимо = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Для Каждого Тип Из Поле.ТипыСохраненияТипаЗапрещенный Цикл
			Если Не ЭтоПростойТип(Тип) Тогда
				Продолжить;
			КонецЕсли;
			Если СвойстваПоля.ТипыСохраненияТипов.Найти(Тип)           <> Неопределено
			 Или СвойстваПоля.ТипыСохраненияТипаРазрешенный.Найти(Тип) <> Неопределено Тогда
				Совместимо = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если Не Совместимо Тогда
			Продолжить;
		КонецЕсли;
		// Объединение уточнений специальных значений.
		Поле.ЕстьУточнениеNull =
			Поле.ЕстьУточнениеNull Или СвойстваПоля.ЕстьУточнениеNull;
		Поле.ЕстьУточнениеНеопределено =
			Поле.ЕстьУточнениеНеопределено Или СвойстваПоля.ЕстьУточнениеНеопределено;
		Поле.ЕстьТипВедущегоСписка =
			Поле.ЕстьТипВедущегоСписка Или СвойстваПоля.ЕстьТипВедущегоСписка;
		Поле.ЕстьТипВладельцаНастроекПрав =
			Поле.ЕстьТипВладельцаНастроекПрав Или СвойстваПоля.ЕстьТипВладельцаНастроекПрав;
		Поле.ЕстьПроверкаАвторизованногоПользователя =
			Поле.ЕстьПроверкаАвторизованногоПользователя Или СвойстваПоля.ЕстьПроверкаАвторизованногоПользователя;
		// Объединение типов сохранения пустой ссылки.
		Для Каждого Тип Из СвойстваПоля.ТипыСохраненияПустойСсылки Цикл
			Если Поле.ТипыСохраненияПустойСсылки.Найти(Тип) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			Поле.ТипыСохраненияПустойСсылки.Добавить(Тип);
		КонецЦикла;
		// Объединение типов сохранения значения ТипРазрешенный.
		Для Каждого Тип Из СвойстваПоля.ТипыСохраненияТипаРазрешенный Цикл
			Если Поле.ТипыСохраненияЗначений.Найти(Тип)        <> Неопределено
			 Или Поле.ТипыСохраненияТипов.Найти(Тип)           <> Неопределено
			 Или Поле.ТипыСохраненияТипаРазрешенный.Найти(Тип) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			Индекс = Поле.ТипыСохраненияТипаЗапрещенный.Найти(Тип);
			Если Индекс <> Неопределено Тогда
				Поле.ТипыСохраненияТипаЗапрещенный.Удалить(Индекс);
				Поле.ТипыСохраненияТипов.Добавить(Тип);
				Продолжить;
			КонецЕсли;
			Поле.ТипыСохраненияТипаРазрешенный.Добавить(Тип);
		КонецЦикла;
		// Объединение типов сохранения значения ТипЗапрещенный.
		Для Каждого Тип Из СвойстваПоля.ТипыСохраненияТипаЗапрещенный Цикл
			Если Поле.ТипыСохраненияЗначений.Найти(Тип)        <> Неопределено
			 Или Поле.ТипыСохраненияТипов.Найти(Тип)           <> Неопределено
			 Или Поле.ТипыСохраненияТипаЗапрещенный.Найти(Тип) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			Индекс = Поле.ТипыСохраненияТипаРазрешенный.Найти(Тип);
			Если Индекс <> Неопределено Тогда
				Поле.ТипыСохраненияТипаРазрешенный.Удалить(Индекс);
				Поле.ТипыСохраненияТипов.Добавить(Тип);
				Продолжить;
			КонецЕсли;
			Поле.ТипыСохраненияТипаЗапрещенный.Добавить(Тип);
		КонецЦикла;
		// Объединение типов сохранения типа значения.
		Для Каждого Тип Из СвойстваПоля.ТипыСохраненияТипов Цикл
			Если Поле.ТипыСохраненияЗначений.Найти(Тип) <> Неопределено
			 Или Поле.ТипыСохраненияТипов.Найти(Тип)    <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			Индекс = Поле.ТипыСохраненияТипаЗапрещенный.Найти(Тип);
			Если Индекс <> Неопределено Тогда
				Поле.ТипыСохраненияТипаЗапрещенный.Удалить(Индекс);
			КонецЕсли;
			Индекс = Поле.ТипыСохраненияТипаРазрешенный.Найти(Тип);
			Если Индекс <> Неопределено Тогда
				Поле.ТипыСохраненияТипаРазрешенный.Удалить(Индекс);
			КонецЕсли;
			Поле.ТипыСохраненияТипов.Добавить(Тип);
		КонецЦикла;
		// Объединение типов сохранения значения.
		Для Каждого Тип Из СвойстваПоля.ТипыСохраненияЗначений Цикл
			Если Поле.ТипыСохраненияЗначений.Найти(Тип) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			Индекс = Поле.ТипыСохраненияТипов.Найти(Тип);
			Если Индекс <> Неопределено Тогда
				Поле.ТипыСохраненияТипов.Удалить(Индекс);
			КонецЕсли;
			Индекс = Поле.ТипыСохраненияТипаЗапрещенный.Найти(Тип);
			Если Индекс <> Неопределено Тогда
				Поле.ТипыСохраненияТипаЗапрещенный.Удалить(Индекс);
			КонецЕсли;
			Индекс = Поле.ТипыСохраненияТипаРазрешенный.Найти(Тип);
			Если Индекс <> Неопределено Тогда
				Поле.ТипыСохраненияТипаРазрешенный.Удалить(Индекс);
			КонецЕсли;
			Поле.ТипыСохраненияЗначений.Добавить(Тип);
		КонецЦикла;
		// Объединение неиспользуемых типов значений доступа.
		Для Каждого Тип Из СвойстваПоля.НеиспользуемыеТипыЗначенийДоступа Цикл
			Если Поле.НеиспользуемыеТипыЗначенийДоступа.Найти(Тип) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			Поле.НеиспользуемыеТипыЗначенийДоступа.Добавить(Тип);
		КонецЦикла;
		// Объединение используемых типов значений доступа.
		Для Каждого Тип Из СвойстваПоля.ИспользуемыеТипыЗначенийДоступа Цикл
			Если Поле.ИспользуемыеТипыЗначенийДоступа.Найти(Тип) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			Поле.ИспользуемыеТипыЗначенийДоступа.Добавить(Тип);
		КонецЦикла;
		Поле.Чтение = Поле.Чтение Или СвойстваПоля.Чтение;
		Если Поле.ТипыСтрокой <> СвойстваПоля.ТипыСтрокой Тогда
			Поле.ТипыСтрокой = Поле.ТипыСтрокой + Символы.ПС + СвойстваПоля.ТипыСтрокой;
		КонецЕсли;
		Возврат Поле;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Для процедуры ЗаполнитьСвойстваПолей.
Процедура УточнитьСвойстваПоляСравнения(Свойства, ОписаниеПоля, Контекст)
	
	Контекст.СвойстваПолейКлючаДоступа.Вставить(ОписаниеПоля.Поле, Свойства);
	
	Родитель = ОписаниеПоля.Родители[0];
	
	Узлы = ",ТипЗначения,=,<>,В,ЕстьNull,"; // В ключ сохраняется результат сравнения.
	Если СтрНайти(Узлы, "," + Родитель.Узел + ",") = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если Родитель.Узел = "ТипЗначения" Тогда
		РодительУзлаСравнения = ОписаниеПоля.Родители[1];
		
		Если РодительУзлаСравнения.ВторойАргумент = Родитель Тогда
			УзелТип         = РодительУзлаСравнения.ПервыйАргумент;
			УзелТипЗначения = РодительУзлаСравнения.ВторойАргумент;
		Иначе
			УзелТип         = РодительУзлаСравнения.ВторойАргумент;
			УзелТипЗначения = РодительУзлаСравнения.ПервыйАргумент;
		КонецЕсли;
		Контекст.СвойстваПолейКлючаДоступа.Вставить(УзелТипЗначения, Свойства);
		
		ВыражениеТипаЗначения = "ТИПЗНАЧЕНИЯ(" + Свойства.ИмяПоляДляЗапроса + ")";
		ВыражениеТипа = "ТИП(" + УзелТип.Имя + ")";
		ОднойСтрокой = СтрДлина(ВыражениеТипаЗначения) + СтрДлина(ВыражениеТипа) < 60;
		
		Свойства.ИмяПоляДляЗапроса = ВыражениеТипаЗначения + ?(ОднойСтрокой, " ", "
		|			") + РодительУзлаСравнения.Узел + " " + ВыражениеТипа;
		
	ИначеЕсли Родитель.Узел = "="
	      Или Родитель.Узел = "<>" Тогда
		
		УзелЗначениеИлиКонстанта = ?(Родитель.ВторойАргумент = ОписаниеПоля.Поле,
			Родитель.ПервыйАргумент, Родитель.ВторойАргумент);
		
		ВыражениеУзла = ВыражениеУзлаЗначениеИлиКонстанта(УзелЗначениеИлиКонстанта);
		ОднойСтрокой = СтрДлина(Свойства.ИмяПоляДляЗапроса) + СтрДлина(ВыражениеУзла) < 60;
		
		Свойства.ИмяПоляДляЗапроса = Свойства.ИмяПоляДляЗапроса + ?(ОднойСтрокой, " ", "
		|			") + Родитель.Узел + " " + ВыражениеУзла;
		
	ИначеЕсли Родитель.Узел = "В" Тогда
		
		СписокЗначений = "";
		Для Каждого УзелЗначениеИлиКонстанта Из Родитель.Значения Цикл
			СписокЗначений = СписокЗначений + ?(СписокЗначений = "", "", ",");
			ПоследняяСтрока = СтрПолучитьСтроку(СписокЗначений, СтрЧислоСтрок(СписокЗначений));
			Если СтрДлина(ПоследняяСтрока) > 40 Тогда
				СписокЗначений = СписокЗначений + "
				|			";
			Иначе
				СписокЗначений = СписокЗначений + " ";
			КонецЕсли;
			СписокЗначений = СписокЗначений
				+ ВыражениеУзлаЗначениеИлиКонстанта(УзелЗначениеИлиКонстанта);
		КонецЦикла;
		Свойства.ИмяПоляДляЗапроса = Свойства.ИмяПоляДляЗапроса + "
		|	В (" + СписокЗначений + ")";
	
	Иначе // Родитель.Узел = "ЕстьNull".
		Свойства.ИмяПоляДляЗапроса = Свойства.ИмяПоляДляЗапроса + " ЕСТЬ NULL";
		Свойства.Вставить("ПроверкаЕстьNull");
	КонецЕсли;
	
	Свойства.ТипКонечногоПоля = Новый ОписаниеТипов("Булево");
	
КонецПроцедуры

// Для процедуры ЗаполнитьСвойстваПолей.
Функция НаборПолейУсловияКогда(ИсходныеСвойстваПоля, ОписаниеПоля, Контекст)
	
	Родитель = ОписаниеПоля.Родители[0];
	НаборПолей = Новый Массив;
	
	Если Родитель.Узел <> "Выбор"
	 Или Родитель.Выбор = Неопределено Тогда
		
		НаборПолей.Добавить(ИсходныеСвойстваПоля);
		Возврат НаборПолей;
	КонецЕсли;
	
	// Для "ВЫБОР <Поле> КОГДА <Значение>" в ключ сохраняется
	// результат сравнения "<Поле> = <Значение>".
	
	Для Каждого ОписаниеКогда Из Родитель.Когда Цикл
		ФиксированныеСвойства = Новый ФиксированнаяСтруктура(ИсходныеСвойстваПоля);
		Свойства = Новый Структура(ФиксированныеСвойства);
		
		ВыражениеУзла = ВыражениеУзлаЗначениеИлиКонстанта(ОписаниеКогда.Условие);
		ОднойСтрокой = СтрДлина(Свойства.ИмяПоляДляЗапроса) + СтрДлина(ВыражениеУзла) < 60;
		
		Свойства.ИмяПоляДляЗапроса = Свойства.ИмяПоляДляЗапроса + ?(ОднойСтрокой, " = ", "
		|			= ") + ВыражениеУзла;
		
		Свойства.ТипКонечногоПоля = Новый ОписаниеТипов("Булево");
		НаборПолей.Добавить(Свойства);
		
		Контекст.СвойстваПолейКлючаДоступа.Вставить(ОписаниеКогда.Условие, Свойства);
	КонецЦикла;
	
	Возврат НаборПолей;
	
КонецФункции

// Для функций СвойстваПоля, УточнитьСвойстваПоляСравнения, НаборПолейУсловияКогда.
Функция БезЗначенияNull(СвойстваПоля, ВГруппеОднаДополнительнаяТаблицаСПолями)
	
	Возврат СтрЧислоВхождений(СвойстваПоля.ИмяПоляДляЗапроса, ".") = 1
	      И Не СвойстваПоля.Свойство("ПолеСодержитNull")
	      И (    СтрНачинаетсяС(СвойстваПоля.ИмяПоляДляЗапроса, "ТекущийСписок")
	         Или ВГруппеОднаДополнительнаяТаблицаСПолями);
	
КонецФункции

// Для процедуры ЗаполнитьСвойстваПолей.
Процедура ДобавитьСвойстваТиповПоля(Свойства, ОписаниеПоля, Контекст)
	
	Свойства.Вставить("ТипыСохраненияКлючейДоступа",               Новый Массив);
	Свойства.Вставить("ТипыСохраненияГруппЗначений",               Новый Массив);
	Свойства.Вставить("ТипыСохраненияЗначений",                    Новый Массив);
	Свойства.Вставить("ТипыСохраненияПустойСсылки",                Новый Массив);
	Свойства.Вставить("ТипыСохраненияТипов",                       Новый Массив);
	Свойства.Вставить("ТипыСохраненияТипаЗапрещенный",             Новый Массив);
	Свойства.Вставить("ТипыСохраненияТипаРазрешенный",             Новый Массив);
	Свойства.Вставить("НеиспользуемыеТипыЗначенийДоступа",         Новый Массив);
	Свойства.Вставить("ИспользуемыеТипыЗначенийДоступа",           Новый Массив);
	Свойства.Вставить("НесколькоГруппЗначений",                    Ложь);
	Свойства.Вставить("ЭтоСписокЗначенийДоступаСГруппамиЗначений", Ложь);
	Свойства.Вставить("ЕстьУточнениеNull",                         Ложь);
	Свойства.Вставить("ЕстьУточнениеНеопределено",                 Ложь);
	Свойства.Вставить("ЕстьТипВедущегоСписка",                     Ложь);
	Свойства.Вставить("ЕстьТипВладельцаНастроекПрав",              Ложь);
	Свойства.Вставить("ЕстьПроверкаАвторизованногоПользователя",   Ложь);
	
	Родитель = ОписаниеПоля.Родители[0];
	
	Если Родитель.Узел = "ЧтениеОбъектаРазрешено"
	 Или Родитель.Узел = "ИзменениеОбъектаРазрешено"
	 Или Родитель.Узел = "ЧтениеСпискаРазрешено"
	 Или Родитель.Узел = "ИзменениеСпискаРазрешено"
	 Или Родитель.Узел = "ЗначениеРазрешено"
	 Или Родитель.Узел = "ЭтоАвторизованныйПользователь" Тогда
		
		ЕстьУточнениеПустойСсылки          = ТипУточнен(Родитель, "ПустаяСсылка");
		Свойства.ЕстьУточнениеNull         = ТипУточнен(Родитель, "Null") Или Свойства.Свойство("ЕстьВыразить");
		Свойства.ЕстьУточнениеНеопределено = ТипУточнен(Родитель, "Неопределено");
	КонецЕсли;
	
	Если Родитель.Узел = "ЧтениеОбъектаРазрешено"
	 Или Родитель.Узел = "ИзменениеОбъектаРазрешено"
	 Или Родитель.Узел = "ЧтениеСпискаРазрешено"
	 Или Родитель.Узел = "ИзменениеСпискаРазрешено" Тогда
		
		Для Каждого Тип Из Свойства.ТипКонечногоПоля.Типы() Цикл
			ИмяТипа = ИмяТипаНаЯзыкеЗапросов(Тип);
			
			Уточнение = УточнениеТипа(Родитель, ИмяТипа);
			Если Уточнение = "Истина" Тогда
				Свойства.ТипыСохраненияТипаРазрешенный.Добавить(Тип);
				Продолжить;
			ИначеЕсли Уточнение = "Ложь" Тогда
				Свойства.ТипыСохраненияТипаЗапрещенный.Добавить(Тип);
				Продолжить;
			КонецЕсли;
			
			Если Не ТипПроверяется(Родитель, ИмяТипа) Тогда
				Свойства.ТипыСохраненияТипаЗапрещенный.Добавить(Тип);
				Продолжить;
			КонецЕсли;
			
			Если ЭтоПростойТип(Тип) Тогда
				Свойства.ТипыСохраненияТипаРазрешенный.Добавить(Тип);
				Продолжить;
			КонецЕсли;
			
			Если Тип = Тип("СправочникСсылка.ИдентификаторыОбъектовМетаданных")
			 Или Тип = Тип("СправочникСсылка.ИдентификаторыОбъектовРасширений") Тогда
				Свойства.ТипыСохраненияЗначений.Добавить(Тип);
				Свойства.ЕстьТипВедущегоСписка = Истина;
				Продолжить;
			КонецЕсли;
			
			Если Родитель.Узел = "ЧтениеСпискаРазрешено"
			 Или Родитель.Узел = "ИзменениеСпискаРазрешено" Тогда
				
				Свойства.ТипыСохраненияТипов.Добавить(Тип);
				Свойства.ЕстьТипВедущегоСписка = Истина;
				Продолжить;
			КонецЕсли;
			
			Если Контекст.СпискиСЗаписьюКлючейДляЗависимыхСписковБезКлючей <> Неопределено
			   И Не Контекст.ИспользуетсяОграничениеПоВладельцу
			   И (    Контекст.СпискиСОграничением.Получить(ИмяТипа) = Неопределено
			      Или Контекст.СпискиСОтключеннымОграничением.Получить(ИмяТипа) <> Неопределено) Тогда
				
				Свойства.ТипыСохраненияТипов.Добавить(Тип);
				Свойства.ЕстьТипВедущегоСписка = Истина;
				Продолжить;
			КонецЕсли;
			
			Если ЕстьУточнениеПустойСсылки Тогда
				Свойства.ТипыСохраненияПустойСсылки.Добавить(Тип);
			КонецЕсли;
			
			Значение = Контекст.ТипыВладельцевНастроекПрав.Получить(Тип);
			Если Значение <> Неопределено
			   И ВРег(Контекст.Список) = ВРег(Значение[0].ВладелецПрав) Тогда
				
				Свойства.ТипыСохраненияЗначений.Добавить(Тип);
				Свойства.ЕстьТипВладельцаНастроекПрав = Истина;
				ДобавитьВидОграниченияПрав("НастройкиПрав." + ИмяТипа, Свойства, Контекст);
				Продолжить;
			КонецЕсли;
			
			Свойства.ТипыСохраненияКлючейДоступа.Добавить(Тип);
			Если Контекст.СпискиСЗаписьюКлючейДляЗависимыхСписковБезКлючей = Неопределено
			 Или (  Контекст.СпискиСОграничением.Получить(ИмяТипа) <> Неопределено
			      И Контекст.СпискиСОтключеннымОграничением.Получить(ИмяТипа) = Неопределено) Тогда
			   
				ДобавитьВедущийСписокПоПолюСсылка(Контекст.ВедущиеСпискиПоКлючамДоступа,
					ИмяТипа, ОписаниеПоля, Свойства, Контекст);
				ДобавитьВидОграниченияПрав("Объект." + ИмяТипа, Свойства, Контекст);
			КонецЕсли;
		КонецЦикла;
		
		Возврат;
	КонецЕсли;
	
	Если Родитель.Узел = "ЗначениеРазрешено" Тогда
		СвойстваВидовДоступа = Контекст.СвойстваВидовДоступа;
		ОтключеноКакЛожь = УточнениеТипа(Родитель, "Отключено") = "Ложь";
		
		Для Каждого Тип Из Свойства.ТипКонечногоПоля.Типы() Цикл
			ИмяТипа = ИмяТипаНаЯзыкеЗапросов(Тип);
			
			Уточнение = УточнениеТипа(Родитель, ИмяТипа);
			Если Уточнение = "Истина" Тогда
				Свойства.ТипыСохраненияТипаРазрешенный.Добавить(Тип);
				Продолжить;
			ИначеЕсли Уточнение = "Ложь" Тогда
				Свойства.ТипыСохраненияТипаЗапрещенный.Добавить(Тип);
				Продолжить;
			КонецЕсли;
			
			Если Не ТипПроверяется(Родитель, ИмяТипа) Тогда
				Свойства.ТипыСохраненияТипаЗапрещенный.Добавить(Тип);
				Продолжить;
			КонецЕсли;
			
			СвойстваВидаДоступа = СвойстваВидовДоступа.ПоТипамГруппИЗначений.Получить(Тип);
			Если СвойстваВидаДоступа = Неопределено Тогда
				Свойства.ТипыСохраненияТипаРазрешенный.Добавить(Тип);
				Продолжить;
			КонецЕсли;
			
			ДобавитьВидОграниченияПрав(СвойстваВидаДоступа.Имя, Свойства, Контекст);
			
			Если Контекст.ИспользуемыеТипыЗначений.Получить(СвойстваВидаДоступа.ТипЗначений) = Неопределено Тогда
				Свойства.НеиспользуемыеТипыЗначенийДоступа.Добавить(СвойстваВидаДоступа.ТипЗначений);
				
				Если ОтключеноКакЛожь Тогда
					Свойства.ТипыСохраненияТипаЗапрещенный.Добавить(Тип);
				Иначе
					Свойства.ТипыСохраненияТипаРазрешенный.Добавить(Тип);
				КонецЕсли;
				Продолжить;
			КонецЕсли;
			
			Свойства.ИспользуемыеТипыЗначенийДоступа.Добавить(СвойстваВидаДоступа.ТипЗначений);
			
			Если СвойстваВидовДоступа.ПоТипамЗначений.Получить(Тип) = Неопределено Тогда
				// Тип группы значений доступа.
				Если Контекст.Список = Метаданные.НайтиПоТипу(Тип).ПолноеИмя() Тогда
					Свойства.ТипыСохраненияЗначений.Добавить(Тип);
				Иначе
					Свойства.ТипыСохраненияТипаРазрешенный.Добавить(Тип);
				КонецЕсли;
				Продолжить;
			КонецЕсли;
			
			Если ЕстьУточнениеПустойСсылки Тогда
				Свойства.ТипыСохраненияПустойСсылки.Добавить(Тип);
			КонецЕсли;
			
			Если СвойстваВидовДоступа.ТипыЗначенийДоступаСГруппами.Получить(Тип) = Неопределено
			 Или Контекст.ТипыПользователя.Найти(Тип) <> Неопределено Тогда
				
				Свойства.ТипыСохраненияЗначений.Добавить(Тип);
				Продолжить;
			КонецЕсли;
			Свойства.ТипыСохраненияГруппЗначений.Добавить(Тип);
			
			Если Контекст.Список = ИмяТипа
			   И ВРег(Свойства.ИмяПоляДляЗапроса) = ВРег("ТекущийСписок.Ссылка") Тогда
				
				Свойства.ЭтоСписокЗначенийДоступаСГруппамиЗначений = Истина;
			Иначе
				ДобавитьВедущийСписокПоПолюСсылка(Контекст.ВедущиеСпискиПоЗначениямСГруппами,
					ИмяТипа, ОписаниеПоля, Свойства, Контекст);
			КонецЕсли;
			
			Если СвойстваВидовДоступа.СОднойГруппойДляЗначенияДоступа.Найти(Тип) = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			Свойства.НесколькоГруппЗначений = Истина;
		КонецЦикла;
		
		Возврат;
	КонецЕсли;
	
	Если Родитель.Узел = "ЭтоАвторизованныйПользователь" Тогда
		Свойства.ЕстьПроверкаАвторизованногоПользователя = Истина;
		
		Для Каждого Тип Из Свойства.ТипКонечногоПоля.Типы() Цикл
			ИмяТипа = ИмяТипаНаЯзыкеЗапросов(Тип);
			
			Уточнение = УточнениеТипа(Родитель, ИмяТипа);
			Если Уточнение = "Истина" Тогда
				Свойства.ТипыСохраненияТипаРазрешенный.Добавить(Тип);
				Продолжить;
			ИначеЕсли Уточнение = "Ложь" Тогда
				Свойства.ТипыСохраненияТипаЗапрещенный.Добавить(Тип);
				Продолжить;
			КонецЕсли;
			
			Если Не ТипПроверяется(Родитель, ИмяТипа) Тогда
				Свойства.ТипыСохраненияТипаЗапрещенный.Добавить(Тип);
				Продолжить;
			КонецЕсли;
			
			Если Тип <> Тип("СправочникСсылка.Пользователи")
			   И Тип <> Тип("СправочникСсылка.ВнешниеПользователи") Тогда
				
				Свойства.ТипыСохраненияТипаЗапрещенный.Добавить(Тип);
				Продолжить;
			КонецЕсли;
			
			Если ЕстьУточнениеПустойСсылки Тогда
				Свойства.ТипыСохраненияПустойСсылки.Добавить(Тип);
			КонецЕсли;
			
			Свойства.ТипыСохраненияЗначений.Добавить(Тип);
		КонецЦикла;
		
		Возврат;
	КонецЕсли;
	
	// Остались только узлы Поле для получения значения Булево.
	Свойства.ТипыСохраненияЗначений.Добавить(Тип("Булево"));
	
	Если Свойства.ТипКонечногоПоля.Типы().Количество() = 1
	   И Свойства.ТипКонечногоПоля.СодержитТип(Тип("Булево")) Тогда
		Возврат;
	КонецЕсли;
	Свойства.ТипКонечногоПоля = Новый ОписаниеТипов("Булево");
	Свойства.ИмяПоляДляЗапроса = Свойства.ИмяПоляДляЗапроса + " = ИСТИНА";
	
КонецПроцедуры

// Для функций СвойстваПоля, ДобавитьСвойстваТиповПоля.
Функция ИмяТипаНаЯзыкеЗапросов(Тип, ОбъектМетаданных = Неопределено)
	
	ОбъектМетаданных = Метаданные.НайтиПоТипу(Тип);
	Если ОбъектМетаданных <> Неопределено Тогда
		Возврат ОбъектМетаданных.ПолноеИмя();
	КонецЕсли;
	
	Возврат Строка(Тип);
	
КонецФункции

// Для процедуры ДобавитьСвойстваТиповПоля.
Процедура ДобавитьВидОграниченияПрав(ВидОграничения, СвойстваПоля, Контекст)
	
	Если СвойстваПоля.Чтение Тогда
		Контекст.ВсеВидыОграниченийПрав.Вставить("Чтение." + ВидОграничения, Истина);
	КонецЕсли;
	
	Контекст.ВсеВидыОграниченийПрав.Вставить("Изменение." + ВидОграничения, Истина);
	
КонецПроцедуры

// Для процедуры ЗаполнитьСвойстваПолей.
Функция СвойстваПоля(УзелПоле, Контекст, СвойстваПоля = Неопределено)
	
	Свойства = Новый Структура;
	ЭтоКорневойУзел = СвойстваПоля = Неопределено;
	
	Если ЭтоКорневойУзел Тогда
		СвойстваПоля = Свойства;
		// Внутри функции ЕстьNull() может быть только поле, т.е. функции Выразить() не может быть.
		Если ЗначениеЗаполнено(УзелПоле.Выразить) Тогда
			Типы = Новый Массив;
			Типы.Добавить(ТипСсылкиПоПолномуИмениМетаданных(УзелПоле.Выразить));
			ТипКонечногоПоля = Новый ОписаниеТипов(Типы);
		Иначе
			ТипКонечногоПоля = УзелПоле.ТипыПоля[УзелПоле.ТипыПоля.Количество() - 1];
			Если ЗначениеЗаполнено(УзелПоле.ЕстьNull) Тогда
				Типы = Новый Массив;
				Типы.Добавить(ТипЗначенияУзлаЗначениеИлиКонстанта(УзелПоле.ЕстьNull));
				ТипКонечногоПоля = Новый ОписаниеТипов(ТипКонечногоПоля, Типы);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если УзелПоле.Вложение <> Неопределено Тогда
		СвойстваВложения = СвойстваПоля(УзелПоле.Вложение, Контекст, СвойстваПоля);
		ТабличнаяЧасть    = СвойстваВложения.ТабличнаяЧасть;
		ПсевдонимТаблицы  = СвойстваВложения.ПсевдонимТаблицы;
		ИмяПоляДляЗапроса = СвойстваВложения.ИмяПоляДляЗапроса + "." + УзелПоле.Имя;
		ТипыСтрокой       = СвойстваВложения.ТипыСтрокой + Символы.ПС + УзелПоле.ТипыСтрокой;
	Иначе
		Если ТипЗнч(УзелПоле.ТипыПоля[0]) = Тип("ОписаниеТипов") Тогда
			ТабличнаяЧасть = "";
			Если ЗначениеЗаполнено(УзелПоле.Псевдоним)
			   И УзелПоле.Псевдоним <> Контекст.СтруктураОграничения.ПсевдонимОсновнойТаблицы Тогда
				
				ПсевдонимТаблицы = УзелПоле.Псевдоним;
				ИмяПоляДляЗапроса = ПсевдонимТаблицы + "." + УзелПоле.Имя;
			Иначе
				ПсевдонимТаблицы = "ТекущийСписок";
				ДобавитьОпорноеПоле(Контекст, УзелПоле, СвойстваПоля);
				Если Не ЗначениеЗаполнено(УзелПоле.Выразить) Тогда
					ИмяПоляДляЗапроса = ТекстСОтступом(
						ИмяПоляСРазверткойОпорногоПоляПоТипам(ПсевдонимТаблицы, УзелПоле), "		");
				Иначе
					ИмяПоляДляЗапроса = ПсевдонимТаблицы + "." + УзелПоле.Имя;
				КонецЕсли;
			КонецЕсли;
		Иначе // Первая часть имени поля - это имя табличной части.
			ТабличнаяЧасть = УзелПоле.ТипыПоля[0];
			ПсевдонимТаблицы = "ТекущийСписок" + ТабличнаяЧасть;
			ЧастиИмени = СтрРазделить(УзелПоле.Имя, ".");
			ЧастиИмени.Удалить(0);
			ИмяПоляДляЗапроса = ПсевдонимТаблицы + "." + СтрСоединить(ЧастиИмени, ".");
		КонецЕсли;
		ТипыСтрокой = УзелПоле.ТипыСтрокой;
	КонецЕсли;
	
	// Внутри функции ЕстьNull() может быть только поле, т.е. функции Выразить() не может быть.
	Если ЗначениеЗаполнено(УзелПоле.ЕстьNull) Тогда
		ИмяПоляДляЗапроса = "ЕСТЬNULL(" + ИмяПоляДляЗапроса + ", "
			+ ВыражениеУзлаЗначениеИлиКонстанта(УзелПоле.ЕстьNull) + ")";
		
		Если ЭтоКорневойУзел Тогда
			Свойства.Вставить("БезЗначенияNull", Истина);
		КонецЕсли;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(УзелПоле.Выразить) Тогда
		ИмяПоляДляЗапроса = "ВЫРАЗИТЬ(" + ИмяПоляДляЗапроса + " КАК " + УзелПоле.Выразить + ")";
		СвойстваПоля.Вставить("ЕстьВыразить");
	КонецЕсли;
	
	Свойства.Вставить("ПсевдонимТаблицы",  ПсевдонимТаблицы);
	Свойства.Вставить("ИмяПоляДляЗапроса", ИмяПоляДляЗапроса);
	Свойства.Вставить("ТипКонечногоПоля",  ТипКонечногоПоля);
	Свойства.Вставить("ТипыСтрокой",       ТипыСтрокой);
	
	Если УзелПоле.Свойство("ПолеСодержитNull") Тогда
		Свойства.Вставить("ПолеСодержитNull");
	КонецЕсли;
	
	// Для расчета ведущих списков.
	Свойства.Вставить("ТабличнаяЧасть",    ТабличнаяЧасть);
	Свойства.Вставить("СвойстваВложения",  СвойстваВложения);
	Свойства.Вставить("УзелПоле",          УзелПоле);
	Свойства.Вставить("ЭтоПолеСписка",
		ПсевдонимТаблицы = "ТекущийСписок"
		Или СвойстваВложения <> Неопределено
		  И ЗначениеЗаполнено(СвойстваВложения.ТабличнаяЧасть));
	
	Возврат Свойства;
	
КонецФункции


// Для функции ПараметрыОграниченияПоСтруктуреОграничения.
Функция ОписаниеВедущихСписковПоЗначениямПолей()
	
	Возврат Новый Структура("Поля, СоединенияОтборов", Новый Соответствие, Новый Соответствие);
	
КонецФункции

// Для функций ГруппыДополнительныхТаблиц.
Процедура ДобавитьВедущиеСпискиПоЗначениямПолей(Контекст, УзелПоле, СвойстваВложения = Неопределено,
			ГруппаТаблиц = Неопределено, ПсевдонимТаблицыУсловия = Неопределено)
	
	ДополнительныйКонтекст = Новый Структура;
	ДополнительныйКонтекст.Вставить("СвойстваПоляРодителя",    СвойстваВложения);
	ДополнительныйКонтекст.Вставить("ГруппаТаблиц",            ГруппаТаблиц);
	ДополнительныйКонтекст.Вставить("ПсевдонимТаблицыУсловия", ПсевдонимТаблицыУсловия);
	ДополнительныйКонтекст.Вставить("ПсевдонимТаблицыПоля",    УзелПоле.Псевдоним);
	
	ИменаПолей = СтрРазделить(УзелПоле.Имя, ".");
	
	Если УзелПоле.Вложение <> Неопределено Тогда
		ДобавитьПолеВедущегоСпискаПоЗначениямПолей(Контекст, УзелПоле.Таблица, ИменаПолей[0],
			УзелПоле.ТипыПоля[0], ДополнительныйКонтекст, Истина, Истина);
		
	ИначеЕсли ЗначениеЗаполнено(УзелПоле.Псевдоним)
	        И УзелПоле.Псевдоним <> Контекст.СтруктураОграничения.ПсевдонимОсновнойТаблицы Тогда
		
		ДобавитьПолеВедущегоСпискаПоЗначениямПолей(Контекст, УзелПоле.Таблица, ИменаПолей[0],
			УзелПоле.ТипыПоля[0], ДополнительныйКонтекст);
	КонецЕсли;
	
	ИндексПервогоПоля = ?(ТипЗнч(УзелПоле.ТипыПоля[0]) = Тип("ОписаниеТипов"), 0, 1);
	
	Если ИндексПервогоПоля + 2 > ИменаПолей.Количество() Тогда
		Возврат;
	КонецЕсли;
	
	СвойстваПоляРодителя = Новый Структура("ИмяПоляДляЗапроса, ТабличнаяЧасть");
	Если СвойстваВложения <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(СвойстваПоляРодителя, СвойстваВложения);
		СвойстваПоляРодителя.ИмяПоляДляЗапроса = СвойстваПоляРодителя.ИмяПоляДляЗапроса + "." + ИменаПолей[ИндексПервогоПоля];
	Иначе
		Если ИндексПервогоПоля > 0 Тогда
			СвойстваПоляРодителя.ТабличнаяЧасть = ИменаПолей[0];
		КонецЕсли;
		Если Не ЗначениеЗаполнено(УзелПоле.Псевдоним)
		 Или УзелПоле.Псевдоним = Контекст.СтруктураОграничения.ПсевдонимОсновнойТаблицы Тогда
			
			ПсевдонимПоляРодителя = "ТекущийСписок";
			ДополнительныйКонтекст.ГруппаТаблиц = Неопределено;
		Иначе
			ПсевдонимПоляРодителя = УзелПоле.Псевдоним;
		КонецЕсли;
		СвойстваПоляРодителя.ИмяПоляДляЗапроса = ПсевдонимПоляРодителя + "." + ИменаПолей[ИндексПервогоПоля];
	КонецЕсли;
	ДополнительныйКонтекст.СвойстваПоляРодителя = СвойстваПоляРодителя;
	
	Для Индекс = ИндексПервогоПоля + 1 По ИменаПолей.Количество()-1 Цикл
		Поле = ИменаПолей[Индекс];
		ТипПоля = УзелПоле.ТипыПоля[Индекс];
		Для Каждого Таблица Из УзелПоле.ТаблицыСледующегоПоля[Индекс-1] Цикл
			ДобавитьПолеВедущегоСпискаПоЗначениямПолей(Контекст, Таблица, Поле,
				ТипПоля, ДополнительныйКонтекст, Истина, Истина);
		КонецЦикла;
		СвойстваПоляРодителя.ИмяПоляДляЗапроса = СвойстваПоляРодителя.ИмяПоляДляЗапроса + "." + Поле;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ДобавитьВедущиеСпискиПоЗначениямПолей.
Процедура ДобавитьПолеВедущегоСпискаПоЗначениямПолей(Контекст, Таблица, Поле, ТипПоля, ДополнительныйКонтекст,
			ЭтоОсновнаяТаблица = Ложь, ЭтоСсылочныйТипТаблицы = Неопределено)
	
	Если Не ЭтоОсновнаяТаблица
	   И СтрЧислоВхождений(Таблица, ".") = 2 Тогда
		
		СоставИмени = СтрРазделить(Таблица, ".");
		ТабличнаяЧасть = СоставИмени[2];
		СоставИмени.Удалить(2);
		ПолноеИмя = СтрСоединить(СоставИмени, ".");
	Иначе
		ТабличнаяЧасть = "";
		ПолноеИмя = Таблица;
	КонецЕсли;
	
	Если ТипЗнч(ДополнительныйКонтекст.ГруппаТаблиц) <> Тип("Массив")
	   И (    ВРег(Поле) = ВРег("Ссылка")
	      Или ВРег(Поле) = ВРег("Ref")) Тогда
		
		Если ЭтоСсылочныйТипТаблицы = Неопределено Тогда
			СоставИмени = СтрРазделить(Таблица, ".");
			ТипТаблицы = Контекст.СтруктураОграничения.ВнутренниеДанные.ТипыТаблицПоИменам.Получить(ВРег(СоставИмени[0]));
			ЭтоСсылочныйТипТаблицы = ТипТаблицы.ЭтоСсылочныйТип;
		КонецЕсли;
		Если ЭтоСсылочныйТипТаблицы Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ОписаниеПолей      = Контекст.ВедущиеСпискиПоЗначениямПолей.Поля.Получить(ПолноеИмя);
	ОписаниеСоединений = Контекст.ВедущиеСпискиПоЗначениямПолей.СоединенияОтборов.Получить(ПолноеИмя);
	
	Если ОписаниеПолей = Неопределено Тогда
		Если ЭтоСсылочныйТипТаблицы = Неопределено Тогда
			СоставИмени = СтрРазделить(Таблица, ".");
			ТипТаблицы = Контекст.СтруктураОграничения.ВнутренниеДанные.ТипыТаблицПоИменам.Получить(ВРег(СоставИмени[0]));
			ЭтоСсылочныйТипТаблицы = ТипТаблицы.ЭтоСсылочныйТип;
		КонецЕсли;
		ОписаниеПолей = Новый Структура;
		ОписаниеПолей.Вставить("ЭтоСсылочныйТип", ЭтоСсылочныйТипТаблицы);
		ОписаниеПолей.Вставить("ДляОтслеживания", Новый Структура("ПоляШапки, ТабличныеЧасти",
			Новый Соответствие, Новый Соответствие));
		ОписаниеПолей.Вставить("ДляОтбора", Новый Структура("ПоляШапки, ТабличныеЧасти",
			Новый Соответствие, Новый Соответствие));
		Контекст.ВедущиеСпискиПоЗначениямПолей.Поля.Вставить(ПолноеИмя, ОписаниеПолей);
		
		ОписаниеСоединений = Новый Структура("ПоляШапки, ТабличныеЧасти", Новый Соответствие, Новый Соответствие);
		Контекст.ВедущиеСпискиПоЗначениямПолей.СоединенияОтборов.Вставить(ПолноеИмя, ОписаниеСоединений);
	КонецЕсли;
	
	ВставитьПолеВедущегоСпискаПоЗначениямПолей(ОписаниеПолей.ДляОтслеживания, ТабличнаяЧасть, Поле, ТипПоля);
	
	Если ЗначениеЗаполнено(ТабличнаяЧасть) Тогда
		СоединенияОтборов = ОписаниеСоединений.ТабличныеЧасти.Получить(ТабличнаяЧасть);
		Если СоединенияОтборов = Неопределено Тогда
			СоединенияОтборов = Новый Соответствие;
			ОписаниеСоединений.ТабличныеЧасти.Вставить(ТабличнаяЧасть, СоединенияОтборов);
		КонецЕсли;
	Иначе
		СоединенияОтборов = ОписаниеСоединений.ПоляШапки;
	КонецЕсли;
	
	Если ДополнительныйКонтекст.СвойстваПоляРодителя <> Неопределено Тогда
		Если СоставИмени = Неопределено Тогда
			СоставИмени = СтрРазделить(Таблица, ".");
			ТипТаблицы = Контекст.СтруктураОграничения.ВнутренниеДанные.ТипыТаблицПоИменам.Получить(ВРег(СоставИмени[0]));
		КонецЕсли;
		ТипСсылки = Новый ОписаниеТипов(ТипТаблицы.ЯзыкРусский + "Ссылка." + СоставИмени[1]);
		ВставитьПолеВедущегоСпискаПоЗначениямПолей(ОписаниеПолей.ДляОтслеживания, "", "Ссылка", ТипСсылки);
		ВставитьПолеВедущегоСпискаПоЗначениямПолей(ОписаниеПолей.ДляОтбора,       "", "Ссылка", ТипСсылки);
		ИмяПоляДляЗапроса = ДополнительныйКонтекст.СвойстваПоляРодителя.ИмяПоляДляЗапроса;
		СоединениеОтбора = СоединенияОтборов.Получить(ВРег(ИмяПоляДляЗапроса));
		Если СоединениеОтбора = Неопределено Тогда
			СоединениеОтбора = Новый Структура;
			СоединениеОтбора.Вставить("ПолеИлиПсевдоним", ИмяПоляДляЗапроса);
			СоединениеОтбора.Вставить("ПоляДляОтбора",    "Ссылка");
			СоединениеОтбора.Вставить("ТабличнаяЧасть",   ДополнительныйКонтекст.СвойстваПоляРодителя.ТабличнаяЧасть);
			СоединениеОтбора.Вставить("ГруппаТаблиц",     ДополнительныйКонтекст.ГруппаТаблиц);
			СоединенияОтборов.Вставить(ВРег(ИмяПоляДляЗапроса), СоединениеОтбора);
			Если ТипЗнч(ДополнительныйКонтекст.ГруппаТаблиц) = Тип("Массив") Тогда
				СоединениеОтбора.Вставить("ВсеПоляВУсловииСвоейТаблицы",
					ДополнительныйКонтекст.ПсевдонимТаблицыПоля = ДополнительныйКонтекст.ПсевдонимТаблицыУсловия);
			КонецЕсли;
		КонецЕсли;
	Иначе
		Если ТипЗнч(ДополнительныйКонтекст.ГруппаТаблиц) = Тип("Массив") Тогда
			ВставитьПолеВедущегоСпискаПоЗначениямПолей(ОписаниеПолей.ДляОтбора, ТабличнаяЧасть, Поле, ТипПоля);
			СоединениеОтбора = СоединенияОтборов.Получить(ВРег(ДополнительныйКонтекст.ПсевдонимТаблицыПоля));
			Если СоединениеОтбора = Неопределено Тогда
				СоединениеОтбора = Новый Структура;
				СоединениеОтбора.Вставить("ПолеИлиПсевдоним", ДополнительныйКонтекст.ПсевдонимТаблицыПоля);
				СоединениеОтбора.Вставить("ПоляДляОтбора",    Новый Массив);
				СоединениеОтбора.Вставить("ТабличнаяЧасть",   Неопределено);
				СоединениеОтбора.Вставить("ГруппаТаблиц",     ДополнительныйКонтекст.ГруппаТаблиц);
				СоединениеОтбора.Вставить("ВсеПоляВУсловииСвоейТаблицы", Истина);
				СоединенияОтборов.Вставить(ВРег(ДополнительныйКонтекст.ПсевдонимТаблицыПоля), СоединениеОтбора);
			КонецЕсли;
			Если СоединениеОтбора.ПоляДляОтбора.Найти(Поле) = Неопределено Тогда
				СоединениеОтбора.ПоляДляОтбора.Добавить(Поле);
				Если ДополнительныйКонтекст.ПсевдонимТаблицыПоля <> ДополнительныйКонтекст.ПсевдонимТаблицыУсловия Тогда
					СоединениеОтбора.ВсеПоляВУсловииСвоейТаблицы = Ложь;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуру ДобавитьПолеВедущегоСпискаПоЗначениямПолей.
Процедура ВставитьПолеВедущегоСпискаПоЗначениямПолей(ОписаниеПолей, ТабличнаяЧасть, Поле, ТипПоля)
	
	Если ЗначениеЗаполнено(ТабличнаяЧасть) Тогда
		Поля = ОписаниеПолей.ТабличныеЧасти.Получить(ТабличнаяЧасть);
		Если Поля = Неопределено Тогда
			Поля = Новый Соответствие;
			ОписаниеПолей.ТабличныеЧасти.Вставить(ТабличнаяЧасть, Поля);
		КонецЕсли;
	Иначе
		Поля = ОписаниеПолей.ПоляШапки;
	КонецЕсли;
	
	Если Поля.Получить(Поле) <> Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Поля.Вставить(Поле, Новый ХранилищеЗначения(ТипПоля));
	
КонецПроцедуры

// Для функции ПараметрыОграниченияПоСтруктуреОграничения.
Функция ОписаниеВедущихСписковПоПолюСсылка()
	
	Описание = Новый Структура;
	Описание.Вставить("Списки",               Новый Соответствие);
	Описание.Вставить("КлючиЗапросовПоТипам", Новый Соответствие);
	Описание.Вставить("СоединенияОтборов",    Новый Соответствие);
	Описание.Вставить("ТипСсылки",            Новый ОписаниеТипов);
	
	Возврат Описание;
	
КонецФункции

// Для процедуры ДобавитьСвойстваТиповПоля.
Процедура ДобавитьВедущийСписокПоПолюСсылка(ВедущиеСписки, ВедущийСписок, УзелПоле, СвойстваПоля, Контекст)
	
	СоставИмени = СтрРазделить(ВедущийСписок, ".");
	ТипТаблицы = Контекст.СтруктураОграничения.ВнутренниеДанные.ТипыТаблицПоИменам.Получить(ВРег(СоставИмени[0]));
	ИмяТипаСсылки = ТипТаблицы.ЯзыкРусский + "Ссылка." + СоставИмени[1];
	
	ВедущиеСписки.ТипСсылки = Новый ОписаниеТипов(ВедущиеСписки.ТипСсылки, ИмяТипаСсылки);
	ТипСсылки = Тип(ИмяТипаСсылки);
	
	Ключи = ВедущиеСписки.КлючиЗапросовПоТипам.Получить(ТипСсылки);
	Если Ключи = Неопределено Тогда
		Ключи = Новый Массив;
		ВедущиеСписки.КлючиЗапросовПоТипам.Вставить(ТипСсылки, Ключи);
		ВедущиеСписки.Списки.Вставить(ВедущийСписок, Истина);
	КонецЕсли;
	
	Ключ = ВРег(СвойстваПоля.ИмяПоляДляЗапроса);
	Если Ключи.Найти(Ключ) = Неопределено Тогда
		Ключи.Добавить(Ключ);
	КонецЕсли;
	
	ГруппаТаблиц = ?(СвойстваПоля.ЭтоПолеСписка, Неопределено, СвойстваПоля.ПсевдонимТаблицы);
	
	СоединениеОтбора = ВедущиеСписки.СоединенияОтборов.Получить(Ключ);
	Если СоединениеОтбора = Неопределено Тогда
		СоединениеОтбора = Новый Структура;
		СоединениеОтбора.Вставить("ПолеИлиПсевдоним", СвойстваПоля.ИмяПоляДляЗапроса);
		СоединениеОтбора.Вставить("ПоляДляОтбора",    "Ссылка");
		СоединениеОтбора.Вставить("ТабличнаяЧасть",   СвойстваПоля.ТабличнаяЧасть);
		СоединениеОтбора.Вставить("ГруппаТаблиц",     ГруппаТаблиц);
		ВедущиеСписки.СоединенияОтборов.Вставить(Ключ, СоединениеОтбора);
	КонецЕсли;
	
КонецПроцедуры

// Для функции ГруппыДополнительныхТаблиц.
Процедура ЗаполнитьОтборыПоЗначениямПолейВедущегоСписка(ВедущийСписок, Описание, Группы, Контекст)
	
	СоединенияОтборов = Новый Массив;
	Для Каждого СоединениеОтбора Из Описание.ПоляШапки Цикл
		СоединенияОтборов.Добавить(ТекстСоединенияОтбораПоЗначениямПолей(СоединениеОтбора.Значение, Группы, Контекст));
	КонецЦикла;
	Описание.ПоляШапки = СоединенияОтборов;
	
	ТабличныеЧасти = Новый Соответствие;
	Для Каждого ОписаниеТабличнойЧасти Из Описание.ТабличныеЧасти Цикл
		СоединенияОтборов = Новый Массив;
		ТабличныеЧасти.Вставить(ОписаниеТабличнойЧасти.Ключ, СоединенияОтборов);
		Для Каждого СоединениеОтбора Из ОписаниеТабличнойЧасти.Значение Цикл
			СоединенияОтборов.Добавить(ТекстСоединенияОтбораПоЗначениямПолей(СоединениеОтбора.Значение, Группы, Контекст));
		КонецЦикла;
	КонецЦикла;
	Описание.ТабличныеЧасти = ТабличныеЧасти;
	
КонецПроцедуры

// Для функции ГруппыДополнительныхТаблиц.
Процедура ЗаполнитьОтборыВедущихСписковПоПолюСсылка(ВедущиеСписки, Группы, Контекст)
	
	СоединенияОтборов = Новый Соответствие;
	Для Каждого СоединениеОтбора Из ВедущиеСписки.СоединенияОтборов Цикл
		СоединенияОтборов.Вставить(СоединениеОтбора.Ключ,
			ТекстСоединенияОтбораПоЗначениямПолей(СоединениеОтбора.Значение, Группы, Контекст));
	КонецЦикла;
	ВедущиеСписки.СоединенияОтборов = СоединенияОтборов;
	
КонецПроцедуры

// Для процедуры ЗаполнитьОтборыПоЗначениямПолейВедущегоСписка.
Функция ТекстСоединенияОтбораПоЗначениямПолей(Условие, Группы, Контекст)
	
	Если Контекст.ЭтоСсылочныйТип Тогда
		ДополнительноеУсловие = "
		|		И (&УточнениеПланаЗапроса)";
	Иначе
		ДополнительноеУсловие = ?(Не ЗначениеЗаполнено(Контекст.ИмяОтдельногоРегистраКлючей), "
		|		И (ТекущийСписок.Регистр = &ИдентификаторРегистра)", "") + "
		|		И (ТекущийСписок.ДляВнешнихПользователей = " + ?(Контекст.ДляВнешнихПользователей, "ИСТИНА", "ЛОЖЬ") + ")
		|		И (&УточнениеПланаЗапроса)";
	КонецЕсли;
	
	Если Условие.ГруппаТаблиц = Неопределено Или ЗначениеЗаполнено(Условие.ТабличнаяЧасть) Тогда
		ТекстСоединения =
		"#ТекущиеДанныеДляОтбора КАК ТекущиеДанныеДляОтбора
		|	ВНУТРЕННЕЕ СОЕДИНЕНИЕ &ТекущийСписок КАК ТекущийСписок
		|	ПО (" + Условие.ПолеИлиПсевдоним + " = ТекущиеДанныеДляОтбора." + Условие.ПоляДляОтбора + ")";
		Если ЗначениеЗаполнено(Условие.ТабличнаяЧасть) Тогда
			ТекстСоединения = СтрЗаменить(ТекстСоединения,
				"&ТекущийСписок", "&ТекущийСписок." + Условие.ТабличнаяЧасть);
			ТекстСоединения = СтрЗаменить(ТекстСоединения,
				"ТекущийСписок" + Условие.ТабличнаяЧасть + ".", "ТекущийСписок.");
		КонецЕсли;
		Возврат ТекстСоединения + ДополнительноеУсловие;
	КонецЕсли;
	
	Если ТипЗнч(Условие.ГруппаТаблиц) = Тип("Строка") Тогда
		ЭтоПолеУсловияСоединения = Ложь;
		ПсевдонимПолейОтбора = Условие.ГруппаТаблиц;
		Группа = Группы.НомераПоПсевдонимам.Получить(ПсевдонимПолейОтбора);
		ГруппаТаблиц = Группы.ТаблицыПоГруппам.Получить(Группа);
	Иначе
		ЭтоПолеУсловияСоединения = Истина;
		ГруппаТаблиц = Условие.ГруппаТаблиц;
		ЗаменяемоеПоле = Условие.ПолеИлиПсевдоним;
		ПсевдонимПолейОтбора = СтрРазделить(ЗаменяемоеПоле, ".")[0];
	КонецЕсли;
	
	Индекс = ГруппаТаблиц.Количество();
	ПерваяДополнительнаяТаблицаНайдена = Ложь;
	ОбратнаяГруппаТаблиц = Новый Массив;
	ТребуемыеПсевдонимы = Новый Соответствие;
	
	Пока Индекс >= 1 Цикл
		Индекс = Индекс - 1;
		ДополнительнаяТаблица = ГруппаТаблиц[Индекс];
		ПервыйПсевдоним = ДополнительнаяТаблица.Псевдоним;
		Если Не ПерваяДополнительнаяТаблицаНайдена И ПервыйПсевдоним <> ПсевдонимПолейОтбора Тогда
			Продолжить;
		КонецЕсли;
		ПерваяДополнительнаяТаблицаНайдена = Истина;
		Если ПервыйПсевдоним <> ПсевдонимПолейОтбора
		   И ТребуемыеПсевдонимы.Получить(ДополнительнаяТаблица.Псевдоним) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		СвойстваТаблицы = Новый Структура("Таблица, Псевдоним, ПоляУсловияСоединения",
			ДополнительнаяТаблица.Таблица, ДополнительнаяТаблица.Псевдоним, Новый Массив);
		ОбратнаяГруппаТаблиц.Добавить(СвойстваТаблицы);
		Для Каждого ПараПолей Из ДополнительнаяТаблица.ПоляУсловияСоединения Цикл
			ТребуемыеПсевдонимы.Вставить(ПараПолей.ПервоеПоле.Псевдоним, Истина);
			ТребуемыеПсевдонимы.Вставить(ПараПолей.ВтороеПоле.Псевдоним, Истина);
			СвойстваТаблицы.ПоляУсловияСоединения.Добавить(
				Новый Структура(Новый ФиксированнаяСтруктура(ПараПолей)));
		КонецЦикла;
	КонецЦикла;
	
	ВспомогательнаяТаблица = Неопределено;
	ПерваяТаблица = ОбратнаяГруппаТаблиц[0];
	ВсеПервыеПоляЗаменяемые = Истина;
	
	Если ЭтоПолеУсловияСоединения И ПерваяТаблица.ПоляУсловияСоединения.Количество() > 1 Тогда
		Для Каждого ПараПолей Из ПерваяТаблица.ПоляУсловияСоединения Цикл
			Если СтрНайти(ПараПолей.ПервоеПоле.Поле, ПерваяТаблица.Псевдоним + ".") > 0
			   И СтрНайти(ПараПолей.ПервоеПоле.Поле, ЗаменяемоеПоле + ".") = 0 Тогда
				ВсеПервыеПоляЗаменяемые = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если Не ЭтоПолеУсловияСоединения Или Не ВсеПервыеПоляЗаменяемые Тогда
		ВспомогательнаяТаблица = Новый Структура("Таблица, Псевдоним, ПоляУсловияСоединения",
			ПерваяТаблица.Таблица, "ТекущиеДанныеДляОтбора", Новый Массив);
		ОбратнаяГруппаТаблиц.Вставить(0, ВспомогательнаяТаблица);
		ПараПолей = Новый Структура("ПервоеПоле, ВтороеПоле");
		ВспомогательнаяТаблица.ПоляУсловияСоединения.Добавить(ПараПолей);
		ПараПолей.ПервоеПоле = Новый Структура("Поле, Псевдоним",
			Условие.ПолеИлиПсевдоним, "ТекущиеДанныеДляОтбора");
		ПараПолей.ВтороеПоле = Новый Структура("Поле, Псевдоним",
			"ТекущиеДанныеДляОтбора." + Условие.ПоляДляОтбора, ПсевдонимПолейОтбора);
		
	ИначеЕсли ТипЗнч(Условие.ГруппаТаблиц) = Тип("Массив")
	        И Не Условие.ВсеПоляВУсловииСвоейТаблицы Тогда
		
		ВспомогательнаяТаблица = Новый Структура("Таблица, Псевдоним, ПоляУсловияСоединения",
			ПерваяТаблица.Таблица, "ТекущиеДанныеДляОтбора", Новый Массив);
		ОбратнаяГруппаТаблиц.Вставить(0, ВспомогательнаяТаблица);
		Если ТипЗнч(Условие.ПоляДляОтбора) = Тип("Массив") Тогда
			Для Каждого ПолеДляОтбора Из Условие.ПоляДляОтбора Цикл
				ПараПолей = Новый Структура("ПервоеПоле, ВтороеПоле");
				ВспомогательнаяТаблица.ПоляУсловияСоединения.Добавить(ПараПолей);
				ПараПолей.ПервоеПоле = Новый Структура("Поле, Псевдоним",
					Условие.ПолеИлиПсевдоним + "." + ПолеДляОтбора, "ТекущиеДанныеДляОтбора");
				ПараПолей.ВтороеПоле = Новый Структура("Поле, Псевдоним",
					"ТекущиеДанныеДляОтбора." + ПолеДляОтбора, ПсевдонимПолейОтбора);
			КонецЦикла;
		Иначе
			ПараПолей = Новый Структура("ПервоеПоле, ВтороеПоле");
			ВспомогательнаяТаблица.ПоляУсловияСоединения.Добавить(ПараПолей);
			ПараПолей.ПервоеПоле = Новый Структура("Поле, Псевдоним",
				Условие.ПолеИлиПсевдоним, "ТекущиеДанныеДляОтбора");
			ПараПолей.ВтороеПоле = Новый Структура("Поле, Псевдоним",
				"ТекущиеДанныеДляОтбора." + Условие.ПоляДляОтбора, ПсевдонимПолейОтбора);
		КонецЕсли;
		Индекс = ПерваяТаблица.ПоляУсловияСоединения.Количество() - 1;
		ИндексВставки = ВспомогательнаяТаблица.ПоляУсловияСоединения.Количество();
		Пока Индекс >= 0 Цикл
			ПараПолей = ПерваяТаблица.ПоляУсловияСоединения[Индекс];
			Если ПараПолей.ПервоеПоле.Псевдоним = ПерваяТаблица.Псевдоним Тогда
				ПерваяТаблица.ПоляУсловияСоединения.Удалить(Индекс);
				ВспомогательнаяТаблица.ПоляУсловияСоединения.Вставить(ИндексВставки, ПараПолей);
			КонецЕсли;
			Индекс = Индекс - 1;
		КонецЦикла;
	КонецЕсли;
	
	ТекстСоединения =
	"#ТекущиеДанныеДляОтбора КАК ТекущиеДанныеДляОтбора";
	ОставшиесяПсевдонимы = Новый Соответствие;
	ОставшиесяПсевдонимы.Вставить("ТекущийСписок", Новый Массив);
	
	Для Каждого ДополнительнаяТаблица Из ОбратнаяГруппаТаблиц Цикл
		ОставшиесяПсевдонимы.Вставить(ДополнительнаяТаблица.Псевдоним,
			Новый Массив(Новый ФиксированныйМассив(ДополнительнаяТаблица.ПоляУсловияСоединения)));
	КонецЦикла;
	
	ЗаменитьПервоеПоле = Истина;
	Индекс = -1;
	Для Каждого ДополнительнаяТаблица Из ОбратнаяГруппаТаблиц Цикл
		Индекс = Индекс + 1;
		
		ПервыйПсевдоним = ДополнительнаяТаблица.Псевдоним;
		ПоляУсловияСоединения = ОставшиесяПсевдонимы.Получить(ПервыйПсевдоним);
		ОставшиесяПсевдонимы.Удалить(ПервыйПсевдоним);
		
		Если Индекс >= ОбратнаяГруппаТаблиц.Количество() - 1 Тогда
			ВторойПсевдоним = "ТекущийСписок";
		Иначе
			ВторойПсевдоним = ОбратнаяГруппаТаблиц[Индекс + 1].Псевдоним;
		КонецЕсли;
		ОстальныеПоляУсловияСоединения = ОставшиесяПсевдонимы.Получить(ВторойПсевдоним);
		Для Каждого ПараПолей Из ОстальныеПоляУсловияСоединения Цикл
			ПоляУсловияСоединения.Добавить(ПараПолей);
		КонецЦикла;
		ОставшиесяПсевдонимы.Вставить(ВторойПсевдоним, Новый Массив);
		
		УсловияСоединения = Новый Массив;
		Для Каждого ПараПолей Из ПоляУсловияСоединения Цикл
			Если Не ЗначениеЗаполнено(ПараПолей.ПервоеПоле.Псевдоним)
			   И Не ЗначениеЗаполнено(ПараПолей.ВтороеПоле.Псевдоним) Тогда
				
				УсловияСоединения.Добавить(ПараПолей.ПервоеПоле.Поле
					+ " = " + ПараПолей.ВтороеПоле.Поле);
				
			ИначеЕсли ПараПолей.ПервоеПоле.Псевдоним = ПервыйПсевдоним
			        И (Не ЗначениеЗаполнено(ПараПолей.ВтороеПоле.Псевдоним)
			           Или ПараПолей.ВтороеПоле.Псевдоним = ВторойПсевдоним)
			      Или ПараПолей.ПервоеПоле.Псевдоним = ВторойПсевдоним
			        И Не ЗначениеЗаполнено(ПараПолей.ВтороеПоле.Псевдоним) Тогда
				
				ПервоеПоле = ПараПолей.ПервоеПоле.Поле;
				
				Если ПараПолей.ПервоеПоле.Псевдоним = ПервыйПсевдоним
				   И ЗаменитьПервоеПоле
				   И ВспомогательнаяТаблица = Неопределено Тогда
					
					Позиция = СтрНайти(ПервоеПоле, ЗаменяемоеПоле);
					НачалоПоля = Лев(ПервоеПоле, Позиция - 1);
					Если Не СтрНачинаетсяС(ПервоеПоле, ЗаменяемоеПоле) Тогда
						ТекстОшибки = НСтр("ru = 'Не удалось подготовить условие соединения запроса данных по зависимостям.'");
						ВызватьИсключение ТекстОшибки;
					КонецЕсли;
					КонецПоля = Сред(ПервоеПоле, Позиция + СтрДлина(ЗаменяемоеПоле));
					ПервоеПоле = НачалоПоля + "ТекущиеДанныеДляОтбора"
						+ ?(ЗаменяемоеПоле <> ПервыйПсевдоним, ".Ссылка", "") + КонецПоля;
				КонецЕсли;
				Если СтрНачинаетсяС(ПервоеПоле, "ТекущиеДанныеДляОтбора.") Тогда
					УсловияСоединения.Добавить(ПараПолей.ВтороеПоле.Поле + " = " + ПервоеПоле);
					
				ИначеЕсли СтрНачинаетсяС(ПараПолей.ВтороеПоле.Поле, "ТекущиеДанныеДляОтбора.") Тогда
					УсловияСоединения.Добавить(ПервоеПоле + " = " + ПараПолей.ВтороеПоле.Поле);
					
				ИначеЕсли ПараПолей.ВтороеПоле.Псевдоним = ВторойПсевдоним Тогда
					УсловияСоединения.Добавить(ПараПолей.ВтороеПоле.Поле + " = " + ПервоеПоле);
				Иначе
					УсловияСоединения.Добавить(ПервоеПоле + " = " + ПараПолей.ВтороеПоле.Поле);
				КонецЕсли;
			Иначе
				ОставшиесяУсловия = ОставшиесяПсевдонимы.Получить(ПараПолей.ПервоеПоле.Псевдоним);
				ОставшиесяУсловия.Добавить(ПараПолей);
			КонецЕсли;
		КонецЦикла;
		Если ВторойПсевдоним = "ТекущийСписок" Тогда
			ТаблицаИПсевдоним = "&ТекущийСписок КАК ТекущийСписок";
		Иначе
			СледующаяТаблица = ОбратнаяГруппаТаблиц[Индекс + 1];
			ТаблицаИПсевдоним = СледующаяТаблица.Таблица + " КАК " + СледующаяТаблица.Псевдоним;
		КонецЕсли;
		ТекстСоединения = ТекстСоединения + "
		|	ВНУТРЕННЕЕ СОЕДИНЕНИЕ " + ТаблицаИПсевдоним + "
		|	ПО (" + СтрСоединить(УсловияСоединения, ")
		|		И (") + ")";
		ЗаменитьПервоеПоле = Ложь;
	КонецЦикла;
	
	Возврат ТекстСоединения + ДополнительноеУсловие;
	
КонецФункции


// Для процедур ДобавитьОпорноеПоле, ДобавитьТипыИзмерения, ДобавитьСвойстваТиповПоля,
// ДобавитьПроверкуПоТипам и функции СвойстваПоля.
//
Функция ЭтоПростойТип(Тип)
	
	Возврат Тип = Тип("Булево")
	    Или Тип = Тип("Дата")
	    Или Тип = Тип("Строка")
	    Или Тип = Тип("Число")
	    Или Тип = Тип("УникальныйИдентификатор")
	    Или Тип = Тип("ХранилищеЗначения");
	
КонецФункции

// Для функции ДобавитьСвойстваТиповПоля.
Функция ТипПроверяется(Узел, ПолноеИмя)
	
	Если Узел.Типы.Количество() = 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	ТипУказан = Ложь;
	Для Каждого ИмяТаблицы Из Узел.Типы Цикл
		Если ВРег(ИмяТаблицы) = ВРег(ПолноеИмя) Тогда
			ТипУказан = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Узел.ПроверятьТипыКромеУказанных И Не ТипУказан
	 Или Не Узел.ПроверятьТипыКромеУказанных И    ТипУказан;
	
КонецФункции

// Для функции ДобавитьСвойстваТиповПоля.
Функция ТипУточнен(Узел, ИмяТипаНаЯзыкеЗапросов)
	
	ТипУточнен = Ложь;
	Для Каждого УточнениеСравнения Из Узел.УточненияСравнения Цикл
		Если ВРег(УточнениеСравнения.Ключ) = ВРег(ИмяТипаНаЯзыкеЗапросов) Тогда
			ТипУточнен = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ТипУточнен;
	
КонецФункции

// Для функции ДобавитьСвойстваТиповПоля.
Функция УточнениеТипа(Узел, ИмяТипаНаЯзыкеЗапросов)
	
	Уточнение = "";
	Для Каждого УточнениеСравнения Из Узел.УточненияСравнения Цикл
		Если ВРег(УточнениеСравнения.Ключ) = ВРег(ИмяТипаНаЯзыкеЗапросов) Тогда
			Уточнение = УточнениеСравнения.Значение;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Уточнение;
	
КонецФункции

// Для функции СвойстваПоля.
Функция ТипЗначенияУзлаЗначениеИлиКонстанта(Узел)
	
	Если Узел.Узел = "Значение" Тогда
		Возврат ТипСсылкиПоПолномуИмениПредопределенного(Узел.Имя);
	КонецЕсли;
	
	Возврат ТипЗнч(Узел.Значение);
	
КонецФункции

// Для функций ТекстУсловияСоединения, СвойстваПоля, НаборПолейУсловияКогда и
// процедуры УточнитьСвойстваПоляСравнения.
//
Функция ВыражениеУзлаЗначениеИлиКонстанта(Узел)
	
	Если Узел.Узел = "Значение" Тогда
		Выражение = "Значение(" + Узел.Имя + ")";
	
	ИначеЕсли ТипЗнч(Узел.Значение) = Тип("Булево") Тогда
		Выражение = ?(Узел.Значение, "Истина", "Ложь");
		
	ИначеЕсли ТипЗнч(Узел.Значение) = Тип("Число") Тогда
		Выражение = Формат(Узел.Значение, "ЧГ=");
		
	ИначеЕсли ТипЗнч(Узел.Значение) = Тип("Неопределено") Тогда
		Выражение = "Неопределено";
	Иначе
		Выражение = """" + Узел.Значение + """";
	КонецЕсли;
	
	Возврат Выражение;
	
КонецФункции

// Для функции ТипЗначенияУзлаЗначениеИлиКонстанта.
Функция ТипСсылкиПоПолномуИмениПредопределенного(ПолноеИмяПредопределенного)
	
	ЧастиИмени = СтрРазделить(ПолноеИмяПредопределенного, ".");
	ЧастиИмени.Удалить(2);
	
	ПолноеИмя = СтрСоединить(ЧастиИмени, ".");
	
	Возврат ТипСсылкиПоПолномуИмениМетаданных(ПолноеИмя);
	
КонецФункции

// Для функций СвойстваПоля, ТипСсылкиПоПолномуИмениПредопределенного.
Функция ТипСсылкиПоПолномуИмениМетаданных(ПолноеИмя)
	
	Если ЭтоРусскийВариантВидаОбъектаМетаданных(ПолноеИмя) Тогда
		ИмяТипаСсылки = СтрЗаменить(ПолноеИмя, ".", "Ссылка.");
	Иначе
		ИмяТипаСсылки = СтрЗаменить(ПолноеИмя, ".", "Ref.");
	КонецЕсли;
	
	Возврат Тип(ИмяТипаСсылки);
	
КонецФункции

// Для функции ТипСсылкиПоПолномуИмениМетаданных.
Функция ЭтоРусскийВариантВидаОбъектаМетаданных(ПолноеИмя)
	
	ПервыйСимвол = Лев(ПолноеИмя, 1);
	
	Возврат ПервыйСимвол > "А" И ПервыйСимвол < "Я"
	    Или ПервыйСимвол > "а" И ПервыйСимвол < "я";
	
КонецФункции

#КонецОбласти

#Область ПараметрыОграниченияДоступаТекстыЗапросовДляСписка

// Основная функция области, которая является второй частью
// функции ПараметрыОграниченияПоСтруктуреОграничения, но
// не используется при подготовке хранимых параметров ограничения доступа,
// а используется при вызове функции ПараметрыОграничения.
//
Процедура ДобавитьТекстыЗапросовВПараметрыОграничения(Результат)
	
	ПроверитьОпределяемыйТипПолеРегистраКлючейДоступаКРегистрам(Результат.Контекст);
	
	Контекст = Результат.Контекст;
	Результат.Удалить("Контекст");
	
	// Проверка прав Чтение и Изменение объекта или набора записей в базе данных.
	Результат.Вставить("ТекстЗапросаПроверкиПравЧтениеИзменение");
	// Проверка права Чтение объекта или набора записей в базе данных.
	Результат.Вставить("ТекстЗапросаПроверкиПраваЧтение");
	
	ДобавитьТекстЗапросаДатыСледующегоЭлементаДанных(Результат, Контекст); 
	
	Если Результат.БезЗаписиКлючейДоступа
	 Или Результат.СЗаписьюВсегдаРазрешенногоКлючаДоступа Тогда
		
		// Запрос объектов или отборов записей для удаления или установки пустых ключей.
		Результат.Вставить("ТекстЗапросаУстаревшихЭлементовДанных");
		ДобавитьТекстЗапросаУстаревшихЭлементовДанных(Результат, Контекст);
		
		Если Результат.СЗаписьюВсегдаРазрешенногоКлючаДоступа Тогда
			// Запрос объектов или отборов записей, у которых ключ не является разрешенным.
			Результат.Вставить("ТекстЗапросаЭлементовДанныхСУстаревшимРазрешеннымКлючом");
			ДобавитьТекстЗапросаЭлементовДанныхСУстаревшимРазрешеннымКлючом(Результат, Контекст);
			
		ИначеЕсли Результат.ИспользуетсяОграничениеПоВладельцу Тогда
			// Формирование запросов проверки прав.
			ЗаполнитьЗапросыПроверкиПравЧтениеИзменение(Результат, Контекст);
		КонецЕсли;
		
		Возврат;
	КонецЕсли;
	
	// Имена используемых таблиц ключа.
	Результат.Вставить("ТаблицыКлюча");
	// Имена используемых реквизитов таблиц ключа.
	Результат.Вставить("РеквизитыТаблицКлюча");
	
	// Запрос объектов или отборов записей, у которых устарели ключи доступа.
	Результат.Вставить("ТекстЗапросаЭлементовДанныхСУстаревшимиКлючами");
	// Запрос отборов записей, которых нет в регистре ключей доступа регистров при фоновом обновлении.
	Результат.Вставить("ТекстЗапросаЭлементовДанныхБезКлючейДоступа");
	// Запрос отборов записей, которых нет в регистре ключей доступа регистров при записи нового набора.
	Результат.Вставить("ТекстЗапросаНовыхКомбинацийЗначенийОпорныхПолейСуществующихЗаписей");
	Результат.Вставить("ТекстЗапросаНовыхКомбинацийЗначенийОпорныхПолейНовыхЗаписей");
	// Запросы объектов или отборов записей, у которых устарели ключи доступа
	// по составу изменений ведущих объектов (для точечного задания).
	Результат.Вставить("ОписаниеЗапросовУстаревшихКлючейДоступаПоВедущимОбъектам", Новый Соответствие);
	// Запрос несуществующих объектов и отборов записей, которые не используются.
	Результат.Вставить("ТекстЗапросаУстаревшихЭлементовДанных");
	
	// Запрос текущих ключей доступа отборов записей регистра перед записью рассчитанных ключей доступа.
	Результат.Вставить("ТекстЗапросаТекущихКлючейДоступаРегистра");
	
	// Запрос значений объектов или отборов записей.
	Результат.Вставить("ТекстЗапросаЗначенийЭлементовДанныхДляКлючейДоступа");
	// Запрос значений из используемых ключей доступа для сравнения со значениями из объектов или отборов записей.
	Результат.Вставить("ТекстЗапросаЗначенийИзИспользуемыхКлючейДоступаДляСравнения");
	// Запрос значений из всех ключей доступа для сравнения со значениями из объектов или
	// отборов записей перед записью нового ключа.
	Результат.Вставить("ТекстЗапросаЗначенийИзВсехКлючейДоступаДляСравнения");
	// Запрос проверки существования ключа доступа перед записью нового ключа.
	Результат.Вставить("ТекстЗапросаСуществованияКлючейДляСравнения");
	
	// Запрос ключей доступа для обновления пользователей и групп доступа, которым они разрешены.
	Результат.Вставить("ТекстЗапросаКлючейДоступаДляОбновленияПрав");
	// Запрос ключей доступа по ведущим ключам для обновления пользователей и групп доступа, которым они разрешены.
	Результат.Вставить("ТекстЗапросаКлючейПоВедущимКлючамДляОбновленияПрав");
	// Запрос значений из ключей доступа для вычисления пользователей и групп доступа, которым они разрешены.
	Результат.Вставить("ТекстЗапросаЗначенийИзКлючейДоступаДляРасчетаПрав");
	// Запрос неиспользуемых ключей доступа для установки даты неиспользования или удаления.
	Результат.Вставить("ТекстЗапросаУстаревшихКлючейДоступа");
	
	Контекст.Вставить("ОтдельныйРегистр", Истина); // Уточнение регистра ключей для нессылочных типов.
	
	Контекст.Вставить("ТаблицыКлюча",                                       Новый Массив);
	Контекст.Вставить("РеквизитыТаблицКлюча",                               Новый Соответствие);
	Контекст.Вставить("ЧастиУсловияПроверки",                               Новый Массив);
	Контекст.Вставить("ЧастиЗапросаЗначенийИзОбъектов",                     Новый Массив);
	Контекст.Вставить("ЧастиЗапросаЗначенийИзКлючейДляСравнения",           Новый Массив);
	Контекст.Вставить("ЧастиЗапросаСуществованияКлючейДляСравнения",        Новый Массив);
	Контекст.Вставить("ЧастиЗапросаЗначенийИзКлючейДляРасчетаПрав",         Новый Массив);
	Контекст.Вставить("ЧастиУсловияВыбораПравВедущихКлючейДоступа",         Новый Массив);
	Контекст.Вставить("ЧастиУсловияВыбораПравВедущихСписков",               Новый Массив);
	Контекст.Вставить("ЧастиУсловияВыбораПравПоВладельцамНастроекПрав",     Новый Массив);
	Контекст.Вставить("ЧастиУсловияОтбораПоВедущимКлючамДоступа",           Новый Массив);
	Контекст.Вставить("ОписаниеЗапросовПроверкиПоВедущимОбъектам",          Новый Соответствие);
	
	// Формирование запроса элементов данных с устаревшими ключами.
	ЗаполнитьШаблоныЧастейЗапросаПроверки(Контекст);
	
	Для НомерШапки = 0 По 2 Цикл
		ДобавитьПроверкуШапкиКлюча(Контекст, НомерШапки);
	КонецЦикла;
	
	Для НомерТабличнойЧастиКлюча = 1 По Контекст.КоличествоТабличныхЧастейКлюча Цикл
		ДобавитьПроверкуТабличнойЧастиКлюча(Контекст, НомерТабличнойЧастиКлюча);
	КонецЦикла;
	СобратьЧастиЗапросаПроверки(Результат, Контекст);
	
	// Формирование запросов значений из элементов данных и из ключей.
	Для НомерШапки = 0 По 2 Цикл
		ДобавитьЗаполнениеШапкиКлюча(Контекст, НомерШапки);
	КонецЦикла;
	ДобавитьВыборКлючейБезПолейВШапке(Контекст);
	
	Для НомерТабличнойЧастиКлюча = 1 По Контекст.КоличествоТабличныхЧастейКлюча Цикл
		ДобавитьЗаполнениеТабличнойЧастиКлюча(Контекст, НомерТабличнойЧастиКлюча);
	КонецЦикла;
	СобратьЧастиЗапросовЗаполнения(Результат, Контекст);
	
	Результат.ТаблицыКлюча         = Контекст.ТаблицыКлюча;
	Результат.РеквизитыТаблицКлюча = Контекст.РеквизитыТаблицКлюча;
	
	ДобавитьТекстЗапросаУстаревшихЭлементовДанных(Результат, Контекст);
	
	// Формирование запросов проверки прав.
	ЗаполнитьЗапросыПроверкиПравЧтениеИзменение(Результат, Контекст);
	
КонецПроцедуры

// Для процедуры ДобавитьТекстыЗапросовВПараметрыОграничения.
Процедура ПроверитьОпределяемыйТипПолеРегистраКлючейДоступаКРегистрам(Контекст)
	
	Если Контекст.ЭтоСсылочныйТип Или Контекст.ИспользуетсяОграничениеПоВладельцу Тогда
		Возврат;
	КонецЕсли;
	
	Если Контекст.Свойство("ПропуститьПроверкуОпределяемыхТипов") Тогда
		Возврат;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Контекст.ИмяОтдельногоРегистраКлючей) Тогда
		Измерения = Метаданные.РегистрыСведений[Контекст.ИмяОтдельногоРегистраКлючей].Измерения;
	Иначе
		Измерения = Метаданные.РегистрыСведений.КлючиДоступаКРегистрам.Измерения;
	КонецЕсли;
	
	НедостающиеТипы = Новый Соответствие;
	Поля = Новый Соответствие;
	СписокНедостающихТипов = Новый СписокЗначений;
	СписокПолей = Новый СписокЗначений;
	
	Индекс = Контекст.ОпорныеПоля.ТипыВсех.Количество() - 1;
	Пока Индекс >= 0 Цикл
		ТребуемыйТип = Контекст.ОпорныеПоля.ТипыВсех.Получить(Индекс).Получить();
		ТипИзмерения = Измерения["Поле" + (Индекс + 1)].Тип;
		НедостающийТип = Новый ОписаниеТипов(ТребуемыйТип, , ТипИзмерения.Типы());
		Для Каждого Тип Из НедостающийТип.Типы() Цикл
			Если НедостающиеТипы.Получить(Тип) = Неопределено Тогда
				НедостающиеТипы.Вставить(Тип, Истина);
				СписокНедостающихТипов.Добавить(ИмяТипаСсылки(ИмяТипаНаЯзыкеЗапросов(Тип),
					Контекст.СтруктураОграничения.ВнутренниеДанные.ТипыТаблицПоИменам));
				Поле = Контекст.ОпорныеПоля.Все.Получить(Индекс);
				Если Поля.Получить(Поле) = Неопределено Тогда
					Поля.Вставить(Поле, Истина);
					СписокПолей.Добавить(Поле);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		Индекс = Индекс - 1;
	КонецЦикла;
	
	Если СписокНедостающихТипов.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	СписокНедостающихТипов.СортироватьПоЗначению();
	ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Для списка %1 
		           |не удалось подготовить параметры ограничения доступа к работе, так как
		           |в определяемом типе ПолеРегистраКлючейДоступаКРегистрам не хватает типов:
		           |	- %2,
		           |имеющихся у полей (%3) в ограничении доступа:
		           |	%4'"),
		Контекст.Список,
		СтрСоединить(СписокНедостающихТипов.ВыгрузитьЗначения(), "," + Символы.ПС + "	- "),
		СтрСоединить(СписокПолей.ВыгрузитьЗначения(), ", "),
		ТекстСОтступом(Контекст.ОписанияОграничений.Получить(Контекст.Список).Текст, "	"));
	
	ВызватьИсключение ТекстОшибки;
	
КонецПроцедуры

// Для процедуры ДобавитьТекстыЗапросовВПараметрыОграничения.
Процедура ДобавитьТекстЗапросаДатыСледующегоЭлементаДанных(Результат, Контекст)
	
	Если Не Результат.СписокСДатой И Не Результат.СписокСПериодом Тогда
		Возврат;
	КонецЕсли;
	
	Если Результат.СписокСДатой Тогда
		ТекстЗапроса =
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	ТекущийСписок.Дата КАК Дата
		|ИЗ
		|	&ТекущийСписок КАК ТекущийСписок
		|ГДЕ
		|	ТекущийСписок.Дата < &ДатаНачала
		|
		|УПОРЯДОЧИТЬ ПО
		|	ТекущийСписок.Дата УБЫВ";
	Иначе
		ТекстЗапроса =
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	ТекущийСписок.Период КАК Период
		|ИЗ
		|	&ТекущийСписок КАК ТекущийСписок
		|ГДЕ
		|	ТекущийСписок.Период < &ДатаНачала
		|
		|УПОРЯДОЧИТЬ ПО
		|	ТекущийСписок.Период УБЫВ";
		Если Контекст.ИмяКоллекцииТипа = "РегистрыРасчета" Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ".Период", ".ПериодРегистрации");
		КонецЕсли;
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ТекущийСписок", Результат.Список);
	
	Результат.Вставить("ТекстЗапросаДатыСледующегоЭлементаДанных", ТекстЗапроса);
	
КонецПроцедуры

// Для процедуры ДобавитьТекстыЗапросовВПараметрыОграничения.
Процедура ДобавитьТекстЗапросаЭлементовДанныхСУстаревшимРазрешеннымКлючом(Результат, Контекст)
	
	Если Не Результат.ЭтоСсылочныйТип Тогда
		Возврат;
	КонецЕсли;
	
	ЗаполнитьШаблоныЧастейЗапросаПроверкиОбъекта(Контекст);
	ТекстЗапроса = Контекст.ТекстЧастиЗапросаПроверки;
	
	Условие = "КлючиДоступаКОбъектам.Объект ЕСТЬ NULL";
	Если Результат.ДляВнешнихПользователей Тогда
		УсловиеСоединения = "	И КлючиДоступаКОбъектам.КлючДоступаВнешнихПользователей = &РазрешенныйКлючДоступа";
	Иначе
		УсловиеСоединения = "	И КлючиДоступаКОбъектам.КлючДоступаПользователей = &РазрешенныйКлючДоступа";
	КонецЕсли;
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#Соединения", УсловиеСоединения);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#Условие", Условие);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ТекущийСписок", Результат.Список);
	
	Результат.ТекстЗапросаЭлементовДанныхСУстаревшимРазрешеннымКлючом = ТекстЗапроса;
	
КонецПроцедуры

// Для процедуры ДобавитьТекстыЗапросовВПараметрыОграничения.
Процедура ДобавитьТекстЗапросаУстаревшихЭлементовДанных(Результат, Контекст)
	
	Если Результат.ЭтоСсылочныйТип Тогда
		ТипСсылки  = ТипСсылкиПоПолномуИмениМетаданных(Результат.Список);
		ТипыСсылок = УправлениеДоступомСлужебныйПовтИсп.ТипыПоляТаблицы("ОпределяемыйТип.ВладелецЗначенийКлючейДоступа");
		
		Если ТипыСсылок.Получить(ТипСсылки) = Неопределено Тогда
			ТекстЗапроса =
			"ВЫБРАТЬ ПЕРВЫЕ 0
			|	КлючиДоступаКОбъектам.Объект КАК ТекущаяСсылка
			|ИЗ
			|	РегистрСведений.КлючиДоступаКОбъектам КАК КлючиДоступаКОбъектам";
		ИначеЕсли Результат.ДляВнешнихПользователей Тогда
			Если Результат.БезЗаписиКлючейДоступа
			   И Не Результат.БезЗаписиКлючейДоступаДляПользователейИВнешнихПользователей Тогда
				ТекстЗапроса =
				"ВЫБРАТЬ ПЕРВЫЕ " + МаркерРазмераПорции() + "
				|	КлючиДоступаКОбъектам.Объект КАК ТекущаяСсылка
				|ИЗ
				|	РегистрСведений.КлючиДоступаКОбъектам КАК КлючиДоступаКОбъектам
				|ГДЕ
				|	ТИПЗНАЧЕНИЯ(КлючиДоступаКОбъектам.Объект) = ТИП(&ТекущийСписок)
				|	И ВЫРАЗИТЬ(КлючиДоступаКОбъектам.Объект КАК &ТекущийСписок) > &ПоследняяОбработаннаяСсылка
				|	И КлючиДоступаКОбъектам.КлючДоступаВнешнихПользователей <> ЗНАЧЕНИЕ(Справочник.КлючиДоступа.ПустаяСсылка)
				|	И &УточнениеПланаЗапроса
				|
				|УПОРЯДОЧИТЬ ПО
				|	КлючиДоступаКОбъектам.Объект";
			Иначе
				ТекстЗапроса = "";
			КонецЕсли;
		ИначеЕсли Результат.БезЗаписиКлючейДоступаДляПользователейИВнешнихПользователей Тогда
			ТекстЗапроса =
			"ВЫБРАТЬ ПЕРВЫЕ " + МаркерРазмераПорции() + "
			|	КлючиДоступаКОбъектам.Объект КАК ТекущаяСсылка
			|ИЗ
			|	РегистрСведений.КлючиДоступаКОбъектам КАК КлючиДоступаКОбъектам
			|ГДЕ
			|	ТИПЗНАЧЕНИЯ(КлючиДоступаКОбъектам.Объект) = ТИП(&ТекущийСписок)
			|	И ВЫРАЗИТЬ(КлючиДоступаКОбъектам.Объект КАК &ТекущийСписок) > &ПоследняяОбработаннаяСсылка
			|	И &УточнениеПланаЗапроса
			|
			|УПОРЯДОЧИТЬ ПО
			|	КлючиДоступаКОбъектам.Объект";
		Иначе
			ТекстЗапроса =
			"ВЫБРАТЬ ПЕРВЫЕ " + МаркерРазмераПорции() + "
			|	КлючиДоступаКОбъектам.Объект КАК ТекущаяСсылка,
			|	ТекущийСписок.Ссылка ЕСТЬ NULL КАК Удалить
			|ИЗ
			|	РегистрСведений.КлючиДоступаКОбъектам КАК КлючиДоступаКОбъектам
			|		ЛЕВОЕ СОЕДИНЕНИЕ &ТекущийСписок КАК ТекущийСписок
			|		ПО (ТИПЗНАЧЕНИЯ(КлючиДоступаКОбъектам.Объект) = ТИП(&ТекущийСписок))
			|			И (ТекущийСписок.Ссылка = КлючиДоступаКОбъектам.Объект)
			|ГДЕ
			|	ТИПЗНАЧЕНИЯ(КлючиДоступаКОбъектам.Объект) = ТИП(&ТекущийСписок)
			|	И ВЫРАЗИТЬ(КлючиДоступаКОбъектам.Объект КАК &ТекущийСписок) > &ПоследняяОбработаннаяСсылка
			|	И #Условие
			|	И &УточнениеПланаЗапроса
			|
			|УПОРЯДОЧИТЬ ПО
			|	КлючиДоступаКОбъектам.Объект";
			Если Результат.БезЗаписиКлючейДоступа Тогда
				Условие =
				"(КлючиДоступаКОбъектам.КлючДоступаПользователей <> ЗНАЧЕНИЕ(Справочник.КлючиДоступа.ПустаяСсылка)
				|		ИЛИ ТекущийСписок.Ссылка ЕСТЬ NULL)";
			Иначе
				Условие = "ТекущийСписок.Ссылка ЕСТЬ NULL";
			КонецЕсли;
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#Условие", Условие);
		КонецЕсли;
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ТекущийСписок", Результат.Список);
		Результат.ТекстЗапросаУстаревшихЭлементовДанных = ТекстЗапроса;
		Возврат;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Результат.ИмяОтдельногоРегистраКлючей) Тогда
		ИмяРегистра   = Результат.ИмяОтдельногоРегистраКлючей;
		ОсновнойОтбор = "";
	Иначе
		ИмяРегистра   = "КлючиДоступаКРегистрам";
		ОсновнойОтбор = "КлючиДоступаКРегистрам.Регистр = &ИдентификаторРегистра";
	КонецЕсли;
	
	Если Результат.ДляВнешнихПользователей Тогда
		ОсновнойОтбор = ОсновнойОтбор + ?(ОсновнойОтбор = "", "", "
		|	И ") + "КлючиДоступаКРегистрам.ДляВнешнихПользователей = ИСТИНА";
	Иначе
		ОсновнойОтбор = ОсновнойОтбор + ?(ОсновнойОтбор = "", "", "
		|	И ") + "КлючиДоступаКРегистрам.ДляВнешнихПользователей = ЛОЖЬ";
	КонецЕсли;
	ОпорныеПоля = Контекст.ОпорныеПоля;
	Если ОпорныеПоля = Неопределено Тогда
		МаксимальноеКоличествоОпорныхПолей =
			УправлениеДоступомСлужебныйПовтИсп.КоличествоОпорныхПолейРегистра(ИмяРегистра);
	Иначе
		МаксимальноеКоличествоОпорныхПолей = ОпорныеПоля.МаксимальноеКоличество;
	КонецЕсли;
	
	ОпорныеПоляВыбора = "";
	ОпорныеПоляДляОтбора = "";
	ОпорныеПоляДляУпорядочения = "";
	
	Для Номер = 1 По МаксимальноеКоличествоОпорныхПолей Цикл
		// Поля для выбора.
		ОпорныеПоляВыбора = ОпорныеПоляВыбора + ?(ОпорныеПоляВыбора = "", "", ",
		|	") + "КлючиДоступаКРегистрам.Поле" + Номер + " КАК Поле" + Номер;
		
		// Поля для отбора.
		Отбор = "";
		Для ДополнительныйНомер = 1 По Номер - 1 Цикл
			Отбор = Отбор + ?(ДополнительныйНомер = 1, "", "
			|	И ") + "КлючиДоступаКРегистрам.Поле" + ДополнительныйНомер + " = &Поле" + ДополнительныйНомер;
		КонецЦикла;
		Отбор = Отбор + ?(Отбор = "", "", "
		|	И ") + "КлючиДоступаКРегистрам.Поле" + Номер + " > &Поле" + Номер;
		
		Отбор = ?(Номер = 1, ?(МаксимальноеКоличествоОпорныхПолей > 1, "(", "") + Отбор, "
		|			ИЛИ " + ТекстСОтступом(Отбор, "			"));
		
		ОпорныеПоляДляОтбора = ОпорныеПоляДляОтбора + ?(ОпорныеПоляДляОтбора = "", "", ?(Номер = 1, "
		|	И ", "")) + Отбор;
		
		// Поля для упорядочения.
		ОпорныеПоляДляУпорядочения = ОпорныеПоляДляУпорядочения + ?(ОпорныеПоляДляУпорядочения = "", "", ",
		|	") + "КлючиДоступаКРегистрам.Поле" + Номер;
	КонецЦикла;
	Если МаксимальноеКоличествоОпорныхПолей > 1 Тогда
		ОпорныеПоляДляОтбора  = ОпорныеПоляДляОтбора  + ")";
	КонецЕсли;
	
	Если Результат.БезЗаписиКлючейДоступа Тогда
		ТекстЗапроса =
		"ВЫБРАТЬ ПЕРВЫЕ " + МаркерРазмераПорции() + "
		|	" + ОпорныеПоляВыбора + "
		|ИЗ
		|	РегистрСведений." + ИмяРегистра + " КАК КлючиДоступаКРегистрам
		|ГДЕ
		|	" + ОсновнойОтбор + "
		|	И " + ОпорныеПоляДляОтбора + "
		|	И &УточнениеПланаЗапроса
		|
		|УПОРЯДОЧИТЬ ПО
		|	" + ОпорныеПоляДляУпорядочения;
	Иначе
		Если ЗначениеЗаполнено(Результат.ИмяОтдельногоРегистраКлючей) Тогда
			ТекстЗапросаОчистки =
			"ВЫБРАТЬ ПЕРВЫЕ " + МаркерРазмераПорции() + "
			|	" + ОпорныеПоляВыбора + "
			|ИЗ
			|	РегистрСведений.КлючиДоступаКРегистрам КАК КлючиДоступаКРегистрам
			|ГДЕ
			|	КлючиДоступаКРегистрам.Регистр = &ИдентификаторРегистра
			|	И " + ОпорныеПоляДляОтбора + "
			|	И &УточнениеПланаЗапроса
			|
			|УПОРЯДОЧИТЬ ПО
			|	" + ОпорныеПоляДляУпорядочения;
			Результат.Вставить("ТекстЗапросаУстаревшихЭлементовДанныхИзОбщегоРегистра", ТекстЗапросаОчистки);
		КонецЕсли;
		Номер = 1;
		ОпорныеПоляВыбораПриПроверке = "";
		ОпорныеПоляДляСравнения = "";
		Для Каждого ИмяОпорногоПоля Из ОпорныеПоля.Используемые Цикл
			// Поля для выбора при проверке устаревания перед записью.
			ОпорныеПоляВыбораПриПроверке = ОпорныеПоляВыбораПриПроверке + ?(ОпорныеПоляВыбораПриПроверке = "", "", ",
			|	") + "КлючиДоступаКРегистрам.Поле" + Номер + " КАК Поле" + Номер;
			// Поля для сравнения.
			ОпорныеПоляДляСравнения = ОпорныеПоляДляСравнения + ?(ОпорныеПоляДляСравнения = "", "", "
			|И ") + "ТекущийСписок." + ИмяОпорногоПоля + " = КлючиДоступаКРегистрам.Поле" + Номер;
			Номер = Номер + 1;
		КонецЦикла;
		
		НачальныйНомер = ОпорныеПоля.Используемые.Количество() + 1;
		ОтборНепустыхПолей = "";
		Для Номер = НачальныйНомер По ОпорныеПоля.МаксимальноеКоличество Цикл
			ОтборНепустыхПолей = ОтборНепустыхПолей + ?(ОтборНепустыхПолей = "", "", "
			|		ИЛИ ") + "КлючиДоступаКРегистрам.Поле" + Номер + " <> ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.Null)";
		КонецЦикла;
		ОтборНепустыхПолей = ?(ОтборНепустыхПолей = "", "ЛОЖЬ", ОтборНепустыхПолей);
		
		ТекстЗапроса =
		"ВЫБРАТЬ ПЕРВЫЕ " + МаркерРазмераПорции() + "
		|	" + ОпорныеПоляВыбора + ",
		|	" + ОтборНепустыхПолей + " КАК Удалить
		|ИЗ
		|	РегистрСведений." + ИмяРегистра + " КАК КлючиДоступаКРегистрам
		|ГДЕ
		|	" + ОсновнойОтбор + "
		|	И " + ОпорныеПоляДляОтбора + "
		|	И (" + ТекстСОтступом(ОтборНепустыхПолей, "	") + "
		|			ИЛИ НЕ ИСТИНА В
		|					(ВЫБРАТЬ ПЕРВЫЕ 1
		|						ИСТИНА
		|					ИЗ
		|						&ТекущийСписок КАК ТекущийСписок
		|					ГДЕ
		|						" + ТекстСОтступом(ОпорныеПоляДляСравнения, "						") + "))
		|	И &УточнениеПланаЗапроса
		|
		|УПОРЯДОЧИТЬ ПО
		|	" + ОпорныеПоляДляУпорядочения;
		
		ТекстЗапросаПроверки =
		"ВЫБРАТЬ
		|	" + ОпорныеПоляВыбораПриПроверке + "
		|ПОМЕСТИТЬ КлючиДоступаКРегистрам
		|ИЗ
		|	&КлючиДоступаКРегистрам КАК КлючиДоступаКРегистрам
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	" + ОпорныеПоляВыбораПриПроверке + "
		|ИЗ
		|	КлючиДоступаКРегистрам КАК КлючиДоступаКРегистрам
		|ГДЕ
		|	НЕ ИСТИНА В
		|				(ВЫБРАТЬ ПЕРВЫЕ 1
		|					ИСТИНА
		|				ИЗ
		|					&ТекущийСписок КАК ТекущийСписок
		|				ГДЕ
		|					" + ТекстСОтступом(ОпорныеПоляДляСравнения, "						") + ")
		|	И &УточнениеПланаЗапроса";
		
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ТекущийСписок", Результат.Список);
		ТекстЗапросаПроверки = СтрЗаменить(ТекстЗапросаПроверки, "&ТекущийСписок", Результат.Список);
		Результат.Вставить("ТекстЗапросаПроверкиУстаревшихЭлементовДанных", ТекстЗапросаПроверки);
	КонецЕсли;
	
	Результат.ТекстЗапросаУстаревшихЭлементовДанных = ТекстЗапроса;
	
КонецПроцедуры

// Для процедуры ДобавитьТекстыЗапросовВПараметрыОграничения.
Процедура ЗаполнитьШаблоныЧастейЗапросаПроверки(Контекст)
	
	Если Контекст.ЭтоСсылочныйТип Тогда
		ЗаполнитьШаблоныЧастейЗапросаПроверкиОбъекта(Контекст);
	Иначе
		ЗаполнитьШаблоныЧастейЗапросаПроверкиРегистра(Контекст);
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ЗаполнитьШаблоныЧастейЗапросаПроверки.
Процедура ЗаполнитьШаблоныЧастейЗапросаПроверкиОбъекта(Контекст)
	
	Контекст.Вставить("ТекстЗапросаПроверки");
	Контекст.Вставить("ТекстЧастиЗапросаПроверки");
	Контекст.Вставить("ТекстЗапросаТочечнойПроверки");
	
	Если Контекст.СписокСДатой Тогда
		Контекст.ТекстЗапросаПроверки =
		"ВЫБРАТЬ ПЕРВЫЕ " + МаркерРазмераПорции() + "
		|	ТекущийСписок.Ссылка КАК ТекущаяСсылка,
		|	ТекущийСписок.Дата КАК Дата
		|ИЗ
		|	&ТекущийСписок КАК ТекущийСписок
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.КлючиДоступаКОбъектам КАК КлючиДоступаКОбъектам
		|		ПО (КлючиДоступаКОбъектам.Объект = ТекущийСписок.Ссылка)
		|ГДЕ
		|	ТекущийСписок.Дата МЕЖДУ &ДатаНачала И &ДатаОкончания
		|	И (КлючиДоступаКОбъектам.Объект ЕСТЬ NULL
		|			ИЛИ #Условие)
		|	И &УточнениеПланаЗапроса
		|
		|УПОРЯДОЧИТЬ ПО
		|	ТекущийСписок.Дата УБЫВ";
		
		Контекст.ТекстЧастиЗапросаПроверки =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ ПЕРВЫЕ " + МаркерРазмераПорции() + "
		|	ТекущийСписок.Ссылка КАК ТекущаяСсылка,
		|	ТекущийСписок.Дата КАК Дата
		|ИЗ
		|	&ТекущийСписок КАК ТекущийСписок
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.КлючиДоступаКОбъектам КАК КлючиДоступаКОбъектам
		|		ПО (КлючиДоступаКОбъектам.Объект = ТекущийСписок.Ссылка)
		|		#Соединения
		|ГДЕ
		|	ТекущийСписок.Дата МЕЖДУ &ДатаНачала И &ДатаОкончания
		|	И #Условие
		|	И &УточнениеПланаЗапроса
		|
		|УПОРЯДОЧИТЬ ПО
		|	ТекущийСписок.Дата УБЫВ";
	Иначе
		Контекст.ТекстЗапросаПроверки =
		"ВЫБРАТЬ ПЕРВЫЕ " + МаркерРазмераПорции() + "
		|	ТекущийСписок.Ссылка КАК ТекущаяСсылка
		|ИЗ
		|	&ТекущийСписок КАК ТекущийСписок
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.КлючиДоступаКОбъектам КАК КлючиДоступаКОбъектам
		|		ПО (КлючиДоступаКОбъектам.Объект = ТекущийСписок.Ссылка)
		|ГДЕ
		|	ТекущийСписок.Ссылка >= &ПоследняяОбработаннаяСсылка
		|	И (КлючиДоступаКОбъектам.Объект ЕСТЬ NULL
		|			ИЛИ #Условие)
		|	И &УточнениеПланаЗапроса
		|
		|УПОРЯДОЧИТЬ ПО
		|	ТекущийСписок.Ссылка";
		
		Контекст.ТекстЧастиЗапросаПроверки =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ ПЕРВЫЕ " + МаркерРазмераПорции() + "
		|	ТекущийСписок.Ссылка КАК ТекущаяСсылка
		|ИЗ
		|	&ТекущийСписок КАК ТекущийСписок
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.КлючиДоступаКОбъектам КАК КлючиДоступаКОбъектам
		|		ПО (КлючиДоступаКОбъектам.Объект = ТекущийСписок.Ссылка)
		|		#Соединения
		|ГДЕ
		|	ТекущийСписок.Ссылка >= &ПоследняяОбработаннаяСсылка
		|	И #Условие
		|	И &УточнениеПланаЗапроса
		|
		|УПОРЯДОЧИТЬ ПО
		|	ТекущийСписок.Ссылка";
	КонецЕсли;
	
	Контекст.ТекстЗапросаТочечнойПроверки =
	"ВЫБРАТЬ
	|	ТекущийСписок.Ссылка КАК ТекущаяСсылка
	|ИЗ
	|	&ТекущийСписок КАК ТекущийСписок
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ТекущийСписокПоВедущимОбъектам КАК ТекущийСписокПоВедущимОбъектам
	|		ПО (ТекущийСписокПоВедущимОбъектам.Ссылка = ТекущийСписок.Ссылка)
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.КлючиДоступаКОбъектам КАК КлючиДоступаКОбъектам
	|		ПО (КлючиДоступаКОбъектам.Объект = ТекущийСписок.Ссылка)
	|ГДЕ
	|	(КлючиДоступаКОбъектам.Объект ЕСТЬ NULL
	|			ИЛИ #Условие)
	|	И &УточнениеПланаЗапроса";
	
	Если Не Контекст.Свойство("ОписаниеЗапросовПроверкиПоВедущимОбъектам") Тогда
		Возврат;
	КонецЕсли;
	
	ТекстЗапросаОберткиВыбораДанныхДляТочечнойПроверки =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ ПЕРВЫЕ " + МаркерРазмераПорции() + "
	|	ТекущийСписок.Ссылка КАК Ссылка
	|ПОМЕСТИТЬ ТекущийСписокПоВедущимОбъектам
	|ИЗ
	|	(#ЗапросыВыбораДанных) КАК ТекущийСписок";
	
	Контекст.ОписаниеЗапросовПроверкиПоВедущимОбъектам.Вставить("ТекстЗапросаОберткиВыбораДанных",
		ТекстЗапросаОберткиВыбораДанныхДляТочечнойПроверки);
	
	ШаблонЗапроса =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ ПЕРВЫЕ " + МаркерРазмераПорции() + "
	|	ТекущийСписок.Ссылка КАК Ссылка
	|ИЗ
	|	";
	ДобавитьЗапросыПроверкиПоВедущимСпискам(ШаблонЗапроса, Контекст);
	
КонецПроцедуры

// Для процедуры ЗаполнитьШаблоныЧастейЗапросаПроверки.
Процедура ЗаполнитьШаблоныЧастейЗапросаПроверкиРегистра(Контекст)
	
	ОпорныеПоля = Контекст.ОпорныеПоля;
	ОпорныеПоля.Вставить("ДляВыбора",         "");
	ОпорныеПоля.Вставить("УсловиеСоединения", "");
	ОпорныеПоля.Вставить("ДляОтбора",         "");
	ОпорныеПоля.Вставить("ДляУпорядочения",   "");
	
	// Для запроса новых комбинаций.
	ОпорныеПоляДляВыбора = "";
	ОпорныеПоляУсловиеСоединения = "";
	ОпорныеПоляДляГруппировкиИлиУпорядочения = "";
	ОпорныеПоляДляОтбора = "";
	
	// Для запроса текущих ключей доступа.
	УсловиеОтбора = "";
	
	Если Не ЗначениеЗаполнено(Контекст.ИмяОтдельногоРегистраКлючей) Тогда
		Контекст.ОтдельныйРегистр = Ложь;
		// Для запроса новых комбинаций.
		ОпорныеПоляУсловиеСоединения  = "(КлючиДоступаКРегистрам.Регистр = &ИдентификаторРегистра)";
		// Для запроса текущих ключей доступа.
		УсловиеОтбора                 = "ТекущийСписок.Регистр = &ИдентификаторРегистра";
		// Для остальных запросов.
		ОпорныеПоля.УсловиеСоединения = "(ТекущийСписокИсточник.Регистр = ТекущийСписок.Регистр)";
		ОпорныеПоля.ДляОтбора         = "ТекущийСписок.Регистр = &ИдентификаторРегистра";
	КонецЕсли;
	
	ОтборПоТипуПользователей = ?(Контекст.ДляВнешнихПользователей, "ИСТИНА", "ЛОЖЬ");
	
	// Для запроса новых комбинаций.
	ОпорныеПоляУсловиеСоединения = ОпорныеПоляУсловиеСоединения + ?(ОпорныеПоляУсловиеСоединения = "", "", "
	|			И ") + "(КлючиДоступаКРегистрам.ДляВнешнихПользователей = " + ОтборПоТипуПользователей + ")";
	
	// Для запроса текущих ключей доступа.
	УсловиеОтбора = УсловиеОтбора + ?(УсловиеОтбора = "", "", "
	|	И ") + "ТекущийСписок.ДляВнешнихПользователей = " + ОтборПоТипуПользователей;
	
	// Для остальных запросов.
	ОпорныеПоля.УсловиеСоединения = ОпорныеПоля.УсловиеСоединения + ?(ОпорныеПоля.УсловиеСоединения = "", "", "
	|	И ") + "(ТекущийСписокИсточник.ДляВнешнихПользователей = " + ОтборПоТипуПользователей + ")";
	
	ОпорныеПоля.ДляОтбора = ОпорныеПоля.ДляОтбора + ?(ОпорныеПоля.ДляОтбора = "", "", "
	|	И ") + "ТекущийСписок.ДляВнешнихПользователей = " + ОтборПоТипуПользователей;
	
	Номер = 0;
	Для Каждого ИмяОпорногоПоля Из ОпорныеПоля.Используемые Цикл
		Номер = Номер + 1;
		
		// Для запроса новых комбинаций.
		ОпорныеПоляДляВыбора = ОпорныеПоляДляВыбора + ?(ОпорныеПоляДляВыбора = "", "", ",
		|	") + "ТекущийРегистр." + ИмяОпорногоПоля + " КАК Поле" + Номер;
		
		ОпорныеПоляУсловиеСоединения = ОпорныеПоляУсловиеСоединения + ?(ОпорныеПоляУсловиеСоединения = "", "", "
		|			И ") + "(КлючиДоступаКРегистрам.Поле" + Номер + " = ТекущийРегистр." + ИмяОпорногоПоля + ")";
		
		ОпорныеПоляДляГруппировкиИлиУпорядочения = ОпорныеПоляДляГруппировкиИлиУпорядочения
			+ ?(ОпорныеПоляДляГруппировкиИлиУпорядочения = "", "", ", ") + ИмяОпорногоПоля;
		
		Отбор = "";
		Для ДополнительныйНомер = 1 По Номер - 1 Цикл
			ТекущееИмяОпорногоПоля = ОпорныеПоля.Используемые[ДополнительныйНомер - 1];
			Отбор = Отбор + ?(ДополнительныйНомер = 1, "", "
			|	И ") + "ТекущийРегистр." + ТекущееИмяОпорногоПоля + " = &Поле" + ДополнительныйНомер;
		КонецЦикла;
		Отбор = Отбор + ?(Отбор = "", "", "
		|	И ") + "ТекущийРегистр." + ИмяОпорногоПоля + " > &Поле" + Номер;
		
		Отбор = ?(Номер = 1, ?(ОпорныеПоля.Используемые.Количество() > 1, "(", "") + Отбор, "
		|		ИЛИ " + ТекстСОтступом(Отбор, "		"));
		
		ОпорныеПоляДляОтбора = ОпорныеПоляДляОтбора + ?(ОпорныеПоляДляОтбора = "", "", ?(Номер = 1, "
		|	И ", "")) + Отбор;
		
		// Для запроса текущих ключей доступа.
		УсловиеОтбора = УсловиеОтбора + ?(УсловиеОтбора = "", "", "
		|	И ") + "ТекущийСписок.Поле" + Номер + " = &Поле" + Номер + "_%1";
		
		// Для остальных запросов.
		ОпорныеПоля.ДляВыбора = ОпорныеПоля.ДляВыбора + ?(ОпорныеПоля.ДляВыбора = "", "", ",
		|	") + "ТекущийСписок.Поле" + Номер + " КАК Поле" + Номер;
		
		ОпорныеПоля.УсловиеСоединения = ОпорныеПоля.УсловиеСоединения + ?(ОпорныеПоля.УсловиеСоединения = "", "", "
		|	И ") + "(ТекущийСписокИсточник.Поле" + Номер + " = ТекущийСписок.Поле" + Номер + ")";
		
		Отбор = "";
		Для ДополнительныйНомер = 1 По Номер - 1 Цикл
			Отбор = Отбор + ?(ДополнительныйНомер = 1, "", "
			|		И ") + "ТекущийСписок.Поле" + ДополнительныйНомер + " = &Поле" + ДополнительныйНомер;
		КонецЦикла;
		Отбор = Отбор + ?(Отбор = "", "", "
		|		И ") + "ТекущийСписок.Поле" + Номер + " > &Поле" + Номер;
		
		Отбор = ?(Номер = 1, ?(ОпорныеПоля.Используемые.Количество() > 1, "(", "") + Отбор, "
		|			ИЛИ " + ТекстСОтступом(Отбор, "		"));
		
		ОпорныеПоля.ДляОтбора = ОпорныеПоля.ДляОтбора + ?(ОпорныеПоля.ДляОтбора = "", "", ?(Номер = 1, "
		|	И ", "")) + Отбор;
		
		ОпорныеПоля.ДляУпорядочения = ОпорныеПоля.ДляУпорядочения + ?(ОпорныеПоля.ДляУпорядочения = "", "", ", ") + "Поле" + Номер;
	КонецЦикла;
	
	Если ОпорныеПоля.Используемые.Количество() > 1 Тогда
		ОпорныеПоляДляОтбора  = ОпорныеПоляДляОтбора  + ")";
		ОпорныеПоля.ДляОтбора = ОпорныеПоля.ДляОтбора + ")";
	КонецЕсли;
	
	НачальныйНомер = Номер + 1;
	Для Номер = НачальныйНомер По ОпорныеПоля.МаксимальноеКоличество Цикл
		// Для запроса новых комбинаций.
		ОпорныеПоляУсловиеСоединения = ОпорныеПоляУсловиеСоединения + ?(ОпорныеПоляУсловиеСоединения = "", "", "
		|			И ") + "(КлючиДоступаКРегистрам.Поле" + Номер + " = ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.Null))";
		// Для запроса проверки.
		ОпорныеПоля.ДляОтбора = ОпорныеПоля.ДляОтбора + ?(ОпорныеПоля.ДляОтбора = "", "", "
		|	И ") + "ТекущийСписок.Поле" + Номер + " = ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.Null)";
	КонецЦикла;
	
	// Установка шаблонов запросов.
	ТекстЗапросаПроверкиКомбинаций =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ ПЕРВЫЕ " + МаркерРазмераПорции() + "
	|	" + ОпорныеПоля.ДляВыбора + "
	|ИЗ
	|	&ТекущийСписок КАК ТекущийСписок
	|ГДЕ
	|	" + ОпорныеПоля.ДляОтбора + "
	|	И (#Условие)
	|	И &УточнениеПланаЗапроса
	|
	|УПОРЯДОЧИТЬ ПО
	|	" + ОпорныеПоля.ДляУпорядочения;
	
	Контекст.Вставить("ТекстЗапросаПроверки", ТекстЗапросаПроверкиКомбинаций);
	
	ТекстЗапросаТочечнойПроверкиКомбинаций =
	"ВЫБРАТЬ
	|	" + ОпорныеПоля.ДляВыбора + "
	|ИЗ
	|	ТекущийСписокПоВедущимОбъектам КАК ТекущийСписок
	|ГДЕ
	|	(#Условие)
	|	И &УточнениеПланаЗапроса";
	
	Контекст.Вставить("ТекстЗапросаТочечнойПроверки", ТекстЗапросаТочечнойПроверкиКомбинаций);
	
	ТекстЗапросаОберткиВыбораДанныхДляТочечнойПроверкиКомбинаций =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ ПЕРВЫЕ " + МаркерРазмераПорции() + "
	|	" + ОпорныеПоля.ДляВыбора + ",
	|	ТекущийСписок.КлючДоступа КАК КлючДоступа
	|ПОМЕСТИТЬ ТекущийСписокПоВедущимОбъектам
	|ИЗ
	|	(#ЗапросыВыбораДанных) КАК ТекущийСписок";
	
	Контекст.ОписаниеЗапросовПроверкиПоВедущимОбъектам.Вставить("ТекстЗапросаОберткиВыбораДанных",
		ТекстЗапросаОберткиВыбораДанныхДляТочечнойПроверкиКомбинаций);
	
	ШаблонЗапроса =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ ПЕРВЫЕ " + МаркерРазмераПорции() + "
	|	" + ОпорныеПоля.ДляВыбора + ",
	|	ТекущийСписок.КлючДоступа КАК КлючДоступа
	|ИЗ
	|	";
	ДобавитьЗапросыПроверкиПоВедущимСпискам(ШаблонЗапроса, Контекст);
	
	Если Контекст.СписокСПериодом Тогда
		ТекстЗапросаНовыхКомбинаций =
		"ВЫБРАТЬ ПЕРВЫЕ " + МаркерРазмераПорции() + "
		|	МАКСИМУМ(ТекущийРегистр.Период) КАК Период,
		|	" + ОпорныеПоляДляВыбора + "
		|ИЗ
		|	&ТекущийРегистр КАК ТекущийРегистр
		|		ЛЕВОЕ СОЕДИНЕНИЕ &ТекущийСписок КАК КлючиДоступаКРегистрам
		|		ПО " + ОпорныеПоляУсловиеСоединения + "
		|ГДЕ
		|	ТекущийРегистр.Период >= &ДатаНачала
		|	И (ТекущийРегистр.Период < &ДатаОкончания
		|		ИЛИ ТекущийРегистр.Период = &ДатаОкончания
		|			И " + ТекстСОтступом(ОпорныеПоляДляОтбора, "	") + ")
		|	И КлючиДоступаКРегистрам.ДляВнешнихПользователей ЕСТЬ NULL
		|	И &УточнениеПланаЗапроса
		|
		|СГРУППИРОВАТЬ ПО
		|	" + ОпорныеПоляДляГруппировкиИлиУпорядочения + "
		|
		|УПОРЯДОЧИТЬ ПО
		|	Период УБЫВ, " + ОпорныеПоляДляГруппировкиИлиУпорядочения;
		Если Контекст.ИмяКоллекцииТипа = "РегистрыРасчета" Тогда
			ТекстЗапросаНовыхКомбинаций = СтрЗаменить(ТекстЗапросаНовыхКомбинаций,
				".Период", ".ПериодРегистрации");
		КонецЕсли;
	Иначе
		ТекстЗапросаНовыхКомбинаций =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ ПЕРВЫЕ " + МаркерРазмераПорции() + "
		|	" + ОпорныеПоляДляВыбора + "
		|ИЗ
		|	&ТекущийРегистр КАК ТекущийРегистр
		|		ЛЕВОЕ СОЕДИНЕНИЕ &ТекущийСписок КАК КлючиДоступаКРегистрам
		|		ПО " + ОпорныеПоляУсловиеСоединения + "
		|ГДЕ
		|	" + ОпорныеПоляДляОтбора + "
		|	И КлючиДоступаКРегистрам.ДляВнешнихПользователей ЕСТЬ NULL
		|	И &УточнениеПланаЗапроса
		|
		|УПОРЯДОЧИТЬ ПО
		|	" + ОпорныеПоляДляГруппировкиИлиУпорядочения;
	КонецЕсли;
	Контекст.Вставить("ТекстЗапросаНовыхКомбинаций", ТекстЗапросаНовыхКомбинаций);
	
	// Текст запроса текущих ключей доступа.
	ТекстЗапросаТекущихКлючейДоступа =
	"ВЫБРАТЬ ПЕРВЫЕ 2
	|	ТекущийСписок.КлючДоступа КАК КлючДоступа
	|ИЗ
	|	&ТекущийСписок КАК ТекущийСписок
	|ГДЕ
	|	" + УсловиеОтбора;
	Контекст.Вставить("ТекстЗапросаТекущихКлючейДоступа", ТекстЗапросаТекущихКлючейДоступа);
	
КонецПроцедуры

// Для процедур ЗаполнитьШаблоныЧастейЗапросаПроверкиОбъекта, ЗаполнитьШаблоныЧастейЗапросаПроверкиРегистра.
Процедура ДобавитьЗапросыПроверкиПоВедущимСпискам(ШаблонЗапроса, Контекст)
	
	ОписаниеЗапросов = Новый Соответствие;
	Для Каждого СоединениеОтбора Из Контекст.ВедущиеСпискиПоЗначениямПолей.СоединенияОтборов Цикл
		ОписаниеСоединения = СоединениеОтбора.Значение;
		Поля = Контекст.ВедущиеСпискиПоЗначениямПолей.Поля.Получить(СоединениеОтбора.Ключ);
		ВедущаяТаблица = СоединениеОтбора.Ключ;
		Если ОписаниеСоединения.ПоляШапки.Количество() > 0 Тогда
			ОписаниеЗапросов.Вставить(ВедущаяТаблица,
				ОписаниеЗапросовПроверкиПоВедущейТаблице(ОписаниеСоединения.ПоляШапки,
					Поля.ДляОтбора.ПоляШапки, ВедущаяТаблица, ШаблонЗапроса, Контекст));
		КонецЕсли;
		Для Каждого ОписаниеТабличнойЧасти Из ОписаниеСоединения.ТабличныеЧасти Цикл
			ВедущаяТаблица = СоединениеОтбора.Ключ + "." + ОписаниеТабличнойЧасти.Ключ;
			ТипыПолей = Поля.ДляОтбора.ТабличныеЧасти.Получить(ОписаниеТабличнойЧасти.Ключ);
			ОписаниеЗапросов.Вставить(ВедущаяТаблица,
				ОписаниеЗапросовПроверкиПоВедущейТаблице(ОписаниеТабличнойЧасти.Значение,
					ТипыПолей, ВедущаяТаблица, ШаблонЗапроса, Контекст));
		КонецЦикла;
	КонецЦикла;
	Контекст.ОписаниеЗапросовПроверкиПоВедущимОбъектам.Вставить("ПоЗначениямПолей", ОписаниеЗапросов);
	
	ДобавитьЗапросыПроверкиПоПолюСсылкаВедущихСписков("ПоЗначениямСГруппами", ШаблонЗапроса, Контекст);
	ДобавитьЗапросыПроверкиПоПолюСсылкаВедущихСписков("ПоКлючамДоступа", ШаблонЗапроса, Контекст);
	
КонецПроцедуры

// Для процедуры ДобавитьЗапросыПроверкиПоВедущимСпискам.
Функция ОписаниеЗапросовПроверкиПоВедущейТаблице(СоединенияОтборов, ТипыПолей,
			ВедущаяТаблица, ШаблонЗапроса, Контекст)
	
	ВедущаяТаблицаБезТочек = СтрЗаменить(ВедущаяТаблица, ".", "_");
	
	Поля = Новый Массив;
	Для Каждого ОписаниеПоля Из ТипыПолей Цикл
		Поля.Добавить(ОписаниеПоля.Ключ + " КАК " + ОписаниеПоля.Ключ);
	КонецЦикла;
	
	ТекстЗапросаПараметров =
	"ВЫБРАТЬ
	|	ТекущиеДанныеДляОтбора." + СтрСоединить(Поля, ",
	|	ТекущиеДанныеДляОтбора.") + "
	|ПОМЕСТИТЬ " + ВедущаяТаблицаБезТочек + "
	|ИЗ
	|	&" + ВедущаяТаблицаБезТочек + " КАК ТекущиеДанныеДляОтбора";
	
	ОписаниеЗапросов = Новый Структура;
	ОписаниеЗапросов.Вставить("ТипыПолей", ТипыПолей);
	ОписаниеЗапросов.Вставить("ТекстЗапросаПараметров", ТекстЗапросаПараметров);
	ОписаниеЗапросов.Вставить("ТекстыЗапросовДанных", Новый Массив);
	
	Для Каждого СоединениеОтбора Из СоединенияОтборов Цикл
		ТекстЗапроса = ШаблонЗапроса + ТекстСОтступом(СоединениеОтбора, "	");
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#ТекущиеДанныеДляОтбора", ВедущаяТаблицаБезТочек);
		ПодставитьОбщиеПараметрыВЗапрос(ТекстЗапроса, Контекст);
		ОписаниеЗапросов.ТекстыЗапросовДанных.Добавить(ТекстЗапроса);
	КонецЦикла;
	
	Возврат ОписаниеЗапросов;
	
КонецФункции

// Для процедуры ДобавитьЗапросыПроверкиПоВедущимСпискам.
Процедура ДобавитьЗапросыПроверкиПоПолюСсылкаВедущихСписков(ВидВедущегоСписка, ШаблонЗапроса, Контекст)
	
	Свойства = ?(ВидВедущегоСписка = "ПоКлючамДоступа",
		Контекст.ВедущиеСпискиПоКлючамДоступа, Контекст.ВедущиеСпискиПоЗначениямСГруппами);
	
	Если Не ЗначениеЗаполнено(Свойства.СоединенияОтборов) Тогда
		Возврат;
	КонецЕсли;
	
	ИмяВременнойТаблицы = "ТекущиеДанныеДляОтбора" + ВидВедущегоСписка;
	
	ТекстЗапросаПараметров =
	"ВЫБРАТЬ
	|	ТекущиеДанныеДляОтбора.Ссылка
	|ПОМЕСТИТЬ " + ИмяВременнойТаблицы + "
	|ИЗ
	|	&" + ВидВедущегоСписка + " КАК ТекущиеДанныеДляОтбора";
	
	ТекстыЗапросовПоКлючам = Новый Соответствие;
	Для Каждого СоединениеОтбора Из Свойства.СоединенияОтборов Цикл
		ТекстЗапроса = ШаблонЗапроса + ТекстСОтступом(СоединениеОтбора.Значение, "	");
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#ТекущиеДанныеДляОтбора", ИмяВременнойТаблицы);
		ПодставитьОбщиеПараметрыВЗапрос(ТекстЗапроса, Контекст);
		ТекстыЗапросовПоКлючам.Вставить(СоединениеОтбора.Ключ, ТекстЗапроса);
	КонецЦикла;
	
	ОписаниеЗапросов = Новый Структура;
	ОписаниеЗапросов.Вставить("ТипСсылки",              Новый ХранилищеЗначения(Свойства.ТипСсылки));
	ОписаниеЗапросов.Вставить("КлючиЗапросовПоТипам",   Свойства.КлючиЗапросовПоТипам);
	ОписаниеЗапросов.Вставить("ТекстыЗапросовПоКлючам", ТекстыЗапросовПоКлючам);
	ОписаниеЗапросов.Вставить("ТекстЗапросаПараметров", ТекстЗапросаПараметров);
	
	Контекст.ОписаниеЗапросовПроверкиПоВедущимОбъектам.Вставить(ВидВедущегоСписка, ОписаниеЗапросов);
	
КонецПроцедуры

// Для процедуры ДобавитьТекстыЗапросовВПараметрыОграничения.
Процедура СобратьЧастиЗапросаПроверки(Результат, Контекст)
	
	Условие = "";
	Для Каждого ТекстЧастиУсловия Из Контекст.ЧастиУсловияПроверки Цикл
		Если ЗначениеЗаполнено(Условие) Тогда
			Условие = Условие + "
			|		ИЛИ ";
		КонецЕсли;
		Условие = Условие + ТекстСОтступом(ТекстЧастиУсловия, "			");
	КонецЦикла;
	Условие = ТекстСОтступом(Условие, "	");
	
	Контекст.ТекстЗапросаПроверки = СтрЗаменить(Контекст.ТекстЗапросаПроверки,
		"#Условие", ?(Контекст.ЭтоСсылочныйТип, Условие, ТекстСОтступом(Условие, "		")));
	ПодставитьОбщиеПараметрыВЗапрос(Контекст.ТекстЗапросаПроверки, Контекст);
	Результат.ТекстЗапросаЭлементовДанныхСУстаревшимиКлючами = Контекст.ТекстЗапросаПроверки;
	
	ТекстЗапроса = СтрЗаменить(Контекст.ТекстЗапросаТочечнойПроверки, "#Условие", Условие);
	ПодставитьОбщиеПараметрыВЗапрос(ТекстЗапроса, Контекст);
	Контекст.ОписаниеЗапросовПроверкиПоВедущимОбъектам.Вставить("ТекстЗапросаТочечнойПроверки", ТекстЗапроса);
	
	Результат.ОписаниеЗапросовУстаревшихКлючейДоступаПоВедущимОбъектам =
		Контекст.ОписаниеЗапросовПроверкиПоВедущимОбъектам;
	
	Если Не Контекст.ЭтоСсылочныйТип Тогда
		ПодставитьОбщиеПараметрыВЗапрос(Контекст.ТекстЗапросаНовыхКомбинаций, Контекст);
		Результат.ТекстЗапросаЭлементовДанныхБезКлючейДоступа = Контекст.ТекстЗапросаНовыхКомбинаций;
		
		ПодставитьОбщиеПараметрыВЗапрос(Контекст.ТекстЗапросаТекущихКлючейДоступа, Контекст);
		Результат.ТекстЗапросаТекущихКлючейДоступаРегистра = Контекст.ТекстЗапросаТекущихКлючейДоступа;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ДобавитьТекстыЗапросовВПараметрыОграничения.
Процедура СобратьЧастиЗапросовЗаполнения(Результат, Контекст)
	
	ТекстЗапроса = СтрСоединить(Контекст.ЧастиЗапросаЗначенийИзОбъектов,
		ОбщегоНазначения.РазделительПакетаЗапросов());
	ПодставитьОбщиеПараметрыВЗапрос(ТекстЗапроса, Контекст);
	Результат.ТекстЗапросаЗначенийЭлементовДанныхДляКлючейДоступа = ТекстЗапроса;
	
	ТекстЗапроса = СтрСоединить(Контекст.ЧастиЗапросаЗначенийИзКлючейДляСравнения,
		ОбщегоНазначения.РазделительПакетаЗапросов());
	ПодставитьОбщиеПараметрыВЗапрос(ТекстЗапроса, Контекст);
	Результат.ТекстЗапросаЗначенийИзИспользуемыхКлючейДоступаДляСравнения = ТекстЗапроса;
	Результат.ТекстЗапросаЗначенийИзВсехКлючейДоступаДляСравнения = СтрЗаменить(ТекстЗапроса,
		".НеИспользуетсяС = ДАТАВРЕМЯ(1, 1, 1)", ".Список = &Список");
	
	ТекстЗапроса = СтрСоединить(Контекст.ЧастиЗапросаСуществованияКлючейДляСравнения,
		ОбщегоНазначения.РазделительПакетаЗапросов());
	ПодставитьОбщиеПараметрыВЗапрос(ТекстЗапроса, Контекст);
	Результат.ТекстЗапросаСуществованияКлючейДляСравнения = ТекстЗапроса;
	
	ДобавитьЧастьЗапросаВыбораПравВедущихКлючейДоступа(Контекст);
	ДобавитьЧастьЗапросаВыбораПравВедущихСписков(Контекст);
	ДобавитьЧастьЗапросаВыбораПравПоВладельцамНастроекПрав(Контекст);
	ТекстЗапроса = СтрСоединить(Контекст.ЧастиЗапросаЗначенийИзКлючейДляРасчетаПрав,
		ОбщегоНазначения.РазделительПакетаЗапросов());
	ПодставитьОбщиеПараметрыВЗапрос(ТекстЗапроса, Контекст);
	Результат.ТекстЗапросаЗначенийИзКлючейДоступаДляРасчетаПрав = ТекстЗапроса;
	
	Результат.ТекстЗапросаКлючейДоступаДляОбновленияПрав =
		ТекстЗапросаКлючейДоступаДляОбновленияПрав(Контекст);
	
	Результат.ТекстЗапросаКлючейПоВедущимКлючамДляОбновленияПрав =
		ТекстЗапросаКлючейПоВедущимКлючамДляОбновленияПрав(Контекст);
	
	Результат.ТекстЗапросаУстаревшихКлючейДоступа =
		ТекстЗапросаУстаревшихКлючейДоступа(Контекст);
	
КонецПроцедуры

// Для процедуры СобратьЧастиЗапросовЗаполнения.
Процедура ДобавитьЧастьЗапросаВыбораПравВедущихКлючейДоступа(Контекст)
	
	Если Контекст.ЧастиУсловияВыбораПравВедущихКлючейДоступа.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если Контекст.ЧастиУсловияВыбораПравВедущихКлючейДоступа.Количество() = 1 Тогда
		УсловиеОтбора = Контекст.ЧастиУсловияВыбораПравВедущихКлючейДоступа[0];
	Иначе
		УсловиеОтбора = "(" + СтрСоединить(Контекст.ЧастиУсловияВыбораПравВедущихКлючейДоступа,
			Символы.ПС + "			ИЛИ ") + ")";
	КонецЕсли;
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ПраваНаСпискиВедущихКлючейДоступа.Таблица КАК Список,
	|	ПраваНаСпискиВедущихКлючейДоступа.ГруппаДоступа КАК ГруппаДоступа,
	|	ПраваНаСпискиВедущихКлючейДоступа.Изменение КАК Изменение
	|ИЗ
	|	РегистрСведений.ТаблицыГруппДоступа КАК ПраваНаСпискиВедущихКлючейДоступа
	|ГДЕ
	|	ПраваНаСпискиВедущихКлючейДоступа.Таблица В
	|			(ВЫБРАТЬ РАЗЛИЧНЫЕ
	|				СпискиВедущихКлючейДоступа.Список
	|			ИЗ
	|				Справочник.КлючиДоступа КАК СпискиВедущихКлючейДоступа
	|			ГДЕ
	|				&УсловиеОтбора)
	|	И &УточнениеПланаЗапроса
	|ИТОГИ ПО
	|	Список";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбора",
		СтрЗаменить(УсловиеОтбора, "#ПроверяемоеПоле", "СпискиВедущихКлючейДоступа.Ссылка"));
	
	Контекст.ЧастиЗапросаЗначенийИзКлючейДляРасчетаПрав.Добавить(ТекстЗапроса);
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	СпискиВедущихКлючейДоступа.Ссылка КАК КлючДоступа,
	|	СпискиВедущихКлючейДоступа.Список КАК Список
	|ИЗ
	|	Справочник.КлючиДоступа КАК СпискиВедущихКлючейДоступа
	|ГДЕ
	|	&УсловиеОтбора
	|	И &УточнениеПланаЗапроса";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбора",
		СтрЗаменить(УсловиеОтбора, "#ПроверяемоеПоле", "СпискиВедущихКлючейДоступа.Ссылка"));
	
	Контекст.ЧастиЗапросаЗначенийИзКлючейДляРасчетаПрав.Добавить(ТекстЗапроса);
	
	Если Не Контекст.РассчитыватьПраваПользователей Тогда
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	ПраваНаКлючиДоступа.КлючДоступа КАК КлючДоступа,
		|	ПраваНаКлючиДоступа.ГруппаДоступа КАК ВладелецПрав,
		|	ПраваНаКлючиДоступа.Изменение КАК Изменение
		|ИЗ
		|	РегистрСведений.КлючиДоступаГруппДоступа КАК ПраваНаКлючиДоступа
		|ГДЕ
		|	ТИПЗНАЧЕНИЯ(ПраваНаКлючиДоступа.ГруппаДоступа) = ТИП(Справочник.ГруппыДоступа)
		|	И &УсловиеОтбора
		|	И &УточнениеПланаЗапроса
		|ИТОГИ ПО
		|	КлючДоступа";
	ИначеЕсли Не Контекст.ДляВнешнихПользователей Тогда
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	ПраваНаКлючиДоступа.КлючДоступа КАК КлючДоступа,
		|	ПраваНаКлючиДоступа.ГруппаДоступа КАК ВладелецПрав,
		|	ПраваНаКлючиДоступа.Изменение КАК Изменение
		|ИЗ
		|	РегистрСведений.КлючиДоступаГруппДоступа КАК ПраваНаКлючиДоступа
		|ГДЕ
		|	&УсловиеОтбора
		|	И &УточнениеПланаЗапроса
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	ПраваНаКлючиДоступа.КлючДоступа,
		|	ПраваНаКлючиДоступа.Пользователь.Пользователь,
		|	ПраваНаКлючиДоступа.Изменение
		|ИЗ
		|	РегистрСведений.КлючиДоступаПользователей КАК ПраваНаКлючиДоступа
		|ГДЕ
		|	ПраваНаКлючиДоступа.ЭтоПраваНабораГрупп = ЛОЖЬ
		|	И ЕСТЬNULL(ПраваНаКлючиДоступа.Пользователь.Пользователь, ЗНАЧЕНИЕ(Справочник.Пользователи.ПустаяСсылка)) <> ЗНАЧЕНИЕ(Справочник.Пользователи.ПустаяСсылка)
		|	И &УсловиеОтбора
		|ИТОГИ ПО
		|	КлючДоступа";
	Иначе
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	ПраваНаКлючиДоступа.КлючДоступа КАК КлючДоступа,
		|	ПраваНаКлючиДоступа.ГруппаДоступа КАК ВладелецПрав,
		|	ПраваНаКлючиДоступа.Изменение КАК Изменение
		|ИЗ
		|	РегистрСведений.КлючиДоступаГруппДоступа КАК ПраваНаКлючиДоступа
		|ГДЕ
		|	&УсловиеОтбора
		|	И &УточнениеПланаЗапроса
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	ПраваНаКлючиДоступа.КлючДоступа,
		|	ПраваНаКлючиДоступа.ВнешнийПользователь.Пользователь,
		|	ПраваНаКлючиДоступа.Изменение
		|ИЗ
		|	РегистрСведений.КлючиДоступаВнешнихПользователей КАК ПраваНаКлючиДоступа
		|ГДЕ
		|	ПраваНаКлючиДоступа.ЭтоПраваНабораГрупп = ЛОЖЬ
		|	И ЕСТЬNULL(ПраваНаКлючиДоступа.ВнешнийПользователь.Пользователь, ЗНАЧЕНИЕ(Справочник.Пользователи.ПустаяСсылка)) <> ЗНАЧЕНИЕ(Справочник.Пользователи.ПустаяСсылка)
		|	И &УсловиеОтбора
		|ИТОГИ ПО
		|	КлючДоступа";
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбора",
		СтрЗаменить(УсловиеОтбора, "#ПроверяемоеПоле", "ПраваНаКлючиДоступа.КлючДоступа"));
	
	Контекст.ЧастиЗапросаЗначенийИзКлючейДляРасчетаПрав.Добавить(ТекстЗапроса);
	
КонецПроцедуры

// Для процедуры СобратьЧастиЗапросовЗаполнения.
Процедура ДобавитьЧастьЗапросаВыбораПравВедущихСписков(Контекст)
	
	Если Контекст.ЧастиУсловияВыбораПравВедущихСписков.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если Контекст.Свойство("ЧастиУсловияВыбораПравВедущихСписковСТипами") Тогда
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	ПраваНаСписки.Таблица КАК Список,
		|	ТИПЗНАЧЕНИЯ(ПраваНаСписки.Таблица.ЗначениеПустойСсылки) КАК ТипЗначения,
		|	ПраваНаСписки.ГруппаДоступа КАК ВладелецПрав,
		|	ПраваНаСписки.Изменение КАК Изменение
		|ИЗ
		|	РегистрСведений.ТаблицыГруппДоступа КАК ПраваНаСписки
		|ГДЕ
		|	&УсловиеОтбора
		|	И &УточнениеПланаЗапроса
		|ИТОГИ ПО
		|	Список";
	Иначе
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	ПраваНаСписки.Таблица КАК Список,
		|	ПраваНаСписки.ГруппаДоступа КАК ВладелецПрав,
		|	ПраваНаСписки.Изменение КАК Изменение
		|ИЗ
		|	РегистрСведений.ТаблицыГруппДоступа КАК ПраваНаСписки
		|ГДЕ
		|	&УсловиеОтбора
		|	И &УточнениеПланаЗапроса
		|ИТОГИ ПО
		|	Список";
	КонецЕсли;
	
	Если Контекст.ЧастиУсловияВыбораПравВедущихСписков.Количество() = 1 Тогда
		УсловиеОтбора = Контекст.ЧастиУсловияВыбораПравВедущихСписков[0];
	Иначе
		УсловиеОтбора = "(" + СтрСоединить(Контекст.ЧастиУсловияВыбораПравВедущихСписков,
			Символы.ПС + "			ИЛИ ") + ")";
	КонецЕсли;
	УсловиеОтбора = СтрЗаменить(УсловиеОтбора, "#ПроверяемоеПоле", "ПраваНаСписки.Таблица");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбора", УсловиеОтбора);
	
	Контекст.ЧастиЗапросаЗначенийИзКлючейДляРасчетаПрав.Добавить(ТекстЗапроса);
	
КонецПроцедуры

// Для процедуры СобратьЧастиЗапросовЗаполнения.
Процедура ДобавитьЧастьЗапросаВыбораПравПоВладельцамНастроекПрав(Контекст)
	
	Если Контекст.ЧастиУсловияВыбораПравПоВладельцамНастроекПрав.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ТекстЗапроса =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	НаследованиеНастроек.Объект КАК Объект
	|ПОМЕСТИТЬ ОбъектыСЗапрещениемЧтения
	|ИЗ
	|	РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
	|		ПО НастройкиПрав.Объект = НаследованиеНастроек.Родитель
	|			И (НаследованиеНастроек.УровеньИспользования < НастройкиПрав.УровеньЗапрещенияЧтения)
	|			И (&УсловиеОтбора)
	|			И (&УточнениеПланаЗапроса)
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	Объект
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	НаследованиеНастроек.Объект КАК Объект
	|ПОМЕСТИТЬ ОбъектыСЗапрещениемИзменения
	|ИЗ
	|	РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
	|		ПО НастройкиПрав.Объект = НаследованиеНастроек.Родитель
	|			И (НастройкиПрав.Таблица = &ИдентификаторТаблицыНастроекПрав)
	|			И (НаследованиеНастроек.УровеньИспользования < НастройкиПрав.УровеньЗапрещенияИзменения)
	|			И (&УсловиеОтбора)
	|			И (&УточнениеПланаЗапроса)
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	Объект
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	НастройкиПравЧтения.Объект КАК Объект,
	|	НастройкиПравЧтения.Пользователь КАК Пользователь
	|ПОМЕСТИТЬ НастройкиПравЧтения
	|ИЗ
	|	(ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		НаследованиеНастроек.Объект КАК Объект,
	|		ВЫБОР
	|			КОГДА НаследованиеНастроек.Объект В
	|					(ВЫБРАТЬ
	|						ОбъектыСЗапрещениемЧтения.Объект
	|					ИЗ
	|						ОбъектыСЗапрещениемЧтения)
	|				ТОГДА СоставыГруппПользователей.Пользователь
	|			ИНАЧЕ СоставыГруппПользователей.ГруппаПользователей
	|		КОНЕЦ КАК Пользователь,
	|		ИСТИНА КАК ЧтениеРазрешено,
	|		ЛОЖЬ КАК ЧтениеЗапрещено
	|	ИЗ
	|		РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
	|			ПО НастройкиПрав.Объект = НаследованиеНастроек.Родитель
	|				И (НаследованиеНастроек.УровеньИспользования < НастройкиПрав.УровеньРазрешенияЧтения)
	|				И (&УсловиеОтбора)
	|				И (&УточнениеПланаЗапроса)
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|			ПО (СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь)
	|				И (ТИПЗНАЧЕНИЯ(СоставыГруппПользователей.Пользователь) = ТИП(Справочник.Пользователи))
	|				И (СоставыГруппПользователей.Используется)
	|				И (СоставыГруппПользователей.Пользователь.ИдентификаторПользователяИБ <> &ПустойУникальныйИдентификатор)
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		НаследованиеНастроек.Объект,
	|		СоставыГруппПользователей.Пользователь,
	|		ЛОЖЬ,
	|		ИСТИНА
	|	ИЗ
	|		РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
	|			ПО (НаследованиеНастроек.Объект В
	|					(ВЫБРАТЬ
	|						ОбъектыСЗапрещениемЧтения.Объект
	|					ИЗ
	|						ОбъектыСЗапрещениемЧтения))
	|				И НастройкиПрав.Объект = НаследованиеНастроек.Родитель
	|				И (НаследованиеНастроек.УровеньИспользования < НастройкиПрав.УровеньЗапрещенияЧтения)
	|				И (&УсловиеОтбора)
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|			ПО (СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь)
	|				И (ТИПЗНАЧЕНИЯ(СоставыГруппПользователей.Пользователь) = ТИП(Справочник.Пользователи))
	|				И (СоставыГруппПользователей.Используется)
	|				И (СоставыГруппПользователей.Пользователь.ИдентификаторПользователяИБ <> &ПустойУникальныйИдентификатор)) КАК НастройкиПравЧтения
	|
	|СГРУППИРОВАТЬ ПО
	|	НастройкиПравЧтения.Объект,
	|	НастройкиПравЧтения.Пользователь
	|
	|ИМЕЮЩИЕ
	|	МАКСИМУМ(НастройкиПравЧтения.ЧтениеРазрешено) = ИСТИНА И
	|	МАКСИМУМ(НастройкиПравЧтения.ЧтениеЗапрещено) = ЛОЖЬ
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	НастройкиПравИзменения.Объект КАК Объект,
	|	НастройкиПравИзменения.Пользователь КАК Пользователь
	|ПОМЕСТИТЬ НастройкиПравИзменения
	|ИЗ
	|	(ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		НаследованиеНастроек.Объект КАК Объект,
	|		ВЫБОР
	|			КОГДА НаследованиеНастроек.Объект В
	|					(ВЫБРАТЬ
	|						ОбъектыСЗапрещениемИзменения.Объект
	|					ИЗ
	|						ОбъектыСЗапрещениемИзменения)
	|				ТОГДА СоставыГруппПользователей.Пользователь
	|			ИНАЧЕ СоставыГруппПользователей.ГруппаПользователей
	|		КОНЕЦ КАК Пользователь,
	|		ИСТИНА КАК ИзменениеРазрешено,
	|		ЛОЖЬ КАК ИзменениеЗапрещено
	|	ИЗ
	|		РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
	|			ПО НастройкиПрав.Объект = НаследованиеНастроек.Родитель
	|				И (НастройкиПрав.Таблица = &ИдентификаторТаблицыНастроекПрав)
	|				И (НаследованиеНастроек.УровеньИспользования < НастройкиПрав.УровеньРазрешенияИзменения)
	|				И (&УсловиеОтбора)
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|			ПО (СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь)
	|				И (ТИПЗНАЧЕНИЯ(СоставыГруппПользователей.Пользователь) = ТИП(Справочник.Пользователи))
	|				И (СоставыГруппПользователей.Используется)
	|				И (СоставыГруппПользователей.Пользователь.ИдентификаторПользователяИБ <> &ПустойУникальныйИдентификатор)
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ НастройкиПравЧтения КАК НастройкиПравЧтения
	|			ПО (НастройкиПравЧтения.Объект = НаследованиеНастроек.Объект)
	|				И (НастройкиПравЧтения.Пользователь = СоставыГруппПользователей.ГруппаПользователей
	|					ИЛИ НастройкиПравЧтения.Пользователь = СоставыГруппПользователей.Пользователь)
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		НаследованиеНастроек.Объект,
	|		СоставыГруппПользователей.Пользователь,
	|		ЛОЖЬ,
	|		ИСТИНА
	|	ИЗ
	|		РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
	|			ПО (НаследованиеНастроек.Объект В
	|					(ВЫБРАТЬ
	|						ОбъектыСЗапрещениемИзменения.Объект
	|					ИЗ
	|						ОбъектыСЗапрещениемИзменения))
	|				И НастройкиПрав.Объект = НаследованиеНастроек.Родитель
	|				И (НастройкиПрав.Таблица = &ИдентификаторТаблицыНастроекПрав)
	|				И (НаследованиеНастроек.УровеньИспользования < НастройкиПрав.УровеньЗапрещенияИзменения)
	|				И (&УсловиеОтбора)
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|			ПО (СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь)
	|				И (ТИПЗНАЧЕНИЯ(СоставыГруппПользователей.Пользователь) = ТИП(Справочник.Пользователи))
	|				И (СоставыГруппПользователей.Используется)
	|				И (СоставыГруппПользователей.Пользователь.ИдентификаторПользователяИБ <> &ПустойУникальныйИдентификатор)
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ НастройкиПравЧтения КАК НастройкиПравЧтения
	|			ПО (НастройкиПравЧтения.Объект = НаследованиеНастроек.Объект)
	|				И (НастройкиПравЧтения.Пользователь = СоставыГруппПользователей.ГруппаПользователей
	|					ИЛИ НастройкиПравЧтения.Пользователь = СоставыГруппПользователей.Пользователь)) КАК НастройкиПравИзменения
	|
	|СГРУППИРОВАТЬ ПО
	|	НастройкиПравИзменения.Объект,
	|	НастройкиПравИзменения.Пользователь
	|
	|ИМЕЮЩИЕ
	|	МАКСИМУМ(НастройкиПравИзменения.ИзменениеРазрешено) = ИСТИНА И
	|	МАКСИМУМ(НастройкиПравИзменения.ИзменениеЗапрещено) = ЛОЖЬ
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	НастройкиПрав.Объект КАК ВладелецНастроекПрав,
	|	НастройкиПрав.Пользователь КАК ВладелецПрав,
	|	МАКСИМУМ(НастройкиПрав.Изменение) КАК Изменение
	|ИЗ
	|	(ВЫБРАТЬ
	|		НастройкиПравЧтения.Объект КАК Объект,
	|		НастройкиПравЧтения.Пользователь КАК Пользователь,
	|		ЛОЖЬ КАК Изменение
	|	ИЗ
	|		НастройкиПравЧтения КАК НастройкиПравЧтения
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ВЫБРАТЬ
	|		НастройкиПравИзменения.Объект,
	|		НастройкиПравИзменения.Пользователь,
	|		ИСТИНА
	|	ИЗ
	|		НастройкиПравИзменения КАК НастройкиПравИзменения) КАК НастройкиПрав
	|
	|СГРУППИРОВАТЬ ПО
	|	НастройкиПрав.Объект,
	|	НастройкиПрав.Пользователь
	|ИТОГИ ПО
	|	ВладелецНастроекПрав";
	
	Если Контекст.ДляВнешнихПользователей Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "Справочник.Пользователи", "Справочник.ВнешниеПользователи");
	КонецЕсли;
	
	Если Контекст.ЧастиУсловияВыбораПравПоВладельцамНастроекПрав.Количество() = 1 Тогда
		УсловиеОтбора = Контекст.ЧастиУсловияВыбораПравПоВладельцамНастроекПрав[0];
	Иначе
		УсловиеОтбора =  СтрСоединить(Контекст.ЧастиУсловияВыбораПравПоВладельцамНастроекПрав,
			Символы.ПС + "			ИЛИ ");
	КонецЕсли;
	УсловиеОтбора = СтрЗаменить(УсловиеОтбора, "#ПроверяемоеПоле", "НаследованиеНастроек.Объект");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбора", ТекстСОтступом(УсловиеОтбора, "	"));
	
	Контекст.ЧастиЗапросаЗначенийИзКлючейДляРасчетаПрав.Добавить(ТекстЗапроса);
	
КонецПроцедуры

// Для процедуры СобратьЧастиЗапросовЗаполнения.
Функция ТекстЗапросаКлючейДоступаДляОбновленияПрав(Контекст)
	
	ТекстЗапроса =
	"ВЫБРАТЬ ПЕРВЫЕ " + МаркерРазмераПорции() + "
	|	КлючиДоступа.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.КлючиДоступа КАК КлючиДоступа
	|ГДЕ
	|	КлючиДоступа.Список = &Список
	|	И КлючиДоступа.СоставПолей = &СоставПолей
	|	И КлючиДоступа.ДляВнешнихПользователей = &ДляВнешнихПользователей
	|	И КлючиДоступа.Ссылка > &ПоследнийКлючДоступа
	|	И &УточнениеПланаЗапроса
	|
	|УПОРЯДОЧИТЬ ПО
	|	КлючиДоступа.Ссылка";
	
	ПодставитьОбщиеПараметрыВЗапрос(ТекстЗапроса, Контекст);
	Возврат ТекстЗапроса;
	
КонецФункции

// Для процедуры СобратьЧастиЗапросовЗаполнения.
Функция ТекстЗапросаКлючейПоВедущимКлючамДляОбновленияПрав(Контекст)
	
	Если Контекст.ЧастиУсловияОтбораПоВедущимКлючамДоступа.Количество() = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	ТекстЗапроса =
	"ВЫБРАТЬ ПЕРВЫЕ " + МаркерРазмераПорции() + "
	|	КлючиДоступа.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.КлючиДоступа КАК КлючиДоступа
	|ГДЕ
	|	КлючиДоступа.Список = &Список
	|	И КлючиДоступа.СоставПолей = &СоставПолей
	|	И КлючиДоступа.ДляВнешнихПользователей = &ДляВнешнихПользователей
	|	И &УсловиеОтбора
	|	И &УточнениеПланаЗапроса
	|
	|УПОРЯДОЧИТЬ ПО
	|	КлючиДоступа.Ссылка";
	
	ПодставитьОбщиеПараметрыВЗапрос(ТекстЗапроса, Контекст);
	Если Контекст.ЧастиУсловияОтбораПоВедущимКлючамДоступа.Количество() = 1 Тогда
		УсловиеОтбора = Контекст.ЧастиУсловияОтбораПоВедущимКлючамДоступа[0];
	Иначе
		УсловиеОтбора = "(" + СтрСоединить(Контекст.ЧастиУсловияОтбораПоВедущимКлючамДоступа,
			Символы.ПС + "			ИЛИ ") + ")";
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбора", УсловиеОтбора);
	
	Возврат ТекстЗапроса;
	
КонецФункции

// Для процедуры СобратьЧастиЗапросовЗаполнения.
Функция ТекстЗапросаУстаревшихКлючейДоступа(Контекст)
	
	Если Контекст.ЭтоСсылочныйТип Тогда
		ТекстЗапросаИспользуемых =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	КлючиДоступаКОбъектам.#КлючДоступаПользователей КАК КлючДоступа
		|ПОМЕСТИТЬ ИспользуемыеКлючиДоступа
		|ИЗ
		|	РегистрСведений.КлючиДоступаКОбъектам КАК КлючиДоступаКОбъектам
		|ГДЕ
		|	ТИПЗНАЧЕНИЯ(КлючиДоступаКОбъектам.Объект) = ТИП(&ТекущийСписок)
		|	И КлючиДоступаКОбъектам.#КлючДоступаПользователей > &ПоследнийКлючДоступа
		|	И &УточнениеПланаЗапроса
		|
		|ИНДЕКСИРОВАТЬ ПО
		|	КлючДоступа"
	Иначе
		ТекстЗапросаИспользуемых =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	КлючиДоступаКРегистрам.КлючДоступа КАК КлючДоступа
		|ПОМЕСТИТЬ ИспользуемыеКлючиДоступа
		|ИЗ
		|	&ТекущийСписок КАК КлючиДоступаКРегистрам
		|ГДЕ
		|	КлючиДоступаКРегистрам.Регистр = &Список
		|	И КлючиДоступаКРегистрам.ДляВнешнихПользователей = &ДляВнешнихПользователей
		|	И КлючиДоступаКРегистрам.КлючДоступа > &ПоследнийКлючДоступа
		|	И &УточнениеПланаЗапроса
		|
		|ИНДЕКСИРОВАТЬ ПО
		|	КлючДоступа";
		Если ЗначениеЗаполнено(Контекст.ИмяОтдельногоРегистраКлючей) Тогда
			ТекстЗапросаИспользуемых = СтрЗаменить(ТекстЗапросаИспользуемых,
				"КлючиДоступаКРегистрам.Регистр = &Список
				|	И ", "");
		КонецЕсли;
	КонецЕсли;
	
	ТекстЗапроса =
	"ВЫБРАТЬ ПЕРВЫЕ " + МаркерРазмераПорции() + "
	|	КлючиДоступа.Ссылка КАК Ссылка,
	|	КлючиДоступа.Список КАК Список,
	|	КлючиДоступа.СоставПолей КАК СоставПолей,
	|	КлючиДоступа.Хеш КАК Хеш,
	|	НЕ ИспользуемыеКлючиДоступа.КлючДоступа ЕСТЬ NULL КАК Используется,
	|	КлючиДоступа.НеИспользуетсяС <> ДАТАВРЕМЯ(1, 1, 1)
	|		И КлючиДоступа.НеИспользуетсяС < &ДатаУстаревания КАК Удалить
	|ИЗ
	|	Справочник.КлючиДоступа КАК КлючиДоступа
	|		ЛЕВОЕ СОЕДИНЕНИЕ ИспользуемыеКлючиДоступа КАК ИспользуемыеКлючиДоступа
	|		ПО (ИспользуемыеКлючиДоступа.КлючДоступа = КлючиДоступа.Ссылка)
	|ГДЕ
	|	КлючиДоступа.Список = &Список
	|	И КлючиДоступа.ДляВнешнихПользователей = &ДляВнешнихПользователей
	|	И КлючиДоступа.Ссылка > &ПоследнийКлючДоступа
	|	И ВЫБОР
	|			КОГДА КлючиДоступа.НеИспользуетсяС = ДАТАВРЕМЯ(1, 1, 1)
	|				ТОГДА ИспользуемыеКлючиДоступа.КлючДоступа ЕСТЬ NULL
	|			ИНАЧЕ НЕ ИспользуемыеКлючиДоступа.КлючДоступа ЕСТЬ NULL
	|					ИЛИ КлючиДоступа.НеИспользуетсяС < &ДатаУстаревания
	|		КОНЕЦ
	|	И &УточнениеПланаЗапроса
	|
	|УПОРЯДОЧИТЬ ПО
	|	КлючиДоступа.Ссылка";
	
	ТекстЗапроса = ТекстЗапросаИспользуемых
		+ ОбщегоНазначения.РазделительПакетаЗапросов() + ТекстЗапроса;
	
	ПодставитьОбщиеПараметрыВЗапрос(ТекстЗапроса, Контекст);
	Возврат ТекстЗапроса;
	
КонецФункции

// Для процедуры ДобавитьТекстыЗапросовВПараметрыОграничения.
Процедура ЗаполнитьЗапросыПроверкиПравЧтениеИзменение(Результат, Контекст)
	
	Если Контекст.ИмяКоллекцииТипа = "ЖурналыДокументов" Тогда
		Возврат;
	КонецЕсли;
	
	Свойства = СвойстваОграниченияСписка(Контекст.Список, Контекст);
	
	Если Контекст.ЭтоСсылочныйТип
	 Или Результат.ИспользуетсяОграничениеПоВладельцу Тогда
		
		Если Свойства.ОграничениеВШаблонахЧерезКлючиДоступаПользователейИГруппДоступа
		 Или Свойства.ОграничениеВШаблонахЧерезКлючиДоступаПользователей Тогда
			Если Контекст.ДляВнешнихПользователей Тогда
				ТекстЗапроса =
				"ВЫБРАТЬ ПЕРВЫЕ 1
				|	ИСТИНА КАК ЗначениеИстина
				|ИЗ
				|	РегистрСведений.КлючиДоступаКОбъектам КАК КлючиДоступаКОбъектам
				|ГДЕ
				|	КлючиДоступаКОбъектам.Объект = &Объект
				|	И (ИСТИНА В
				|				(ВЫБРАТЬ ПЕРВЫЕ 1
				|					ИСТИНА
				|				ИЗ
				|					РегистрСведений.КлючиДоступаВнешнихПользователей КАК РазрешенныеКлючиДоступа
				|				ГДЕ
				|					РазрешенныеКлючиДоступа.КлючДоступа = КлючиДоступаКОбъектам.КлючДоступаВнешнихПользователей
				|					И РазрешенныеКлючиДоступа.ВнешнийПользователь В (&РазрешенныйПользователь, &РазрешенныйНаборГруппПользователей)
				|					И РазрешенныеКлючиДоступа.Изменение)
				|			ИЛИ ИСТИНА В
				|				(ВЫБРАТЬ ПЕРВЫЕ 1
				|					ИСТИНА
				|				ИЗ
				|					РегистрСведений.КлючиДоступаНаборовГруппДоступа КАК РазрешенныеКлючиДоступа
				|				ГДЕ
				|					РазрешенныеКлючиДоступа.КлючДоступа = КлючиДоступаКОбъектам.КлючДоступаВнешнихПользователей
				|					И РазрешенныеКлючиДоступа.НаборГруппДоступа В (&РазрешенныйНаборГруппДоступа, &РазрешенныйПустойНаборГруппДоступа)
				|					И РазрешенныеКлючиДоступа.Изменение))";
			Иначе
				ТекстЗапроса =
				"ВЫБРАТЬ ПЕРВЫЕ 1
				|	ИСТИНА КАК ЗначениеИстина
				|ИЗ
				|	РегистрСведений.КлючиДоступаКОбъектам КАК КлючиДоступаКОбъектам
				|ГДЕ
				|	КлючиДоступаКОбъектам.Объект = &Объект
				|	И (ИСТИНА В
				|				(ВЫБРАТЬ ПЕРВЫЕ 1
				|					ИСТИНА
				|				ИЗ
				|					РегистрСведений.КлючиДоступаПользователей КАК РазрешенныеКлючиДоступа
				|				ГДЕ
				|					РазрешенныеКлючиДоступа.КлючДоступа = КлючиДоступаКОбъектам.КлючДоступаПользователей
				|					И РазрешенныеКлючиДоступа.Пользователь В (&РазрешенныйПользователь, &РазрешенныйНаборГруппПользователей)
				|					И РазрешенныеКлючиДоступа.Изменение)
				|			ИЛИ ИСТИНА В
				|				(ВЫБРАТЬ ПЕРВЫЕ 1
				|					ИСТИНА
				|				ИЗ
				|					РегистрСведений.КлючиДоступаНаборовГруппДоступа КАК РазрешенныеКлючиДоступа
				|				ГДЕ
				|					РазрешенныеКлючиДоступа.КлючДоступа = КлючиДоступаКОбъектам.КлючДоступаПользователей
				|					И РазрешенныеКлючиДоступа.НаборГруппДоступа В (&РазрешенныйНаборГруппДоступа, &РазрешенныйПустойНаборГруппДоступа)
				|					И РазрешенныеКлючиДоступа.Изменение))";
			КонецЕсли;
		Иначе
			Если Контекст.ДляВнешнихПользователей Тогда
				ТекстЗапроса =
				"ВЫБРАТЬ ПЕРВЫЕ 1
				|	ИСТИНА КАК ЗначениеИстина
				|ИЗ
				|	РегистрСведений.КлючиДоступаКОбъектам КАК КлючиДоступаКОбъектам
				|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.КлючиДоступаНаборовГруппДоступа КАК РазрешенныеКлючиДоступа
				|		ПО (КлючиДоступаКОбъектам.Объект = &Объект)
				|			И (РазрешенныеКлючиДоступа.КлючДоступа = КлючиДоступаКОбъектам.КлючДоступаВнешнихПользователей)
				|			И (РазрешенныеКлючиДоступа.НаборГруппДоступа В (&РазрешенныйНаборГруппДоступа, &РазрешенныйПустойНаборГруппДоступа))
				|			И (РазрешенныеКлючиДоступа.Изменение)";
			Иначе
				ТекстЗапроса =
				"ВЫБРАТЬ ПЕРВЫЕ 1
				|	ИСТИНА КАК ЗначениеИстина
				|ИЗ
				|	РегистрСведений.КлючиДоступаКОбъектам КАК КлючиДоступаКОбъектам
				|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.КлючиДоступаНаборовГруппДоступа КАК РазрешенныеКлючиДоступа
				|		ПО (КлючиДоступаКОбъектам.Объект = &Объект)
				|			И (РазрешенныеКлючиДоступа.КлючДоступа = КлючиДоступаКОбъектам.КлючДоступаПользователей)
				|			И (РазрешенныеКлючиДоступа.НаборГруппДоступа В (&РазрешенныйНаборГруппДоступа, &РазрешенныйПустойНаборГруппДоступа))
				|			И (РазрешенныеКлючиДоступа.Изменение)";
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если Не Результат.ИспользуетсяОграничениеПоВладельцу Тогда
		ТекстЗапросаСПроверкойПоВладельцамНастроекПрав = "";
	Иначе
		ТипКонечногоПоля = Контекст.СвойстваПолей[0].ТипКонечногоПоля;
		ТипыВладельцевНастроекПравПоля = Новый Соответствие;
		Если Контекст.ОграничениеДоступаВключено Тогда
			Для Каждого КлючИЗначение Из Контекст.ТипыВладельцевНастроекПрав Цикл
				Если ТипКонечногоПоля.СодержитТип(КлючИЗначение.Ключ) Тогда
					ТипыВладельцевНастроекПравПоля.Вставить(КлючИЗначение.Ключ,
						ИмяТипаНаЯзыкеЗапросов(КлючИЗначение.Ключ));
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Если ТипыВладельцевНастроекПравПоля.Количество() = 0 Тогда
			ТекстЗапросаСПроверкойПоВладельцамНастроекПрав = "";
			
		ИначеЕсли ТипКонечногоПоля.Типы().Количество() = ТипыВладельцевНастроекПравПоля.Количество() Тогда
			ТекстЗапросаСПроверкойПоВладельцамНастроекПрав =
				ТекстЗапросаСПроверкойПоВладельцамНастроекПрав();
		Иначе
			Если Контекст.ЭтоСсылочныйТип Тогда
				ТекстЗапросаСПроверкойПоВладельцамНастроекПрав =
				"ВЫБРАТЬ ПЕРВЫЕ 1
				|	ИСТИНА КАК ЗначениеИстина
				|ГДЕ
				|	ВЫБОР
				|			КОГДА &УсловиеПроверкиТипаВладельцаНастроекПрав
				|				ТОГДА &УсловиеСПроверкойПоВладельцамНастроекПрав
				|			ИНАЧЕ ИСТИНА В
				|				(&ТекстЗапросаСтандартнойПроверки)
				|		КОНЕЦ";
			Иначе
				ТекстЗапросаСПроверкойПоВладельцамНастроекПрав =
				"ВЫБРАТЬ ПЕРВЫЕ 1
				|	ЛОЖЬ КАК ЗначениеЛожь
				|ИЗ
				|	" + Контекст.Список + " КАК ТекущаяТаблица
				|ГДЕ
				|	&ОтборПоИзмерениям
				|	И ВЫБОР
				|			КОГДА &УсловиеПроверкиТипаВладельцаНастроекПрав
				|				ТОГДА &УсловиеСПроверкойПоВладельцамНастроекПрав
				|			ИНАЧЕ ИСТИНА В
				|				(&ТекстЗапросаСтандартнойПроверки)
				|		КОНЕЦ";
			КонецЕсли;
			УсловиеПроверкиТипа = "";
			Для Каждого СвойстваТипа Из ТипыВладельцевНастроекПравПоля Цикл
				УсловиеПроверкиТипа = УсловиеПроверкиТипа + ?(УсловиеПроверкиТипа = "", "", "
				|					") + "ТИПЗНАЧЕНИЯ(&Объект) = ТИП(" + СвойстваТипа.Значение + ")";
			КонецЦикла;
			ТекстЗапросаСПроверкойПоВладельцамНастроекПрав = СтрЗаменить(
				ТекстЗапросаСПроверкойПоВладельцамНастроекПрав,
				"&УсловиеПроверкиТипаВладельцаНастроекПрав",
				УсловиеПроверкиТипа);
			
			ТекстЗапросаСПроверкойПоВладельцамНастроекПрав = СтрЗаменить(
				ТекстЗапросаСПроверкойПоВладельцамНастроекПрав,
				"&УсловиеСПроверкойПоВладельцамНастроекПрав",
				ТекстСОтступом(УсловиеИзЗапросаСПроверкойПоВладельцамНастроекПрав(),
					"				"));
			
			ТекстЗапросаСПроверкойПоВладельцамНастроекПрав = СтрЗаменить(
				ТекстЗапросаСПроверкойПоВладельцамНастроекПрав,
				"&ТекстЗапросаСтандартнойПроверки",
				ТекстСОтступом(ТекстЗапроса, "				"));
		КонецЕсли;
	КонецЕсли;
	
	Если Результат.ИспользуетсяОграничениеПоВладельцу Тогда
		Если Контекст.ЭтоСсылочныйТип Тогда
			ПолеОбъекта = "ВЫРАЗИТЬ(&Объект КАК " + Контекст.Список + ")." + Результат.ПолеВладельца.Имя;
		Иначе
			ПолеОбъекта = "ТекущаяТаблица." + Результат.ПолеВладельца.Имя;
		КонецЕсли;
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Объект", ПолеОбъекта);
		ТекстЗапросаСПроверкойПоВладельцамНастроекПрав =
			СтрЗаменить(ТекстЗапросаСПроверкойПоВладельцамНастроекПрав, "&Объект", ПолеОбъекта);
		
	ИначеЕсли Не Контекст.ЭтоСсылочныйТип Тогда
		
		Если Свойства.ОграничениеВШаблонахЧерезКлючиДоступаПользователей Тогда
			Если Контекст.ДляВнешнихПользователей Тогда
				ТекстЗапроса =
				"ВЫБРАТЬ ПЕРВЫЕ 1
				|	ИСТИНА КАК ЗначениеИстина
				|ИЗ
				|	РегистрСведений.КлючиДоступаКРегистрам КАК КлючиДоступаКРегистрам
				|ГДЕ
				|	КлючиДоступаКРегистрам.Регистр = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				|	И КлючиДоступаКРегистрам.ДляВнешнихПользователей = ИСТИНА
				|	И КлючиДоступаКРегистрам.Поле1 = &ТекущаяТаблицаПоле1
				|	И (ИСТИНА В
				|				(ВЫБРАТЬ ПЕРВЫЕ 1
				|					ИСТИНА
				|				ИЗ
				|					РегистрСведений.КлючиДоступаВнешнихПользователей КАК РазрешенныеКлючиДоступа
				|				ГДЕ
				|					РазрешенныеКлючиДоступа.КлючДоступа = КлючиДоступаКРегистрам.КлючДоступа
				|					И РазрешенныеКлючиДоступа.ВнешнийПользователь В (&РазрешенныйПользователь, &РазрешенныйНаборГруппПользователей)
				|					И РазрешенныеКлючиДоступа.Изменение)
				|			ИЛИ ИСТИНА В
				|				(ВЫБРАТЬ ПЕРВЫЕ 1
				|					ИСТИНА
				|				ИЗ
				|					РегистрСведений.КлючиДоступаНаборовГруппДоступа КАК РазрешенныеКлючиДоступа
				|				ГДЕ
				|					РазрешенныеКлючиДоступа.КлючДоступа = КлючиДоступаКРегистрам.КлючДоступа
				|					И РазрешенныеКлючиДоступа.НаборГруппДоступа В (&РазрешенныйНаборГруппДоступа, &РазрешенныйПустойНаборГруппДоступа)
				|					И РазрешенныеКлючиДоступа.Изменение))";
			Иначе
				ТекстЗапроса =
				"ВЫБРАТЬ ПЕРВЫЕ 1
				|	ИСТИНА КАК ЗначениеИстина
				|ИЗ
				|	РегистрСведений.КлючиДоступаКРегистрам КАК КлючиДоступаКРегистрам
				|ГДЕ
				|	КлючиДоступаКРегистрам.Регистр = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				|	И КлючиДоступаКРегистрам.ДляВнешнихПользователей = ЛОЖЬ
				|	И КлючиДоступаКРегистрам.Поле1 = &ТекущаяТаблицаПоле1
				|	И (ИСТИНА В
				|				(ВЫБРАТЬ ПЕРВЫЕ 1
				|					ИСТИНА
				|				ИЗ
				|					РегистрСведений.КлючиДоступаПользователей КАК РазрешенныеКлючиДоступа
				|				ГДЕ
				|					РазрешенныеКлючиДоступа.КлючДоступа = КлючиДоступаКРегистрам.КлючДоступа
				|					И РазрешенныеКлючиДоступа.Пользователь В (&РазрешенныйПользователь, &РазрешенныйНаборГруппПользователей)
				|					И РазрешенныеКлючиДоступа.Изменение)
				|			ИЛИ ИСТИНА В
				|				(ВЫБРАТЬ ПЕРВЫЕ 1
				|					ИСТИНА
				|				ИЗ
				|					РегистрСведений.КлючиДоступаНаборовГруппДоступа КАК РазрешенныеКлючиДоступа
				|				ГДЕ
				|					РазрешенныеКлючиДоступа.КлючДоступа = КлючиДоступаКРегистрам.КлючДоступа
				|					И РазрешенныеКлючиДоступа.НаборГруппДоступа В (&РазрешенныйНаборГруппДоступа, &РазрешенныйПустойНаборГруппДоступа)
				|					И РазрешенныеКлючиДоступа.Изменение))";
			КонецЕсли;
		Иначе
			Если Контекст.ДляВнешнихПользователей Тогда
				ТекстЗапроса =
				"ВЫБРАТЬ ПЕРВЫЕ 1
				|	ИСТИНА КАК ЗначениеИстина
				|ИЗ
				|	РегистрСведений.КлючиДоступаКРегистрам КАК КлючиДоступаКРегистрам
				|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.КлючиДоступаНаборовГруппДоступа КАК РазрешенныеКлючиДоступа
				|		ПО (КлючиДоступаКРегистрам.Регистр = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка))
				|			И (КлючиДоступаКРегистрам.ДляВнешнихПользователей = ИСТИНА)
				|			И (КлючиДоступаКРегистрам.Поле1 = &ТекущаяТаблицаПоле1)
				|			И (РазрешенныеКлючиДоступа.КлючДоступа = КлючиДоступаКРегистрам.КлючДоступа)
				|			И (РазрешенныеКлючиДоступа.НаборГруппДоступа В (&РазрешенныйНаборГруппДоступа, &РазрешенныйПустойНаборГруппДоступа))
				|			И (РазрешенныеКлючиДоступа.Изменение)";
			Иначе
				ТекстЗапроса =
				"ВЫБРАТЬ ПЕРВЫЕ 1
				|	ИСТИНА КАК ЗначениеИстина
				|ИЗ
				|	РегистрСведений.КлючиДоступаКРегистрам КАК КлючиДоступаКРегистрам
				|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.КлючиДоступаНаборовГруппДоступа КАК РазрешенныеКлючиДоступа
				|		ПО (КлючиДоступаКРегистрам.Регистр = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка))
				|			И (КлючиДоступаКРегистрам.ДляВнешнихПользователей = ЛОЖЬ)
				|			И (КлючиДоступаКРегистрам.Поле1 = &ТекущаяТаблицаПоле1)
				|			И (РазрешенныеКлючиДоступа.КлючДоступа = КлючиДоступаКРегистрам.КлючДоступа)
				|			И (РазрешенныеКлючиДоступа.НаборГруппДоступа В (&РазрешенныйНаборГруппДоступа, &РазрешенныйПустойНаборГруппДоступа))
				|			И (РазрешенныеКлючиДоступа.Изменение)";
			КонецЕсли;
		КонецЕсли;
		
		УточнитьРегистрКлючейИУсловиеСоединения(ТекстЗапроса, Результат, Контекст);
		
		Если Контекст.ДляВнешнихПользователей Тогда
			ТекстЗапросаНовыхКомбинацийЗначенийОпорныхПолейСуществующихЗаписей =
			"ВЫБРАТЬ РАЗЛИЧНЫЕ
			|	&ТекущаяТаблицаПоле1 КАК Поле1
			|ИЗ
			|	&Список КАК ТекущаяТаблица
			|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.КлючиДоступаКРегистрам КАК КлючиДоступаКРегистрам
			|		ПО (КлючиДоступаКРегистрам.Регистр = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка))
			|			И (КлючиДоступаКРегистрам.ДляВнешнихПользователей = ИСТИНА)
			|			И (КлючиДоступаКРегистрам.Поле1 = &ТекущаяТаблицаПоле1)
			|ГДЕ
			|	&ОтборПоИзмерениям
			|	И КлючиДоступаКРегистрам.ДляВнешнихПользователей ЕСТЬ NULL";
			ТекстЗапросаНовыхКомбинацийЗначенийОпорныхПолейНовыхЗаписей =
			"ВЫБРАТЬ
			|	&ТекущаяТаблицаПоле1 КАК ТекущаяТаблицаПоле1
			|ПОМЕСТИТЬ КомбинацииЗначенийОпорныхПолей
			|ИЗ
			|	&КомбинацииЗначенийОпорныхПолей КАК ТекущаяТаблица
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|ВЫБРАТЬ РАЗЛИЧНЫЕ
			|	&ТекущаяТаблицаПоле1 КАК Поле1
			|ИЗ
			|	КомбинацииЗначенийОпорныхПолей КАК ТекущаяТаблица
			|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.КлючиДоступаКРегистрам КАК КлючиДоступаКРегистрам
			|		ПО (КлючиДоступаКРегистрам.Регистр = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка))
			|			И (КлючиДоступаКРегистрам.ДляВнешнихПользователей = ИСТИНА)
			|			И (КлючиДоступаКРегистрам.Поле1 = &ТекущаяТаблицаПоле1)
			|ГДЕ
			|	КлючиДоступаКРегистрам.ДляВнешнихПользователей ЕСТЬ NULL";
		Иначе
			ТекстЗапросаНовыхКомбинацийЗначенийОпорныхПолейСуществующихЗаписей =
			"ВЫБРАТЬ РАЗЛИЧНЫЕ
			|	&ТекущаяТаблицаПоле1 КАК Поле1
			|ИЗ
			|	&Список КАК ТекущаяТаблица
			|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.КлючиДоступаКРегистрам КАК КлючиДоступаКРегистрам
			|		ПО (КлючиДоступаКРегистрам.Регистр = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка))
			|			И (КлючиДоступаКРегистрам.ДляВнешнихПользователей = ЛОЖЬ)
			|			И (КлючиДоступаКРегистрам.Поле1 = &ТекущаяТаблицаПоле1)
			|ГДЕ
			|	&ОтборПоИзмерениям
			|	И КлючиДоступаКРегистрам.ДляВнешнихПользователей ЕСТЬ NULL";
			ТекстЗапросаНовыхКомбинацийЗначенийОпорныхПолейНовыхЗаписей =
			"ВЫБРАТЬ
			|	&ТекущаяТаблицаПоле1 КАК ТекущаяТаблицаПоле1
			|ПОМЕСТИТЬ КомбинацииЗначенийОпорныхПолей
			|ИЗ
			|	&КомбинацииЗначенийОпорныхПолей КАК ТекущаяТаблица
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|ВЫБРАТЬ РАЗЛИЧНЫЕ
			|	&ТекущаяТаблицаПоле1 КАК Поле1
			|ИЗ
			|	КомбинацииЗначенийОпорныхПолей КАК ТекущаяТаблица
			|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.КлючиДоступаКРегистрам КАК КлючиДоступаКРегистрам
			|		ПО (КлючиДоступаКРегистрам.Регистр = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка))
			|			И (КлючиДоступаКРегистрам.ДляВнешнихПользователей = ЛОЖЬ)
			|			И (КлючиДоступаКРегистрам.Поле1 = &ТекущаяТаблицаПоле1)
			|ГДЕ
			|	КлючиДоступаКРегистрам.ДляВнешнихПользователей ЕСТЬ NULL";
		КонецЕсли;
		УточнитьРегистрКлючейИУсловиеСоединения(ТекстЗапросаНовыхКомбинацийЗначенийОпорныхПолейСуществующихЗаписей,
			Результат, Контекст, Истина);
		УточнитьРегистрКлючейИУсловиеСоединения(ТекстЗапросаНовыхКомбинацийЗначенийОпорныхПолейНовыхЗаписей,
			Результат, Контекст, Истина);
		
		Результат.ТекстЗапросаНовыхКомбинацийЗначенийОпорныхПолейСуществующихЗаписей =
			ТекстЗапросаНовыхКомбинацийЗначенийОпорныхПолейСуществующихЗаписей;
		Результат.ТекстЗапросаНовыхКомбинацийЗначенийОпорныхПолейНовыхЗаписей =
			ТекстЗапросаНовыхКомбинацийЗначенийОпорныхПолейНовыхЗаписей;
	КонецЕсли;
	
	Если Не Контекст.ЭтоСсылочныйТип Тогда
		ТекстЗапроса =
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	ЛОЖЬ КАК ЗначениеЛожь
		|ИЗ
		|	" + Контекст.Список + " КАК ТекущаяТаблица
		|ГДЕ
		|	&ОтборПоИзмерениям
		|	И НЕ ИСТИНА В
		|				(" + ТекстСОтступом(ТекстЗапроса, "				") + ")";
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ТекстЗапросаСПроверкойПоВладельцамНастроекПрав) Тогда
		Результат.ТекстЗапросаПроверкиПравЧтениеИзменение = ТекстЗапросаСПроверкойПоВладельцамНастроекПрав;
	Иначе
		Результат.ТекстЗапросаПроверкиПравЧтениеИзменение = ТекстЗапроса;
	КонецЕсли;
	
	Если Не Результат.ОграничениеЧтенияОтключено Тогда
		Результат.ТекстЗапросаПроверкиПраваЧтение = СтрЗаменить(ТекстЗапроса,
			"РазрешенныеКлючиДоступа.Изменение", "Истина");
	КонецЕсли;
	
	Если Результат.ИспользуетсяОграничениеПоВладельцу
	   И Результат.ПолеВладельца.ИзменениеКакЧтение Тогда
		
		Результат.ТекстЗапросаПроверкиПравЧтениеИзменение = Результат.ТекстЗапросаПроверкиПраваЧтение;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ЗаполнитьЗапросыПроверкиПравЧтениеИзменение.
Функция УсловиеИзЗапросаСПроверкойПоВладельцамНастроекПрав()
	
	Строки = СтрРазделить(ТекстЗапросаСПроверкойПоВладельцамНастроекПрав(), Символы.ПС, "");
	Строки.Удалить(0);
	Строки.Удалить(0);
	Строки.Удалить(0);
	
	Возврат СокрЛП(СтрСоединить(Строки, Символы.ПС));
	
КонецФункции

// Для процедуры ЗаполнитьЗапросыПроверкиПравЧтениеИзменение.
Функция ТекстЗапросаСПроверкойПоВладельцамНастроекПрав()
	
	Возврат
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА КАК ЗначениеИстина
	|ГДЕ
	|	ИСТИНА В
	|			(ВЫБРАТЬ ПЕРВЫЕ 1
	|				ИСТИНА
	|			ИЗ
	|				РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
	|					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
	|					ПО
	|						НаследованиеНастроек.Объект = &Объект
	|							И НастройкиПрав.Объект = НаследованиеНастроек.Родитель
	|							И НастройкиПрав.Таблица = &ИдентификаторТаблицыНастроекПрав
	|							И НаследованиеНастроек.УровеньИспользования < НастройкиПрав.УровеньРазрешенияИзменения
	|					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|					ПО
	|						СоставыГруппПользователей.Пользователь = &АвторизованныйПользователь
	|							И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь)
	|	И НЕ ЛОЖЬ В
	|				(ВЫБРАТЬ ПЕРВЫЕ 1
	|					ЛОЖЬ
	|				ИЗ
	|					РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
	|						ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
	|						ПО
	|							НаследованиеНастроек.Объект = &Объект
	|								И НастройкиПрав.Объект = НаследованиеНастроек.Родитель
	|								И НастройкиПрав.Таблица = &ИдентификаторТаблицыНастроекПрав
	|								И НаследованиеНастроек.УровеньИспользования < НастройкиПрав.УровеньЗапрещенияИзменения
	|						ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|						ПО
	|							СоставыГруппПользователей.Пользователь = &АвторизованныйПользователь
	|								И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь)";
	
КонецФункции

// Для процедуры ЗаполнитьЗапросыПроверкиПравЧтениеИзменение.
Процедура УточнитьРегистрКлючейИУсловиеСоединения(ТекстЗапроса, Результат, Контекст, ДобавитьПоляВыбора = Ложь)
	
	Если ЗначениеЗаполнено(Результат.ИмяОтдельногоРегистраКлючей) Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса,
			"РегистрСведений.КлючиДоступаКРегистрам",
			"РегистрСведений." + Результат.ИмяОтдельногоРегистраКлючей);
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса,
			"КлючиДоступаКРегистрам.Регистр = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)",
			"ИСТИНА");
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса,
			"ИдентификаторыОбъектовМетаданных.ПустаяСсылка",
			УправлениеДоступомСлужебныйПовтИсп.ОписаниеПредопределенногоИдентификатораОбъектаМетаданных(
				Контекст.Список));
	КонецЕсли;
	
	УсловиеОтбора = "";
	УсловиеСоединения = "";
	НомерПоля = 1;
	Для Каждого Поле Из Результат.ОпорныеПоля.Используемые Цикл
		УсловиеОтбора = УсловиеОтбора + Символы.ПС
			+ "И КлючиДоступаКРегистрам.Поле" + НомерПоля + " = ТекущаяТаблица." + Поле;
		УсловиеСоединения = УсловиеСоединения + Символы.ПС
			+ "И (КлючиДоступаКРегистрам.Поле" + НомерПоля + " = ТекущаяТаблица." + Поле + ")";
		НомерПоля = НомерПоля + 1;
	КонецЦикла;
	Для ТекущийНомер = НомерПоля По Результат.ОпорныеПоля.МаксимальноеКоличество Цикл
		УсловиеОтбора = УсловиеОтбора + Символы.ПС
			+ "И КлючиДоступаКРегистрам.Поле" + ТекущийНомер
			+ " = Значение(Перечисление.ДополнительныеЗначенияДоступа.Null)";
		УсловиеСоединения = УсловиеСоединения + Символы.ПС
			+ "И (КлючиДоступаКРегистрам.Поле" + ТекущийНомер
			+ " = Значение(Перечисление.ДополнительныеЗначенияДоступа.Null))";
	КонецЦикла;
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса,
		"И КлючиДоступаКРегистрам.Поле1 = &ТекущаяТаблицаПоле1",
		ТекстСОтступом(СокрЛ(УсловиеОтбора), "	"));
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса,
		"И (КлючиДоступаКРегистрам.Поле1 = &ТекущаяТаблицаПоле1)",
		ТекстСОтступом(СокрЛ(УсловиеСоединения), "			"));
	
	Если Не ДобавитьПоляВыбора Тогда
		Возврат;
	КонецЕсли;
	
	ОпорныеПоля = "";
	ПоляВыбора = "";
	НомерПоля = 1;
	Для Каждого Поле Из Результат.ОпорныеПоля.Используемые Цикл
		ОпорныеПоля = ОпорныеПоля + ?(ОпорныеПоля = "", "", "," + Символы.ПС)
			+ "ТекущаяТаблица." + Поле + " КАК " + Поле;
		ПоляВыбора = ПоляВыбора + ?(ПоляВыбора = "", "", "," + Символы.ПС)
			+ "ТекущаяТаблица." + Поле + " КАК Поле" + НомерПоля;
		НомерПоля = НомерПоля + 1;
	КонецЦикла;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса,
		"&ТекущаяТаблицаПоле1 КАК ТекущаяТаблицаПоле1",
		ТекстСОтступом(СокрЛ(ОпорныеПоля), "	"));
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса,
		"&ТекущаяТаблицаПоле1 КАК Поле1",
		ТекстСОтступом(СокрЛ(ПоляВыбора), "	"));
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Список", Контекст.Список);
	
КонецПроцедуры

// Для функции СобратьЧастиЗапросов.
Процедура ПодставитьОбщиеПараметрыВЗапрос(ТекстЗапроса, Контекст)
	
	Если Контекст.ДляВнешнихПользователей Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#КлючДоступаПользователейКОбъекту", "КлючДоступаВнешнихПользователей");
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#КлючДоступаПользователейКОбъекту", "КлючДоступаПользователей");
	КонецЕсли;
	
	Если Контекст.ЭтоСсылочныйТип Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ТекущийСписок", Контекст.Список);
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#КлючиДоступаКДанным", "КлючиДоступаКОбъектам");
		
		Если Контекст.ДляВнешнихПользователей Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#КлючДоступаПользователей", "КлючДоступаВнешнихПользователей");
		Иначе
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#КлючДоступаПользователей", "КлючДоступаПользователей");
		КонецЕсли;
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ТекущийРегистр", Контекст.Список);
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#КлючиДоступаКДанным", "ТекущийСписок");
		Номер = 0;
		Для Каждого ИмяОпорногоПоля Из Контекст.ОпорныеПоля.Используемые Цикл
			Номер = Номер + 1;
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ТекущийСписок."
				+ ИмяОпорногоПоля, "ТекущийСписок.Поле" + Номер);
			
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ТекущийСписокИсточник."
				+ ИмяОпорногоПоля, "ТекущийСписокИсточник.Поле" + Номер);
		КонецЦикла;
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ТекущийСписок", ?(Контекст.ИмяОтдельногоРегистраКлючей = "",
			"РегистрСведений.КлючиДоступаКРегистрам", "РегистрСведений." + Контекст.ИмяОтдельногоРегистраКлючей));
		
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#КлючДоступаПользователей", "КлючДоступа");
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&СоставПолей", Формат(Контекст.СоставПолей, "ЧГ="));
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ДляВнешнихПользователей",
		?(Контекст.ДляВнешнихПользователей, "ИСТИНА", "ЛОЖЬ"));
	
КонецПроцедуры

// Для процедуры ДобавитьТекстыЗапросовВПараметрыОграничения.
Процедура ДобавитьПроверкуШапкиКлюча(Контекст, НомерШапки)
	
	ГруппаПолей = Контекст.ГруппыПолей.Получить("Шапка" + НомерШапки);
	Если ГруппаПолей = Неопределено Тогда
		Если НомерШапки > 0 Тогда
			Возврат;
		КонецЕсли;
		СоединенияИПоля = Новый Структура("Соединения, Поля", "", "");
	Иначе
		СоединенияИПоля = СоединенияИПоляПоТаблицам(ГруппаПолей,
			Ложь, НомерШапки).Получить("ТекущийСписок");
	КонецЕсли;
	
	Если НомерШапки = 0 Тогда
		Соединения = СоединенияИПоля.Соединения + "
		|ЛЕВОЕ СОЕДИНЕНИЕ Справочник.КлючиДоступа КАК Шапка0
		|ПО (Шапка0.Ссылка = #КлючиДоступаКДанным.#КлючДоступаПользователей)
		|	И (Шапка0.СоставПолей = &СоставПолей)";
	Иначе
		Соединения = СоединенияИПоля.Соединения + "
		|ЛЕВОЕ СОЕДИНЕНИЕ Справочник.КлючиДоступа.Шапка КАК Шапка?
		|ПО (Шапка?.Ссылка = #КлючиДоступаКДанным.#КлючДоступаПользователей)
		|	И (Шапка?.НомерСтроки = " + НомерШапки + ")";
	КонецЕсли;
	
	Соединения = СокрЛ(Соединения) + ТекстСОтступом(СоединенияИПоля.Поля, "	");
	Соединения = ТекстСОтступом(Соединения, "		");
	
	Условие = "НЕ Шапка?.Ссылка ЕСТЬ NULL";
	Условие = ТекстСОтступом(Условие, "	");
	
	ШаблонТекстаЧастиУсловия =
	"НЕ ИСТИНА В
	|(ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА
	|ИЗ
	|	(ВЫБРАТЬ
	|		ИСТИНА КАК ЗначениеИстина) КАК ЗначениеИстина
	|		#Соединения
	|ГДЕ
	|	#Условие)";
	
	ТекстЧастиУсловия = ШаблонТекстаЧастиУсловия;
	ТекстЧастиУсловия = СтрЗаменить(ТекстЧастиУсловия, "#Соединения", Соединения);
	ТекстЧастиУсловия = СтрЗаменить(ТекстЧастиУсловия, "#Условие",    Условие);
	
	ТекстЧастиУсловия = СтрЗаменить(ТекстЧастиУсловия, "Шапка?", "Шапка" + НомерШапки);
	Контекст.ЧастиУсловияПроверки.Добавить(ТекстЧастиУсловия);
	
КонецПроцедуры

// Для процедуры ДобавитьТекстыЗапросовВПараметрыОграничения.
Процедура ДобавитьПроверкуТабличнойЧастиКлюча(Контекст, НомерТабличнойЧастиКлюча)
	
	ТаблицыПоГруппам  = Контекст.ГруппыДополнительныхТаблиц.ТаблицыПоГруппам;
	ГруппаДополнительныхТаблиц = ТаблицыПоГруппам.Получить(НомерТабличнойЧастиКлюча);
	
	ИмяТабличнойЧастиКлюча = "ТабличнаяЧасть" + НомерТабличнойЧастиКлюча;
	ГруппаПолей = Контекст.ГруппыПолей.Получить(ИмяТабличнойЧастиКлюча);
	
	СоединенияИПоляПоТаблицам = СоединенияИПоляПоТаблицам(ГруппаПолей,
		Истина, , , ВГруппеОднаДополнительнаяТаблицаСПолями(Контекст, ГруппаДополнительныхТаблиц));
	
	Соединения = "";
	Условие = "";
	Поля = "";
	
	Если ГруппаДополнительныхТаблиц = Неопределено Тогда
		ПсевдонимТабличнойЧастиОбъекта = Контекст.ПсевдонимыТабличныхЧастейОбъекта.Получить(НомерТабличнойЧастиКлюча);
		ИмяТабличнойЧастиОбъекта = СтрЗаменить(ПсевдонимТабличнойЧастиОбъекта, "ТекущийСписок", "");
		СоединенияИПоля = СоединенияИПоляПоТаблицам.Получить(ПсевдонимТабличнойЧастиОбъекта);
		Соединения = Соединения + "
		|ЛЕВОЕ СОЕДИНЕНИЕ &ТекущийСписок." + ИмяТабличнойЧастиОбъекта + " КАК " + ПсевдонимТабличнойЧастиОбъекта + "
		|ПО " + ПсевдонимТабличнойЧастиОбъекта + ".Ссылка = ТекущийСписок.Ссылка"
		+ СоединенияИПоля.Соединения;
		Условие = ПсевдонимТабличнойЧастиОбъекта + ".Ссылка #ПроверкаNULL";
		Поля = СоединенияИПоля.Поля;
	Иначе
		Для Каждого ДополнительнаяТаблица Из ГруппаДополнительныхТаблиц Цикл
			Соединения = Соединения + "
			|ЛЕВОЕ СОЕДИНЕНИЕ " + ДополнительнаяТаблица.Таблица + " КАК " + ДополнительнаяТаблица.Псевдоним + "
			|ПО " + ТекстСОтступом(ДополнительнаяТаблица.ТекстУсловияСоединения, "	");
			СоединенияИПоля = СоединенияИПоляПоТаблицам.Получить(ДополнительнаяТаблица.Псевдоним);
			Если СоединенияИПоля = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			Соединения = Соединения + СоединенияИПоля.Соединения;
			Условие = Условие + ?(Условие = "", "", "
			|ИЛИ ") + ДополнительнаяТаблица.ПолеПроверкиСоединения + " #ПроверкаNULL";
			Поля = Поля + СоединенияИПоля.Поля;
		КонецЦикла;
		Если СтрЧислоСтрок(Условие) > 1 Тогда
			Условие = "(" + Условие + ")";
		КонецЕсли;
	КонецЕсли;
	ИсходныеСоединения = Соединения;
	ИсходноеУсловие = Условие;
	
	ШаблонТекстаЧастиУсловия =
	"ЛОЖЬ В
	|(ВЫБРАТЬ ПЕРВЫЕ 1
	|	ЛОЖЬ
	|ИЗ
	|	(ВЫБРАТЬ
	|		ИСТИНА КАК ЗначениеИстина) КАК ЗначениеИстина
	|		#Соединения
	|ГДЕ
	|	#Условие)";
	
	// Прямое соединение (проверка наличия требуемых записей в ключе).
	Соединения = ИсходныеСоединения + "
	|ЛЕВОЕ СОЕДИНЕНИЕ Справочник.КлючиДоступа.ТабличнаяЧасть? КАК ТабличнаяЧасть?
	|ПО (ТабличнаяЧасть?.Ссылка = #КлючиДоступаКДанным.#КлючДоступаПользователей)";
	Соединения = СокрЛ(Соединения) + ТекстСОтступом(Поля, "	");
	Соединения = ТекстСОтступом(Соединения, "		");
	
	Условие =
	"ТабличнаяЧасть?.Ссылка ЕСТЬ NULL
	|И " + ТекстСОтступом(СокрЛ(ИсходноеУсловие), "	");
	Условие = ТекстСОтступом(Условие, "	");
	Условие = СтрЗаменить(Условие, "#ПроверкаNULL", "ЕСТЬ НЕ NULL");
	
	ТекстЧастиУсловия = ШаблонТекстаЧастиУсловия;
	ТекстЧастиУсловия = СтрЗаменить(ТекстЧастиУсловия, "#Соединения",     Соединения);
	ТекстЧастиУсловия = СтрЗаменить(ТекстЧастиУсловия, "#Условие",        Условие);
	ТекстЧастиУсловия = СтрЗаменить(ТекстЧастиУсловия, "ТабличнаяЧасть?", ИмяТабличнойЧастиКлюча);
	Контекст.ЧастиУсловияПроверки.Добавить(ТекстЧастиУсловия);
	
	// Обратное соединение (проверка отсутствия лишних записей в ключе).
	Если ГруппаДополнительныхТаблиц = Неопределено
	 Или ГруппаДополнительныхТаблиц.Количество() = 1 Тогда
		
		Соединения =
		"ЛЕВОЕ СОЕДИНЕНИЕ Справочник.КлючиДоступа.ТабличнаяЧасть? КАК ТабличнаяЧасть?
		|ПО (ТабличнаяЧасть?.Ссылка = #КлючиДоступаКДанным.#КлючДоступаПользователей)";
		
		Если ГруппаДополнительныхТаблиц = Неопределено Тогда
			Соединения = Соединения + "
			|ЛЕВОЕ СОЕДИНЕНИЕ &ТекущийСписок." + ИмяТабличнойЧастиОбъекта + " КАК " + ПсевдонимТабличнойЧастиОбъекта
				  + ТекстСОтступом(СоединенияИПоля.Соединения, "	") + "
			|ПО " + ПсевдонимТабличнойЧастиОбъекта + ".Ссылка = ТекущийСписок.Ссылка"
			      + ТекстСОтступом(СоединенияИПоля.Поля, "	");
		Иначе
			ДополнительнаяТаблица = ГруппаДополнительныхТаблиц[0];
			СоединенияИПоля = СоединенияИПоляПоТаблицам.Получить(ДополнительнаяТаблица.Псевдоним);
			Соединения = Соединения + "
			|ЛЕВОЕ СОЕДИНЕНИЕ " + ДополнительнаяТаблица.Таблица + " КАК " + ДополнительнаяТаблица.Псевдоним
				  + ТекстСОтступом(СоединенияИПоля.Соединения, "	") + "
			|ПО " + ТекстСОтступом(ДополнительнаяТаблица.ТекстУсловияСоединения, "	")
			      + ТекстСОтступом(СоединенияИПоля.Поля, "	");
		КонецЕсли;
		Соединения = ТекстСОтступом(Соединения, "		");
		
		Условие =
		"ТабличнаяЧасть?.Ссылка ЕСТЬ НЕ NULL
		|И " + СокрЛ(ИсходноеУсловие);
		Условие = ТекстСОтступом(Условие, "	");
		Условие = СтрЗаменить(Условие, "#ПроверкаNULL", "ЕСТЬ NULL");
	Иначе
		Соединения =
		"ЛЕВОЕ СОЕДИНЕНИЕ Справочник.КлючиДоступа.ТабличнаяЧасть? КАК ТабличнаяЧасть?
		|ПО (ТабличнаяЧасть?.Ссылка = #КлючиДоступаКДанным.#КлючДоступаПользователей)
		|ЛЕВОЕ СОЕДИНЕНИЕ &ТекущийСписок КАК ТекущийСписокИсточник"
			+ ТекстСОтступом(ИсходныеСоединения, "	") + "
		|ПО " + ?(Контекст.ЭтоСсылочныйТип, "(ТекущийСписокИсточник.Ссылка = ТекущийСписок#.Ссылка)",
			Контекст.ОпорныеПоля.УсловиеСоединения);
		
		Соединения = Соединения + ТекстСОтступом(Поля, "	");
		Соединения = ТекстСОтступом(Соединения, "		");
		Соединения = СтрЗаменить(Соединения, "ТекущийСписок.", "ТекущийСписокИсточник.");
		Соединения = СтрЗаменить(Соединения, "ТекущийСписок#.", "ТекущийСписок.");
		
		Если Контекст.ЭтоСсылочныйТип Тогда
			Условие =
			"ТабличнаяЧасть?.Ссылка ЕСТЬ НЕ NULL
			|И ТекущийСписокИсточник.Ссылка ЕСТЬ NULL";
		Иначе
			Условие =
			"ТабличнаяЧасть?.Ссылка ЕСТЬ НЕ NULL
			|И ТекущийСписокИсточник.Поле1 ЕСТЬ NULL";
		КонецЕсли;
		Условие = ТекстСОтступом(Условие, "	");
	КонецЕсли;
	
	ТекстЧастиУсловия = ШаблонТекстаЧастиУсловия;
	ТекстЧастиУсловия = СтрЗаменить(ТекстЧастиУсловия, "#Соединения",     Соединения);
	ТекстЧастиУсловия = СтрЗаменить(ТекстЧастиУсловия, "#Условие",        Условие);
	ТекстЧастиУсловия = СтрЗаменить(ТекстЧастиУсловия, "ТабличнаяЧасть?", ИмяТабличнойЧастиКлюча);
	Контекст.ЧастиУсловияПроверки.Добавить(ТекстЧастиУсловия);
	
КонецПроцедуры

// Для процедуры ДобавитьТекстыЗапросовВПараметрыОграничения.
Процедура ДобавитьЗаполнениеШапкиКлюча(Контекст, НомерШапки)
	
	Если Не Контекст.ЭтоСсылочныйТип И НомерШапки = 0 Тогда
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	ТекущийСписок.ТекущаяСсылка КАК ТекущаяСсылка,
		|	" + Контекст.ОпорныеПоля.ДляВыбора + "
		|	ПОМЕСТИТЬ ТекущийСписок
		|ИЗ
		|	&ЗначенияОпорныхПолей КАК ТекущийСписок";
		Контекст.ЧастиЗапросаЗначенийИзОбъектов.Добавить(ТекстЗапроса);
	КонецЕсли;
	
	ГруппаПолей = Контекст.ГруппыПолей.Получить("Шапка" + НомерШапки);
	Если ГруппаПолей = Неопределено Тогда
		Возврат;
	КонецЕсли;
	ДобавитьОписаниеТаблицыКлюча("Шапка" + НомерШапки, ГруппаПолей, Контекст);
	
	СоединенияИПоля = СоединенияИПоляПоТаблицам(ГруппаПолей, Ложь,
		НомерШапки, Истина).Получить("ТекущийСписок");
	
	// Выбор значений из объектов для поиска и создания ключей доступа.
	Если Контекст.ЭтоСсылочныйТип Тогда
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	ТекущийСписок.Ссылка КАК ТекущаяСсылка" + ТекстСОтступом(СоединенияИПоля.Поля, "	") + "
		|ИЗ
		|	&ТекущийСписок КАК ТекущийСписок" + ТекстСОтступом(СоединенияИПоля.Соединения, "	") + "
		|ГДЕ
		|	ТекущийСписок.Ссылка В (&СсылкиНаОбъекты)
		|	И &УточнениеПланаЗапроса
		|
		|УПОРЯДОЧИТЬ ПО
		|	ТекущаяСсылка
		|ИТОГИ ПО
		|	ТекущаяСсылка";
	Иначе
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	ТекущийСписок.ТекущаяСсылка КАК ТекущаяСсылка" + ТекстСОтступом(СоединенияИПоля.Поля, "	") + "
		|ИЗ
		|	ТекущийСписок КАК ТекущийСписок" + ТекстСОтступом(СоединенияИПоля.Соединения, "	") + "
		|ГДЕ
		|	&УточнениеПланаЗапроса
		|
		|УПОРЯДОЧИТЬ ПО
		|	ТекущаяСсылка, " + Контекст.ОпорныеПоля.ДляУпорядочения + "
		|ИТОГИ ПО
		|	ТекущаяСсылка";
	КонецЕсли;
	
	Контекст.ЧастиЗапросаЗначенийИзОбъектов.Добавить(ТекстЗапроса);
	
	// Выбор значений из ключей доступа для сравнения со значениями требуемых ключей.
	Если НомерШапки = 0 Тогда
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	Шапка0.Ссылка КАК ТекущаяСсылка" + ТекстСОтступом(СоединенияИПоля.Реквизиты, "	") + "
		|ИЗ
		|	Справочник.КлючиДоступа КАК Шапка0
		|ГДЕ
		|	Шапка0.Хеш В(&Хеши)
		|	И Шапка0.Список = &Список
		|	И Шапка0.СоставПолей = &СоставПолей
		|	И Шапка0.ДляВнешнихПользователей = &ДляВнешнихПользователей
		|	И Шапка0.НеИспользуетсяС = ДАТАВРЕМЯ(1, 1, 1)
		|	И &УточнениеПланаЗапроса
		|
		|УПОРЯДОЧИТЬ ПО
		|	ТекущаяСсылка
		|ИТОГИ ПО
		|	ТекущаяСсылка";
	Иначе
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	Шапка?.Ссылка КАК ТекущаяСсылка" + ТекстСОтступом(СоединенияИПоля.Реквизиты, "	") + "
		|ИЗ
		|	Справочник.КлючиДоступа.Шапка КАК Шапка?
		|ГДЕ
		|	Шапка?.НомерСтроки = " + НомерШапки + "
		|	И Шапка?.Ссылка.Хеш В(&Хеши)
		|	И Шапка?.Ссылка.Список = &Список
		|	И Шапка?.Ссылка.СоставПолей = &СоставПолей
		|	И Шапка?.Ссылка.ДляВнешнихПользователей = &ДляВнешнихПользователей
		|	И Шапка?.Ссылка.НеИспользуетсяС = ДАТАВРЕМЯ(1, 1, 1)
		|	И &УточнениеПланаЗапроса
		|
		|УПОРЯДОЧИТЬ ПО
		|	ТекущаяСсылка
		|ИТОГИ ПО
		|	ТекущаяСсылка";
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "Шапка?", "Шапка" + НомерШапки);
	Контекст.ЧастиЗапросаЗначенийИзКлючейДляСравнения.Добавить(ТекстЗапроса);
	
	// Проверка существования ключа доступа перед записью нового ключа.
	Если НомерШапки = 0 Тогда
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	ИСТИНА КАК ЗначениеИстина
		|ИЗ
		|	Справочник.КлючиДоступа КАК Шапка0
		|ГДЕ
		|	Шапка0.Хеш = &Хеш
		|	И Шапка0.Список = &Список
		|	И Шапка0.СоставПолей = &СоставПолей
		|	И Шапка0.ДляВнешнихПользователей = &ДляВнешнихПользователей
		|	И &УточнениеПланаЗапроса";
		Контекст.ЧастиЗапросаСуществованияКлючейДляСравнения.Добавить(ТекстЗапроса);
	КонецЕсли;
	
	// Запрос ключей доступа по ведущим ключам для обновления пользователей и групп доступа, которым они разрешены.
	ДобавитьУсловиеОтбораПоВедущимКлючамДоступа(Контекст, ГруппаПолей, НомерШапки);
	
	// Выбор значений из ключей доступа для вычисления пользователей и групп доступа, которым они разрешены.
	Если НомерШапки = 0 Тогда
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	КлючиДоступа.Ссылка КАК Ссылка
		|ПОМЕСТИТЬ ПорцияКлючей
		|ИЗ
		|	&КлючиДоступа КАК КлючиДоступа
		|
		|ИНДЕКСИРОВАТЬ ПО
		|	Ссылка";
		Контекст.ЧастиЗапросаЗначенийИзКлючейДляРасчетаПрав.Добавить(ТекстЗапроса);
	КонецЕсли;
	
	Если НомерШапки = 0 Тогда
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	ПорцияКлючей.Ссылка КАК Ссылка" + ТекстСОтступом(СоединенияИПоля.Реквизиты, "	") + "
		|ИЗ
		|	ПорцияКлючей КАК ПорцияКлючей
		|	ЛЕВОЕ СОЕДИНЕНИЕ @Справочник.КлючиДоступа КАК Шапка0
		|	ПО
		|		Шапка0.Ссылка = ПорцияКлючей.Ссылка
		|		И &УточнениеПланаЗапроса
		|
		|УПОРЯДОЧИТЬ ПО
		|	Ссылка
		|ИТОГИ ПО
		|	Ссылка";
	Иначе
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	ПорцияКлючей.Ссылка КАК Ссылка" + ТекстСОтступом(СоединенияИПоля.Реквизиты, "	") + "
		|ИЗ
		|	ПорцияКлючей КАК ПорцияКлючей
		|	ЛЕВОЕ СОЕДИНЕНИЕ @Справочник.КлючиДоступа.Шапка КАК Шапка?
		|	ПО
		|		Шапка?.Ссылка = ПорцияКлючей.Ссылка
		|		И Шапка?.НомерСтроки = " + НомерШапки + "
		|		И &УточнениеПланаЗапроса
		|
		|УПОРЯДОЧИТЬ ПО
		|	Ссылка
		|ИТОГИ ПО
		|	Ссылка";
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "Шапка?", "Шапка" + НомерШапки);
	Контекст.ЧастиЗапросаЗначенийИзКлючейДляРасчетаПрав.Добавить(ТекстЗапроса);
	
	// Условие отбора прав ведущих ключей доступа.
	ДобавитьУсловиеОтбораПравДляШапкиКлюча(Контекст, ГруппаПолей, НомерШапки, "ДляВедущихКлючей");
	
	// Условие отбора прав ведущих списков.
	ДобавитьУсловиеОтбораПравДляШапкиКлюча(Контекст, ГруппаПолей, НомерШапки, "ДляВедущихСписков");
	
	// Условие отбора прав по владельцам настроек прав.
	ДобавитьУсловиеОтбораПравДляШапкиКлюча(Контекст, ГруппаПолей, НомерШапки, "ДляВладельцевНастроекПрав");
	
КонецПроцедуры

// Для процедуры ДобавитьЗаполнениеШапкиКлюча.
Процедура ДобавитьУсловиеОтбораПравДляШапкиКлюча(Контекст, ГруппаПолей, НомерШапки, НазначениеУсловия)
	
	// Условие выбора прав ведущих ключей доступа.
	Для Каждого СвойстваПоля Из ГруппаПолей Цикл
		Если НазначениеУсловия = "ДляВедущихКлючей"
		   И СвойстваПоля.ТипыСохраненияКлючейДоступа.Количество() = 0
		 Или НазначениеУсловия = "ДляВедущихСписков"
		   И Не СвойстваПоля.ЕстьТипВедущегоСписка
		 Или НазначениеУсловия = "ДляВладельцевНастроекПрав"
		   И Не СвойстваПоля.ЕстьТипВладельцаНастроекПрав Тогда
			Продолжить;
		КонецЕсли;
		
		Если НазначениеУсловия = "ДляВедущихСписков"
		   И СвойстваПоля.ТипыСохраненияЗначений.Количество() > 0 Тогда
			
			Контекст.Вставить("ЧастиУсловияВыбораПравВедущихСписковСТипами");
			УсловиеОтбора =
			"#ПроверяемоеПоле В
			|				(ВЫБРАТЬ
			|					ЕСТЬNULL(ТипыКонфигурации.Ссылка, ЕСТЬNULL(ТипыРасширений.Ссылка, Шапка?.Реквизит?))
			|				ИЗ
			|					ПорцияКлючей КАК ПорцияКлючей
			|						ЛЕВОЕ СОЕДИНЕНИЕ @Справочник.КлючиДоступа КАК Шапка?
			|						ПО
			|							Шапка?.Ссылка = ПорцияКлючей.Ссылка
			|							
			|						ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ИдентификаторыОбъектовМетаданных КАК ТипыКонфигурации
			|						ПО
			|							Шапка?.Реквизит? <> НЕОПРЕДЕЛЕНО
			|							И ТИПЗНАЧЕНИЯ(Шапка?.Реквизит?) <> ТИП(Справочник.ИдентификаторыОбъектовМетаданных)
			|							И ТИПЗНАЧЕНИЯ(Шапка?.Реквизит?) <> ТИП(Справочник.ИдентификаторыОбъектовРасширений)
			|							И ТИПЗНАЧЕНИЯ(ТипыКонфигурации.ЗначениеПустойСсылки) = ТИПЗНАЧЕНИЯ(Шапка?.Реквизит?)
			|							
			|						ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ИдентификаторыОбъектовРасширений КАК ТипыРасширений
			|						ПО
			|							Шапка?.Реквизит? <> НЕОПРЕДЕЛЕНО
			|							И ТИПЗНАЧЕНИЯ(ТипыРасширений.ЗначениеПустойСсылки) = ТИПЗНАЧЕНИЯ(Шапка?.Реквизит?))";
		Иначе
			УсловиеОтбора =
			"#ПроверяемоеПоле В
			|				(ВЫБРАТЬ
			|					Шапка?.Реквизит?
			|				ИЗ
			|					ПорцияКлючей КАК ПорцияКлючей
			|						ЛЕВОЕ СОЕДИНЕНИЕ @Справочник.КлючиДоступа КАК Шапка?
			|						ПО
			|							Шапка?.Ссылка = ПорцияКлючей.Ссылка)";
		КонецЕсли;
		Если НомерШапки > 0 Тогда
			УсловиеОтбора = СтрЗаменить(УсловиеОтбора,
				"Справочник.КлючиДоступа КАК Шапка?", "Справочник.КлючиДоступа.Шапка КАК Шапка?");
			УсловиеОтбора = СтрЗаменить(УсловиеОтбора,
				"Шапка?.Ссылка = ПорцияКлючей.Ссылка", ТекстСОтступом(
				"Шапка?.Ссылка = ПорцияКлючей.Ссылка
				|	И Шапка?.НомерСтроки = " + НомерШапки, "							"));
		КонецЕсли;
		УсловиеОтбора = СтрЗаменить(УсловиеОтбора, "Шапка?", "Шапка" + НомерШапки);
		УсловиеОтбора = СтрЗаменить(УсловиеОтбора, "Реквизит?", СвойстваПоля.ИмяРеквизитаГруппыПолейКлючаДоступа);
		
		Если НазначениеУсловия = "ДляВедущихКлючей" Тогда
			Контекст.ЧастиУсловияВыбораПравВедущихКлючейДоступа.Добавить(УсловиеОтбора);
			
		ИначеЕсли НазначениеУсловия = "ДляВедущихСписков" Тогда
			Контекст.ЧастиУсловияВыбораПравВедущихСписков.Добавить(УсловиеОтбора);
		Иначе
			Контекст.ЧастиУсловияВыбораПравПоВладельцамНастроекПрав.Добавить(УсловиеОтбора);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ДобавитьТекстыЗапросовВПараметрыОграничения.
Процедура ДобавитьВыборКлючейБезПолейВШапке(Контекст)
	
	Если Контекст.ГруппыПолей.Получить("Шапка0") <> Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	// Выбор значений из ключей доступа для сравнения со значениями требуемых ключей.
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	КлючиДоступа.Ссылка КАК ТекущаяСсылка
	|ИЗ
	|	Справочник.КлючиДоступа КАК КлючиДоступа
	|ГДЕ
	|	КлючиДоступа.Хеш В(&Хеши)
	|	И КлючиДоступа.Список = &Список
	|	И КлючиДоступа.СоставПолей = &СоставПолей
	|	И КлючиДоступа.ДляВнешнихПользователей = &ДляВнешнихПользователей
	|	И КлючиДоступа.НеИспользуетсяС = ДАТАВРЕМЯ(1, 1, 1)
	|	И &УточнениеПланаЗапроса
	|
	|УПОРЯДОЧИТЬ ПО
	|	ТекущаяСсылка";
	
	Контекст.ЧастиЗапросаЗначенийИзКлючейДляСравнения.Добавить(ТекстЗапроса);
	
	// Проверка существования ключа доступа перед записью нового ключа.
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ИСТИНА КАК ЗначениеИстина
	|ИЗ
	|	Справочник.КлючиДоступа КАК Шапка0
	|ГДЕ
	|	Шапка0.Хеш = &Хеш
	|	И Шапка0.Список = &Список
	|	И Шапка0.СоставПолей = &СоставПолей
	|	И Шапка0.ДляВнешнихПользователей = &ДляВнешнихПользователей
	|	И &УточнениеПланаЗапроса";
	Контекст.ЧастиЗапросаСуществованияКлючейДляСравнения.Добавить(ТекстЗапроса);
	
	// Выбор значений из ключей доступа для вычисления пользователей и групп доступа, которым они разрешены.
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	КлючиДоступа.Ссылка КАК Ссылка
	|ПОМЕСТИТЬ ПорцияКлючей
	|ИЗ
	|	&КлючиДоступа КАК КлючиДоступа
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	Ссылка";
	Контекст.ЧастиЗапросаЗначенийИзКлючейДляРасчетаПрав.Добавить(ТекстЗапроса);
	
КонецПроцедуры

// Для процедуры ДобавитьТекстыЗапросовВПараметрыОграничения.
Процедура ДобавитьЗаполнениеТабличнойЧастиКлюча(Контекст, НомерТабличнойЧастиКлюча)
	
	ТаблицыПоГруппам  = Контекст.ГруппыДополнительныхТаблиц.ТаблицыПоГруппам;
	ГруппаДополнительныхТаблиц = ТаблицыПоГруппам.Получить(НомерТабличнойЧастиКлюча);
	
	ИмяТабличнойЧастиКлюча = "ТабличнаяЧасть" + НомерТабличнойЧастиКлюча;
	ГруппаПолей = Контекст.ГруппыПолей.Получить(ИмяТабличнойЧастиКлюча);
	
	ДобавитьОписаниеТаблицыКлюча(ИмяТабличнойЧастиКлюча, ГруппаПолей, Контекст);
	
	СоединенияИПоляПоТаблицам = СоединенияИПоляПоТаблицам(ГруппаПолей,
		Истина, , Истина, ВГруппеОднаДополнительнаяТаблицаСПолями(Контекст, ГруппаДополнительныхТаблиц));
	
	// Выбор значений из объектов для поиска и создания ключей доступа.
	Если ГруппаДополнительныхТаблиц = Неопределено Тогда
		ПсевдонимТабличнойЧастиОбъекта = Контекст.ПсевдонимыТабличныхЧастейОбъекта.Получить(НомерТабличнойЧастиКлюча);
		ИмяТабличнойЧастиОбъекта = СтрЗаменить(ПсевдонимТабличнойЧастиОбъекта, "ТекущийСписок", "");
		СоединенияИПоля = СоединенияИПоляПоТаблицам.Получить(ПсевдонимТабличнойЧастиОбъекта);
		ПоляВыбора = ТекстСОтступом(СоединенияИПоля.Поля, "	");
		Соединения = ТекстСОтступом(СоединенияИПоля.Соединения, "	");
		ПоляУпорядочения = СоединенияИПоля.ПоляУпорядочения;
		Реквизиты        = СоединенияИПоля.Реквизиты;
		ТекстЗапроса =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	" + ПсевдонимТабличнойЧастиОбъекта + ".Ссылка КАК ТекущаяСсылка" + ПоляВыбора + "
		|ИЗ
		|	&ТекущийСписок." + ИмяТабличнойЧастиОбъекта + " КАК " + ПсевдонимТабличнойЧастиОбъекта + Соединения + "
		|ГДЕ
		|	" + ПсевдонимТабличнойЧастиОбъекта + ".Ссылка В (&СсылкиНаОбъекты)
		|
		|УПОРЯДОЧИТЬ ПО
		|	ТекущаяСсылка" + ПоляУпорядочения + "
		|ИТОГИ ПО
		|	ТекущаяСсылка";
	Иначе
		ПоляВыбора = "";
		Соединения = "";
		Условие = "";
		ПоляУпорядочения = "";
		Реквизиты = "";
		Для Каждого ДополнительнаяТаблица Из ГруппаДополнительныхТаблиц Цикл
			СоединенияИПоля = СоединенияИПоляПоТаблицам.Получить(ДополнительнаяТаблица.Псевдоним);
			Соединения = Соединения + "
			|ЛЕВОЕ СОЕДИНЕНИЕ " + ДополнительнаяТаблица.Таблица + " КАК " + ДополнительнаяТаблица.Псевдоним + "
			|ПО " + ТекстСОтступом(ДополнительнаяТаблица.ТекстУсловияСоединения, "	");
			Если СоединенияИПоля = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			Соединения = Соединения + СоединенияИПоля.Соединения;
			Условие = Условие + ?(Условие = "", "", "
			|ИЛИ ") + ДополнительнаяТаблица.ПолеПроверкиСоединения + " ЕСТЬ НЕ NULL";
			ПоляВыбора       = ПоляВыбора       + СоединенияИПоля.Поля;
			ПоляУпорядочения = ПоляУпорядочения + СоединенияИПоля.ПоляУпорядочения;
			Реквизиты        = Реквизиты        + СоединенияИПоля.Реквизиты;
		КонецЦикла;
		Если СтрЧислоСтрок(Условие) > 1 Тогда
			Условие = "(" + Условие + ")";
		КонецЕсли;
		Если Контекст.ЭтоСсылочныйТип Тогда
			ТекстЗапроса =
			"ВЫБРАТЬ РАЗЛИЧНЫЕ
			|	ТекущийСписок.Ссылка КАК ТекущаяСсылка" + ТекстСОтступом(ПоляВыбора, "	") + "
			|ИЗ
			|	&ТекущийСписок КАК ТекущийСписок" + ТекстСОтступом(Соединения, "	") + "
			|ГДЕ
			|	ТекущийСписок.Ссылка В (&СсылкиНаОбъекты)
			|	И " + ТекстСОтступом(Условие, "	") + "
			|
			|УПОРЯДОЧИТЬ ПО
			|	ТекущаяСсылка" + ПоляУпорядочения + "
			|ИТОГИ ПО
			|	ТекущаяСсылка";
		Иначе
			ТекстЗапроса =
			"ВЫБРАТЬ
			|	ТекущийСписок.ТекущаяСсылка КАК ТекущаяСсылка"  + ТекстСОтступом(ПоляВыбора, "	") + "
			|ИЗ
			|	ТекущийСписок КАК ТекущийСписок" + ТекстСОтступом(Соединения, "	") + "
			|ГДЕ
			|	" + ТекстСОтступом(Условие, "	") + "
			|
			|УПОРЯДОЧИТЬ ПО
			|	ТекущаяСсылка, " + Контекст.ОпорныеПоля.ДляУпорядочения + ПоляУпорядочения + "
			|ИТОГИ ПО
			|	ТекущаяСсылка";
		КонецЕсли;
	КонецЕсли;
	
	Контекст.ЧастиЗапросаЗначенийИзОбъектов.Добавить(ТекстЗапроса);
	
	// Запрос ключей доступа по ведущим ключам для обновления пользователей и групп доступа, которым они разрешены.
	ДобавитьУсловиеОтбораПоВедущимКлючамДоступа(Контекст, ГруппаПолей, , НомерТабличнойЧастиКлюча);
	
	// Выбор значений из ключей доступа для сравнения со значениями требуемых ключей.
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ТабличнаяЧасть?.Ссылка КАК ТекущаяСсылка" + ТекстСОтступом(Реквизиты, "	") + "
	|ИЗ
	|	Справочник.КлючиДоступа.ТабличнаяЧасть? КАК ТабличнаяЧасть?
	|ГДЕ
	|	ТабличнаяЧасть?.Ссылка.Хеш В(&Хеши)
	|	И ТабличнаяЧасть?.Ссылка.Список = &Список
	|	И ТабличнаяЧасть?.Ссылка.СоставПолей = &СоставПолей
	|	И ТабличнаяЧасть?.Ссылка.ДляВнешнихПользователей = &ДляВнешнихПользователей
	|	И ТабличнаяЧасть?.Ссылка.НеИспользуетсяС = ДАТАВРЕМЯ(1, 1, 1)
	|	И &УточнениеПланаЗапроса
	|
	|УПОРЯДОЧИТЬ ПО
	|	ТекущаяСсылка" + ПоляУпорядочения + "
	|ИТОГИ ПО
	|	ТекущаяСсылка";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ТабличнаяЧасть?", "ТабличнаяЧасть" + НомерТабличнойЧастиКлюча);
	Контекст.ЧастиЗапросаЗначенийИзКлючейДляСравнения.Добавить(ТекстЗапроса);
	
	// Выбор значений из ключей доступа для вычисления пользователей и групп доступа, которым они разрешены.
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ПорцияКлючей.Ссылка КАК Ссылка" + ТекстСОтступом(Реквизиты, "	") + "
	|ИЗ
	|	ПорцияКлючей КАК ПорцияКлючей
	|	ЛЕВОЕ СОЕДИНЕНИЕ @Справочник.КлючиДоступа.ТабличнаяЧасть? КАК ТабличнаяЧасть?
	|	ПО
	|		ТабличнаяЧасть?.Ссылка = ПорцияКлючей.Ссылка
	|
	|УПОРЯДОЧИТЬ ПО
	|	Ссылка
	|ИТОГИ ПО
	|	Ссылка";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ТабличнаяЧасть?", "ТабличнаяЧасть" + НомерТабличнойЧастиКлюча);
	Контекст.ЧастиЗапросаЗначенийИзКлючейДляРасчетаПрав.Добавить(ТекстЗапроса);
	
	// Условие отбора прав ведущих ключей доступа.
	ДобавитьУсловиеОтбораПравДляТабличнойЧастиКлюча(Контекст,
		ГруппаПолей, НомерТабличнойЧастиКлюча, "ДляВедущихКлючей");
	
	// Условие отбора прав ведущих списков.
	ДобавитьУсловиеОтбораПравДляТабличнойЧастиКлюча(Контекст,
		ГруппаПолей, НомерТабличнойЧастиКлюча, "ДляВедущихСписков");
	
	// Условие отбора прав по владельцам настроек прав.
	ДобавитьУсловиеОтбораПравДляТабличнойЧастиКлюча(Контекст,
		ГруппаПолей, НомерТабличнойЧастиКлюча, "ДляВладельцевНастроекПрав");
	
КонецПроцедуры

// Для процедуры ДобавитьЗаполнениеТабличнойЧастиКлюча.
Процедура ДобавитьУсловиеОтбораПравДляТабличнойЧастиКлюча(Контекст, ГруппаПолей,
			НомерТабличнойЧастиКлюча, НазначениеУсловия)
	
	Для Каждого СвойстваПоля Из ГруппаПолей Цикл
		Если НазначениеУсловия = "ДляВедущихКлючей"
		   И СвойстваПоля.ТипыСохраненияКлючейДоступа.Количество() = 0
		 Или НазначениеУсловия = "ДляВедущихСписков"
		   И Не СвойстваПоля.ЕстьТипВедущегоСписка
		 Или НазначениеУсловия = "ДляВладельцевНастроекПрав"
		   И Не СвойстваПоля.ЕстьТипВладельцаНастроекПрав Тогда
			Продолжить;
		КонецЕсли;
		
		Если НазначениеУсловия = "ДляВедущихСписков"
		   И СвойстваПоля.ТипыСохраненияЗначений.Количество() > 0 Тогда
			
			Контекст.Вставить("ЧастиУсловияВыбораПравВедущихСписковСТипами");
			УсловиеОтбора =
			"#ПроверяемоеПоле В
			|				(ВЫБРАТЬ
			|					ЕСТЬNULL(ТипыКонфигурации.Ссылка, ЕСТЬNULL(ТипыРасширений.Ссылка, ТабличнаяЧасть?.Реквизит?))
			|				ИЗ
			|					ПорцияКлючей КАК ПорцияКлючей
			|						ЛЕВОЕ СОЕДИНЕНИЕ @Справочник.КлючиДоступа.ТабличнаяЧасть? КАК ТабличнаяЧасть?
			|						ПО
			|							ТабличнаяЧасть?.Ссылка = ПорцияКлючей.Ссылка
			|							
			|						ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ИдентификаторыОбъектовМетаданных КАК ТипыКонфигурации
			|						ПО
			|							ТабличнаяЧасть?.Реквизит? <> НЕОПРЕДЕЛЕНО
			|							И ТИПЗНАЧЕНИЯ(ТабличнаяЧасть?.Реквизит?) <> ТИП(Справочник.ИдентификаторыОбъектовМетаданных)
			|							И ТИПЗНАЧЕНИЯ(ТабличнаяЧасть?.Реквизит?) <> ТИП(Справочник.ИдентификаторыОбъектовРасширений)
			|							И ТИПЗНАЧЕНИЯ(ТипыКонфигурации.ЗначениеПустойСсылки) = ТИПЗНАЧЕНИЯ(ТабличнаяЧасть?.Реквизит?)
			|							
			|						ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ИдентификаторыОбъектовРасширений КАК ТипыРасширений
			|						ПО
			|							ТабличнаяЧасть?.Реквизит? <> НЕОПРЕДЕЛЕНО
			|							И ТИПЗНАЧЕНИЯ(ТипыРасширений.ЗначениеПустойСсылки) = ТИПЗНАЧЕНИЯ(ТабличнаяЧасть?.Реквизит?))";
		Иначе
			УсловиеОтбора =
			"#ПроверяемоеПоле В
			|				(ВЫБРАТЬ
			|					ТабличнаяЧасть?.Реквизит?
			|				ИЗ
			|					ПорцияКлючей КАК ПорцияКлючей
			|						ЛЕВОЕ СОЕДИНЕНИЕ @Справочник.КлючиДоступа.ТабличнаяЧасть? КАК ТабличнаяЧасть?
			|						ПО
			|							ТабличнаяЧасть?.Ссылка = ПорцияКлючей.Ссылка)";
		КонецЕсли;
		
		УсловиеОтбора = СтрЗаменить(УсловиеОтбора, "ТабличнаяЧасть?", "ТабличнаяЧасть" + НомерТабличнойЧастиКлюча);
		УсловиеОтбора = СтрЗаменить(УсловиеОтбора, "Реквизит?", СвойстваПоля.ИмяРеквизитаГруппыПолейКлючаДоступа);
		
		Если НазначениеУсловия = "ДляВедущихКлючей" Тогда
			Контекст.ЧастиУсловияВыбораПравВедущихКлючейДоступа.Добавить(УсловиеОтбора);
			
		ИначеЕсли НазначениеУсловия = "ДляВедущихСписков" Тогда
			Контекст.ЧастиУсловияВыбораПравВедущихСписков.Добавить(УсловиеОтбора);
		Иначе
			Контекст.ЧастиУсловияВыбораПравПоВладельцамНастроекПрав.Добавить(УсловиеОтбора);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для процедур ДобавитьЗаполнениеШапкиКлюча, ДобавитьЗаполнениеТабличнойЧастиКлюча.
Процедура ДобавитьОписаниеТаблицыКлюча(ИмяТаблицыКлюча, ГруппаПолей, Контекст)
	
	ПоляТаблицыКлюча = Новый Массив;
	
	Для Каждого СвойстваПоля Из ГруппаПолей Цикл
		ПоляТаблицыКлюча.Добавить(СвойстваПоля.ИмяРеквизитаГруппыПолейКлючаДоступа);
	КонецЦикла;
	
	Контекст.ТаблицыКлюча.Добавить(ИмяТаблицыКлюча);
	Контекст.РеквизитыТаблицКлюча.Вставить(ИмяТаблицыКлюча, ПоляТаблицыКлюча);
	
КонецПроцедуры

// Для процедуры ДобавитьЗаполнениеШапкиКлюча, ДобавитьЗаполнениеТабличнойЧастиКлюча.
Процедура ДобавитьУсловиеОтбораПоВедущимКлючамДоступа(Контекст, ГруппаПолей, НомерШапки = 0, НомерТабличнойЧастиКлюча = 0)
	
	СоединенияИПоля = СоединенияИПоляПоТаблицам(ГруппаПолей, Ложь,
		НомерШапки, Истина).Получить("ТекущийСписок");
	
	УсловиеОтбора = "";
	НомерРеквизита = ?(НомерШапки = 0, 0, 5);
	
	Для Каждого СвойстваПоля Из ГруппаПолей Цикл
		НомерРеквизита = НомерРеквизита + 1;
		
		Если СвойстваПоля.ТипыСохраненияКлючейДоступа.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		УсловиеОтбора =
		"КлючиДоступа.Ссылка В
		|				(ВЫБРАТЬ
		|					Шапка?.Ссылка
		|				ИЗ
		|					Справочник.КлючиДоступа КАК Шапка?
		|				ГДЕ
		|					Шапка?.Значение? В (&ВедущиеКлючиДоступа))";
		
		УсловиеОтбора = СтрЗаменить(УсловиеОтбора, "Значение?", "Значение" + НомерРеквизита);
		
		Если НомерШапки > 0 Тогда
			УсловиеОтбора = СтрЗаменить(УсловиеОтбора,
				"Справочник.КлючиДоступа КАК Шапка?", "Справочник.КлючиДоступа.Шапка КАК Шапка?");
		КонецЕсли;
		
		Если НомерТабличнойЧастиКлюча = 0 Тогда
			УсловиеОтбора = СтрЗаменить(УсловиеОтбора, "Шапка?", "Шапка" + НомерШапки);
		Иначе
			ИмяТабличнойЧасти = "ТабличнаяЧасть" + НомерТабличнойЧастиКлюча;
			УсловиеОтбора = СтрЗаменить(УсловиеОтбора, " КАК", "." + ИмяТабличнойЧасти + " КАК");
			УсловиеОтбора = СтрЗаменить(УсловиеОтбора, "Шапка?", ИмяТабличнойЧасти);
		КонецЕсли;
		
		Контекст.ЧастиУсловияОтбораПоВедущимКлючамДоступа.Добавить(УсловиеОтбора);
	КонецЦикла;
	
КонецПроцедуры

// Для процедур ДобавитьПроверкуШапкиКлюча, ДобавитьПроверкуТабличнойЧастиКлюча.
Функция СоединенияИПоляПоТаблицам(ГруппаПолей, ТабличнаяЧастьКлюча, НомерШапки = 0, ДляВыбораЗначений = Ложь,
			ВГруппеОднаДополнительнаяТаблицаСПолями = Ложь)
	
	СоединенияИПоляПоТаблицам = Новый Соответствие;
	НомерРеквизита = 1 + ?(НомерШапки = 0, 0, 5);
	
	Для Каждого СвойстваПоля Из ГруппаПолей Цикл
		
		СоединенияИПоля = СоединенияИПоляПоТаблицам.Получить(СвойстваПоля.ПсевдонимТаблицы);
		Если СоединенияИПоля = Неопределено Тогда
			СоединенияИПоля = Новый Структура;
			СоединенияИПоля.Вставить("Соединения",       "");
			СоединенияИПоля.Вставить("Поля",             "");
			СоединенияИПоля.Вставить("ПоляУпорядочения", "");
			СоединенияИПоля.Вставить("Реквизиты",        "");
			СоединенияИПоляПоТаблицам.Вставить(СвойстваПоля.ПсевдонимТаблицы, СоединенияИПоля);
		КонецЕсли;
		
		Соединения = "";
		Если СвойстваПоля.ТипыСохраненияКлючейДоступа.Количество() > 0 Тогда
			Соединения = Соединения + "
			|ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.КлючиДоступаКОбъектам КАК КлючиДоступаКОбъектам?
			|ПО (КлючиДоступаКОбъектам?.Объект = #ИмяПоляДляЗапроса)";
		КонецЕсли;
		
		Если СвойстваПоля.ТипыСохраненияГруппЗначений.Количество() > 0 Тогда
			Если Не СвойстваПоля.ЭтоСписокЗначенийДоступаСГруппамиЗначений Тогда
				Соединения = Соединения + "
				|ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений?
				|ПО (ГруппыЗначений?.ЗначениеДоступа = #ИмяПоляДляЗапроса)
				|	И (ГруппыЗначений?.ГруппаДанных = 0)";
			ИначеЕсли СвойстваПоля.НесколькоГруппЗначений Тогда
				Соединения = Соединения + "
				|ЛЕВОЕ СОЕДИНЕНИЕ &ТекущийСписок.ГруппыДоступа КАК ГруппыЗначений?
				|ПО (ГруппыЗначений?.Ссылка = #ИмяПоляДляЗапроса)";
			КонецЕсли;
		КонецЕсли;
		
		Если СвойстваПоля.ТипыСохраненияТиповКонфигурации.Количество() > 0 Тогда
			Соединения = Соединения + "
			|ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ИдентификаторыОбъектовМетаданных КАК ТипыКонфигурации?
			|ПО (#ИмяПоляДляЗапроса <> НЕОПРЕДЕЛЕНО)
			|	И (ТИПЗНАЧЕНИЯ(ТипыКонфигурации?.ЗначениеПустойСсылки) = ТИПЗНАЧЕНИЯ(#ИмяПоляДляЗапроса))";
		КонецЕсли;
		
		Если СвойстваПоля.ТипыСохраненияТиповРасширений.Количество() > 0 Тогда
			Соединения = Соединения + "
			|ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ИдентификаторыОбъектовРасширений КАК ТипыРасширений?
			|ПО (#ИмяПоляДляЗапроса <> НЕОПРЕДЕЛЕНО)
			|	И (ТИПЗНАЧЕНИЯ(ТипыРасширений?.ЗначениеПустойСсылки) = ТИПЗНАЧЕНИЯ(#ИмяПоляДляЗапроса))";
		КонецЕсли;
		
		Поле = СравнениеПоля(СвойстваПоля, ВГруппеОднаДополнительнаяТаблицаСПолями);
		
		Если ДляВыбораЗначений Тогда
			Поле = СтрЗаменить(Поле, "Шапка?.Значение? = ", "");
			Поле = СтрЗаменить(Поле, "						", "			");
			Позиция = СтрДлина(Символы.ПС + "И ()");
			Поле = "," + Символы.ПС + Сред(Поле, Позиция, СтрДлина(Поле) - Позиция) + " КАК Значение?";
			
			СоединенияИПоля.ПоляУпорядочения = СоединенияИПоля.ПоляУпорядочения
				+ ", " + "Значение" + НомерРеквизита;
			
			СоединенияИПоля.Реквизиты  = СоединенияИПоля.Реквизиты + ",
			|Шапка?.Значение"  + НомерРеквизита + " КАК Значение" + НомерРеквизита;
		КонецЕсли;
		
		ЗаполнитьПсевдонимПоНомеруРеквизита(Соединения, Поле, НомерРеквизита, "Значение?");
		ЗаполнитьПсевдонимПоНомеруРеквизита(Соединения, Поле, НомерРеквизита, "ГруппыЗначений?");
		ЗаполнитьПсевдонимПоНомеруРеквизита(Соединения, Поле, НомерРеквизита, "КлючиДоступаКОбъектам?");
		ЗаполнитьПсевдонимПоНомеруРеквизита(Соединения, Поле, НомерРеквизита, "ТипыКонфигурации?");
		ЗаполнитьПсевдонимПоНомеруРеквизита(Соединения, Поле, НомерРеквизита, "ТипыРасширений?");
		
		Соединения = СтрЗаменить(Соединения, "#ИмяПоляДляЗапроса", СвойстваПоля.ИмяПоляДляЗапроса);
		Поле       = СтрЗаменить(Поле,       "#ИмяПоляДляЗапроса", СвойстваПоля.ИмяПоляДляЗапроса);
		
		Если ТабличнаяЧастьКлюча Тогда
			Поле = СтрЗаменить(Поле, "Шапка?", "ТабличнаяЧасть?");
			СоединенияИПоля.Реквизиты = СтрЗаменить(СоединенияИПоля.Реквизиты, "Шапка?", "ТабличнаяЧасть?");
		КонецЕсли;
		
		СоединенияИПоля.Соединения = СоединенияИПоля.Соединения + Соединения;
		СоединенияИПоля.Поля       = СоединенияИПоля.Поля       + Поле;
		НомерРеквизита = НомерРеквизита + 1;
	КонецЦикла;
	
	Возврат СоединенияИПоляПоТаблицам;
	
КонецФункции

// Для функции СоединенияИПоляПоТаблицам.
Функция ВГруппеОднаДополнительнаяТаблицаСПолями(Контекст, ГруппаДополнительныхТаблиц)
	
	Если ГруппаДополнительныхТаблиц = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ГруппаДополнительныхТаблиц.Количество() = 1 Тогда
		Возврат Истина;
	КонецЕсли;
	
	ПсевдонимыТаблицСПолями = Контекст.ГруппыДополнительныхТаблиц.ПсевдонимыТаблицСПолями;
	
	КоличествоДополнительныхТаблицСПолями = 0;
	Для Каждого ДополнительнаяТаблица Из ГруппаДополнительныхТаблиц Цикл
		Если ПсевдонимыТаблицСПолями.Получить(ДополнительнаяТаблица.Псевдоним) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		КоличествоДополнительныхТаблицСПолями = КоличествоДополнительныхТаблицСПолями + 1;
	КонецЦикла;
	
	Возврат КоличествоДополнительныхТаблицСПолями = 1;
	
КонецФункции

// Для функции СоединенияИПоляПоТаблицам.
Функция СравнениеПоля(СвойстваПоля, ВГруппеОднаДополнительнаяТаблицаСПолями)
	
	КоличествоТиповПоля = СвойстваПоля.ТипКонечногоПоля.Типы().Количество();
	
	БезЗначенияНеопределено = КоличествоТиповПоля = 1;
	Если СвойстваПоля.Свойство("БезЗначенияNull") Тогда
		БезЗначенияNull = СвойстваПоля.БезЗначенияNull;
	Иначе
		БезЗначенияNull = БезЗначенияNull(СвойстваПоля, ВГруппеОднаДополнительнаяТаблицаСПолями);
	КонецЕсли;
	
	БезУточненияНеопределено = Не СвойстваПоля.ЕстьУточнениеНеопределено Или БезЗначенияНеопределено;
	БезУточненияNull         = Не СвойстваПоля.ЕстьУточнениеNull         Или БезЗначенияNull;
	
	// Сохранение только ключей доступа.
	Если СвойстваПоля.ТипыСохраненияПустойСсылки.Количество() = 0
	   И БезУточненияНеопределено
	   И БезУточненияNull
	   И СвойстваПоля.ТипыСохраненияКлючейДоступа.Количество() = КоличествоТиповПоля Тогда
		Возврат "
		|И (Шапка?.Значение? = ЕСТЬNULL(КлючиДоступаКОбъектам?.#КлючДоступаПользователейКОбъекту,
		|						ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.Null)))";
	КонецЕсли;
	
	// Сохранение только групп значений доступа.
	Если СвойстваПоля.ТипыСохраненияПустойСсылки.Количество() = 0
	   И БезУточненияНеопределено
	   И БезУточненияNull
	   И СвойстваПоля.ТипыСохраненияГруппЗначений.Количество() = КоличествоТиповПоля Тогда
		
		Если Не СвойстваПоля.ЭтоСписокЗначенийДоступаСГруппамиЗначений Тогда
			Возврат "
			|И (Шапка?.Значение? = ЕСТЬNULL(ГруппыЗначений?.ГруппаЗначенийДоступа,
			|						ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.Null)))";
		ИначеЕсли СвойстваПоля.НесколькоГруппЗначений Тогда
			Возврат "
			|И (Шапка?.Значение? = ЕСТЬNULL(ГруппыЗначений?.ГруппаДоступа,
			|						ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.Null)))";
		Иначе
			Возврат "
			|И (Шапка?.Значение? = ЕСТЬNULL(ТекущийСписок.ГруппаДоступа,
			|						ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.Null)))";
		КонецЕсли;
	КонецЕсли;
	
	// Сохранение только значений.
	Если Не ЕстьПростойТип(СвойстваПоля.ТипКонечногоПоля)
	   И КоличествоТиповПоля = 1
	   И СвойстваПоля.ТипыСохраненияЗначений.Количество() = КоличествоТиповПоля Тогда
		
		Если БезЗначенияNull Тогда
			Возврат "
			|И (Шапка?.Значение? = #ИмяПоляДляЗапроса)";
		Иначе
			Возврат "
			|И (Шапка?.Значение? = ЕСТЬNULL(#ИмяПоляДляЗапроса,
			|						ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.Null)))";
		КонецЕсли;
	КонецЕсли;
	
	// Сохранение одного ссылочного типа.
	Если БезУточненияNull
	   И КоличествоТиповПоля = 1
	   И СвойстваПоля.ТипыСохраненияТипов.Количество() = КоличествоТиповПоля
	   И СвойстваПоля.ТипыСохраненияТиповПростых.Количество() = 0 Тогда
		
		Если СвойстваПоля.ТипыСохраненияТиповРасширений.Количество() = 0 Тогда
			Возврат "
			|И (Шапка?.Значение? = ЕСТЬNULL(ТипыКонфигурации?.Ссылка,
			|						ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)))";
		ИначеЕсли СвойстваПоля.ТипыСохраненияТиповКонфигурации.Количество() = 0 Тогда
			Возврат "
			|И (Шапка?.Значение? = ЕСТЬNULL(ТипыРасширений?.Ссылка,
			|						ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовРасширений.ПустаяСсылка)))";
		КонецЕсли;
	КонецЕсли;
	
	// Сохранение одного простого типа.
	Если БезУточненияNull
	   И КоличествоТиповПоля = 1
	   И СвойстваПоля.ТипыСохраненияТиповПростых.Количество() = 1 Тогда
		
		Возврат "
		|И (Шапка?.Значение? = ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.ТипРазрешенный))";
	КонецЕсли;
	
	Если СвойстваПоля.ТипыСохраненияТипаЗапрещенный.Количество() = КоличествоТиповПоля Тогда
		Возврат "
		|И (Шапка?.Значение? = ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.ТипЗапрещенный))";
	КонецЕсли;
	
	// Сохранение только значения ТипРазрешенный.
	Если СвойстваПоля.ТипыСохраненияТипаРазрешенный.Количество() = КоличествоТиповПоля Тогда
		Возврат "
		|И (Шапка?.Значение? = ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.ТипРазрешенный))";
	КонецЕсли;
	
	СравнениеПоля = "
	|И (ВЫБОР
	|	#СодержаниеВыбора
	|КОНЕЦ)";
	СодержаниеВыбора = "";
	
	СохранениеЗначенияБулево = СвойстваПоля.ТипыСохраненияЗначений.Найти(Тип("Булево")) <> Неопределено;
	
	Если Не БезЗначенияNull
	   И Не (СохранениеЗначенияБулево И КоличествоТиповПоля = 1) Тогда
		СодержаниеВыбора = СодержаниеВыбора + "
		|КОГДА #ИмяПоляДляЗапроса ЕСТЬ NULL
		|	ТОГДА Шапка?.Значение? = ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.Null)";
	КонецЕсли;
	Если КоличествоТиповПоля > 1 Тогда
		СодержаниеВыбора = СодержаниеВыбора + "
		|КОГДА #ИмяПоляДляЗапроса = НЕОПРЕДЕЛЕНО
		|	ТОГДА Шапка?.Значение? = ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.Неопределено)";
	КонецЕсли;
	Если СохранениеЗначенияБулево Тогда
		Если КоличествоТиповПоля > 1 Тогда
			СодержаниеВыбора = СодержаниеВыбора + "
			|КОГДА #ИмяПоляДляЗапроса
			|	ТОГДА Шапка?.Значение? = ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.Истина)
			|КОГДА НЕ #ИмяПоляДляЗапроса
			|	ТОГДА Шапка?.Значение? = ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.Ложь)";
		Иначе
			СодержаниеВыбора = СодержаниеВыбора + "
			|КОГДА #ИмяПоляДляЗапроса
			|	ТОГДА Шапка?.Значение? = ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.Истина)
			|ИНАЧЕ Шапка?.Значение? = ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.Ложь)";
		КонецЕсли;
	КонецЕсли;
	
	ПроверкиПоТипам = Новый СписокЗначений;
	
	ДобавитьПроверкуПоТипам(ПроверкиПоТипам, СвойстваПоля.ТипыСохраненияТиповПростых,
		"Шапка?.Значение? = ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.ТипРазрешенный)");
	
	ДобавитьПроверкуПоТипам(ПроверкиПоТипам, СвойстваПоля.ТипыСохраненияКлючейДоступа,
		"Шапка?.Значение? = ЕСТЬNULL(КлючиДоступаКОбъектам?.#КлючДоступаПользователейКОбъекту,
		|					ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.Null))");
	
	Если Не СвойстваПоля.ЭтоСписокЗначенийДоступаСГруппамиЗначений Тогда
		ДобавитьПроверкуПоТипам(ПроверкиПоТипам, СвойстваПоля.ТипыСохраненияГруппЗначений,
			"Шапка?.Значение? = ЕСТЬNULL(ГруппыЗначений?.ГруппаЗначенийДоступа,
			|					ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.Null))");
	ИначеЕсли СвойстваПоля.НесколькоГруппЗначений Тогда
		ДобавитьПроверкуПоТипам(ПроверкиПоТипам, СвойстваПоля.ТипыСохраненияГруппЗначений,
			"Шапка?.Значение? = ЕСТЬNULL(ГруппыЗначений?.ГруппаДоступа,
			|					ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.Null))");
	Иначе
		ДобавитьПроверкуПоТипам(ПроверкиПоТипам, СвойстваПоля.ТипыСохраненияГруппЗначений,
			"Шапка?.Значение? = ЕСТЬNULL(ТекущийСписок.ГруппаДоступа,
			|					ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.Null))");
	КонецЕсли;
	
	ДобавитьПроверкуПоТипам(ПроверкиПоТипам, СвойстваПоля.ТипыСохраненияЗначений,
		"Шапка?.Значение? = #ИмяПоляДляЗапроса", , СохранениеЗначенияБулево);
	
	ДобавитьПроверкуПоТипам(ПроверкиПоТипам, СвойстваПоля.ТипыСохраненияПустойСсылки,
		"Шапка?.Значение? = ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.ПустаяСсылкаЛюбогоТипа)",
		"ЭтоПроверкаПустойСсылки");
	
	ДобавитьПроверкуПоТипам(ПроверкиПоТипам, СвойстваПоля.ТипыСохраненияТиповКонфигурации,
		"Шапка?.Значение? = ЕСТЬNULL(ТипыКонфигурации?.Ссылка,
		|					ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка))");
	
	ДобавитьПроверкуПоТипам(ПроверкиПоТипам, СвойстваПоля.ТипыСохраненияТиповРасширений,
		"Шапка?.Значение? = ЕСТЬNULL(ТипыРасширений?.Ссылка,
		|					ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовРасширений.ПустаяСсылка))");
	
	ДобавитьПроверкуПоТипам(ПроверкиПоТипам, СвойстваПоля.ТипыСохраненияТипаЗапрещенный,
		"Шапка?.Значение? = ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.ТипЗапрещенный)");
	
	ДобавитьПроверкуПоТипам(ПроверкиПоТипам, СвойстваПоля.ТипыСохраненияТипаРазрешенный,
		"Шапка?.Значение? = ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.ТипРазрешенный)");
	
	ПроверкиПоТипам.СортироватьПоПредставлению();
	
	Для Каждого ПроверкаПоТипам Из ПроверкиПоТипам Цикл
		Если ПроверкаПоТипам.Значение.Типы.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли;
		Если ПроверкиПоТипам.Индекс(ПроверкаПоТипам) < ПроверкиПоТипам.Количество() - 1 Тогда
			ПроверкаТипов = "";
			Для Каждого Тип Из ПроверкаПоТипам.Значение.Типы Цикл
				Если ЭтоПростойТип(Тип) Тогда
					ИмяТипа = Строка(Тип);
				Иначе
					ИмяТипа = Метаданные.НайтиПоТипу(Тип).ПолноеИмя();
				КонецЕсли;
				Если ПроверкаТипов <> "" Тогда
					ПроверкаТипов = ПроверкаТипов + "
					|			ИЛИ ";
				КонецЕсли;
				ШаблонПроверки = ?(ПроверкаПоТипам.Значение.Свойство("ЭтоПроверкаПустойСсылки"),
					"#ИмяПоляДляЗапроса = ЗНАЧЕНИЕ(#ИмяТипа.ПустаяСсылка)",
					"ТИПЗНАЧЕНИЯ(#ИмяПоляДляЗапроса) = ТИП(#ИмяТипа)");
				ПроверкаТипов = ПроверкаТипов + СтрЗаменить(ШаблонПроверки, "#ИмяТипа", ИмяТипа);
			КонецЦикла;
			Проверка = "
			|КОГДА #ПроверкаТипов
			|	ТОГДА #Проверка";
			Проверка = СтрЗаменить(Проверка, "#ПроверкаТипов", ПроверкаТипов);
		Иначе
			Проверка = "
			|ИНАЧЕ #Проверка";
		КонецЕсли;
		Проверка = СтрЗаменить(Проверка, "#Проверка", ПроверкаПоТипам.Значение.Проверка);
		СодержаниеВыбора = СодержаниеВыбора + Проверка;
	КонецЦикла;
	
	Возврат СтрЗаменить(СравнениеПоля, "#СодержаниеВыбора", ТекстСОтступом(СокрЛ(СодержаниеВыбора), "	"));
	
КонецФункции

// Для функции СравнениеПоля.
Процедура ДобавитьПроверкуПоТипам(ПроверкиПоТипам, ИсходныеТипы, Проверка, ДополнительноеСвойство = "", ПропуститьБулево = Ложь)
	
	Типы = Новый Массив;
	Для Каждого Тип Из ИсходныеТипы Цикл
		Если ПропуститьБулево И Тип = Тип("Булево") Тогда
			Продолжить;
		КонецЕсли;
		Типы.Добавить(Тип);
	КонецЦикла;
	
	Если Типы.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Структура = Новый Структура("Типы, Проверка", Типы, Проверка);
	ПроверкиПоТипам.Добавить(Структура, Формат(Структура.Типы.Количество(), "ЧЦ=10; ЧВН=; ЧГ="));
	
	Если ДополнительноеСвойство = "" Тогда
		Возврат;
	КонецЕсли;
	
	Структура.Вставить(ДополнительноеСвойство);
	
КонецПроцедуры

// Для функции ДобавитьПроверкуШапкиКлюча.
Процедура ЗаполнитьПсевдонимПоНомеруРеквизита(Соединения, Поле, НомерРеквизита, Псевдоним)
	
	ПсевдонимСНомером = СтрЗаменить(Псевдоним, "?", НомерРеквизита);
	
	Соединения = СтрЗаменить(Соединения, Псевдоним, ПсевдонимСНомером);
	Поле       = СтрЗаменить(Поле,       Псевдоним, ПсевдонимСНомером);
	
КонецПроцедуры

// Для функций ДобавитьПроверкуШапкиКлюча, СравнениеПоля.
Функция ТекстСОтступом(Текст, Отступ)
	
	Возврат СтрЗаменить(Текст, Символы.ПС, Символы.ПС + Отступ);
	
КонецФункции

// Для функции СравнениеПоля, ДобавитьОпорноеПоле.
Функция ЕстьПростойТип(ОписаниеТипов)
	
	Возврат ОписаниеТипов.СодержитТип(Тип("Булево"))
	    Или ОписаниеТипов.СодержитТип(Тип("Дата"))
	    Или ОписаниеТипов.СодержитТип(Тип("Строка"))
	    Или ОписаниеТипов.СодержитТип(Тип("Число"))
	    Или ОписаниеТипов.СодержитТип(Тип("УникальныйИдентификатор"))
	    Или ОписаниеТипов.СодержитТип(Тип("ХранилищеЗначения"));
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область ПреобразованиеТекстовОграниченийВСтруктуры

// См. УправлениеДоступом.РазобранноеОграничение.
Функция РазобранноеОграничение(ОсновнаяТаблица, ТекстОграничения) Экспорт
	
	ВнутренниеДанные = Новый Структура;
	ВнутренниеДанные.Вставить("ОсновнаяТаблица",  ОсновнаяТаблица);
	ВнутренниеДанные.Вставить("ТекстОграничения", СокрЛП(ТекстОграничения));
	
	ВнутренниеДанные.Вставить("СинтаксисЯзыка", УправлениеДоступомСлужебныйПовтИсп.СинтаксисЯзыка());
	ВнутренниеДанные.Вставить("ПоляТаблиц",     Новый Соответствие);
	ВнутренниеДанные.Вставить("Псевдонимы",     Новый Соответствие);
	
	ВнутренниеДанные.Вставить("ПоляКлючаДоступа", Новый Массив);
	
	ВнутренниеДанные.Вставить("ТаблицаНаборовСимволов", ТаблицаНаборовСимволов(ВнутренниеДанные));
	ВнутренниеДанные.Вставить("ЧастиОграничения",       ЧастиОграничения(ВнутренниеДанные));
	
	Результат = Новый Структура;
	Результат.Вставить("ВнутренниеДанные", ВнутренниеДанные);
	Результат.Вставить("ПоляТаблиц", ВнутренниеДанные.ПоляТаблиц);
	
	Возврат Результат;
	
КонецФункции

// См. УправлениеДоступом.СтруктураОграничения.
//
// Параметры:
//  РазобранноеОграничение - см. УправлениеДоступом.СтруктураОграничения.РазобранноеОграничение
//
// Возвращаемое значение:
//  См. УправлениеДоступом.СтруктураОграничения
//
Функция СтруктураОграничения(РазобранноеОграничение) Экспорт
	
	ВнутренниеДанные = РазобранноеОграничение.ВнутренниеДанные;
	
	ОтметитьНекорректныеИменаТаблицПолейИТиповПолей(РазобранноеОграничение.ПоляТаблиц,
		ВнутренниеДанные);
	
	// Заполнение найденных ошибок.
	ОписаниеОшибок = Новый Структура;
	ОписаниеОшибок.Вставить("ЕстьОшибки",  Ложь);
	ОписаниеОшибок.Вставить("ТекстОшибок", "");
	ОписаниеОшибок.Вставить("Ограничение", "");
	ОписаниеОшибок.Вставить("Ошибки",      Новый Массив);
	ОписаниеОшибок.Вставить("Дополнение",  "");
	
	Таблица = ВнутренниеДанные.ТаблицаНаборовСимволов;
	ОтборСтрокБезОшибок = Новый Структура("ТекстОшибки", "");
	Если Таблица.Количество() <> Таблица.НайтиСтроки(ОтборСтрокБезОшибок).Количество() Тогда
		ОписаниеОшибок.ЕстьОшибки = Истина;
		ТребуетсяДополнение = Ложь;
		ДлинаНомераСтроки = СтрДлина(Формат(СтрЧислоСтрок(ВнутренниеДанные.ТекстОграничения), "ЧГ="));
		Для Каждого Строка Из Таблица Цикл
			Если Строка.ТекстОшибки = "" Тогда
				Продолжить;
			КонецЕсли;
			ДобавитьОшибку(Строка, ОписаниеОшибок, ВнутренниеДанные, ДлинаНомераСтроки);
			Если Строка.ПозицияОшибки = -1 Тогда
				ТребуетсяДополнение = Истина;
			КонецЕсли;
		КонецЦикла;
		ОписаниеОшибок.Ограничение = ПронумерованныйТекстОграниченияСОтметкамиОшибок(
			ВнутренниеДанные.ТекстОграничения, ОписаниеОшибок.Ошибки, ДлинаНомераСтроки);
		Если ТребуетсяДополнение Тогда
			ОписаниеОшибок.Дополнение = ОписаниеДопустимыхШаблонов();
		КонецЕсли;
	КонецЕсли;
	
	ЧастиОграничения = ВнутренниеДанные.ЧастиОграничения;
	
	СтруктураОграничения = Новый Структура;
	СтруктураОграничения.Вставить("ОписаниеОшибок",           ОписаниеОшибок);
	СтруктураОграничения.Вставить("ДополнительныеТаблицы",    ЧастиОграничения.ДополнительныеТаблицы);
	СтруктураОграничения.Вставить("ПсевдонимОсновнойТаблицы", ЧастиОграничения.ПсевдонимОсновнойТаблицы);
	СтруктураОграничения.Вставить("ОграничениеЧтения",        ЧастиОграничения.ОграничениеЧтения);
	СтруктураОграничения.Вставить("ОграничениеИзменения",     ЧастиОграничения.ОграничениеИзменения);
	
	// Дополнительные сведения для внутреннего использования.
	ИмяТипаТаблицы = СтрРазделить(ВнутренниеДанные.ОсновнаяТаблица, ".")[0];
	СвойстваТипаТаблиц = ВнутренниеДанные.СинтаксисЯзыка.ТипыТаблиц.ПоИменам.Получить(ВРег(ИмяТипаТаблицы));
	
	НовыеВнутренниеДанные = Новый Структура;
	НовыеВнутренниеДанные.Вставить("ПоляКлючаДоступа",   ВнутренниеДанные.ПоляКлючаДоступа);
	НовыеВнутренниеДанные.Вставить("ЭтоСсылочныйТип",    СвойстваТипаТаблиц.ЭтоСсылочныйТип);
	НовыеВнутренниеДанные.Вставить("ИмяКоллекцииТипа",   СвойстваТипаТаблиц.ИмяКоллекции);
	НовыеВнутренниеДанные.Вставить("ТипыТаблицПоИменам", ВнутренниеДанные.СинтаксисЯзыка.ТипыТаблиц.ПоИменам);
	
	СтруктураОграничения.Вставить("ВнутренниеДанные", НовыеВнутренниеДанные);
	
	Для Каждого Строка Из ВнутренниеДанные.ТаблицаНаборовСимволов Цикл
		Строка.Строки.Очистить();
		Строка.КонечнаяСтрока = Неопределено;
	КонецЦикла;
	ВнутренниеДанные.ТаблицаНаборовСимволов.Очистить();
	ВнутренниеДанные.ЧастиОграничения.Очистить();
	ВнутренниеДанные.Очистить();
	
	Возврат СтруктураОграничения;
	
КонецФункции

// Формирует полный текст ошибок описания ограничения доступа с дополнением,
// который можно указать, как текст для вызова исключения.
//
// Параметры:
//  ПолноеИмя               - Строка    - полное имя таблицы списка.
//  ОписаниеОшибок          - Структура - значение возвращаемое функцией СтруктураОграничения.
//  ДляВнешнихПользователей - Булево    - если передать Истина, тогда текст ошибки будет содержать
//                                        назначение ограничения для внешних пользователей.
//
// Возвращаемое значение:
//  Строка - текст для вызова исключения.
//
Функция ТекстОшибокДляВызоваИсключения(ПолноеИмя, ОписаниеОшибок, ДляВнешнихПользователей, ВМодулеМенеджера)
	
	Если Не ОписаниеОшибок.ЕстьОшибки Тогда
		Возврат "";
	КонецЕсли;
	
	Если ОписаниеОшибок.Ошибки.Количество() = 1 Тогда
		Если ВМодулеМенеджера = Неопределено Тогда
			Если ДляВнешнихПользователей Тогда
				ЗаголовокОшибки = 
					НСтр("ru = 'Ошибка в ограничении доступа внешних пользователей к списку ""%1"":'");
			Иначе
				ЗаголовокОшибки = 
					НСтр("ru = 'Ошибка в ограничении доступа пользователей к списку ""%1"":'");
			КонецЕсли;
		ИначеЕсли ВМодулеМенеджера Тогда
			Если ДляВнешнихПользователей Тогда
				ЗаголовокОшибки = 
					НСтр("ru = 'Ошибка в ограничении доступа внешних пользователей к списку ""%1"",
					           |указанному в процедуре ПриЗаполненииОграниченияДоступа модуля менеджера объекта метаданных:'");
			Иначе
				ЗаголовокОшибки = 
					НСтр("ru = 'Ошибка в ограничении доступа пользователей к списку ""%1"",
					           |указанному в процедуре ПриЗаполненииОграниченияДоступа модуля менеджера объекта метаданных:'");
			КонецЕсли;
		Иначе
			Если ДляВнешнихПользователей Тогда
				ЗаголовокОшибки = 
					НСтр("ru = 'Ошибка в ограничении доступа внешних пользователей к списку ""%1"",
					           |указанному в процедуре УправлениеДоступомПереопределяемый.ПриЗаполненииОграниченияДоступа:'");
			Иначе
				ЗаголовокОшибки = 
					НСтр("ru = 'Ошибка в ограничении доступа пользователей к списку ""%1"",
					           |указанному в процедуре УправлениеДоступомПереопределяемый.ПриЗаполненииОграниченияДоступа:'");
			КонецЕсли;
		КонецЕсли;
	Иначе
		Если ВМодулеМенеджера = Неопределено Тогда
			Если ДляВнешнихПользователей Тогда
				ЗаголовокОшибки = 
					НСтр("ru = 'Ошибки в ограничении доступа внешних пользователей к списку ""%1"":'");
			Иначе
				ЗаголовокОшибки = 
					НСтр("ru = 'Ошибки в ограничении доступа пользователей к списку ""%1"":'");
			КонецЕсли;
		ИначеЕсли ВМодулеМенеджера Тогда
			Если ДляВнешнихПользователей Тогда
				ЗаголовокОшибки = 
					НСтр("ru = 'Ошибки в ограничении доступа внешних пользователей к списку ""%1"",
					           |указанному в процедуре ПриЗаполненииОграниченияДоступа модуля менеджера объекта метаданных:'");
			Иначе
				ЗаголовокОшибки = 
					НСтр("ru = 'Ошибки в ограничении доступа пользователей к списку ""%1"",
					           |указанному в процедуре ПриЗаполненииОграниченияДоступа модуля менеджера объекта метаданных:'");
			КонецЕсли;
		Иначе
			Если ДляВнешнихПользователей Тогда
				ЗаголовокОшибки = 
					НСтр("ru = 'Ошибки в ограничении доступа внешних пользователей к списку ""%1"",
					           |указанному в процедуре УправлениеДоступомПереопределяемый.ПриЗаполненииОграниченияДоступа:'");
			Иначе
				ЗаголовокОшибки = 
					НСтр("ru = 'Ошибки в ограничении доступа пользователей к списку ""%1"",
					           |указанному в процедуре УправлениеДоступомПереопределяемый.ПриЗаполненииОграниченияДоступа:'");
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ЗаголовокОшибки, ПолноеИмя);
	ТекстОшибки = ТекстОшибки + Символы.ПС + Символы.ПС + ОписаниеОшибок.ТекстОшибок;
	ТекстОшибки = ТекстОшибки + Символы.ПС + Символы.ПС + ОписаниеОшибок.Ограничение;
	
	Если ЗначениеЗаполнено(ОписаниеОшибок.Дополнение) Тогда
		ТекстОшибки = ТекстОшибки + Символы.ПС + Символы.ПС + ОписаниеОшибок.Дополнение;
	КонецЕсли;
	
	Возврат Символы.ПС + ТекстОшибки + Символы.ПС;
	
КонецФункции

// Для функции СтруктураОграничения.
Процедура ДобавитьОшибку(Строка, ОписаниеОшибок, ВнутренниеДанные, ДлинаНомераСтроки)
	
	ПозицияВТексте = Строка.Позиция;
	ПозицияОшибкиВКонцеСтроки = Ложь;
	ТекстОграничения = ВнутренниеДанные.ТекстОграничения;
	
	Если Строка.ПозицияОшибки > 0 Тогда
		ПозицияВТексте = ПозицияВТексте + Строка.ПозицияОшибки;
		Если Строка.ПозицияОшибки = СтрДлина(Строка.Символы) Тогда
			ПозицияВТексте = ПозицияВТексте - 1;
			ПозицияОшибкиВКонцеСтроки = Истина;
		КонецЕсли;
	ИначеЕсли Строка.Позиция > СтрДлина(ТекстОграничения) Тогда
		ПозицияВТексте = ПозицияВТексте - 1;
		ПозицияОшибкиВКонцеСтроки = Истина;
	КонецЕсли;
	
	Координаты = КоординатыПозицииВТексте(ТекстОграничения, ПозицияВТексте);
	Координаты.ПозицияВСтроке = Координаты.ПозицияВСтроке + ?(ПозицияОшибкиВКонцеСтроки, 1, 0);
	
	СтрокаОшибки = СтрПолучитьСтроку(ТекстОграничения, Координаты.НомерСтроки);
	СтрокаОшибки = Лев(СтрокаОшибки, Координаты.ПозицияВСтроке - 1)
		+ "<<?>>" + Сред(СтрокаОшибки, Координаты.ПозицияВСтроке);
	
	Ошибка = Новый Структура;
	Ошибка.Вставить("НомерСтроки",    Координаты.НомерСтроки);
	Ошибка.Вставить("ПозицияВСтроке", Координаты.ПозицияВСтроке);
	Ошибка.Вставить("ТекстОшибки",    Строка.ТекстОшибки);
	Ошибка.Вставить("СтрокаОшибки",   СтрокаОшибки);
	
	ОписаниеОшибок.Ошибки.Добавить(Ошибка);
	
	Если ЗначениеЗаполнено(ОписаниеОшибок.ТекстОшибок) Тогда
		ОписаниеОшибок.ТекстОшибок = ОписаниеОшибок.ТекстОшибок + Символы.ПС + Символы.ПС;
	КонецЕсли;
	
	ОписаниеОшибок.ТекстОшибок = ОписаниеОшибок.ТекстОшибок
		+ "{(" + Формат(Ошибка.НомерСтроки, "ЧЦ=" + ДлинаНомераСтроки + "; ЧВН=; ЧГ=")
		+ ", " + Формат(Ошибка.ПозицияВСтроке, "ЧГ=") + ")}:"
		+ " " + Ошибка.ТекстОшибки + Символы.ПС + Ошибка.СтрокаОшибки;
	
КонецПроцедуры

// Для функции СтруктураОграничения.
Функция ПронумерованныйТекстОграниченияСОтметкамиОшибок(ТекстОграничения, Ошибки, ДлинаНомераСтроки)
	
	КоличествоСтрок = СтрЧислоСтрок(ТекстОграничения);
	СтрокиТекстаОграничений = Новый Массив;
	
	Для НомерСтроки = 1 По КоличествоСтрок Цикл
		Строка = СтрПолучитьСтроку(ТекстОграничения, НомерСтроки);
		СтрокиТекстаОграничений.Добавить(Строка);
	КонецЦикла;
	
	Индекс = Ошибки.Количество() - 1;
	Пока Индекс >= 0 Цикл
		Ошибка = Ошибки[Индекс];
		Строка = СтрокиТекстаОграничений[Ошибка.НомерСтроки - 1];
		СтрокиТекстаОграничений[Ошибка.НомерСтроки - 1] = Лев(Строка, Ошибка.ПозицияВСтроке - 1)
			+ "<<?>>" + Сред(Строка, Ошибка.ПозицияВСтроке);
		Индекс = Индекс - 1;
	КонецЦикла;
	
	Текст = "";
	НомерСтроки = 1;
	
	Для Каждого Строка Из СтрокиТекстаОграничений Цикл
		Текст = Текст + ?(Текст = "", "", Символы.ПС)
			+ ?(СтрНайти(Строка, "<<?>>") > 0, "*", " ")
			+ " " + Формат(НомерСтроки, "ЧЦ=" + ДлинаНомераСтроки + "; ЧВН=; ЧГ=") + " " + Строка;
		НомерСтроки = НомерСтроки + 1;
	КонецЦикла;
	
	Возврат Текст;
	
КонецФункции

// Для функции СтруктураОграничения.
Функция ОписаниеДопустимыхШаблонов()
	
	Если ВариантВстроенногоЯзыкаРусский() Тогда
		Шаблон1 =
		"        РазрешитьЧтениеИзменение
		|        ГДЕ ...";
		
		Шаблон2 =
		"        РазрешитьЧтение
		|        ГДЕ ...
		|        ;
		|        РазрешитьИзменениеЕслиРазрешеноЧтение
		|        ГДЕ ...";
		
		Шаблон3 =
		"        ПрисоединитьДополнительныеТаблицы
		|        ЭтотСписок КАК <Псевдоним>
		|        ЛЕВОЕ СОЕДИНЕНИЕ ...
		|        ;
		|        РазрешитьЧтение
		|        ГДЕ ...
		|        ;
		|        РазрешитьИзменениеЕслиРазрешеноЧтение
		|        ГДЕ ...";
	Иначе
		Шаблон1 =
		"        AllowReadWrite
		|        WHERE ...";
		
		Шаблон2 =
		"        AllowRead
		|        WHERE ...
		|        ;
		|        AllowWriteIfAllowRead
		|        WHERE ...";
		
		Шаблон3 =
		"        AttachAdditionalTables
		|        LIST AS <Alias>
		|        LEFT/INNER JOIN ...
		|        ;
		|        AllowRead
		|        WHERE ...
		|        ;
		|        AllowWriteIfAllowRead
		|        WHERE ...";
	КонецЕсли;
	
	Описание = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Ограничение может состоять из 1-3 частей в одном из 4 вариантов:
		           |1) одинаковое ограничение чтения и изменения:
		           |%1
		           |2) разные ограничения чтения и изменения:
		           |%2
		           |3) любой из вариантов выше с дополнительными таблицами, например:
		           |%3'"),
		Шаблон1, Шаблон2, Шаблон3);
	
	Возврат Описание;
	
КонецФункции

// Для процедуры ДобавитьОшибку.
Функция КоординатыПозицииВТексте(Текст, ПозицияВТексте)
	
	Результат = Новый Структура;
	Результат.Вставить("НомерСтроки", 0);
	Результат.Вставить("ПозицияВСтроке", 0);
	
	КоличествоСтрок = СтрЧислоСтрок(Текст);
	ПозицияНачалаСтроки = 1;
	Для НомерСтроки = 1 По КоличествоСтрок Цикл
		ДлинаТекущейСтроки = СтрДлина(СтрПолучитьСтроку(Текст, НомерСтроки));
		Если ПозицияВТексте < ПозицияНачалаСтроки + ДлинаТекущейСтроки Тогда
			Прервать;
		КонецЕсли;
		ПозицияНачалаСтроки = ПозицияНачалаСтроки + ДлинаТекущейСтроки + 1;
	КонецЦикла;
	
	Результат.НомерСтроки = НомерСтроки;
	Результат.ПозицияВСтроке = ПозицияВТексте - ПозицияНачалаСтроки + 1;
	
	Возврат Результат;
	
КонецФункции

#Область ЛексическийАнализ

// Для функции РазобранноеОграничение.
// Раскладывает текст в таблицу наборов символов, в которых:
// - нет символов отступа (пробелов, табуляций, переводов строки);
// - выделены символы произвольных строк и чисел;
// - определены ключевые слова и операции;
// - проверен формат имен и чисел;
// - добавлены ошибки с описанием.
// 
// Параметры:
//  ТекстОграничения - Строка - текст ограничения доступа.
//
// Возвращаемое значение:
//  ТаблицаЗначений - с колонками:
//    * Символы       - Строка - символ, пара символов или слово.
//    * Позиция       - Число  - позиция символов в тексте ограничения.
//    * Вид           - Строка - "КлючевоеСлово", "Операция", "Имя", "Разделитель",
//                               "Число", "ПроизвольнаяСтрока", "НедопустимыйСимвол", "Конец".
//    * Тип           - Строка - тип для для видов "КлючевоеСлово" и "Операция".
//    * Приоритет     - Число  - приоритет для видов "КлючевоеСлово" и "Операция".
//    * Уточнение     - Число  - числовое значение для вида "Число".
//                    - Строка - имя для вида "КлючевоеСлово", строка символов для вида "ПроизвольнаяСтрока".
//    * ЭтоРезерв     - Булево - если Истина, значит это зарезервированная операция или ключевое слово.
//    * ПозицияОшибки - Число  - позиция ошибки в тексте ограничения, если текст ошибки не пустой.
//    * ТекстОшибки   - Строка - текст ошибки, если найдена ошибка.
//
Функция ТаблицаНаборовСимволов(ВнутренниеДанные)
	
	ТаблицаНаборовСимволов = Новый ТаблицаЗначений;
	ТаблицаНаборовСимволов.Колонки.Добавить("Символы",       Новый ОписаниеТипов("Строка"));
	ТаблицаНаборовСимволов.Колонки.Добавить("Позиция",       Новый ОписаниеТипов("Число"));
	ТаблицаНаборовСимволов.Колонки.Добавить("Вид",           Новый ОписаниеТипов("Строка"));
	ТаблицаНаборовСимволов.Колонки.Добавить("Тип",           Новый ОписаниеТипов("Строка"));
	ТаблицаНаборовСимволов.Колонки.Добавить("Приоритет",     Новый ОписаниеТипов("Число"));
	ТаблицаНаборовСимволов.Колонки.Добавить("Уточнение",     Новый ОписаниеТипов("Число, Строка"));
	ТаблицаНаборовСимволов.Колонки.Добавить("ЭтоРезерв",     Новый ОписаниеТипов("Булево"));
	ТаблицаНаборовСимволов.Колонки.Добавить("ПозицияОшибки", Новый ОписаниеТипов("Число"));
	ТаблицаНаборовСимволов.Колонки.Добавить("ТекстОшибки",   Новый ОписаниеТипов("Строка"));
	
	ТекстОграничения = ВнутренниеДанные.ТекстОграничения;
	
	Если Не ЗначениеЗаполнено(ТекстОграничения) Тогда
		Возврат ТаблицаНаборовСимволов;
	КонецЕсли;
	
	ДлинаТекстаОграничения = СтрДлина(ТекстОграничения);
	
	СинтаксисЯзыка = ВнутренниеДанные.СинтаксисЯзыка;
	СимволыЯзыка = СинтаксисЯзыка.СимволыЯзыка;
	
	ВидНабораСимволов = ""; // Слово, ПроизвольнаяСтрока, Операция.
	ПозицияНабораСимволов = 0;
	НаборСимволов = Новый Массив;
	СтрокаТаблицы = Неопределено;
	
	Для НомерСимвола = 1 По ДлинаТекстаОграничения Цикл
		Символ = Сред(ТекстОграничения, НомерСимвола, 1);
		ТипСимвола = СимволыЯзыка.Получить(Символ);
		// Сначала обработка символов слов, так как они встречаются наиболее часто.
		Если ТипСимвола = "СимволСлова" И ВидНабораСимволов = "Слово" Тогда
			НаборСимволов.Добавить(Символ);
			Продолжить;
		КонецЕсли;
		// Обработка произвольной строки символов.
		Если ВидНабораСимволов = "ПроизвольнаяСтрока" Тогда
			Если ТипСимвола = "ОграничительСтроки" Тогда
				Если Сред(ТекстОграничения, НомерСимвола + 1, 1) <> Символ Тогда
					СтрокаТаблицы.Уточнение = СтрСоединить(НаборСимволов);
					СтрокаТаблицы.Позиция = ПозицияНабораСимволов;
					НаборСимволов = Новый Массив;
					ВидНабораСимволов = "";
					Продолжить;
				Иначе
					НомерСимвола = НомерСимвола + 1;
				КонецЕсли;
			КонецЕсли;
			НаборСимволов.Добавить(Символ);
			Продолжить;
		КонецЕсли;
		Если ВидНабораСимволов = "Слово" Тогда
			// Вначале цикла уже обработан случай, когда ТипСимвола = "СимволСлова",
			// для остальных типов символов слово завершено и его нужно добавить в дерево.
			ВидНабораСимволов = "";
			ДобавитьСловоВТаблицуНаборовСимволов(ТаблицаНаборовСимволов,
				НаборСимволов, ПозицияНабораСимволов, СинтаксисЯзыка);
			НаборСимволов = Новый Массив;
		КонецЕсли;
		// Обработка набора составных разделителей.
		Если ВидНабораСимволов = "Операция" Тогда
			Если ТипСимвола = "СимволОперации" Тогда
				НаборСимволов.Добавить(Символ);
				Продолжить;
			КонецЕсли;
			ВидНабораСимволов = "";
			ДобавитьОперациюВТаблицуНаборовСимволов(ТаблицаНаборовСимволов,
				НаборСимволов, ПозицияНабораСимволов, СинтаксисЯзыка);
			НаборСимволов = Новый Массив;
		КонецЕсли;
		// Обработка первого символа наборов символов.
		Если ВидНабораСимволов = "" Тогда
			Если ТипСимвола = "СимволСлова" Тогда
				ВидНабораСимволов = "Слово";
				ПозицияНабораСимволов = НомерСимвола;
				НаборСимволов.Добавить(Символ);
				Продолжить;
			КонецЕсли;
			Если ТипСимвола = "СимволОперации" Тогда
				ВидНабораСимволов = "Операция";
				ПозицияНабораСимволов = НомерСимвола;
				НаборСимволов.Добавить(Символ);
				Продолжить;
			КонецЕсли;
			Если ТипСимвола = "ОграничительСтроки" Тогда
				ВидНабораСимволов = "ПроизвольнаяСтрока";
				ПозицияНабораСимволов = НомерСимвола;
				СтрокаТаблицы = ТаблицаНаборовСимволов.Добавить();
				СтрокаТаблицы.Символы = Символ;
				СтрокаТаблицы.Вид = ВидНабораСимволов;
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		// Обработка отдельных символов.
		Если ТипСимвола = "Отступ" Тогда
			Продолжить;
		КонецЕсли;
		Если ТипСимвола = "Разделитель" Тогда
			СтрокаТаблицы = ТаблицаНаборовСимволов.Добавить();
			СтрокаТаблицы.Символы = Символ;
			СтрокаТаблицы.Позиция = НомерСимвола;
			СтрокаТаблицы.Вид = "Разделитель";
			Продолжить;
		КонецЕсли;
		СтрокаТаблицы = ТаблицаНаборовСимволов.Добавить();
		СтрокаТаблицы.Символы = Символ;
		СтрокаТаблицы.Позиция = НомерСимвола;
		СтрокаТаблицы.Вид = "НедопустимыйСимвол";
		СтрокаТаблицы.ТекстОшибки   = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Недопустимый символ ""%1"" с кодом %2'"), Символ, КодСимвола(Символ));
	КонецЦикла;
	
	Если ВидНабораСимволов = "Слово" Тогда
		ДобавитьСловоВТаблицуНаборовСимволов(ТаблицаНаборовСимволов,
			НаборСимволов, ПозицияНабораСимволов, СинтаксисЯзыка);
		
	ИначеЕсли ВидНабораСимволов = "Операция" Тогда
		ДобавитьОперациюВТаблицуНаборовСимволов(ТаблицаНаборовСимволов,
			НаборСимволов, ПозицияНабораСимволов, СинтаксисЯзыка);
		
	ИначеЕсли ВидНабораСимволов = "ПроизвольнаяСтрока" Тогда
		СтрокаТаблицы.Уточнение = СтрСоединить(НаборСимволов);
		СтрокаТаблицы.Позиция = ПозицияНабораСимволов;
		СтрокаТаблицы.ПозицияОшибки = НомерСимвола - ПозицияНабораСимволов;
		СтрокаТаблицы.ТекстОшибки   = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не указан символ окончания произвольной строки %1'"), СтрокаТаблицы.Символы);
	КонецЕсли;
	
	ПоследняяСтрока = ТаблицаНаборовСимволов.Добавить();
	ПоследняяСтрока.Позиция = СтрДлина(ТекстОграничения) + 1;
	ПоследняяСтрока.Вид = "Конец"; // Для установки текста ошибки недостатка описания.
	ТаблицаНаборовСимволов.Индексы.Добавить("Вид, Уточнение");
	
	Возврат ТаблицаНаборовСимволов;
	
КонецФункции

// Для функции ТаблицаНаборовСимволов.
Процедура ДобавитьСловоВТаблицуНаборовСимволов(Таблица,
			НаборСимволов, ПозицияНабораСимволов, СинтаксисЯзыка)
	
	СтрокаСимволов = СтрСоединить(НаборСимволов);
	СвойстваСлова  = СинтаксисЯзыка.СловаЯзыка.Получить(ВРег(СтрокаСимволов));
	
	НоваяСтрока = Таблица.Добавить();
	НоваяСтрока.Символы = СтрокаСимволов;
	НоваяСтрока.Позиция = ПозицияНабораСимволов;
	
	Если СвойстваСлова <> Неопределено Тогда
		НоваяСтрока.Вид       = "КлючевоеСлово";
		НоваяСтрока.Тип       = СвойстваСлова.Тип;
		НоваяСтрока.Приоритет = СвойстваСлова.Приоритет;
		НоваяСтрока.Уточнение = СвойстваСлова.Идентификатор;
		НоваяСтрока.ЭтоРезерв = СвойстваСлова.ЭтоРезерв;
		
		Если СвойстваСлова.ЭтоРезерв Тогда
			НоваяСтрока.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ключевое слово ""%1"" не поддерживается'"), СтрокаСимволов);
		КонецЕсли;
		Возврат;
	КонецЕсли;
	
	// Слово является именем или числом.
	СимволыЦифр = СинтаксисЯзыка.СимволыЦифр;
	
	Если НаборСимволов[0] = "." Тогда
		Если НаборСимволов.Количество() > 1 Тогда
			ЭтоЧисло = Ложь;
		Иначе
			НоваяСтрока.Вид = "Имя";
			НоваяСтрока.ТекстОшибки = НСтр("ru = 'Имя не может начинаться с точки'");
			Возврат;
		КонецЕсли;
	Иначе
		ЭтоЧисло = СимволыЦифр.Получить(НаборСимволов[0]) <> Неопределено;
	КонецЕсли;
	
	Если ЭтоЧисло Тогда
		НоваяСтрока.Вид = "Число";
		НомерСимвола = 1;
		Для Каждого Символ Из НаборСимволов Цикл
			Если СимволыЦифр.Получить(Символ) = Неопределено Тогда
				НоваяСтрока.ПозицияОшибки = НомерСимвола - 1;
				НоваяСтрока.ТекстОшибки   = НСтр("ru = 'Число может состоять только из цифр'");
				Возврат;
			КонецЕсли;
			НомерСимвола = НомерСимвола + 1;
		КонецЦикла;
		СимволыЧисла = Лев(СтрокаСимволов, НомерСимвола - 1);
		Если СтрДлина(СимволыЧисла) > 16 Тогда
			НоваяСтрока.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Слишком большое число ""%1""'"), СимволыЧисла);
			Возврат;
		КонецЕсли;
		НоваяСтрока.Уточнение = Число(СимволыЧисла);
	Иначе
		НоваяСтрока.Вид = "Имя";
		ЧастиИмени = СтрРазделить(СтрокаСимволов, ".");
		ПозицияЧастиИмени = 1;
		Для Каждого ЧастьИмени Из ЧастиИмени Цикл
			Если ЧастьИмени = "" И ПозицияЧастиИмени > 1 Тогда
				НоваяСтрока.ПозицияОшибки = ПозицияЧастиИмени - 1;
				НоваяСтрока.ТекстОшибки   = НСтр("ru = 'После точки не указано имя'");
				Возврат;
			ИначеЕсли СимволыЦифр.Получить(Лев(ЧастьИмени, 1)) <> Неопределено Тогда
				НоваяСтрока.ПозицияОшибки = ПозицияЧастиИмени - 1;
				НоваяСтрока.ТекстОшибки   = НСтр("ru = 'После точки в имени не может следовать число'");
				Возврат;
			КонецЕсли;
			ПозицияЧастиИмени = ПозицияЧастиИмени + СтрДлина(ЧастьИмени) + 1;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Для функции ТаблицаНаборовСимволов.
Процедура ДобавитьОперациюВТаблицуНаборовСимволов(Таблица,
			НаборСимволов, ПозицияНабораСимволов, СинтаксисЯзыка)
	
	СтрокаСимволов = СтрСоединить(НаборСимволов);
	СвойстваОперации = СинтаксисЯзыка.ОперацииЯзыка.Получить(СтрокаСимволов);
	
	НоваяСтрока = Таблица.Добавить();
	НоваяСтрока.Символы   = СтрокаСимволов;
	НоваяСтрока.Позиция   = ПозицияНабораСимволов;
	НоваяСтрока.Вид       = "Операция";
	НоваяСтрока.Тип       = СвойстваОперации.Тип;
	НоваяСтрока.Приоритет = СвойстваОперации.Приоритет;
	НоваяСтрока.ЭтоРезерв = СвойстваОперации.ЭтоРезерв;
	
	Если СвойстваОперации = Неопределено Тогда
		НоваяСтрока.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Недопустимая операция ""%1""'"), СтрокаСимволов);
		
	ИначеЕсли СвойстваОперации.ЭтоРезерв Тогда
		НоваяСтрока.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Операция ""%1"" не поддерживается'"), СтрокаСимволов);
	КонецЕсли;
	
КонецПроцедуры

// Для функции РазобранноеОграничение и косвенно для многих других.
Функция СинтаксисЯзыка() Экспорт
	
	СинтаксисЯзыка = Новый Структура;
	СинтаксисЯзыка.Вставить("СимволыЯзыка",  СимволыЯзыка());
	СинтаксисЯзыка.Вставить("СимволыЦифр",   СимволыЦифр());
	СинтаксисЯзыка.Вставить("ОперацииЯзыка", ОперацииЯзыка());
	СинтаксисЯзыка.Вставить("СловаЯзыка",    СловаЯзыка());
	СинтаксисЯзыка.Вставить("ТипыТаблиц",    ТипыТаблиц());
	
	Возврат Новый ФиксированнаяСтруктура(СинтаксисЯзыка);
	
КонецФункции

// Для функции СинтаксисЯзыка.
Функция СимволыЯзыка()
	
	СимволыЯзыка = Новый Соответствие;
	
	Для КодСимвола = КодСимвола("А") По КодСимвола("Я") Цикл
		СимволыЯзыка.Вставить(Символ(КодСимвола), "СимволСлова");
	КонецЦикла;
	Для КодСимвола = КодСимвола("а") По КодСимвола("я") Цикл
		СимволыЯзыка.Вставить(Символ(КодСимвола), "СимволСлова");
	КонецЦикла;
	Для КодСимвола = КодСимвола("A") По КодСимвола("Z") Цикл
		СимволыЯзыка.Вставить(Символ(КодСимвола), "СимволСлова");
	КонецЦикла;
	Для КодСимвола = КодСимвола("a") По КодСимвола("z") Цикл
		СимволыЯзыка.Вставить(Символ(КодСимвола), "СимволСлова");
	КонецЦикла;
	
	СимволыЯзыка.Вставить("_", "СимволСлова");
	СимволыЯзыка.Вставить(".", "СимволСлова");
	
	Для КодСимвола = КодСимвола("0") По КодСимвола("9") Цикл
		СимволыЯзыка.Вставить(Символ(КодСимвола), "СимволСлова");
	КонецЦикла;
	
	СимволыЯзыка.Вставить(" ",         "Отступ");
	СимволыЯзыка.Вставить(Символы.Таб, "Отступ");
	СимволыЯзыка.Вставить(Символы.ПС,  "Отступ");
	
	СимволыЯзыка.Вставить("""", "ОграничительСтроки");
	
	СимволыЯзыка.Вставить("(", "Разделитель");
	СимволыЯзыка.Вставить(")", "Разделитель");
	СимволыЯзыка.Вставить(",", "Разделитель");
	СимволыЯзыка.Вставить(";", "Разделитель");
	СимволыЯзыка.Вставить("=", "СимволОперации");
	СимволыЯзыка.Вставить("<", "СимволОперации");
	СимволыЯзыка.Вставить(">", "СимволОперации");
	
	// Не поддерживаются.
	СимволыЯзыка.Вставить("+", "СимволОперации");
	СимволыЯзыка.Вставить("-", "СимволОперации");
	СимволыЯзыка.Вставить("*", "СимволОперации");
	СимволыЯзыка.Вставить("/", "СимволОперации");
	
	Возврат Новый ФиксированноеСоответствие(СимволыЯзыка);
	
КонецФункции

// Для функции СинтаксисЯзыка.
Функция СимволыЦифр()
	
	СимволыЦифр = Новый Соответствие;
	
	Для КодСимвола = КодСимвола("0") По КодСимвола("9") Цикл
		СимволыЦифр.Вставить(Символ(КодСимвола), Истина);
	КонецЦикла;
	
	Возврат Новый ФиксированноеСоответствие(СимволыЦифр);
	
КонецФункции

// Для функции СинтаксисЯзыка.
Функция СловаЯзыка()
	
	Слова = Новый Соответствие;
	
	ДобавитьСловоЯзыка(Слова, "ПрисоединитьДополнительныеТаблицы",     "AttachAdditionalTables",      "Начало",       Ложь);
	ДобавитьСловоЯзыка(Слова, "ЭтотСписок",                            "ThisList",                    "НачалоСписок", Ложь);
	ДобавитьСловоЯзыка(Слова, "РазрешитьЧтениеИзменение",              "AllowReadUpdate",             "Начало",       Ложь);
	ДобавитьСловоЯзыка(Слова, "РазрешитьЧтение",                       "AllowRead",                   "Начало",       Ложь);
	ДобавитьСловоЯзыка(Слова, "РазрешитьИзменениеЕслиРазрешеноЧтение", "AllowUpdateIfReadingAllowed", "Начало",       Ложь);
	ДобавитьСловоЯзыка(Слова, "Где",                                   "Where",                       "НачалоГде");
	
	ДобавитьСловоЯзыка(Слова, "Левое",      "Left", "Присоединение");
	ДобавитьСловоЯзыка(Слова, "Соединение", "Join", "Присоединение");
	ДобавитьСловоЯзыка(Слова, "По",         "On",   "Присоединение");
	
	ДобавитьСловоЯзыка(Слова, "И",      "And",    "Соединитель", , 2);
	ДобавитьСловоЯзыка(Слова, "Или",    "Or",     "Соединитель", , 1);
	ДобавитьСловоЯзыка(Слова, "В",      "In",     "Соединитель", , 5);
	ДобавитьСловоЯзыка(Слова, "Как",    "As",     "Соединитель");
	ДобавитьСловоЯзыка(Слова, "Кроме",  "Except", "Соединитель");
	ДобавитьСловоЯзыка(Слова, "Только", "Only",   "Соединитель");
	ДобавитьСловоЯзыка(Слова, "Есть",   "Is",     "Соединитель", , 7);
	ДобавитьСловоЯзыка(Слова, "Не",     "Not",    "Оператор",    , 3);
	
	ДобавитьСловоЯзыка(Слова, "Выбор",  "Case", "СловоВыбора");
	ДобавитьСловоЯзыка(Слова, "Когда",  "When", "СловоВыбора");
	ДобавитьСловоЯзыка(Слова, "Тогда",  "Then", "СловоВыбора");
	ДобавитьСловоЯзыка(Слова, "Иначе",  "Else", "СловоВыбора");
	ДобавитьСловоЯзыка(Слова, "Конец",  "End",  "СловоВыбора");
	
	ДобавитьСловоЯзыка(Слова, "ЕстьNull",                      "IsNull",               "Функция", Ложь);
	ДобавитьСловоЯзыка(Слова, "Выразить",                      "Cast",                 "Функция", Ложь);
	ДобавитьСловоЯзыка(Слова, "Значение",                      "Value",                "Функция", Ложь);
	ДобавитьСловоЯзыка(Слова, "ТипЗначения",                   "ValueType",            "Функция", Ложь);
	ДобавитьСловоЯзыка(Слова, "Тип",                           "Type",                 "Функция", Ложь);
	ДобавитьСловоЯзыка(Слова, "ЗначениеРазрешено",             "ValueAllowed",         "Функция", Ложь);
	ДобавитьСловоЯзыка(Слова, "ЧтениеОбъектаРазрешено",        "ObjectReadingAllowed", "Функция", Ложь);
	ДобавитьСловоЯзыка(Слова, "ИзменениеОбъектаРазрешено",     "ObjectUpdateAllowed",  "Функция", Ложь);
	ДобавитьСловоЯзыка(Слова, "ЧтениеСпискаРазрешено",         "ListReadingAllowed",   "Функция", Ложь);
	ДобавитьСловоЯзыка(Слова, "ИзменениеСпискаРазрешено",      "ListUpdateAllowed",    "Функция", Ложь);
	ДобавитьСловоЯзыка(Слова, "ДляВсехСтрок",                  "ForAllRows",           "Функция", Ложь);
	ДобавитьСловоЯзыка(Слова, "ДляОднойИзСтрок",               "ForAtLeastOneRow",     "Функция", Ложь);
	ДобавитьСловоЯзыка(Слова, "ЭтоАвторизованныйПользователь", "IsAuthorizedUser",     "Функция", Ложь);
	
	ДобавитьСловоЯзыка(Слова, "ПустаяСсылка", "EmptyRef",  "ЗначениеСравнения");
	ДобавитьСловоЯзыка(Слова, "Отключено",    "Disabled",  "ЗначениеСравнения");
	ДобавитьСловоЯзыка(Слова, "Неопределено", "Undefined", "ЗначениеСравнения");
	ДобавитьСловоЯзыка(Слова, "Null",         "Null",      "ЗначениеСравнения");
	ДобавитьСловоЯзыка(Слова, "Ложь",         "False",     "ЗначениеУточнения");
	ДобавитьСловоЯзыка(Слова, "Истина",       "True",      "ЗначениеУточнения");
	
	ДобавитьСловоЯзыка(Слова, "Строка",       "String",    "ИмяТипа");
	ДобавитьСловоЯзыка(Слова, "Число",        "Number",    "ИмяТипа");
	ДобавитьСловоЯзыка(Слова, "Дата",         "Date",      "ИмяТипа");
	ДобавитьСловоЯзыка(Слова, "Булево",       "Boolean",   "ИмяТипа");
	
	// Неподдерживаемые, зарезервированные слова.
	ДобавитьСловоЯзыка(Слова, "Выбрать",             "Select",          "Неопределен",   , , Истина);
	ДобавитьСловоЯзыка(Слова, "Первые",              "Top",             "Неопределен",   , , Истина);
	ДобавитьСловоЯзыка(Слова, "Различные",           "Distinct",        "Неопределен",   , , Истина);
	ДобавитьСловоЯзыка(Слова, "Из",                  "From",            "Неопределен",   , , Истина);
	ДобавитьСловоЯзыка(Слова, "Внутреннее",          "Inner",           "Присоединение", , , Истина);
	ДобавитьСловоЯзыка(Слова, "Полное",              "Full",            "Присоединение", , , Истина);
	ДобавитьСловоЯзыка(Слова, "Сгруппировать",       "Group",           "Неопределен",   , , Истина);
	ДобавитьСловоЯзыка(Слова, "Имеющие",             "Having",          "Неопределен",   , , Истина);
	ДобавитьСловоЯзыка(Слова, "Упорядочить",         "Order",           "Неопределен",   , , Истина);
	ДобавитьСловоЯзыка(Слова, "Итоги",               "Totals",          "Неопределен",   , , Истина);
	ДобавитьСловоЯзыка(Слова, "Год",                 "Year",            "Функция",   Ложь, , Истина);
	ДобавитьСловоЯзыка(Слова, "Квартал",             "Quarter",         "Функция",   Ложь, , Истина);
	ДобавитьСловоЯзыка(Слова, "Месяц",               "Month",           "Функция",   Ложь, , Истина);
	ДобавитьСловоЯзыка(Слова, "ДеньГода",            "DayOfYear",       "Функция",   Ложь, , Истина);
	ДобавитьСловоЯзыка(Слова, "День",                "Day",             "Функция",   Ложь, , Истина);
	ДобавитьСловоЯзыка(Слова, "Неделя",              "Week",            "Функция",   Ложь, , Истина);
	ДобавитьСловоЯзыка(Слова, "ДеньНедели",          "Weekday",         "Функция",   Ложь, , Истина);
	ДобавитьСловоЯзыка(Слова, "Час",                 "Hour",            "Функция",   Ложь, , Истина);
	ДобавитьСловоЯзыка(Слова, "Минута",              "Minute",          "Функция",   Ложь, , Истина);
	ДобавитьСловоЯзыка(Слова, "Секунда",             "Second",          "Функция",   Ложь, , Истина);
	ДобавитьСловоЯзыка(Слова, "НачалоПериода",       "BeginOfPeriod",   "Функция",   Ложь, , Истина);
	ДобавитьСловоЯзыка(Слова, "КонецПериода",        "EndOfPeriod",     "Функция",   Ложь, , Истина);
	ДобавитьСловоЯзыка(Слова, "ДобавитьКДате",       "DateAdd",         "Функция",   Ложь, , Истина);
	ДобавитьСловоЯзыка(Слова, "РазностьДат",         "DateDiff",        "Функция",   Ложь, , Истина);
	ДобавитьСловоЯзыка(Слова, "Сумма",               "Sum",             "Функция",   Ложь, , Истина);
	ДобавитьСловоЯзыка(Слова, "Минимум",             "Min",             "Функция",   Ложь, , Истина);
	ДобавитьСловоЯзыка(Слова, "Максимум",            "Max",             "Функция",   Ложь, , Истина);
	ДобавитьСловоЯзыка(Слова, "Среднее",             "Avg",             "Функция",   Ложь, , Истина);
	ДобавитьСловоЯзыка(Слова, "Количество",          "Count",           "Функция",   Ложь, , Истина);
	ДобавитьСловоЯзыка(Слова, "Представление",       "Presentation",    "Функция",   Ложь, , Истина);
	ДобавитьСловоЯзыка(Слова, "ПредставлениеСсылки", "RefPresentation", "Функция",   Ложь, , Истина);
	
	Возврат Новый ФиксированноеСоответствие(Слова);
	
КонецФункции

// Для функции СинтаксисЯзыка.
Функция ОперацииЯзыка()
	
	ОперацииЯзыка = Новый Соответствие;
	
	ДобавитьСловоЯзыка(ОперацииЯзыка, "=",  "=",  "Соединитель", , 4);
	ДобавитьСловоЯзыка(ОперацииЯзыка, "<>", "<>", "Соединитель", , 4);
	
	// Неподдерживаемые, зарезервированные операции.
	ДобавитьСловоЯзыка(ОперацииЯзыка, "<",  "<",  "Соединитель", , 4, Истина);
	ДобавитьСловоЯзыка(ОперацииЯзыка, "<=", "<=", "Соединитель", , 4, Истина);
	ДобавитьСловоЯзыка(ОперацииЯзыка, ">",  ">",  "Соединитель", , 4, Истина);
	ДобавитьСловоЯзыка(ОперацииЯзыка, ">=", ">=", "Соединитель", , 4, Истина);
	ДобавитьСловоЯзыка(ОперацииЯзыка, "+",  "+",  "Соединитель", , 1, Истина);
	ДобавитьСловоЯзыка(ОперацииЯзыка, "-",  "-",  "Соединитель", , 1, Истина);
	ДобавитьСловоЯзыка(ОперацииЯзыка, "*",  "*",  "Соединитель", , 6, Истина);
	ДобавитьСловоЯзыка(ОперацииЯзыка, "/",  "/",  "Соединитель", , 6, Истина);
	
	Возврат Новый ФиксированноеСоответствие(ОперацииЯзыка);
	
КонецФункции

// Для функций СловаЯзыка и ОперацииЯзыка.
Процедура ДобавитьСловоЯзыка(Слова, ЯзыкРусский, ЯзыкАнглийский, ТипСлова,
			ВерхнийРегистр = Истина, Приоритет = 0, ЭтоРезерв = Ложь)
	
	СвойстваСлова = Новый Структура;
	СвойстваСлова.Вставить("Идентификатор",  ЯзыкРусский);
	СвойстваСлова.Вставить("ЯзыкРусский",    ЯзыкРусский);
	СвойстваСлова.Вставить("ЯзыкАнглийский", ЯзыкАнглийский);
	СвойстваСлова.Вставить("Тип",            ТипСлова);
	СвойстваСлова.Вставить("ВерхнийРегистр", ВерхнийРегистр);
	СвойстваСлова.Вставить("Приоритет",      Приоритет);
	СвойстваСлова.Вставить("ЭтоРезерв",      ЭтоРезерв);
	
	СвойстваСлова = Новый ФиксированнаяСтруктура(СвойстваСлова);
	
	Слова.Вставить(ВРег(ЯзыкРусский),    СвойстваСлова);
	Слова.Вставить(ВРег(ЯзыкАнглийский), СвойстваСлова);
	
КонецПроцедуры

// Для функции СинтаксисЯзыка.
Функция ТипыТаблиц()
	
	ТипыТаблиц = Новый Структура;
	ТипыТаблиц.Вставить("ПоИменам",     Новый Соответствие);
	ТипыТаблиц.Вставить("ПоКоллекциям", Новый Соответствие);
	
	// Установка имен типов таблиц.
	ДобавитьТипТаблиц(ТипыТаблиц, "ПланОбмена",             "ExchangePlan",               "ПланыОбмена");
	ДобавитьТипТаблиц(ТипыТаблиц, "КритерийОтбора",         "FilterCriterion",            "КритерииОтбора");
	ДобавитьТипТаблиц(ТипыТаблиц, "Константы",              "Constants",                  "");
	ДобавитьТипТаблиц(ТипыТаблиц, "Константа",              "Constant",                   "Константы");
	ДобавитьТипТаблиц(ТипыТаблиц, "Справочник",             "Catalog",                    "Справочники");
	ДобавитьТипТаблиц(ТипыТаблиц, "Последовательность",     "Sequence",                   "Последовательности");
	ДобавитьТипТаблиц(ТипыТаблиц, "Документ",               "Document",                   "Документы");
	ДобавитьТипТаблиц(ТипыТаблиц, "ЖурналДокументов",       "DocumentJournal",            "ЖурналыДокументов");
	ДобавитьТипТаблиц(ТипыТаблиц, "Перечисление",           "Enum",                       "Перечисления");
	ДобавитьТипТаблиц(ТипыТаблиц, "ПланВидовХарактеристик", "ChartOfCharacteristicTypes", "ПланыВидовХарактеристик");
	ДобавитьТипТаблиц(ТипыТаблиц, "ПланСчетов",             "ChartOfAccounts",            "ПланыСчетов");
	ДобавитьТипТаблиц(ТипыТаблиц, "ПланВидовРасчета",       "ChartOfCalculationTypes",    "ПланыВидовРасчета");
	ДобавитьТипТаблиц(ТипыТаблиц, "РегистрСведений",        "InformationRegister",        "РегистрыСведений");
	ДобавитьТипТаблиц(ТипыТаблиц, "РегистрНакопления",      "AccumulationRegister",       "РегистрыНакопления");
	ДобавитьТипТаблиц(ТипыТаблиц, "РегистрБухгалтерии",     "AccountingRegister",         "РегистрыБухгалтерии");
	ДобавитьТипТаблиц(ТипыТаблиц, "РегистрРасчета",         "CalculationRegister",        "РегистрыРасчета");
	ДобавитьТипТаблиц(ТипыТаблиц, "БизнесПроцесс",          "BusinessProcess",            "БизнесПроцессы");
	ДобавитьТипТаблиц(ТипыТаблиц, "Задача",                 "Task",                       "Задачи");
	
	// Установка основных свойств основных типов таблиц.
	ИменаТиповТаблиц = "ПланОбмена,Справочник,Документ,ПланВидовХарактеристик,ПланСчетов,ПланВидовРасчета,БизнесПроцесс,Задача";
	УстановитьСвойствоТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "ЭтоСсылочныйТип", Истина);
	УстановитьСвойствоТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "ЕстьОграничение", Истина);
	УстановитьСвойствоТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "ОбщиеРеквизиты",  "Разрешены");
	УстановитьСвойствоТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "Использование",   "Разрешено");
	
	ДобавитьКоллекциюПолейТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "Реквизиты",            "Разрешены");
	ДобавитьКоллекциюПолейТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "СтандартныеРеквизиты", "Разрешены");
	
	ДобавитьКоллекциюТабличныхЧастейТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "ТабличныеЧасти", "Разрешены");
	
	ДобавитьПолеТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "ВерсияДанных",  "DataVersion",  "Запрещено");
	ДобавитьПолеТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "Представление", "Presentation", "Запрещено");
	
	ДобавитьРасширениеТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "Изменения", "Changes", "Запрещено");
	
	// Установка основных свойств регистров.
	ИменаТиповТаблиц = "РегистрСведений,РегистрРасчета";
	УстановитьСвойствоТипаТаблиц(ТипыТаблиц,     ИменаТиповТаблиц, "ОбщиеРеквизиты",       "Разрешены");
	ДобавитьКоллекциюПолейТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "Ресурсы",              "Разрешены");
	ДобавитьКоллекциюПолейТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "Реквизиты",            "Разрешены");
	ДобавитьКоллекциюПолейТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "СтандартныеРеквизиты", "Разрешены");
	
	ИменаТиповТаблиц = "РегистрНакопления,РегистрБухгалтерии";
	УстановитьСвойствоТипаТаблиц(ТипыТаблиц,     ИменаТиповТаблиц, "ОбщиеРеквизиты",       "Недопустимы");
	ДобавитьКоллекциюПолейТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "Ресурсы",              "Недопустимы");
	ДобавитьКоллекциюПолейТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "Реквизиты",            "Недопустимы");
	ДобавитьКоллекциюПолейТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "СтандартныеРеквизиты", "Недопустимы");
	
	ИменаТиповТаблиц = "РегистрСведений,РегистрНакопления,РегистрБухгалтерии,РегистрРасчета";
	УстановитьСвойствоТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "ЕстьОграничение", Истина);
	ДобавитьКоллекциюПолейТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "Измерения", "Разрешены");
	
	ДобавитьРасширениеТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "Изменения", "Changes", "Запрещено");
	
	// Установка некоторых из указанных ранее свойств для остальных типов таблиц.
	УстановитьСвойствоТипаТаблиц(ТипыТаблиц,     "Последовательность", "ЕстьОграничение", Истина);
	ДобавитьКоллекциюПолейТипаТаблиц(ТипыТаблиц, "Последовательность", "Измерения", "Разрешены");
	
	УстановитьСвойствоТипаТаблиц(ТипыТаблиц,     "ЖурналДокументов", "ОбщиеРеквизиты",       "Разрешены");
	ДобавитьКоллекциюПолейТипаТаблиц(ТипыТаблиц, "ЖурналДокументов", "СтандартныеРеквизиты", "Разрешены");
	
	УстановитьСвойствоТипаТаблиц(ТипыТаблиц,     "Перечисление", "ЭтоСсылочныйТип", Истина);
	ДобавитьКоллекциюПолейТипаТаблиц(ТипыТаблиц, "Перечисление", "СтандартныеРеквизиты", "Разрешены");
	
	ИменаТиповТаблиц = "Константа,РегистрСведений";
	УстановитьСвойствоТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "Использование", "Разрешено");
	УстановитьСвойствоТипаТаблиц(ТипыТаблиц, "КритерийОтбора", "Использование", "Недопустимо");
	
	ДобавитьРасширениеТипаТаблиц(ТипыТаблиц, "Константа",       "Изменения",     "Changes",    "Запрещено");
	ДобавитьРасширениеТипаТаблиц(ТипыТаблиц, "РегистрСведений", "СрезПервых",    "SliceFirst", "Недопустимо");
	ДобавитьРасширениеТипаТаблиц(ТипыТаблиц, "РегистрСведений", "СрезПоследних", "SliceLast",  "Недопустимо");
	ДобавитьРасширениеТипаТаблиц(ТипыТаблиц, "БизнесПроцесс",   "Точки",         "Points",     "Запрещено");
	
	// Установка специализированных свойств.
	УстановитьСвойствоТипаТаблиц(ТипыТаблиц, "ПланСчетов", "ПризнакиУчетаСубконто", "Разрешены");
	
	ДобавитьКоллекциюПолейТипаТаблиц(ТипыТаблиц, "ЖурналДокументов", "Графы",              "Разрешены");
	ДобавитьКоллекциюПолейТипаТаблиц(ТипыТаблиц, "ПланСчетов",       "ПризнакиУчета",      "Разрешены");
	ДобавитьКоллекциюПолейТипаТаблиц(ТипыТаблиц, "Задача",           "РеквизитыАдресации", "Разрешены");
	
	ДобавитьКоллекциюТабличныхЧастейТипаТаблиц(ТипыТаблиц, "ПланСчетов",       "СтандартныеТабличныеЧасти", "Разрешены");
	ДобавитьКоллекциюТабличныхЧастейТипаТаблиц(ТипыТаблиц, "ПланВидовРасчета", "СтандартныеТабличныеЧасти", "Разрешены");
	
	ИменаТиповТаблиц = "Справочник,Перечисление,ПланВидовХарактеристик,ПланСчетов,ПланВидовРасчета";
	УстановитьСвойствоТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "ЕстьПредопределенные", Истина);
	
	// Уточнение стандартных полей типов таблиц.
	ИменаТиповТаблиц = "Документ,РегистрСведений,РегистрНакопления,РегистрБухгалтерии";
	ДобавитьПолеТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "МоментВремени", "PointInTime", "Недопустимо");
	
	ИменаТиповТаблиц = "Справочник,ПланВидовХарактеристик,ПланСчетов,ПланВидовРасчета";
	ДобавитьПолеТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, "ИмяПредопределенныхДанных", "PredefinedDataName", "Запрещено");
	
	ДобавитьПолеТипаТаблиц(ТипыТаблиц, "Константа",          "Значение",          "Value",               "Разрешено");
	ДобавитьПолеТипаТаблиц(ТипыТаблиц, "Последовательность", "Регистратор",       "Recorder",            "Разрешено");
	ДобавитьПолеТипаТаблиц(ТипыТаблиц, "Последовательность", "Период",            "Period",              "Разрешено");
	ДобавитьПолеТипаТаблиц(ТипыТаблиц, "ЖурналДокументов",   "Тип",               "Type",                "Недопустимо");
	ДобавитьПолеТипаТаблиц(ТипыТаблиц, "Перечисление",       "Порядок",           "Order",               "Запрещено");
	
	Возврат ТипыТаблиц;
	
КонецФункции

// Для функции ТипыТаблиц.
Процедура ДобавитьТипТаблиц(ТипыТаблиц, ЯзыкРусский, ЯзыкАнглийский, ИмяКоллекции)
	
	// Свойство "Использование" для таблиц.
	// "Разрешено"   - можно использовать без ограничений.
	// "Недопустимо" - не может использоваться в ограничении доступа платформы 1С:Предприятия.
	// "Запрещено"   - запрещено присоединять, как дополнительную таблицу в ограничении доступа БСП.
	
	СвойстваТипаТаблиц = Новый Структура;
	СвойстваТипаТаблиц.Вставить("ИмяКоллекции",             ИмяКоллекции);
	СвойстваТипаТаблиц.Вставить("ЯзыкРусский",              ЯзыкРусский);
	СвойстваТипаТаблиц.Вставить("ЯзыкАнглийский",           ЯзыкАнглийский);
	СвойстваТипаТаблиц.Вставить("ЭтоСсылочныйТип",          Ложь);
	СвойстваТипаТаблиц.Вставить("ЕстьОграничение",          Ложь);
	СвойстваТипаТаблиц.Вставить("ЕстьПредопределенные",     Ложь);
	СвойстваТипаТаблиц.Вставить("КоллекцииПолей",           Новый Соответствие);
	СвойстваТипаТаблиц.Вставить("КоллекцииТабличныхЧастей", Новый Соответствие);
	СвойстваТипаТаблиц.Вставить("ОбщиеРеквизиты",           "Отсутствуют");
	СвойстваТипаТаблиц.Вставить("ПризнакиУчетаСубконто",    "Отсутствуют");
	СвойстваТипаТаблиц.Вставить("УточнениеПолей",           Новый Соответствие);
	СвойстваТипаТаблиц.Вставить("УточнениеТаблиц",          Новый Соответствие);
	СвойстваТипаТаблиц.Вставить("Использование",            "Запрещено");
	
	ТипыТаблиц.ПоИменам.Вставить(ВРег(ЯзыкРусский),    СвойстваТипаТаблиц);
	ТипыТаблиц.ПоИменам.Вставить(ВРег(ЯзыкАнглийский), СвойстваТипаТаблиц);
	
	Если ЗначениеЗаполнено(ИмяКоллекции) Тогда
		ТипыТаблиц.ПоКоллекциям.Вставить(ИмяКоллекции, СвойстваТипаТаблиц);
	КонецЕсли;
	
КонецПроцедуры

// Для функции ТипыТаблиц.
Процедура УстановитьСвойствоТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, Свойство, Значение)
	
	Для Каждого ИмяТипаТаблицы Из СтрРазделить(ИменаТиповТаблиц, ",", Ложь) Цикл
		СвойстваТипаТаблиц = ТипыТаблиц.ПоИменам.Получить(ВРег(ИмяТипаТаблицы));
		СвойстваТипаТаблиц[Свойство] = Значение;
	КонецЦикла;
	
КонецПроцедуры

// Для функции ТипыТаблиц.
Процедура ДобавитьКоллекциюПолейТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, ИмяКоллекции, Использование)
	
	Для Каждого ИмяТипаТаблицы Из СтрРазделить(ИменаТиповТаблиц, ",", Ложь) Цикл
		СвойстваТипаТаблиц = ТипыТаблиц.ПоИменам.Получить(ВРег(ИмяТипаТаблицы));
		СвойстваТипаТаблиц.КоллекцииПолей.Вставить(ИмяКоллекции, Использование);
	КонецЦикла;
	
КонецПроцедуры

// Для функции ТипыТаблиц.
Процедура ДобавитьКоллекциюТабличныхЧастейТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, ИмяКоллекции, Использование)
	
	Для Каждого ИмяТипаТаблицы Из СтрРазделить(ИменаТиповТаблиц, ",", Ложь) Цикл
		СвойстваТипаТаблиц = ТипыТаблиц.ПоИменам.Получить(ВРег(ИмяТипаТаблицы));
		СвойстваТипаТаблиц.КоллекцииТабличныхЧастей.Вставить(ИмяКоллекции, Использование);
	КонецЦикла;
	
КонецПроцедуры

// Для функции ТипыТаблиц.
Процедура ДобавитьПолеТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, ЯзыкРусский, ЯзыкАнглийский, Использование)
	
	// Использование:
	// "Разрешено"   - можно использовать без ограничений.
	// "Недопустимо" - не может использоваться в ограничении доступа платформы 1С:Предприятия.
	// "Запрещено"   - запрещено использовать в ограничении доступа БСП.
	
	Для Каждого ИмяТипаТаблицы Из СтрРазделить(ИменаТиповТаблиц, ",", Ложь) Цикл
		УточнениеПоля = Новый Структура;
		УточнениеПоля.Вставить("ЯзыкРусский",    ЯзыкРусский);
		УточнениеПоля.Вставить("ЯзыкАнглийский", ЯзыкАнглийский);
		УточнениеПоля.Вставить("Использование",  Использование);
		
		СвойстваТипаТаблиц = ТипыТаблиц.ПоИменам.Получить(ВРег(ИмяТипаТаблицы));
		
		СвойстваТипаТаблиц.УточнениеПолей.Вставить(ВРег(ЯзыкРусский),    УточнениеПоля);
		СвойстваТипаТаблиц.УточнениеПолей.Вставить(ВРег(ЯзыкАнглийский), УточнениеПоля);
	КонецЦикла;
	
КонецПроцедуры

// Для функции ТипыТаблиц.
Процедура ДобавитьРасширениеТипаТаблиц(ТипыТаблиц, ИменаТиповТаблиц, ЯзыкРусский, ЯзыкАнглийский, Использование)
	
	// Использование:
	// "Разрешено"   - можно использовать без ограничений.
	// "Недопустимо" - не может использоваться в ограничении доступа платформы 1С:Предприятия.
	// "Запрещено"   - запрещено использовать в ограничении доступа БСП.
	
	Для Каждого ИмяТипаТаблицы Из СтрРазделить(ИменаТиповТаблиц, ",", Ложь) Цикл
		УточнениеТаблиц = Новый Структура;
		УточнениеТаблиц.Вставить("ЯзыкРусский",    ЯзыкРусский);
		УточнениеТаблиц.Вставить("ЯзыкАнглийский", ЯзыкАнглийский);
		УточнениеТаблиц.Вставить("Использование",  Использование);
		
		СвойстваТипаТаблиц = ТипыТаблиц.ПоИменам.Получить(ВРег(ИмяТипаТаблицы));
		
		СвойстваТипаТаблиц.УточнениеТаблиц.Вставить(ВРег(ЯзыкРусский),    УточнениеТаблиц);
		СвойстваТипаТаблиц.УточнениеТаблиц.Вставить(ВРег(ЯзыкАнглийский), УточнениеТаблиц);
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область СинтаксическийАнализ

// Для функции РазобранноеОграничение.
Функция ЧастиОграничения(ВнутренниеДанные)
	
	ЧастиОграничения = Новый Структура;
	ЧастиОграничения.Вставить("ДополнительныеТаблицы",    Новый Массив);
	ЧастиОграничения.Вставить("ПсевдонимОсновнойТаблицы", "");
	ЧастиОграничения.Вставить("ОграничениеЧтения",        Новый Структура);
	ЧастиОграничения.Вставить("ОграничениеИзменения",     Новый Структура);
	
	ТаблицаНаборовСимволов = ВнутренниеДанные.ТаблицаНаборовСимволов;
	
	Если ТаблицаНаборовСимволов.Количество() = 0 Тогда
		Возврат ЧастиОграничения;
	КонецЕсли;
	
	ТаблицаНаборовСимволов.Колонки.Добавить("Строки", Новый ОписаниеТипов("Массив"));
	ТаблицаНаборовСимволов.Колонки.Добавить("КонечнаяСтрока");
	
	// Разделение ограничения на основные части.
	Строки = ТаблицаНаборовСимволов.НайтиСтроки(Новый Структура("Символы, Вид", ";", "Разделитель"));
	
	ИндексыСтрокРазделителя = Новый Массив;
	Для Каждого Строка Из Строки Цикл
		ИндексыСтрокРазделителя.Добавить(ТаблицаНаборовСимволов.Индекс(Строка));
	КонецЦикла;
	ИндексыСтрокРазделителя.Добавить(ТаблицаНаборовСимволов.Количество() - 1);
	
	СвойстваЧастей = Новый Массив;
	ИндексСтроки = 0;
	Для Каждого ИндексСтрокиРазделителя Из ИндексыСтрокРазделителя Цикл
		СтрокиЧасти = Новый Массив;
		Пока ИндексСтроки < ИндексСтрокиРазделителя Цикл
			СтрокаЧасти = ТаблицаНаборовСимволов[ИндексСтроки];
			Если СтрокаЧасти.Вид <> "НедопустимыйСимвол" Тогда
				СтрокиЧасти.Добавить(СтрокаЧасти);
			КонецЕсли;
			ИндексСтроки = ИндексСтроки + 1;
		КонецЦикла;
		СтрокаРазделителя = ТаблицаНаборовСимволов[ИндексСтрокиРазделителя];
		Если СтрокиЧасти.Количество() = 0 Тогда
			СтрокиЧасти.Добавить(СтрокаРазделителя);
		КонецЕсли;
		СвойстваЧасти = Новый Структура;
		СвойстваЧасти.Вставить("Строки", СтрокиЧасти);
		СвойстваЧасти.Вставить("СтрокаРазделителя", СтрокаРазделителя);
		СвойстваЧастей.Добавить(СвойстваЧасти);
		Если СтрокиЧасти[0].Вид = "КлючевоеСлово"
		   И СтрокиЧасти[0].Тип = "Начало" Тогда
			
			СвойстваЧасти.Вставить("Имя",           СтрокиЧасти[0].Уточнение);
			СвойстваЧасти.Вставить("Представление", СтрокиЧасти[0].Символы);
			
			РазобратьЧастьОграничения(СвойстваЧасти, ВнутренниеДанные);
		Иначе
			СвойстваЧасти.Вставить("Имя",           "");
			СвойстваЧасти.Вставить("Представление", "");
		КонецЕсли;
		ИндексСтроки = ИндексСтрокиРазделителя + 1;
	КонецЦикла;
	
	ДобавитьПсевдонимыПоУмолчанию(ВнутренниеДанные);
	
	// Анализ части 1.
	СвойстваЧасти1 = СвойстваЧастей[0];
	
	Если СвойстваЧасти1.Имя = "" Тогда
		УстановитьОшибкуНачалаЧасти(СвойстваЧасти1, ПодставитьКлючевыеСловаВСтроку(ВнутренниеДанные,
			НСтр("ru = 'В начале первой части текста ограничения не найдено ни одно из ключевых слов
			           |""%1"", ""%2"", ""%3""'"),
			"РазрешитьЧтениеИзменение,РазрешитьЧтение,ПрисоединитьДополнительныеТаблицы"));
		Возврат ЧастиОграничения;
		
	ИначеЕсли СвойстваЧасти1.Имя = "РазрешитьИзменениеЕслиРазрешеноЧтение" Тогда
		УстановитьОшибкуНачалаЧасти(СвойстваЧасти1,
			НСтр("ru = 'В начале первой части текста ограничения найдено недопустимое ключевое слово'"));
		Возврат ЧастиОграничения;
		
	ИначеЕсли СвойстваЧастей.Количество() = 1
	        И (    СвойстваЧасти1.Имя = "ПрисоединитьДополнительныеТаблицы"
	           Или СвойстваЧасти1.Имя = "РазрешитьЧтение" ) Тогда
		
		УстановитьОшибкуНачалаЧасти(ТаблицаНаборовСимволов,
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Текст ограничения не может быть только из одной части
				           |с ключевым словом ""%1""'"), СвойстваЧасти1.Представление));
		Возврат ЧастиОграничения;
	КонецЕсли;
	
	УстановитьЧастьОграничения(ЧастиОграничения, СвойстваЧасти1);
	
	Если СвойстваЧастей.Количество() < 2 Тогда
		Возврат ЧастиОграничения;
	КонецЕсли;
	
	// Анализ части 2.
	СвойстваЧасти2 = СвойстваЧастей[1];
	
	Если СвойстваЧасти1.Имя = "РазрешитьЧтениеИзменение" Тогда
		УстановитьОшибкуНачалаЧасти(СвойстваЧасти1.СтрокаРазделителя,
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Второй части текста ограничения не должно быть, когда
				           |в первой части указано ключевое слово ""%1""'"), СвойстваЧасти1.Представление));
		Возврат ЧастиОграничения;
	КонецЕсли;
	
	Если СвойстваЧасти2.Имя = "" Тогда
		Если СвойстваЧасти1.Имя = "РазрешитьЧтение" Тогда
			УстановитьОшибкуНачалаЧасти(СвойстваЧасти2, ПодставитьКлючевыеСловаВСтроку(ВнутренниеДанные,
				НСтр("ru = 'В начале второй части текста ограничения не найдено
				           |ключевое слово ""%1""'"),
				"РазрешитьИзменениеЕслиРазрешеноЧтение"));
		Иначе // СвойстваЧасти1.Имя = "ПрисоединитьДополнительныеТаблицы".
			УстановитьОшибкуНачалаЧасти(СвойстваЧасти2, ПодставитьКлючевыеСловаВСтроку(ВнутренниеДанные,
				НСтр("ru = 'В начале второй части текста ограничения не найдено ни одно из ключевых слов
				           |""%1"", ""%2""'"),
				"РазрешитьЧтениеИзменение,РазрешитьЧтение"));
		КонецЕсли;
		Возврат ЧастиОграничения;
		
	ИначеЕсли СвойстваЧасти1.Имя = "РазрешитьЧтение"
	        И СвойстваЧасти2.Имя <> "РазрешитьИзменениеЕслиРазрешеноЧтение"
	      Или СвойстваЧасти1.Имя = "ПрисоединитьДополнительныеТаблицы"
	        И СвойстваЧасти2.Имя <> "РазрешитьЧтениеИзменение"
	        И СвойстваЧасти2.Имя <> "РазрешитьЧтение" Тогда
		
		УстановитьОшибкуНачалаЧасти(СвойстваЧасти2,
			НСтр("ru = 'В начале второй части текста ограничения найдено недопустимое ключевое слово'"));
		Возврат ЧастиОграничения;
		
	ИначеЕсли СвойстваЧастей.Количество() = 2
	        И СвойстваЧасти2.Имя = "РазрешитьЧтение" Тогда
		
		УстановитьОшибкуНачалаЧасти(ТаблицаНаборовСимволов,
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Текст ограничения не может быть только из двух частей, когда
				           |во второй части указано ключевое слово ""%1""'"), СвойстваЧасти2.Представление));
		Возврат ЧастиОграничения;
	КонецЕсли;
	
	УстановитьЧастьОграничения(ЧастиОграничения, СвойстваЧасти2);
	
	Если СвойстваЧастей.Количество() < 3 Тогда
		Возврат ЧастиОграничения;
	КонецЕсли;
	
	// Анализ части 3.
	СвойстваЧасти3 = СвойстваЧастей[2];
	
	Если СвойстваЧасти2.Имя = "РазрешитьЧтениеИзменение" Тогда
		УстановитьОшибкуНачалаЧасти(СвойстваЧасти2.СтрокаРазделителя,
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Третьей части текста ограничения не должно быть, когда
				           |во второй части указано ключевое слово ""%1""'"), СвойстваЧасти2.Представление));
		Возврат ЧастиОграничения;
	КонецЕсли;
	
	Если СвойстваЧасти3.Имя = "" Тогда
		УстановитьОшибкуНачалаЧасти(СвойстваЧасти3, ПодставитьКлючевыеСловаВСтроку(ВнутренниеДанные,
			НСтр("ru = 'В начале третьей части текста ограничения не найдено
			           |ключевое слово ""%1""'"),
			"РазрешитьИзменениеЕслиРазрешеноЧтение"));
		Возврат ЧастиОграничения;
		
	ИначеЕсли СвойстваЧасти2.Имя = "РазрешитьЧтение"
	        И СвойстваЧасти3.Имя <> "РазрешитьИзменениеЕслиРазрешеноЧтение" Тогда
		
		УстановитьОшибкуНачалаЧасти(СвойстваЧасти3,
			НСтр("ru = 'В начале третьей части текста ограничения найдено недопустимое ключевое слово'"));
		Возврат ЧастиОграничения;
	КонецЕсли;
	
	УстановитьЧастьОграничения(ЧастиОграничения, СвойстваЧасти3);
	
	Возврат ЧастиОграничения;
	
КонецФункции

// Для функции ЧастиОграничения.
Процедура УстановитьЧастьОграничения(ЧастиОграничения, СвойстваЧасти)
	
	Если СвойстваЧасти.Имя = "РазрешитьЧтениеИзменение"
	 Или СвойстваЧасти.Имя = "РазрешитьЧтение" Тогда
		
		ИмяСвойства = "ОграничениеЧтения";
		
	ИначеЕсли СвойстваЧасти.Имя = "РазрешитьИзменениеЕслиРазрешеноЧтение" Тогда
		
		ИмяСвойства = "ОграничениеИзменения";
		
	Иначе // ПрисоединитьДополнительныеТаблицы.
		
		ИмяСвойства = "ДополнительныеТаблицы";
		ЧастиОграничения.ПсевдонимОсновнойТаблицы = СвойстваЧасти.ПсевдонимОсновнойТаблицы;
	КонецЕсли;
	
	ЧастиОграничения[ИмяСвойства] = СвойстваЧасти.Состав;
	
КонецПроцедуры

// Для функции ЧастиОграничения, процедур РазобратьДополнительныеТаблицы, РазобратьУсловиеОграничения.
Процедура УстановитьОшибкуНачалаЧасти(СвойстваЧасти, ТекстОшибки)
	
	Если ТипЗнч(СвойстваЧасти) = Тип("ТаблицаЗначений") Тогда
		СтрокаСОшибкой = СвойстваЧасти[СвойстваЧасти.Количество() - 1];
		
	ИначеЕсли ТипЗнч(СвойстваЧасти) = Тип("СтрокаТаблицыЗначений") Тогда
		СтрокаСОшибкой = СвойстваЧасти;
	Иначе
		СтрокаСОшибкой = СвойстваЧасти.Строки[0];
	КонецЕсли;
	
	СтрокаСОшибкой.ТекстОшибки = ТекстОшибки;
	
	// Требуется описание вариантов первых ключевых слов частей.
	СтрокаСОшибкой.ПозицияОшибки = -1;
	
КонецПроцедуры

// Для процедуры РазобратьСоединение.
Процедура УстановитьОшибкуВнутриЧасти(Строки, ИндексСтроки, ТекстОшибки)
	
	Если ИндексСтроки < Строки.Количество() Тогда
		СтрокаСОшибкой = Строки[ИндексСтроки];
	Иначе
		СтрокаСОшибкой = Строки[ИндексСтроки - 1];
		// Ошибка в конце слова.
		СтрокаСОшибкой.ПозицияОшибки = СтрДлина(СтрокаСОшибкой.Символы);
	КонецЕсли;
	
	СтрокаСОшибкой.ТекстОшибки = ТекстОшибки;
	
КонецПроцедуры

// Для функции ВыраженияВСкобкахВоВложениях, ВыраженияВыборКогдаТогдаВоВложениях.
Процедура УстановитьОшибкуВСтроке(Строка, ТекстОшибки, ВКонцеСлова = Ложь, НомерСлова = 1)
	
	Если ЗначениеЗаполнено(Строка.ТекстОшибки) Тогда
		Возврат;
	КонецЕсли;
	
	Если ВКонцеСлова Тогда
		Строка.ПозицияОшибки = СтрДлина(Строка.Символы);
		
	ИначеЕсли НомерСлова > 1 Тогда
		СоставИмени = СтрРазделить(Строка.Символы, ".");
		Если СоставИмени.Количество() > 1 Тогда
			Строка.ПозицияОшибки = СтрДлина(СоставИмени[0]) + 1;
		КонецЕсли;
	КонецЕсли;
	
	Строка.ТекстОшибки = ТекстОшибки;
	
КонецПроцедуры

// Для функции ЧастиОграничения.
Процедура РазобратьЧастьОграничения(СвойстваЧасти, ВнутренниеДанные)
	
	Если СвойстваЧасти.Имя = "ПрисоединитьДополнительныеТаблицы" Тогда
		СвойстваЧасти.Вставить("Состав", Новый Массив);
		СвойстваЧасти.Вставить("ПсевдонимОсновнойТаблицы", "");
		РазобратьДополнительныеТаблицы(СвойстваЧасти, ВнутренниеДанные);
	Иначе
		СвойстваЧасти.Вставить("Состав", Новый Структура);
		РазобратьУсловиеОграничения(СвойстваЧасти, ВнутренниеДанные);
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры РазобратьЧастьОграничения.
Процедура РазобратьДополнительныеТаблицы(СвойстваЧасти, ВнутренниеДанные)
	
	СтрокиЧасти = СвойстваЧасти.Строки;
	
	Если СтрокиЧасти.Количество() < 2
	 Или СтрокиЧасти[1].Вид <> "КлючевоеСлово"
	 Или СтрокиЧасти[1].Уточнение <> "ЭтотСписок" Тогда
		УстановитьОшибкуНачалаЧасти(
			?(СтрокиЧасти.Количество() < 3, СвойстваЧасти.СтрокаРазделителя, СтрокиЧасти[1]),
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'После ключевого слова ""%1"" не найдено
				           |ключевое слово ""%2""'"),
				СвойстваЧасти.Представление,
				КлючевоеСловоСУчетомЯзыка("ЭтотСписок", ВнутренниеДанные)));
		Возврат;
	КонецЕсли;
	
	ИзменитьВидКлючевогоСловаСписокНаИмя(СтрокиЧасти, СтрокиЧасти[1]);
	
	Если СтрокиЧасти.Количество() < 3
	 Или СтрокиЧасти[2].Вид <> "КлючевоеСлово"
	 Или СтрокиЧасти[2].Уточнение <> "Как" Тогда
		УстановитьОшибкуНачалаЧасти(
			?(СтрокиЧасти.Количество() < 3, СвойстваЧасти.СтрокаРазделителя, СтрокиЧасти[2]),
				ПодставитьКлючевыеСловаВСтроку(ВнутренниеДанные,
					НСтр("ru = 'После ключевого слова ""%1"" не найдено ключевое слово ""%2""'"),
					"Список,Как"));
		Возврат;
	КонецЕсли;
	
	Если СтрокиЧасти.Количество() < 4
	 Или СтрокиЧасти[3].Вид <> "Имя" Тогда
		УстановитьОшибкуНачалаЧасти(
			?(СтрокиЧасти.Количество() < 4, СвойстваЧасти.СтрокаРазделителя, СтрокиЧасти[3]),
				ПодставитьКлючевыеСловаВСтроку(ВнутренниеДанные,
					НСтр("ru = 'После ключевого слова ""%1"" не найден псевдоним'"),
					"Как"));
		Возврат;
	КонецЕсли;
	
	УстановитьПсевдоним(СтрокиЧасти[3], СвойстваЧасти.ПсевдонимОсновнойТаблицы, ВнутренниеДанные);
	
	// Разделение описания на группы левых соединений.
	Соединения = Новый Массив;
	ТекущееСоединение = Новый Массив;
	
	Для Индекс = 4 По СтрокиЧасти.Количество()-1 Цикл
		СтрокаЧасти = СтрокиЧасти[Индекс];
		
		Если СтрокаЧасти.Вид = "КлючевоеСлово"
		   И СтрокаЧасти.Уточнение = "Левое" Тогда
			
			Если ТекущееСоединение.Количество() > 0 Тогда
				Соединения.Добавить(ТекущееСоединение);
			КонецЕсли;
			ТекущееСоединение = Новый Массив;
			ТекущееСоединение.Добавить(СтрокаЧасти);
			
			Если Индекс + 1 < СтрокиЧасти.Количество()
			   И СтрокиЧасти[Индекс + 1].Вид = "КлючевоеСлово"
			   И СтрокиЧасти[Индекс + 1].Уточнение = "Соединение" Тогда
				
				Индекс = Индекс + 1;
				ТекущееСоединение.Добавить(СтрокиЧасти[Индекс]);
			КонецЕсли;
			
			Продолжить;
		КонецЕсли;
		ТекущееСоединение.Добавить(СтрокаЧасти);
	КонецЦикла;
	
	Если ТекущееСоединение.Количество() > 0
	 Или Соединения.Количество() = 0 Тогда
		
		Соединения.Добавить(ТекущееСоединение);
	КонецЕсли;
	
	ВнутренниеДанные.Вставить("ДоступныеПсевдонимы",
		Новый Соответствие(Новый ФиксированноеСоответствие(ВнутренниеДанные.Псевдонимы)));
	
	Для Каждого Соединение Из Соединения Цикл
		// Условие разбирается универсально (по максимуму возможностей)
		// после чего устанавливаются ошибки на запрещенные возможности.
		РазобратьСоединение(Соединение, СвойстваЧасти, ВнутренниеДанные);
	КонецЦикла;
	
	// Продолжение разбора после заполнения псевдонимов всех дополнительных таблиц.
	Для Каждого ОписаниеСоединения Из СвойстваЧасти.Состав Цикл
		ВнутренниеДанные.ДоступныеПсевдонимы.Вставить(ВРег(ОписаниеСоединения.Псевдоним), Истина);
		// Допустимы только простые условия:
		// Поле1 = Поле2 [И Поле3 = Поле4] [И Поле5 = Константа].
		РазобратьПоляУсловияСоединенияИОтметитьЗапреты(ОписаниеСоединения, ВнутренниеДанные);
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры РазобратьДополнительныеТаблицы.
Процедура РазобратьСоединение(Соединение, СвойстваЧасти, ВнутренниеДанные)
	
	ОписаниеСоединения = Новый Структура;
	ОписаниеСоединения.Вставить("Таблица", "");
	ОписаниеСоединения.Вставить("Псевдоним", "");
	ОписаниеСоединения.Вставить("УсловиеСоединения", Неопределено);
	
	Если Соединение[0].Вид <> "КлючевоеСлово"
	 Или Соединение[0].Уточнение <> "Левое" Тогда
		УстановитьОшибкуВнутриЧасти(Соединение, 0, ПодставитьКлючевыеСловаВСтроку(ВнутренниеДанные,
			НСтр("ru = 'Не найдено ключевое слово ""%1""'"), "Левое"));
		
		Если Соединение[0].Вид <> "КлючевоеСлово"
		 Или Соединение[0].Уточнение <> "Внутреннее"
		   И Соединение[0].Уточнение <> "Полное" Тогда
			
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	Если Соединение.Количество() < 2
	 Или Соединение[1].Вид <> "КлючевоеСлово"
	 Или Соединение[1].Уточнение <> "Соединение" Тогда
		УстановитьОшибкуВнутриЧасти(Соединение, 1,
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'После ключевого слова ""%1"" не найдено ключевое слово ""%2""'"),
				Соединение[0].Символы,
				КлючевоеСловоСУчетомЯзыка("Соединение", ВнутренниеДанные)));
		Возврат;
	КонецЕсли;
	
	Если Соединение.Количество() < 3
	 Или Соединение[2].Вид <> "Имя" Тогда
		УстановитьОшибкуВнутриЧасти(Соединение, 2,
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'После ключевого слова ""%1"" не найдено имя таблицы'"),
				Соединение[1].Символы));
		Возврат;
	КонецЕсли;
	
	УстановитьИмяТаблицы(Соединение[2], ОписаниеСоединения, ВнутренниеДанные);
	
	Если Соединение.Количество() < 4
	 Или Соединение[3].Вид <> "КлючевоеСлово"
	 Или Соединение[3].Уточнение <> "Как" Тогда
		УстановитьОшибкуВнутриЧасти(Соединение, 3, ПодставитьКлючевыеСловаВСтроку(ВнутренниеДанные,
			НСтр("ru = 'После имени таблицы не найдено ключевое слово ""%1""'"), "Как"));
		Возврат;
	КонецЕсли;
	
	Если Соединение.Количество() < 5
	 Или Соединение[4].Вид <> "Имя" Тогда
		УстановитьОшибкуВнутриЧасти(Соединение, 4, ПодставитьКлючевыеСловаВСтроку(ВнутренниеДанные,
			НСтр("ru = 'После ключевого слова ""%1"" не найден псевдоним таблицы'"), "Как"));
		Возврат;
	КонецЕсли;
	
	УстановитьПсевдоним(Соединение[4], ОписаниеСоединения, ВнутренниеДанные);
	
	Если Соединение.Количество() < 6
	 Или Соединение[5].Вид <> "КлючевоеСлово"
	 Или Соединение[5].Уточнение <> "По" Тогда
		УстановитьОшибкуВнутриЧасти(Соединение, 5, ПодставитьКлючевыеСловаВСтроку(ВнутренниеДанные,
			НСтр("ru = 'После псевдонима таблицы не найдено ключевое слово ""%1""'"), "По"));
		Возврат;
	КонецЕсли;
	
	Условие = Новый Массив(Новый ФиксированныйМассив(Соединение));
	Для Индекс = 0 По 5 Цикл
		Условие.Удалить(0);
	КонецЦикла;
	
	РазобратьУсловие(Условие, ОписаниеСоединения.УсловиеСоединения, ВнутренниеДанные);
	
	СвойстваЧасти.Состав.Добавить(ОписаниеСоединения);
	
КонецПроцедуры

// Для процедуры РазобратьДополнительныеТаблицы.
Процедура РазобратьПоляУсловияСоединенияИОтметитьЗапреты(ОписаниеСоединения, ВнутренниеДанные)
	
	// Отметка некорректных аргументов операций и запрещенных возможностей.
	ОбщиеУзлы = Новый Соответствие(УправлениеДоступомСлужебныйПовтИсп.УзлыДляПроверкиДоступности(
		"Поле,Значение,Константа,И,=", Ложь));
	
	ОбщиеУзлы.Вставить("Поле", Новый Структура("Выразить, Вложение, ЕстьNull", Ложь, Ложь, Ложь));
	
	ДоступныеУзлы = Новый Структура;
	ДоступныеУзлы.Вставить("Общие",          ОбщиеУзлы);
	ДоступныеУзлы.Вставить("УзлыКогда",      ОбщиеУзлы);
	ДоступныеУзлы.Вставить("УзлыТогдаИначе", ОбщиеУзлы);
	
	ФиксированныйКонтекст = Новый ФиксированнаяСтруктура(ВнутренниеДанные);
	Контекст = Новый Структура(ФиксированныйКонтекст);
	Контекст.Вставить("ЭтоУсловиеСоединения",  Истина);
	Контекст.Вставить("ЭтоУсловиеКогда",       Ложь);
	Контекст.Вставить("ЭтоЗначениеТогдаИначе", Ложь);
	Контекст.Вставить("КорневойУзел",          ОписаниеСоединения.УсловиеСоединения);
	
	ОтметитьНекорректныеАргументыИЗапрещенныеУзлы(ОписаниеСоединения.УсловиеСоединения,
		ДоступныеУзлы, Контекст);
	
	УдалитьСвойствоИсточник(ОписаниеСоединения.УсловиеСоединения);
	
КонецПроцедуры

// Для процедур РазобратьУсловиеСоединения, РазобратьУсловиеОграничения.
Функция УзлыДляПроверкиДоступности(Список, ЭтоСписокИсключений) Экспорт
	
	ВсеУзлы = Новый Соответствие;
	ВсеУзлы.Вставить("Поле", Новый Структура("Выразить, Вложение, ЕстьNull", Истина, Истина, Истина));
	ВсеУзлы.Вставить("Значение",    Истина);
	ВсеУзлы.Вставить("Константа",   Истина);
	ВсеУзлы.Вставить("И",           Истина);
	ВсеУзлы.Вставить("Или",         Истина);
	ВсеУзлы.Вставить("Не",          Истина);
	ВсеУзлы.Вставить("=",           Истина);
	ВсеУзлы.Вставить("<>",          Истина);
	ВсеУзлы.Вставить("В",           Истина);
	ВсеУзлы.Вставить("ЕстьNull",    Истина);
	ВсеУзлы.Вставить("Тип",         Истина);
	ВсеУзлы.Вставить("ТипЗначения", Истина);
	ВсеУзлы.Вставить("Выбор",       Истина);
	ВсеУзлы.Вставить("ЗначениеРазрешено",             Истина);
	ВсеУзлы.Вставить("ЭтоАвторизованныйПользователь", Истина);
	ВсеУзлы.Вставить("ЧтениеОбъектаРазрешено",        Истина);
	ВсеУзлы.Вставить("ИзменениеОбъектаРазрешено",     Истина);
	ВсеУзлы.Вставить("ЧтениеСпискаРазрешено",         Истина);
	ВсеУзлы.Вставить("ИзменениеСпискаРазрешено",      Истина);
	ВсеУзлы.Вставить("ДляВсехСтрок",                  Истина);
	ВсеУзлы.Вставить("ДляОднойИзСтрок",               Истина);
	
	МассивУзлов = СтрРазделить(Список, ",", Ложь);
	Узлы = Новый Соответствие;
	
	Для Каждого Узел Из ВсеУзлы Цикл
		Если ЭтоСписокИсключений Тогда
			Если МассивУзлов.Найти(Узел.Ключ) = Неопределено Тогда
				Узлы.Вставить(Узел.Ключ, Узел.Значение);
			КонецЕсли;
		Иначе
			Если МассивУзлов.Найти(Узел.Ключ) <> Неопределено Тогда
				Узлы.Вставить(Узел.Ключ, Узел.Значение);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый ФиксированноеСоответствие(Узлы);
	
КонецФункции

// Для процедур РазобратьУсловиеСоединения, РазобратьУсловиеОграничения.
Процедура ОтметитьНекорректныеАргументыИЗапрещенныеУзлы(Условие, ДоступныеУзлы, Контекст, Родитель = Неопределено)
	
	Если Не ЗначениеЗаполнено(Условие) Тогда
		Возврат;
	КонецЕсли;
	
	Если Контекст.ЭтоУсловиеКогда Тогда
		ТекущиеДоступныеУзлы = ДоступныеУзлы.УзлыКогда;
		
	ИначеЕсли Контекст.ЭтоЗначениеТогдаИначе Тогда
		ТекущиеДоступныеУзлы = ДоступныеУзлы.УзлыТогдаИначе;
	Иначе
		ТекущиеДоступныеУзлы = ДоступныеУзлы.Общие;
	КонецЕсли;
	
	ДоступностьУзла = ТекущиеДоступныеУзлы.Получить(Условие.Узел);
	
	Если ДоступностьУзла = Неопределено Тогда
		УстановитьОшибкуУзелЗапрещен(Условие.Источник, Контекст);
	КонецЕсли;
	
	Если Условие.Узел = "Поле" Тогда
		
		Если Не Контекст.ЭтоУсловиеСоединения Тогда
			ПолеКлючаДоступа = Новый Структура;
			ПолеКлючаДоступа.Вставить("Поле",   Условие);
			ПолеКлючаДоступа.Вставить("Чтение", Контекст.Чтение);
			Контекст.ПоляКлючаДоступа.Добавить(ПолеКлючаДоступа);
		КонецЕсли;
		
		ВыделитьПсевдонимПоля(Условие, Контекст);
		
		Если Не ДоступностьУзла.Выразить
		   И Условие.Выразить <> Неопределено Тогда
			
			УстановитьОшибкуУзелЗапрещен(Условие.Источник, Контекст);
			
		ИначеЕсли Не ДоступностьУзла.Вложение
		        И Условие.Вложение <> Неопределено Тогда
		
			УстановитьОшибкуУзелЗапрещен(Условие.Вложение.Источник, Контекст);
			
		ИначеЕсли Не ДоступностьУзла.ЕстьNull
		        И Условие.ЕстьNull <> Неопределено Тогда
		
			УстановитьОшибкуУзелЗапрещен(Условие.ЕстьNullИсточник, Контекст);
		КонецЕсли;
		
	ИначеЕсли Условие.Узел = "И"
	      Или Условие.Узел = "Или" Тогда
		
		Для Каждого Аргумент Из Условие.Аргументы Цикл
			ОтметитьНекорректныеАргументыИЗапрещенныеУзлы(Аргумент, ДоступныеУзлы, Контекст);
		КонецЦикла;
		
	ИначеЕсли Условие.Узел = "Не"
	      Или Условие.Узел = "ЕстьNull"
	      Или Условие.Узел = "ДляВсехСтрок"
	      Или Условие.Узел = "ДляОднойИзСтрок" Тогда
		
		// Проверка корректности параметра.
		Если Условие.Узел = "ЕстьNull"
		   И (    Условие.Аргумент = Неопределено
		      Или Условие.Аргумент.Узел <> "Поле" ) Тогда
			
			УстановитьОшибкуВСтроке(Условие.Источник,
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Операция ""%1"" допустима только после поля'"),
					Условие.Источник.Символы));
		КонецЕсли;
		ОтметитьНекорректныеАргументыИЗапрещенныеУзлы(Условие.Аргумент, ДоступныеУзлы, Контекст);
		
	ИначеЕсли Условие.Узел = "="
	      Или Условие.Узел = "<>" Тогда
		
		СочетанияУзлов = Новый Соответствие;
		СочетанияУзлов.Вставить("Значение",  ",Поле,");
		СочетанияУзлов.Вставить("Константа", ",Поле,Константа,");
		
		Если Контекст.ЭтоУсловиеСоединения Тогда
			СочетанияУзлов.Вставить("Поле",        ",Поле,Значение,Константа,");
		Иначе
			СочетанияУзлов.Вставить("Поле",        ",Значение,Константа,");
			СочетанияУзлов.Вставить("Тип",         ",ТипЗначения,");
			СочетанияУзлов.Вставить("ТипЗначения", ",Тип,");
		КонецЕсли;
		
		СочетанияПервогоАргумента = СочетанияУзлов.Получить(Условие.ПервыйАргумент.Узел);
		СочетанияВторогоАргумента = СочетанияУзлов.Получить(Условие.ВторойАргумент.Узел);
		
		ОшибкаВПервомАргументе  = СочетанияПервогоАргумента = Неопределено;
		ОшибкаВоВторомАргументе = СочетанияВторогоАргумента = Неопределено
			Или СочетанияПервогоАргумента <> Неопределено
			  И СтрНайти(СочетанияПервогоАргумента, "," + Условие.ВторойАргумент.Узел + ",") = 0;
		
		Если ОшибкаВПервомАргументе Или ОшибкаВоВторомАргументе Тогда
			Если Контекст.ЭтоУсловиеСоединения Тогда
				ТекстОшибки =
					НСтр("ru = 'Операция ""%1"" допустима только для поля с полем, значением или константой'");
			Иначе
				ТекстОшибки =
					НСтр("ru = 'Операция ""%1"" допустима только для поля со значением или константой,
					           |а также для типа значения с типом'");
			КонецЕсли;
			Если ОшибкаВПервомАргументе Тогда
				УстановитьОшибкуВСтроке(Условие.ПервыйАргумент.Источник,
					СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						ТекстОшибки, Условие.Источник.Символы),
					Истина);
			КонецЕсли;
			Если ОшибкаВоВторомАргументе Тогда
				УстановитьОшибкуВСтроке(Условие.ВторойАргумент.Источник,
					СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						ТекстОшибки, Условие.Источник.Символы));
			КонецЕсли;
		КонецЕсли;
		
		ОтметитьНекорректныеАргументыИЗапрещенныеУзлы(Условие.ПервыйАргумент, ДоступныеУзлы, Контекст, Условие);
		ОтметитьНекорректныеАргументыИЗапрещенныеУзлы(Условие.ВторойАргумент, ДоступныеУзлы, Контекст, Условие);
		
	ИначеЕсли Условие.Узел = "В" Тогда
		ОтметитьНекорректныеАргументыИЗапрещенныеУзлы(Условие.Искомое, ДоступныеУзлы, Контекст);
		Для Каждого Значение Из Условие.Значения Цикл
			ОтметитьНекорректныеАргументыИЗапрещенныеУзлы(Значение, ДоступныеУзлы, Контекст);
		КонецЦикла;
		
	ИначеЕсли Условие.Узел = "ТипЗначения"
	      Или Условие.Узел = "Тип" Тогда
		
		Если Родитель = Неопределено
		 Или Родитель.Узел <> "="
		   И Родитель.Узел <> "<>" Тогда
		
			УстановитьОшибкуВСтроке(Условие.Источник,
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Функция ""%1"" допустима только в операциях ""="" и ""<>""'"),
					Условие.Источник.Символы));
		КонецЕсли;
		
		Если Условие.Узел = "ТипЗначения" Тогда
			ОтметитьНекорректныеАргументыИЗапрещенныеУзлы(Условие.Аргумент, ДоступныеУзлы, Контекст);
		КонецЕсли;
		
	ИначеЕсли Условие.Узел = "Выбор" Тогда
		Если Условие.Выбор <> Неопределено Тогда
			ОтметитьНекорректныеАргументыИЗапрещенныеУзлы(Условие.Выбор, ДоступныеУзлы, Контекст);
		КонецЕсли;
		ФиксированныйКонтекст = Новый ФиксированнаяСтруктура(Контекст);
		КонтекстКогда = Новый Структура(ФиксированныйКонтекст);
		КонтекстКогда.ЭтоУсловиеКогда = Истина;
		КонтекстТогдаИначе = Новый Структура(ФиксированныйКонтекст);
		КонтекстТогдаИначе.ЭтоЗначениеТогдаИначе = Истина;
		
		Для Каждого Когда Из Условие.Когда Цикл
			ОтметитьНекорректныеАргументыИЗапрещенныеУзлы(Когда.Условие,  ДоступныеУзлы, КонтекстКогда);
			ОтметитьНекорректныеАргументыИЗапрещенныеУзлы(Когда.Значение, ДоступныеУзлы, КонтекстТогдаИначе);
		КонецЦикла;
		ОтметитьНекорректныеАргументыИЗапрещенныеУзлы(Условие.Иначе, ДоступныеУзлы, КонтекстТогдаИначе);
		
	ИначеЕсли Условие.Узел = "ЗначениеРазрешено"
	      Или Условие.Узел = "ЭтоАвторизованныйПользователь"
	      Или Условие.Узел = "ЧтениеОбъектаРазрешено"
	      Или Условие.Узел = "ИзменениеОбъектаРазрешено"
	      Или Условие.Узел = "ЧтениеСпискаРазрешено"
	      Или Условие.Узел = "ИзменениеСпискаРазрешено" Тогда
		
		ОтметитьНекорректныеАргументыИЗапрещенныеУзлы(Условие.Поле, ДоступныеУзлы, Контекст);
		ОтметитьПовторыТиповСредиПроверяемыхИУточняемых(Условие, Контекст);
		
		// Добавление типов, наличие которых нужно проверить у полей.
		Поле = Условие.Поле;
		Уточнения = Новый Соответствие;
		Для Каждого УточнениеСравнения Из Условие.УточненияСравнения Цикл
			Если ТипЗнч(УточнениеСравнения.Ключ) <> Тип("СтрокаТаблицыЗначений") Тогда
				Уточнения.Вставить(УточнениеСравнения.Ключ, УточнениеСравнения.Значение);
				Продолжить;
			КонецЕсли;
			Уточнения.Вставить(УточнениеСравнения.Ключ.Символы, УточнениеСравнения.Значение);
			ДобавитьТребуемоеПолеТаблицы(Контекст, Поле.Таблица, Поле.Имя, Поле.ИмяИсточник,
				УточнениеСравнения.Ключ.Символы, УточнениеСравнения.Ключ);
		КонецЦикла;
		
		// Удаление источников типов.
		Условие.УточненияСравнения = Уточнения;
		
		Типы = Новый Массив;
		Для Каждого Тип Из Условие.Типы Цикл
			Типы.Добавить(Тип.Символы);
		КонецЦикла;
		Условие.Типы = Типы;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ОтметитьНекорректныеАргументыИЗапрещенныеУзлы.
Процедура ВыделитьПсевдонимПоля(УзелПоле, Контекст)
	
	Если УзелПоле.Вложение <> Неопределено Тогда
		Вложение = УзелПоле.Вложение;
		ВыделитьПсевдонимПоля(Вложение, Контекст);
		Если ЗначениеЗаполнено(Вложение.Выразить) Тогда
			УзелПоле.Таблица = Вложение.Выразить;
		КонецЕсли;
		
	ИначеЕсли Не ЗначениеЗаполнено(УзелПоле.Имя) Тогда
		Возврат;
	Иначе
		СоставИмени = СтрРазделить(УзелПоле.Имя, ".");
		Если СоставИмени.Количество() > 1 Тогда
			Свойства = Контекст.Псевдонимы.Получить(ВРег(СоставИмени[0]));
			Если Свойства <> Неопределено Тогда
				УзелПоле.Псевдоним = Свойства.Псевдоним;
				СоставИмени.Удалить(0);
				УзелПоле.Имя = СтрСоединить(СоставИмени, ".");
				Если ЗначениеЗаполнено(Свойства.Таблица) Тогда
					УзелПоле.Таблица = Свойства.Таблица;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если Контекст.ЭтоУсловиеСоединения Тогда
			Если Не ЗначениеЗаполнено(УзелПоле.Псевдоним) Тогда
				УстановитьОшибкуВСтроке(УзелПоле.ИмяИсточник,
					НСтр("ru = 'В условии соединения перед именем поля требуется псевдоним'"));
			ИначеЕсли Контекст.ДоступныеПсевдонимы.Получить(ВРег(УзелПоле.Псевдоним)) = Неопределено Тогда
				УстановитьОшибкуВСтроке(УзелПоле.ИмяИсточник,
					НСтр("ru = 'Нельзя указывать псевдоним из следующего соединения'"));
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(УзелПоле.Выразить) Тогда
		ДобавитьТребуемуюТаблицуКакСсылочныйТип(Контекст, УзелПоле.Выразить, УзелПоле.ВыразитьИсточник);
	КонецЕсли;
	
	ДобавитьТребуемоеПолеТаблицы(Контекст, УзелПоле.Таблица, УзелПоле.Имя, УзелПоле.ИмяИсточник,
		УзелПоле.Выразить, УзелПоле.ВыразитьИсточник, УзелПоле);
	
КонецПроцедуры

// Для процедур РазобратьУсловиеСоединения, РазобратьУсловиеОграничения.
Процедура УдалитьСвойствоИсточник(Условие)
	
	Если ТипЗнч(Условие) = Тип("СтрокаТаблицыЗначений") Тогда
		ТекстОшибки = НСтр("ru = 'Не все источники наборов символов удалены'");
		ВызватьИсключение ТекстОшибки;
		
	ИначеЕсли ТипЗнч(Условие) <> Тип("Структура") Тогда
		Возврат;
	КонецЕсли;
	
	Если Условие.Свойство("Источник") Тогда
		Условие.Удалить("Источник");
	КонецЕсли;
	
	Если Условие.Свойство("ИмяИсточник") Тогда
		Условие.Удалить("ИмяИсточник");
	КонецЕсли;
	
	Если Условие.Свойство("ВыразитьИсточник") Тогда
		Условие.Удалить("ВыразитьИсточник");
	КонецЕсли;
	
	Если Условие.Свойство("ЕстьNullИсточник") Тогда
		Условие.Удалить("ЕстьNullИсточник");
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из Условие Цикл
		Значение = КлючИЗначение.Значение;
		
		Если ТипЗнч(Значение) = Тип("Массив") Тогда
			Для Каждого Элемент Из Значение Цикл
				УдалитьСвойствоИсточник(Элемент);
			КонецЦикла;
			
		ИначеЕсли ТипЗнч(Значение) = Тип("Соответствие") Тогда
			Для Каждого КлючИЗначение Из Значение Цикл
				УдалитьСвойствоИсточник(КлючИЗначение.Ключ);
				УдалитьСвойствоИсточник(КлючИЗначение.Значение);
			КонецЦикла;
		Иначе
			УдалитьСвойствоИсточник(Значение);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ОтметитьНекорректныеАргументыИЗапрещенныеУзлы.
Процедура УстановитьОшибкуУзелЗапрещен(Строка, Контекст)
	
	Если Строка.Тип = "Функция" Тогда
		Если Контекст.ЭтоУсловиеСоединения Тогда
			ШаблонОшибки = НСтр("ru = 'Функция ""%1"" запрещена в условии соединения'");
			
		ИначеЕсли Контекст.ЭтоУсловиеКогда Тогда
			ШаблонОшибки = ПодставитьКлючевыеСловаВСтроку(Контекст,
				НСтр("ru = 'Функция ""%3"" запрещена в условии ограничения в операции ""%1"" в предложении ""%2""'"),
				"Выбор,Когда", Строка.Символы);
			
		ИначеЕсли Контекст.ЭтоЗначениеТогдаИначе Тогда
			ШаблонОшибки = ПодставитьКлючевыеСловаВСтроку(Контекст,
				НСтр("ru = 'Функция ""%4"" запрещена в условии ограничения в операции ""%1"" в предложениях ""%2"" и ""%3""'"),
				"Выбор,Тогда,Иначе");
		Иначе
			ШаблонОшибки = НСтр("ru = 'Функция ""%1"" запрещена в условии ограничения'");
		КонецЕсли;
	Иначе
		Если Контекст.ЭтоУсловиеСоединения Тогда
			ШаблонОшибки = НСтр("ru = 'Операция ""%1"" запрещена в условии соединения'");
			
		ИначеЕсли Контекст.ЭтоУсловиеКогда Тогда
			ШаблонОшибки = ПодставитьКлючевыеСловаВСтроку(Контекст,
				НСтр("ru = 'Операция ""%3"" запрещена в условии ограничения в операции ""%1"" в предложении ""%2""'"),
				"Выбор,Когда", Строка.Символы);
			
		ИначеЕсли Контекст.ЭтоЗначениеТогдаИначе Тогда
			ШаблонОшибки = ПодставитьКлючевыеСловаВСтроку(Контекст,
				НСтр("ru = 'Операция ""%4"" запрещена в условии ограничения в операции ""%1"" в предложениях ""%2"" и ""%3""'"),
				"Выбор,Тогда,Иначе");
		Иначе
			ШаблонОшибки = НСтр("ru = 'Операция ""%1"" запрещена в условии ограничения'");
		КонецЕсли;
	КонецЕсли;
	
	УстановитьОшибкуВСтроке(Строка, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		ШаблонОшибки, Строка.Символы));
	
КонецПроцедуры

// Для процедуры ОтметитьНекорректныеАргументыИЗапрещенныеУзлы.
Процедура ОтметитьПовторыТиповСредиПроверяемыхИУточняемых(Узел, Контекст)
	
	ТипыВСписке = Новый Соответствие;
	
	Для Каждого ТипВСписке Из Узел.Типы Цикл
		Если ТипыВСписке.Получить(ВРег(ТипВСписке.Символы)) = Неопределено Тогда
			ТипыВСписке.Вставить(ВРег(ТипВСписке.Символы), Истина);
		Иначе
			УстановитьОшибкуВСтроке(ТипВСписке, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Тип ""%1"" уже указан'"), ТипВСписке.Символы));
		КонецЕсли;
	КонецЦикла;
	
	УточняемыеТипы = Новый Соответствие;
	
	Для Каждого УточнениеСравнения Из Узел.УточненияСравнения Цикл
		Если ТипЗнч(УточнениеСравнения.Ключ) <> Тип("СтрокаТаблицыЗначений") Тогда
			Продолжить;
		КонецЕсли;
		ИсточникТипа = УточнениеСравнения.Ключ;
		
		Если Не Узел.ПроверятьТипыКромеУказанных
		   И ТипыВСписке.Получить(ВРег(ИсточникТипа.Символы)) <> Неопределено Тогда
			
			УстановитьОшибкуВСтроке(ИсточникТипа, ПодставитьКлючевыеСловаВСтроку(Контекст,
				НСтр("ru = 'Тип ""%2"" уже указан среди типов ключевого слова ""%1""'"),
				"Только",
				ИсточникТипа.Символы));
			
		ИначеЕсли Узел.ПроверятьТипыКромеУказанных
		        И ТипыВСписке.Получить(ВРег(ИсточникТипа.Символы)) = Неопределено Тогда
			
			УстановитьОшибкуВСтроке(ИсточникТипа, ПодставитьКлючевыеСловаВСтроку(Контекст,
				НСтр("ru = 'Тип ""%2"" не указан среди типов ключевого слова ""%1""'"),
				"Кроме",
				ИсточникТипа.Символы));
			
		ИначеЕсли УточняемыеТипы.Получить(ВРег(ИсточникТипа.Символы)) <> Неопределено Тогда
			УстановитьОшибкуВСтроке(ИсточникТипа, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Уточнение типа ""%1"" уже указано'"), ИсточникТипа.Символы));
		Иначе
			УточняемыеТипы.Вставить(ВРег(ИсточникТипа.Символы), Истина);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры РазобратьЧастьОграничения.
Процедура РазобратьУсловиеОграничения(СвойстваЧасти, ВнутренниеДанные)
	
	СтрокиЧасти = СвойстваЧасти.Строки;
	ИзменитьВидКлючевогоСловаСписокНаИмя(СтрокиЧасти);
	
	Если СтрокиЧасти.Количество() < 2
	 Или СтрокиЧасти[1].Вид <> "КлючевоеСлово"
	 Или СтрокиЧасти[1].Уточнение <> "Где" Тогда
		УстановитьОшибкуНачалаЧасти(
			?(СтрокиЧасти.Количество() < 2, СвойстваЧасти.СтрокаРазделителя, СтрокиЧасти[1]),
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'После ключевого слова ""%1"" не найдено
					           |ключевое слово ""%2""'"),
					СвойстваЧасти.Представление,
					КлючевоеСловоСУчетомЯзыка("Где", ВнутренниеДанные)));
		Возврат;
	КонецЕсли;
	
	Условие = Новый Массив(Новый ФиксированныйМассив(СтрокиЧасти));
	Для Индекс = 0 По 1 Цикл
		Условие.Удалить(0);
	КонецЦикла;
	
	РазобратьУсловие(Условие, СвойстваЧасти.Состав, ВнутренниеДанные);
	
	// Отметка некорректных параметров операций и неподдерживаемого функционала.
	ОбщиеУзлы = УправлениеДоступомСлужебныйПовтИсп.УзлыДляПроверкиДоступности("", Истина);
	
	УзлыКогда = УправлениеДоступомСлужебныйПовтИсп.УзлыДляПроверкиДоступности(
		"Поле,Значение,Константа,И,Или,Не,=,<>,В,ЕстьNull,Тип,ТипЗначения", Ложь);
	
	УзлыТогдаИначе = УправлениеДоступомСлужебныйПовтИсп.УзлыДляПроверкиДоступности(
		"Выбор,ДляВсехСтрок,ДляОднойИзСтрок", Истина);
	
	ДоступныеУзлы = Новый Структура;
	ДоступныеУзлы.Вставить("Общие",          ОбщиеУзлы);
	ДоступныеУзлы.Вставить("УзлыКогда",      УзлыКогда);
	ДоступныеУзлы.Вставить("УзлыТогдаИначе", УзлыТогдаИначе);
	
	ФиксированныйКонтекст = Новый ФиксированнаяСтруктура(ВнутренниеДанные);
	Контекст = Новый Структура(ФиксированныйКонтекст);
	Контекст.Вставить("ЭтоУсловиеСоединения",  Ложь);
	Контекст.Вставить("ЭтоУсловиеКогда",       Ложь);
	Контекст.Вставить("ЭтоЗначениеТогдаИначе", Ложь);
	Контекст.Вставить("КорневойУзел",          СвойстваЧасти.Состав);
	Контекст.Вставить("Чтение",
		    СвойстваЧасти.Имя = "РазрешитьЧтениеИзменение"
		Или СвойстваЧасти.Имя = "РазрешитьЧтение");
	
	ДобавитьПсевдонимыПоУмолчанию(Контекст);
	
	ОтметитьНекорректныеАргументыИЗапрещенныеУзлы(СвойстваЧасти.Состав, ДоступныеУзлы, Контекст);
	
	УдалитьСвойствоИсточник(СвойстваЧасти.Состав);
	
КонецПроцедуры

// Для процедур ЧастиОграничения, РазобратьУсловиеОграничения.
Процедура ДобавитьПсевдонимыПоУмолчанию(Контекст);
	
	Если Контекст.Псевдонимы.Количество() > 0 Тогда
		Возврат;
	КонецЕсли;
	
	Контекст.Псевдонимы.Вставить(ВРег("ЭтотСписок"), Новый Структура("Псевдоним, Таблица", "ЭтотСписок"));
	Контекст.Псевдонимы.Вставить(ВРег("ThisList"),   Новый Структура("Псевдоним, Таблица", "ThisList"));
	
КонецПроцедуры

// Для процедур РазобратьУсловиеСоединения, РазобратьУсловиеОграничения.
Процедура РазобратьУсловие(Условие, Состав, ВнутренниеДанные)
	
	ВыраженияВСкобкахВоВложениях = ВыраженияВСкобкахВоВложениях(Условие);
	
	ФункцииСВыражениямиВСкобках = ФункцииСВыражениямиВСкобках(
		ВыраженияВСкобкахВоВложениях, ВнутренниеДанные);
	
	ВыраженияВыборКогдаТогдаВоВложениях = ВыраженияВыборКогдаТогдаВоВложениях(
		ФункцииСВыражениямиВСкобках, ВнутренниеДанные);
	
	Условие = ВыраженияВыборКогдаТогдаВоВложениях;
	
	РазобратьВыражение(Условие, Состав, ВнутренниеДанные, Ложь);
	
	ОбъединитьВложенныеЛогическиеОперации(Состав);
	
КонецПроцедуры

// Для процедуры РазобратьУсловие.
Процедура ОбъединитьВложенныеЛогическиеОперации(Состав)
	
	Если Состав = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если Состав.Узел = "И"
	 Или Состав.Узел = "Или" Тогда
		
		Индекс = Состав.Аргументы.Количество() - 1;
		Пока Индекс >= 0 Цикл
			
			Аргумент = Состав.Аргументы[Индекс];
			ОбъединитьВложенныеЛогическиеОперации(Аргумент);
			
			Если Аргумент.Узел = Состав.Узел Тогда
				Состав.Аргументы.Удалить(Индекс);
				ВложенныйИндекс = Аргумент.Аргументы.Количество() - 1;
				Пока ВложенныйИндекс >= 0 Цикл
					Состав.Аргументы.Вставить(Индекс, Аргумент.Аргументы[ВложенныйИндекс]);
					ВложенныйИндекс = ВложенныйИндекс - 1;
				КонецЦикла;
			КонецЕсли;
			Индекс = Индекс - 1;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры


// Для процедур РазобратьУсловие, РазобратьФункцию, РазобратьВыбор.
Процедура РазобратьВыражение(Условие, Состав, ТекущийКонтекст, ВложенноеВыражение = Истина)
	
	ФиксированныйКонтекст = Новый ФиксированнаяСтруктура(ТекущийКонтекст);
	Контекст = Новый Структура(ФиксированныйКонтекст);
	Контекст.Вставить("Вложения", Новый Массив);
	Контекст.Вставить("Описание");
	Контекст.Вставить("Строка");
	
	Для Каждого Строка Из Условие Цикл
		Контекст.Строка = Строка;
		
		Если Строка.Вид = "Имя"
		 Или Строка.Вид = "Число"
		 Или Строка.Вид = "ПроизвольнаяСтрока"
		 Или Строка.Вид = "КлючевоеСлово" 
		   И (    Строка.Уточнение = "Истина"
		      Или Строка.Уточнение = "Ложь"
		      Или Строка.Уточнение = "Неопределено" ) Тогда
			
			НовоеОписание = ОписаниеУзлаПолеИлиУзлаКонстанта(Строка);
			ДобавитьАргументФункциюВыборОператор(Контекст, НовоеОписание);
			
		ИначеЕсли Строка.Вид = "КлючевоеСлово" Тогда
			
			Если Строка.Тип = "Функция"
			 Или Строка.Уточнение = "В" Тогда
				
				Если Строка.Тип = "Функция" Тогда
					РазобратьФункцию(Контекст);
				Иначе
					РазобратьСоединительВ(Контекст);
				КонецЕсли;
				
			ИначеЕсли Строка.Тип = "Соединитель" Тогда
				РазобратьСоединитель(Контекст);
			
			ИначеЕсли Строка.Тип = "Оператор" Тогда
				РазобратьОператор(Контекст);
				
			ИначеЕсли Строка.Тип = "СловоВыбора" Тогда
				РазобратьВыбор(Контекст);
			Иначе
				РазобратьОшибочноеКлючевоеСлово(Контекст);
			КонецЕсли;
			
		ИначеЕсли Строка.Вид = "Операция" Тогда
			РазобратьСоединитель(Контекст, Истина);
			
		ИначеЕсли Строка.Вид = "Разделитель" Тогда
			Если Строка.Символы = "(" Тогда
				НовоеОписание = Неопределено;
				РазобратьВыражение(Строка.Строки, НовоеОписание, Контекст);
				ДобавитьАргументФункциюВыборОператор(Контекст, НовоеОписание);
				Если НовоеОписание <> Неопределено Тогда
					НовоеОписание.Источник.Приоритет = 99;
				КонецЕсли;
			Иначе
				Контекст.Описание = Неопределено;
				УстановитьОшибкуВСтроке(Строка,
					НСтр("ru = 'Запятая может использоваться только для разделения параметров функций'"));
			КонецЕсли;
		Иначе
			Контекст.Описание = Неопределено;
			УстановитьОшибкуВСтроке(Строка, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Обработка ключевого слова ""%1"" не определена'"), Строка.Символы));
		КонецЕсли;
		
		Если Контекст.Описание = Неопределено Тогда
			// Возникала ошибка, останавливающая дальнейший разбор (предотвращение ложных срабатываний).
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если Контекст.Описание = Неопределено Тогда
		Если ВложенноеВыражение Тогда
			Состав = Новый Структура("Источник, Узел, Значение", Строка, "Константа", Ложь);
		Иначе
			Состав = Неопределено;
		КонецЕсли;
		
	ИначеЕсли Контекст.Вложения.Количество() = 0 Тогда
		Состав = Контекст.Описание;
	Иначе
		Состав = Контекст.Вложения[Контекст.Вложения.Количество() - 1];
	КонецЕсли;
	
КонецПроцедуры

// Для процедур РазобратьВыражение, РазобратьПервыйПараметрПроверочнойФункции,
// РазобратьПараметрыФункцииТипЗначения, РазобратьВыбор и
// для функции ОписаниеУзлаПолеИзФункцииЕстьNull.
//
Функция ОписаниеУзлаПолеИлиУзлаКонстанта(Строка)
	
	// <Имя поля>, <Число>, <Произвольная строка>, Истина, Ложь, Неопределено.
	
	Если Строка.Вид = "Имя" Тогда
		НовоеОписание = ОписаниеУзлаПоле(Строка);
		НовоеОписание.Имя         = Строка.Символы;
		НовоеОписание.ИмяИсточник = Строка;
	Иначе
		СвойстваУзла = "Источник, Узел, Значение";
		НовоеОписание = Новый Структура(СвойстваУзла, Строка, "Константа");
		
		Если Строка.Вид = "КлючевоеСлово" Тогда
			Если Строка.Уточнение = "Истина" Тогда
				НовоеОписание.Значение = Истина;
				
			ИначеЕсли Строка.Уточнение = "Ложь" Тогда
				НовоеОписание.Значение = Ложь;
				
			Иначе // Строка.Вид = "Неопределено".
				НовоеОписание.Значение = Неопределено;
			КонецЕсли;
		Иначе // "Число" или "ПроизвольнаяСтрока".
			НовоеОписание.Значение = Строка.Уточнение;
		КонецЕсли;
	КонецЕсли;
	
	Возврат НовоеОписание;
	
КонецФункции

// Для функций ОписаниеУзлаПолеИлиУзлаКонстанта, ОписаниеУзлаПолеИзФункцииВыразить, ОписаниеУзлаПолеИзФункцииЕстьNull.
Функция ОписаниеУзлаПоле(Строка)
	
	СвойстваУзла = "Источник, Узел, Имя, Таблица, Псевдоним, Выразить, Вложение, ЕстьNull";
	НовоеОписание = Новый Структура(СвойстваУзла, Строка, "Поле");
	
	НовоеОписание.Вставить("ИмяИсточник",      Неопределено);
	НовоеОписание.Вставить("ВыразитьИсточник", Неопределено);
	НовоеОписание.Вставить("ЕстьNullИсточник", Неопределено);
	
	Возврат НовоеОписание;
	
КонецФункции

// Для процедуры РазобратьВыражение.
Процедура РазобратьСоединитель(Контекст, ЭтоОперация = Ложь)
	
	// И, Или, Как, Кроме, Только, Есть и любая операция =, <>, ...
	// Ключевое слово В разбирается отдельно в процедуре "РазобратьОперациюВ".
	
	Строка = Контекст.Строка;
	
	НовоеОписание = Новый Структура("Источник, Узел", Строка,
		?(Строка.Вид = "Операция", Строка.Символы, Строка.Уточнение));
	
	Если Строка.Уточнение = "И"
	 Или Строка.Уточнение = "Или" Тогда
		
		НовоеОписание.Вставить("Аргументы", Новый Массив);
		НовоеОписание.Аргументы.Добавить(Неопределено);
		ДобавитьСоединитель(Контекст, НовоеОписание, НовоеОписание.Аргументы[0]);
	
	ИначеЕсли Строка.Уточнение = "Есть" Тогда
		НовоеОписание.Узел = "ЕстьNull";
		НовоеОписание.Вставить("Аргумент", Неопределено);
		ДобавитьСоединитель(Контекст, НовоеОписание, НовоеОписание.Аргумент);
		// Проверка корректности параметров выполняется
		// в процедуре ОтметитьНекорректныеАргументыИЗапрещенныеУзлы.
		
	ИначеЕсли Строка.Вид = "Операция" Тогда
		НовоеОписание.Вставить("ПервыйАргумент", Неопределено);
		НовоеОписание.Вставить("ВторойАргумент", Неопределено);
		ДобавитьСоединитель(Контекст, НовоеОписание, НовоеОписание.ПервыйАргумент);
		// Проверка корректности аргументов выполняется
		// в процедуре ОтметитьНекорректныеАргументыИЗапрещенныеУзлы.
		
	ИначеЕсли Строка.Уточнение = "Как"
	      Или Строка.Уточнение = "Кроме"
	      Или Строка.Уточнение = "Только" Тогда
		
		Контекст.Описание = Неопределено;
		УстановитьОшибкуВСтроке(Строка, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ключевое слово ""%1"" может использоваться только в параметрах функций'"), Строка.Символы));
	Иначе
		Контекст.Описание = Неопределено;
		УстановитьОшибкуВСтроке(Строка, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Обработка ключевого слова ""%1"" не определена'"), Строка.Символы));
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры РазобратьВыражение.
Процедура РазобратьСоединительВ(Контекст)
	
	Строка = Контекст.Строка;
	
	НовоеОписание = Новый Структура("Источник, Узел", Строка, Строка.Уточнение);
	НовоеОписание.Вставить("Искомое",  Неопределено);
	НовоеОписание.Вставить("Значения", Новый Массив);
	
	СоставПараметров = ПараметрыРазделенныеЗапятыми(Строка);
	// Ошибка отсутствия параметров уже установлена в функции ФункцииСВыражениямиВСкобках.
	
	Для Каждого ОписаниеПараметра Из СоставПараметров Цикл
		Для Каждого Подстрока Из ОписаниеПараметра.Строки Цикл
			
			РазобратьЗначениеСоединителяВ(Контекст, Подстрока, НовоеОписание);
			
			Если ОписаниеПараметра.Строки[0] <> Подстрока Тогда
				УстановитьОшибкуВСтроке(Подстрока, НСтр("ru = 'Перед параметром не указана запятая'"));
			КонецЕсли;
			
		КонецЦикла;
	КонецЦикла;
	
	ДобавитьСоединитель(Контекст, НовоеОписание, НовоеОписание.Искомое);
	
	Если НовоеОписание.Искомое.Узел <> "Поле" Тогда
		УстановитьОшибкуВСтроке(Строка, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Операцию ""%1"" можно указывать только после имени поля'"), Строка.Символы));
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры РазобратьСоединительВ.
Процедура РазобратьЗначениеСоединителяВ(Контекст, Подстрока, НовоеОписание)
	
	Строка = Контекст.Строка;
	
	Если Подстрока.Вид = "Число"
	 Или Подстрока.Вид = "ПроизвольнаяСтрока" Тогда
		
		ОписаниеКонстанты = Новый Структура("Источник, Узел", Подстрока, "Константа");
		ОписаниеКонстанты.Вставить("Значение", Подстрока.Уточнение);
		НовоеОписание.Значения.Добавить(ОписаниеКонстанты);
		
	ИначеЕсли Подстрока.Вид = "КлючевоеСлово" Тогда
		
		Если Подстрока.Уточнение = "Значение" Тогда
			НовыйКонтекст = НовыйКонтекст(Контекст, Подстрока, Неопределено);
			РазобратьФункцию(НовыйКонтекст);
			Если НовыйКонтекст.Описание <> Неопределено Тогда
				НовоеОписание.Значения.Добавить(НовыйКонтекст.Описание);
			КонецЕсли;
		Иначе
			УстановитьОшибкуВСтроке(Подстрока, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'В списке значений операции ""%1"" ключевое слово ""%2"" недопустимо'"),
				Строка.Символы, Подстрока.Символы));
		КонецЕсли;
		
	ИначеЕсли Подстрока.Вид = "Имя" Тогда
		УстановитьОшибкуВСтроке(Подстрока, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В списке значений операции ""%1"" имя поля недопустимо'"), Строка.Символы));
		
	ИначеЕсли Подстрока.Символы = "(" Тогда
		УстановитьОшибкуВСтроке(Подстрока, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В списке значений операции ""%1"" скобки допустимы только для параметров функции'"), Строка.Символы));
	Иначе
		УстановитьОшибкуВСтроке(Подстрока, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В списке значений операции ""%1"" можно указывать только значения'"), Строка.Символы));
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры РазобратьЗначениеСоединителяВ.
Функция НовыйКонтекст(Контекст, Строка = null, Описание = null)
	
	ФиксированныйКонтекст = Новый ФиксированнаяСтруктура(Контекст);
	НовыйКонтекст = Новый Структура(ФиксированныйКонтекст);
	
	Если Строка <> null Тогда
		НовыйКонтекст.Строка = Строка;
	КонецЕсли;
	
	Если Описание <> null Тогда
		НовыйКонтекст.Описание = Описание;
	КонецЕсли;
	
	Возврат НовыйКонтекст;
	
КонецФункции

// Для процедур РазобратьСоединитель, РазобратьСоединительВ, ВставитьСоединительСУчетомПриоритета.
Процедура ДобавитьСоединитель(Контекст, НовоеОписание, ПервыйАргумент);
	
	// Добавляемый соединитель: И, Или, В, Есть и любая операция (=, <>, ...).
	
	Описание = Контекст.Описание;
	
	Если Описание = Неопределено Тогда
		Контекст.Описание = НовоеОписание;
		
	ИначеЕсли Описание.Узел = "И"
	      Или Описание.Узел = "Или" Тогда
		
		Если Описание.Аргументы.Количество() = 1 Тогда
			Описание.Аргументы.Добавить(Неопределено);
			ОбработатьПропущенныйАргументПослеСоединителя(Контекст, Описание.Аргументы[1]);
		КонецЕсли;
		ВставитьСоединительСУчетомПриоритета(Контекст,
			Описание.Аргументы[1], НовоеОписание, ПервыйАргумент);
		
	ИначеЕсли Описание.Узел = "Не" Тогда
		Если Не ЗначениеЗаполнено(Описание.Аргумент) Тогда
			ОбработатьПропущенныйАргументПослеСоединителя(Контекст, Описание.Аргумент);
		КонецЕсли;
		ВставитьСоединительСУчетомПриоритета(Контекст,
			Описание.Аргумент, НовоеОписание, ПервыйАргумент);
		
	ИначеЕсли Описание.Источник.Вид = "Операция" Тогда
		Если Не ЗначениеЗаполнено(Описание.ВторойАргумент) Тогда
			ОбработатьПропущенныйАргументПослеСоединителя(Контекст, Описание.ВторойАргумент, Ложь);
		КонецЕсли;
		ВставитьСоединительСУчетомПриоритета(Контекст,
			Описание.ВторойАргумент, НовоеОписание, ПервыйАргумент);
		
	ИначеЕсли СтрНайти(",Поле,Значение,Константа,В,ЕстьNull,Выбор,", "," + Описание.Узел + ",") > 0
	      Или Описание.Источник.Тип = "Функция" Тогда
		// Второй аргумент операции В уже разобран в процедуре РазобратьОперациюВ.
		// Второй аргумент Null операции Есть уже разобран в функции ФункцииСВыражениямиВСкобках.
		// Остальные узлы не имеют второго аргумента.
		ВставитьСоединительСУчетомПриоритета(Контекст, Неопределено, НовоеОписание, ПервыйАргумент);
	Иначе
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не определена обработка узла ""%1""'"), Описание.Узел);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ДобавитьСоединитель.
Процедура ОбработатьПропущенныйАргументПослеСоединителя(Контекст, ВторойАргумент, ЛогическаяОперация = Истина)
	
	УстановитьОшибкуВСтроке(Контекст.Описание.Источник,
		?(ЛогическаяОперация,
			НСтр("ru = 'Не указан аргумент после логической операции'"),
			НСтр("ru = 'Не указан аргумент после операции'")),
		Истина);
	
	ВторойАргумент = Новый Структура("Источник, Узел, Значение", Контекст.Строка, "Константа", Истина);
	
КонецПроцедуры

// Для процедур ДобавитьСоединитель, ОбработатьПропущеннуюЛогическуюОперацию.
Процедура ВставитьСоединительСУчетомПриоритета(Контекст,
			ПоследнийАргументОписания, НовоеОписание, ПервыйАргументНовогоОписания)
	
	Вложения = Контекст.Вложения;
	
	Если ПоследнийАргументОписания <> Неопределено
	   И Контекст.Строка.Приоритет >= Контекст.Описание.Источник.Приоритет Тогда
		
		// Замена аргумента текущего узла на соединитель (случай "А Или Б И ...").
		ПервыйАргументНовогоОписания = ПоследнийАргументОписания;
		ПоследнийАргументОписания = НовоеОписание;
		
		Вложения.Вставить(0, Контекст.Описание);
		Контекст.Описание = НовоеОписание;
		Возврат;
	КонецЕсли;
	
	Если Вложения.Количество() = 0 Тогда
		// Вложение текущего узла, как первого аргумента соединителя (случай "А И Б Или ...").
		ПервыйАргументНовогоОписания = Контекст.Описание;
		Контекст.Описание = НовоеОписание;
		Возврат;
	КонецЕсли;
	
	// Вложение предыдущего узла, как первого аргумента соединителя (случай "А И Не Б Или ...").
	Контекст.Описание = Вложения[0];
	Вложения.Удалить(0);
	
	ДобавитьСоединитель(Контекст, НовоеОписание, ПервыйАргументНовогоОписания);
	
КонецПроцедуры

// Для процедуры РазобратьВыражение.
Процедура РазобратьОператор(Контекст)
	
	// Оператор Не.
	
	НовоеОписание = Новый Структура("Источник, Узел, Аргумент",
		Контекст.Строка, Контекст.Строка.Уточнение);
	
	ДобавитьАргументФункциюВыборОператор(Контекст, НовоеОписание);
	
	Контекст.Вложения.Вставить(0, Контекст.Описание);
	Контекст.Описание = НовоеОписание;
	
КонецПроцедуры

// Для процедур РазобратьВыражение, РазобратьЗначениеСоединителяВ.
Процедура РазобратьФункцию(Контекст)
	
	Строка = Контекст.Строка;
	
	НовоеОписание = Новый Структура("Источник, Узел", Строка, Строка.Уточнение);
	
	Если Строка.Уточнение = "ЗначениеРазрешено"
	 Или Строка.Уточнение = "ЧтениеОбъектаРазрешено"
	 Или Строка.Уточнение = "ИзменениеОбъектаРазрешено"
	 Или Строка.Уточнение = "ЧтениеСпискаРазрешено"
	 Или Строка.Уточнение = "ИзменениеСпискаРазрешено"
	 Или Строка.Уточнение = "ЭтоАвторизованныйПользователь" Тогда
		
		РазобратьПараметрыПроверочнойФункции(Контекст, НовоеОписание);
		
	ИначеЕсли Строка.Уточнение = "ДляВсехСтрок"
	      Или Строка.Уточнение = "ДляОднойИзСтрок" Тогда
		
		ОписаниеВыражения = Неопределено;
		РазобратьВыражение(Строка.Строки, ОписаниеВыражения, Контекст);
		НовоеОписание.Вставить("Аргумент", ОписаниеВыражения);
	
	ИначеЕсли Строка.Уточнение = "Значение" Тогда
		РазобратьПараметрыФункцииЗначениеИлиФункцииТип(Строка, НовоеОписание, Истина, Контекст);
		
	ИначеЕсли Строка.Уточнение = "Тип" Тогда
		РазобратьПараметрыФункцииЗначениеИлиФункцииТип(Строка, НовоеОписание, Ложь, Контекст);
		
	ИначеЕсли Строка.Уточнение = "ТипЗначения" Тогда
		РазобратьПараметрыФункцииТипЗначения(Контекст, НовоеОписание);
		
	ИначеЕсли Строка.Уточнение = "ЕстьNull" Тогда
		НовоеОписание = ОписаниеУзлаПолеИзФункцииЕстьNull(Контекст.Строка, Контекст);
		
	ИначеЕсли Строка.Уточнение = "Выразить" Тогда
		НовоеОписание =  ОписаниеУзлаПолеИзФункцииВыразить(Контекст.Строка, Контекст);
		
	ИначеЕсли Не Строка.ЭтоРезерв Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не определена обработка функции ""%1""'"), Строка.Уточнение);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	ДобавитьАргументФункциюВыборОператор(Контекст, НовоеОписание);
	
КонецПроцедуры

// Для процедуры РазобратьФункцию.
Процедура РазобратьПараметрыПроверочнойФункции(Контекст, НовоеОписание)
	
	Строка = Контекст.Строка;
	
	НовоеОписание.Вставить("Поле",                        Неопределено);
	НовоеОписание.Вставить("Типы",                        Новый Массив);
	НовоеОписание.Вставить("ПроверятьТипыКромеУказанных", Ложь);
	НовоеОписание.Вставить("УточненияСравнения",          Новый Соответствие);
	
	СоставПараметров = ПараметрыРазделенныеЗапятыми(Строка);
	
	Если СоставПараметров.Количество() = 0 Тогда
		Возврат; // Ошибка отсутствия параметров уже установлена в функции ФункцииСВыражениямиВСкобках.
	КонецЕсли;
	
	РазобратьПервыйПараметрПроверочнойФункции(Контекст, СоставПараметров[0], НовоеОписание);
	
	Для Индекс = 1 По СоставПараметров.Количество() - 1 Цикл
		РазобратьДополнительныйПараметрПроверочнойФункции(Контекст,
			СоставПараметров[Индекс], НовоеОписание);
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры РазобратьПараметрыПроверочнойФункции.
Процедура РазобратьПервыйПараметрПроверочнойФункции(Контекст, ПервыйПараметр, НовоеОписание)
	
	Если ПервыйПараметр.Строки[0].Вид = "Имя" Тогда
		НовоеОписание.Поле = ОписаниеУзлаПолеИлиУзлаКонстанта(ПервыйПараметр.Строки[0]);
		
	ИначеЕсли ПервыйПараметр.Строки[0].Вид = "КлючевоеСлово"
	        И ПервыйПараметр.Строки[0].Уточнение = "Выразить" Тогда
		
		НовоеОписание.Поле = ОписаниеУзлаПолеИзФункцииВыразить(ПервыйПараметр.Строки[0], Контекст);
		
	ИначеЕсли ПервыйПараметр.Строки[0].Вид = "КлючевоеСлово"
	        И ПервыйПараметр.Строки[0].Уточнение = "ЕстьNull" Тогда
		
		НовоеОписание.Поле = ОписаниеУзлаПолеИзФункцииЕстьNull(ПервыйПараметр.Строки[0], Контекст);
	Иначе
		УстановитьОшибкуВСтроке(ПервыйПараметр.Строки[0],
			ПодставитьКлючевыеСловаВСтроку(Контекст,
				НСтр("ru = 'Первым параметром может быть имя поля, функция ""%1"" или функция ""%2""'"),
				"Выразить,ЕстьNull"));
		Возврат;
	КонецЕсли;
	
	Если ПервыйПараметр.Строки.Количество() < 2 Тогда
		Возврат;
	КонецЕсли;
	
	Если ПервыйПараметр.Строки[0].Вид = "КлючевоеСлово"
	   И ПервыйПараметр.Строки[0].Уточнение = "Выразить"
	   И НовоеОписание.Поле.Вложение = Неопределено Тогда
		
		УстановитьОшибкуВСтроке(ПервыйПараметр.Строки[0].КонечнаяСтрока,
			ПодставитьКлючевыеСловаВСтроку(Контекст,
				НСтр("ru = 'После вложенной функции ""%3"" должно быть указано имя поля через точку,
				           |если в параметре функции ""%4"" используется ключевое слово ""%1"" или ""%2""'"),
				"Только,Кроме",
				ПервыйПараметр.Строки[0].Символы,
				Контекст.Строка.Символы),
			Истина);
	КонецЕсли;
	
	Если ПервыйПараметр.Строки[1].Вид <> "КлючевоеСлово"
	 Или (  ПервыйПараметр.Строки[1].Уточнение <> "Только"
	      И ПервыйПараметр.Строки[1].Уточнение <> "Кроме" ) Тогда
		
		УстановитьОшибкуВСтроке(ПервыйПараметр.Строки[1],
			ПодставитьКлючевыеСловаВСтроку(Контекст,
				НСтр("ru = 'После описания поля может быть указано, либо ключевое слово ""%1"", либо ""%2""'"),
				"Только,Кроме"));
		Возврат;
	КонецЕсли;
	
	Если ПервыйПараметр.Строки[1].Уточнение = "Кроме" Тогда
		НовоеОписание.ПроверятьТипыКромеУказанных = Истина;
	КонецЕсли;
	
	Если ПервыйПараметр.Строки.Количество() < 3 Тогда
		УстановитьОшибкуВСтроке(ПервыйПараметр.Строки[1],  СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'После ключевого слова ""%1"" не указан тип (имя таблицы)'"), ПервыйПараметр.Строки[1].Символы));
		Возврат;
	КонецЕсли;
	
	Если ПервыйПараметр.Строки[2].Вид <> "Имя"
	   И ПервыйПараметр.Строки[2].Символы <> "(" Тогда
	
		УстановитьОшибкуВСтроке(ПервыйПараметр.Строки[2],  СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'После ключевого слова ""%1"" должен быть указан, либо тип (имя таблицы), либо список типов в скобках'"),
			ПервыйПараметр.Строки[1].Символы));
		Возврат;
	КонецЕсли;
	
	Если ПервыйПараметр.Строки.Количество() > 3 Тогда
		УстановитьОшибкуВСтроке(ПервыйПараметр.Строки[3], СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Перед параметром функции ""%1"" не указана запятая'"), Контекст.Строка.Символы));
	КонецЕсли;
	
	Если ПервыйПараметр.Строки[2].Вид = "Имя" Тогда
		НовоеОписание.Типы.Добавить(ПервыйПараметр.Строки[2]);
		ДобавитьТребуемуюТаблицуКакСсылочныйТип(Контекст, ПервыйПараметр.Строки[2].Символы, ПервыйПараметр.Строки[2]);
		Возврат;
	КонецЕсли;
	
	СоставПараметров = ПараметрыРазделенныеЗапятыми(ПервыйПараметр.Строки[2]);
	
	Если СоставПараметров.Количество() = 0 Тогда
		Возврат; // Ошибка отсутствия параметров уже установлена в функции ФункцииСВыражениямиВСкобках.
	КонецЕсли;
	
	Для Каждого Параметр Из СоставПараметров Цикл
		
		Если Параметр.Строки[0].Вид = "Имя"
		   И Параметр.Строки.Количество() < 2 Тогда
			
			НовоеОписание.Типы.Добавить(Параметр.Строки[0]);
		Иначе
			УстановитьОшибкуВСтроке(Параметр.Строки[?(Параметр.Строки.Количество() < 2, 0, 1)],
				НСтр("ru = 'В списке типов могут быть указаны только имена таблицы через запятую'"));
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры РазобратьПараметрыПроверочнойФункции.
Процедура РазобратьДополнительныйПараметрПроверочнойФункции(Контекст, Параметр, НовоеОписание)
	
	Если Параметр.Строки[0].Вид = "Имя"
	 Или Параметр.Строки[0].Вид = "КлючевоеСлово"
	   И (    Параметр.Строки[0].Тип = "ЗначениеСравнения"
	      Или Параметр.Строки[0].Тип = "ИмяТипа" ) Тогда
		
		Если Параметр.Строки[0].Вид = "Имя" Тогда
			ЗначениеСравнения = Параметр.Строки[0];
			ДобавитьТребуемуюТаблицуКакСсылочныйТип(Контекст, Параметр.Строки[0].Символы, Параметр.Строки[0]);
		Иначе
			ЗначениеСравнения = Параметр.Строки[0].Уточнение;
		КонецЕсли;
	Иначе
		УстановитьОшибкуВСтроке(Параметр.Строки[0],
			ПодставитьКлючевыеСловаВСтроку(Контекст,
				НСтр("ru = 'Дополнительным параметром может быть тип (имя таблицы),
				           |""%1"", ""%2"", ""%3"", ""%4"", ""%5"", ""%6"" и ""%7""'"),
				"ПустаяСсылка,Неопределено,Null,Число,Строка,Дата,Булево"));
		Возврат;
	КонецЕсли;
	
	Если Параметр.Строки.Количество() < 2 Тогда
		Если Параметр.Строки[0].Вид = "Имя" Тогда 
			Шаблон = НСтр("ru = 'После типа (имени таблицы) ""%2"" должно быть указано ключевое слово ""%1""'");
		Иначе
			Шаблон = НСтр("ru = 'После ключевого слова ""%2"" должно быть указано ключевое слово ""%1""'");
		КонецЕсли;
		УстановитьОшибкуВСтроке(Параметр.Строки[0], ПодставитьКлючевыеСловаВСтроку(Контекст,
				Шаблон, "Как", Параметр.Строки[0].Символы),
			Истина);
		Возврат;
	КонецЕсли;
	
	Если Параметр.Строки[1].Вид <> "КлючевоеСлово"
	 Или Параметр.Строки[1].Уточнение <> "Как" Тогда
		
		Если Параметр.Строки[0].Вид = "Имя" Тогда
			Шаблон = НСтр("ru = 'После типа (имени таблицы) ""%2"" должно быть указано ключевое слово ""%1""'");
		Иначе
			Шаблон = НСтр("ru = 'После ключевого слова ""%2"" должно быть указано ключевое слово ""%1""'");
		КонецЕсли;
		УстановитьОшибкуВСтроке(Параметр.Строки[1], ПодставитьКлючевыеСловаВСтроку(Контекст,
			Шаблон, "Как", Параметр.Строки[0].Символы));
		Возврат;
	КонецЕсли;
	
	Если Параметр.Строки.Количество() < 3 Тогда
		УстановитьОшибкуВСтроке(Параметр.Строки[1], ПодставитьКлючевыеСловаВСтроку(Контекст,
				НСтр("ru = 'После ключевого слова ""%4"" не указано значение уточнения ""%1"", ""%2"" или ""%3""'"),
				"Ложь,Истина,Пусто",
				Параметр.Строки[1].Символы),
			Истина);
		Возврат;
	КонецЕсли;
	
	Если Параметр.Строки[2].Вид <> "КлючевоеСлово"
	 Или Параметр.Строки[2].Тип <> "ЗначениеУточнения" Тогда
		
		УстановитьОшибкуВСтроке(Параметр.Строки[2], ПодставитьКлючевыеСловаВСтроку(Контекст,
			НСтр("ru = 'После ключевого слова ""%4"" должно быть указано значение уточнения ""%1"", ""%2"" или ""%3""'"),
			"Ложь,Истина,Пусто",
			Параметр.Строки[1].Символы));
	Иначе
		НовоеОписание.УточненияСравнения.Вставить(ЗначениеСравнения, Параметр.Строки[2].Уточнение);
	КонецЕсли;
	
	Если Параметр.Строки.Количество() > 3 Тогда
		УстановитьОшибкуВСтроке(Параметр.Строки[3],
			НСтр("ru = 'Перед параметром не указана запятая или лишний параметр'"));
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры РазобратьФункцию.
Процедура РазобратьПараметрыФункцииЗначениеИлиФункцииТип(Строка, НовоеОписание, ЭтоФункцияЗначение, Контекст)
	
	НовоеОписание.Вставить("Имя", Неопределено);
	
	СоставПараметров = ПараметрыРазделенныеЗапятыми(Строка);
	
	Если СоставПараметров.Количество() = 0 Тогда
		Возврат; // Ошибка отсутствия параметров уже установлена в функции ФункцииСВыражениямиВСкобках.
	КонецЕсли;
	
	Параметр = СоставПараметров[0];
	Если Параметр.Строки[0].Вид = "Имя" Тогда
		НовоеОписание.Имя = Параметр.Строки[0].Символы;
		
		Если ЭтоФункцияЗначение Тогда
			ДобавитьТребуемыйПредопределенныйЭлемент(Контекст, НовоеОписание.Имя, Параметр.Строки[0]);
		Иначе
			ДобавитьТребуемуюТаблицуКакСсылочныйТип(Контекст, НовоеОписание.Имя, Параметр.Строки[0]);
		КонецЕсли;
		
	ИначеЕсли ЭтоФункцияЗначение Тогда
		УстановитьОшибкуВСтроке(Параметр.Строки[0], СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В функции ""%1"" можно указать только имя предопределенного значения'"), Строка.Символы));
	
	ИначеЕсли Параметр.Строки[0].Вид = "КлючевоеСлово"
	        И Параметр.Строки[0].Тип = "ИмяТипа" Тогда
		
		НовоеОписание.Имя = Параметр.Строки[0].Уточнение;
	Иначе
		УстановитьОшибкуВСтроке(Параметр.Строки[0], ПодставитьКлючевыеСловаВСтроку(Контекст,
			НСтр("ru = 'В функции ""%5"" можно указать имя таблицы или ""%1"", ""%2"", ""%3"" и ""%4""'"),
			"Число,Строка,Дата,Булево",
			Строка.Символы));
	КонецЕсли;
	
	Если Параметр.Строки.Количество() > 1 Тогда
		УстановитьОшибкуВСтроке(Параметр.Строки[1], СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'У функции ""%1"" может быть только один параметр'"), Строка.Символы));
	КонецЕсли;
	
	Если СоставПараметров.Количество() > 1 Тогда
		УстановитьОшибкуВСтроке(СоставПараметров[1].Строки[0], СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'У функции ""%1"" может быть только один параметр'"), Строка.Символы));
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры РазобратьФункцию.
Процедура РазобратьПараметрыФункцииТипЗначения(Контекст, НовоеОписание)
	
	Строка = Контекст.Строка;
	НовоеОписание.Вставить("Аргумент", Неопределено);
	
	СоставПараметров = ПараметрыРазделенныеЗапятыми(Строка);
	
	Если СоставПараметров.Количество() = 0 Тогда
		Возврат; // Ошибка отсутствия параметров уже установлена в функции ФункцииСВыражениямиВСкобках.
	КонецЕсли;
	
	Параметр = СоставПараметров[0];
	
	Если Параметр.Строки[0].Вид = "Имя" Тогда
		НовоеОписание.Аргумент = ОписаниеУзлаПолеИлиУзлаКонстанта(Параметр.Строки[0]);
		
	ИначеЕсли Параметр.Строки[0].Вид = "КлючевоеСлово"
	        И Параметр.Строки[0].Уточнение = "Выразить" Тогда
		
		НовоеОписание.Аргумент = ОписаниеУзлаПолеИзФункцииВыразить(Параметр.Строки[0], Контекст);
		
	ИначеЕсли Параметр.Строки[0].Вид = "КлючевоеСлово"
	        И Параметр.Строки[0].Уточнение = "ЕстьNull" Тогда
		
		НовоеОписание.Аргумент = ОписаниеУзлаПолеИзФункцииЕстьNull(Параметр.Строки[0], Контекст);
	Иначе
		УстановитьОшибкуВСтроке(Параметр.Строки[0],
			ПодставитьКлючевыеСловаВСтроку(Контекст,
				НСтр("ru = 'Параметром может быть имя поля, функция ""%1"" или функция ""%2""'"),
				"Выразить,ЕстьNull"));
		Возврат;
	КонецЕсли;
	
	Если Параметр.Строки[0].Вид = "КлючевоеСлово"
	   И Параметр.Строки[0].Уточнение = "Выразить"
	   И НовоеОписание.Аргумент.Вложение = Неопределено Тогда
		
		УстановитьОшибкуВСтроке(Параметр.Строки[0].КонечнаяСтрока,
			ПодставитьКлючевыеСловаВСтроку(Контекст,
				НСтр("ru = 'После вложенной функции ""%1"" должно быть указано имя поля через точку'"),
				Параметр.Строки[0].Символы),
			Истина);
	КонецЕсли;
	
	Если Параметр.Строки.Количество() < 2 Тогда
		Возврат;
	КонецЕсли;
	
	Если Параметр.Строки.Количество() > 1 Тогда
		УстановитьОшибкуВСтроке(Параметр.Строки[1], СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'У функции ""%1"" может быть только один параметр'"), Строка.Символы));
	КонецЕсли;
	
	Если СоставПараметров.Количество() > 1 Тогда
		УстановитьОшибкуВСтроке(СоставПараметров[1].Строки[0], СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'У функции ""%1"" может быть только один параметр'"), Строка.Символы));
	КонецЕсли;
	
КонецПроцедуры

// Для процедур РазобратьФункцию, РазобратьПервыйПараметрПроверочнойФункции, РазобратьПараметрыФункцииТипЗначения.
Функция ОписаниеУзлаПолеИзФункцииВыразить(Строка, Контекст)
	
	НовоеОписание = ОписаниеУзлаПоле(Строка);
	
	Если Строка.Строки.Количество() > 0 Тогда
		ПоследняяСтрока = Строка.Строки[Строка.Строки.Количество() - 1];
		Если ПоследняяСтрока.Тип = "ДополнениеКВыразить" Тогда
			Строка.Строки.Удалить(Строка.Строки.Количество() - 1);
			НовоеОписание.Имя         = Сред(ПоследняяСтрока.Символы, 2);
			НовоеОписание.ИмяИсточник = ПоследняяСтрока;
			НовоеОписание.Вложение    = ОписаниеУзлаПолеИзФункцииВыразить(Строка, Контекст);
			Возврат НовоеОписание;
		КонецЕсли;
	КонецЕсли;
	
	СоставПараметров = ПараметрыРазделенныеЗапятыми(Строка);
	
	Если СоставПараметров.Количество() = 0 Тогда
		// Ошибка отсутствия параметров уже установлена в функции ФункцииСВыражениямиВСкобках.
		Возврат НовоеОписание;
	КонецЕсли;
	
	ПервыйПараметр = СоставПараметров[0];
	
	Если ПервыйПараметр.Строки[0].Вид = "Имя" Тогда
		НовоеОписание.Имя         = ПервыйПараметр.Строки[0].Символы;
		НовоеОписание.ИмяИсточник = ПервыйПараметр.Строки[0];
		
	ИначеЕсли ПервыйПараметр.Строки[0].Вид = "КлючевоеСлово"
	        И ПервыйПараметр.Строки[0].Уточнение = "Выразить" Тогда
		
		НовоеОписание.Вложение = ОписаниеУзлаПолеИзФункцииВыразить(ПервыйПараметр.Строки[0], Контекст);
		Если НовоеОписание.Вложение.Вложение = Неопределено Тогда
			УстановитьОшибкуВСтроке(ПервыйПараметр.Строки[0].КонечнаяСтрока,
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'После вложенной функции ""%1"" должно быть указано имя поля через точку'"),
					ПервыйПараметр.Строки[0].Символы),
				Истина);
		Иначе
			НовоеОписание = НовоеОписание.Вложение;
		КонецЕсли;
		
	ИначеЕсли ПервыйПараметр.Строки[0].Вид = "КлючевоеСлово"
	        И ПервыйПараметр.Строки[0].Уточнение = "ЕстьNull" Тогда
		
		НовоеОписание = ОписаниеУзлаПолеИзФункцииЕстьNull(ПервыйПараметр.Строки[0], Контекст);
	Иначе
		УстановитьОшибкуВСтроке(ПервыйПараметр.Строки[0],
			ПодставитьКлючевыеСловаВСтроку(Контекст,
				НСтр("ru = 'Первым параметром может быть имя поля, функция ""%1"" или функция ""%2""'"),
				"Выразить,ЕстьNull"));
		Возврат НовоеОписание;
	КонецЕсли;
	
	Если ПервыйПараметр.Строки.Количество() < 2 Тогда
		УстановитьОшибкуВСтроке(ПервыйПараметр.Строки[0],
			ПодставитьКлючевыеСловаВСтроку(Контекст,
				НСтр("ru = 'После описания поля должно быть указано ключевое слово ""%1""'"), "Как"), Истина);
		Возврат НовоеОписание;
	КонецЕсли;
	
	Если ПервыйПараметр.Строки[1].Вид <> "КлючевоеСлово"
	 Или ПервыйПараметр.Строки[1].Уточнение <> "Как" Тогда
		
		УстановитьОшибкуВСтроке(ПервыйПараметр.Строки[1],
			ПодставитьКлючевыеСловаВСтроку(Контекст,
				НСтр("ru = 'После описания поля должно быть указано ключевое слово ""%1""'"), "Как"));
		Возврат НовоеОписание;
	КонецЕсли;
	
	Если ПервыйПараметр.Строки.Количество() < 3 Тогда
		УстановитьОшибкуВСтроке(ПервыйПараметр.Строки[1],  СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'После ключевого слова ""%1"" не указан тип (имя таблицы)'"), ПервыйПараметр.Строки[1].Символы));
		Возврат НовоеОписание;
	КонецЕсли;
	
	Если ПервыйПараметр.Строки[2].Вид <> "Имя" Тогда
		УстановитьОшибкуВСтроке(ПервыйПараметр.Строки[2],  СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'После ключевого слова ""%1"" должен быть указан тип (имя таблицы)'"),
			ПервыйПараметр.Строки[1].Символы));
	Иначе
		НовоеОписание.Выразить = ПервыйПараметр.Строки[2].Символы;
		НовоеОписание.ВыразитьИсточник = ПервыйПараметр.Строки[2];
	КонецЕсли;
	
	Если ПервыйПараметр.Строки.Количество() > 3 Тогда
		УстановитьОшибкуВСтроке(ПервыйПараметр.Строки[3], СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'У функции ""%1"" может быть только один параметр'"), Строка.Символы));
	КонецЕсли;
	
	Если СоставПараметров.Количество() > 1 Тогда
		УстановитьОшибкуВСтроке(ПервыйПараметр.КонечнаяСтрока, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'У функции ""%1"" может быть только один параметр'"), Строка.Символы));
	КонецЕсли;
	
	Возврат НовоеОписание;
	
КонецФункции

// Для процедур РазобратьФункцию, РазобратьПервыйПараметрПроверочнойФункции,
// РазобратьПараметрыФункцииТипЗначения и
// для функции ОписаниеУзлаПолеИзФункцииВыразить.
//
Функция ОписаниеУзлаПолеИзФункцииЕстьNull(Строка, Контекст)
	
	НовоеОписание = ОписаниеУзлаПоле(Строка);
	НовоеОписание.ЕстьNullИсточник = Строка;
	
	СоставПараметров = ПараметрыРазделенныеЗапятыми(Строка);
	
	Если СоставПараметров.Количество() = 0 Тогда
		// Ошибка отсутствия параметров уже установлена в функции ФункцииСВыражениямиВСкобках.
		Возврат НовоеОписание;
	КонецЕсли;
	
	ПервыйПараметр = СоставПараметров[0];
	
	Если ПервыйПараметр.Строки[0].Вид = "Имя" Тогда
		НовоеОписание.Имя         = ПервыйПараметр.Строки[0].Символы;
		НовоеОписание.ИмяИсточник = ПервыйПараметр.Строки[0];
	Иначе
		УстановитьОшибкуВСтроке(ПервыйПараметр.Строки[0], СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Первым параметром функции ""%1"" может быть только имя поля'"), Строка.Символы));
	КонецЕсли;
	
	Если ПервыйПараметр.Строки.Количество() > 1 Тогда
		УстановитьОшибкуВСтроке(ПервыйПараметр.Строки[1], СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Перед параметром функции ""%1"" не указана запятая'"), Строка.Символы));
		Возврат НовоеОписание;
	КонецЕсли;
	
	Если СоставПараметров.Количество() < 2 Тогда
		УстановитьОшибкуВСтроке(ПервыйПараметр.КонечнаяСтрока, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'У функции ""%1"" должно быть два параметра'"), Строка.Символы));
		Возврат НовоеОписание;
	КонецЕсли;
	
	ВторойПараметр = СоставПараметров[1];
	
	Если ВторойПараметр.Строки[0].Вид = "Число"
	 Или ВторойПараметр.Строки[0].Вид = "ПроизвольнаяСтрока"
	 Или ВторойПараметр.Строки[0].Вид = "КлючевоеСлово"
	   И (    ВторойПараметр.Строки[0].Уточнение = "Истина"
	      Или ВторойПараметр.Строки[0].Уточнение = "Ложь"
	      Или ВторойПараметр.Строки[0].Уточнение = "Неопределено"
	      Или ВторойПараметр.Строки[0].Уточнение = "Значение" ) Тогда
		
		Если ВторойПараметр.Строки[0].Уточнение = "Значение" Тогда
			НовоеОписание.ЕстьNull = Новый Структура("Источник, Узел",
				ВторойПараметр.Строки[0], ВторойПараметр.Строки[0].Уточнение);
			
			РазобратьПараметрыФункцииЗначениеИлиФункцииТип(ВторойПараметр.Строки[0], НовоеОписание.ЕстьNull, Истина, Контекст);
		Иначе
			НовоеОписание.ЕстьNull = ОписаниеУзлаПолеИлиУзлаКонстанта(ВторойПараметр.Строки[0]);
		КонецЕсли;
	Иначе
		УстановитьОшибкуВСтроке(ВторойПараметр.Строки[0], СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'У функции ""%1"" второй параметр может быть, либо предопределенным значением, либо константой'"),
			Строка.Символы));
	КонецЕсли;
	
	Если ВторойПараметр.Строки.Количество() > 1 Тогда
		УстановитьОшибкуВСтроке(ВторойПараметр.Строки[1], СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'У функции ""%1"" может быть только два параметра'"), Строка.Символы));
	КонецЕсли;
	
	Если СоставПараметров.Количество() > 2 Тогда
		УстановитьОшибкуВСтроке(СоставПараметров[2].Строки[0], СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'У функции ""%1"" должно быть только два параметра'"), Строка.Символы));
	КонецЕсли;
	
	Возврат НовоеОписание;
	
КонецФункции

// Для процедур РазобратьСоединительВ, РазобратьПараметрыПроверочнойФункции,
// РазобратьПараметрыФункцииЗначениеИлиФункцииТип, РазобратьПараметрыФункцииТипЗначения и
// для функций ОписаниеУзлаПолеИзФункцииВыразить, ОписаниеУзлаПолеИзФункцииЕстьNull.
//
Функция ПараметрыРазделенныеЗапятыми(Строка)
	
	СоставПараметров = Новый Массив;
	
	Если Строка.Строки.Количество() = 0 Тогда
		Возврат СоставПараметров;
	КонецЕсли;
	
	ОписаниеПараметра = Новый Структура("Строки, КонечнаяСтрока", Новый Массив);
	ПредыдущаяПодстрокаЭтоЧастьАргумента = Ложь;
	
	Для Каждого Подстрока Из Строка.Строки Цикл
		
		Если Подстрока.Символы = "," Тогда
			Если Не ПредыдущаяПодстрокаЭтоЧастьАргумента Тогда
				Если Строка.Строки[0] = Подстрока Тогда
					УстановитьОшибкуВСтроке(Подстрока, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Перед запятой не указан параметр'"), Подстрока.Символы));
					ОписаниеПараметра.Строки.Добавить(ДополнительнаяСтрока(Подстрока, ""));
				Иначе
					УстановитьОшибкуВСтроке(Подстрока, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Пропущен параметр или лишняя запятая'"), Подстрока.Символы));
				КонецЕсли;
			КонецЕсли;
			Если ОписаниеПараметра.Строки.Количество() > 0 Тогда
				СоставПараметров.Добавить(ОписаниеПараметра);
				ОписаниеПараметра.КонечнаяСтрока = Подстрока;
			КонецЕсли;
			ОписаниеПараметра = Новый Структура("Строки, КонечнаяСтрока", Новый Массив);
			ПредыдущаяПодстрокаЭтоЧастьАргумента = Ложь;
			Продолжить;
		КонецЕсли;
		
		ПредыдущаяПодстрокаЭтоЧастьАргумента = Истина;
		
		ОписаниеПараметра.Строки.Добавить(Подстрока);
	КонецЦикла;
	
	Если ОписаниеПараметра.Строки.Количество() > 0 Тогда
		СоставПараметров.Добавить(ОписаниеПараметра);
		ОписаниеПараметра.КонечнаяСтрока = Строка.КонечнаяСтрока;
	Иначе
		УстановитьОшибкуВСтроке(Подстрока, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Лишняя запятая или после запятой не указан параметр'"), Подстрока.Символы), Истина);
	КонецЕсли;
	
	Возврат СоставПараметров;
	
КонецФункции

// Для процедуры РазобратьВыражение.
Процедура РазобратьВыбор(Контекст)
	
	Строка = Контекст.Строка;
	
	СвойстваУзла = "Источник, Узел, Выбор, Когда, Иначе";
	НовоеОписание = Новый Структура(СвойстваУзла, Строка, "Выбор");
	НовоеОписание.Когда = Новый Массив;
	
	ПропуститьАнализКогда = Ложь;
	
	Выбор = Строка.Строки[0];
	Если Выбор.Строки.Количество() > 0 Тогда
		Если Выбор.Строки[0].Вид = "Имя" Тогда
			НовоеОписание.Выбор = ОписаниеУзлаПолеИлиУзлаКонстанта(Выбор.Строки[0]);
		Иначе
			ПропуститьАнализКогда = Истина;
			УстановитьОшибкуВСтроке(Выбор.Строки[0], СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Когда аргумент ключевого слова ""%1"" указан, то это может быть только имя поля'"),
				Строка.Символы));
		КонецЕсли;
	КонецЕсли;
	
	Индекс = 1;
	Пока Строка.Строки[Индекс].Уточнение = "Когда" Цикл
		ОписаниеКогдаТогда = Новый Структура("Условие, Значение");
		НовоеОписание.Когда.Добавить(ОписаниеКогдаТогда);
		
		Когда = Строка.Строки[Индекс];
		
		Если Не ПропуститьАнализКогда Тогда
			Если НовоеОписание.Выбор = Неопределено Тогда
				РазобратьВыражение(Когда.Строки, ОписаниеКогдаТогда.Условие, Контекст);
				
			ИначеЕсли Когда.Строки.Количество() = 0 Тогда
				Если ЗначениеЗаполнено(Когда.Символы) Тогда
					УстановитьОшибкуВСтроке(Когда.Строки[0], СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Так как после ключевого слова ""%1"" указано поле, то после ключевого слова ""%2""
						           |должно быть указано, либо предопределенное значение, либо константа'"),
						Строка.Символы,
						Когда.Символы));
				КонецЕсли;
				
			ИначеЕсли Когда.Строки[0].Вид = "Число"
			      Или Когда.Строки[0].Вид = "ПроизвольнаяСтрока"
			      Или Когда.Строки[0].Вид = "КлючевоеСлово"
			        И (    Когда.Строки[0].Уточнение = "Истина"
			           Или Когда.Строки[0].Уточнение = "Ложь"
			           Или Когда.Строки[0].Уточнение = "Неопределено"
			           Или Когда.Строки[0].Уточнение = "Значение" ) Тогда
				
				Если Когда.Строки[0].Уточнение = "Значение" Тогда
					ОписаниеКогдаТогда.Условие = Новый Структура("Источник, Узел",
						Когда.Строки[0], Когда.Строки[0].Уточнение);
					
					РазобратьПараметрыФункцииЗначениеИлиФункцииТип(Когда.Строки[0], ОписаниеКогдаТогда.Условие, Истина, Контекст);
				Иначе
					ОписаниеКогдаТогда.Условие = ОписаниеУзлаПолеИлиУзлаКонстанта(Когда.Строки[0]);
				КонецЕсли;
			ИначеЕсли ЗначениеЗаполнено(Когда.Символы) Тогда
				УстановитьОшибкуВСтроке(Когда.Строки[0], СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Так как после ключевого слова ""%1"" указано поле, то после ключевого слова ""%2""
					           |должно быть указано, либо предопределенное значение, либо константа'"),
					Строка.Символы,
					Когда.Символы));
			КонецЕсли;
		КонецЕсли;
		
		СоставТогда = Строка.Строки[Индекс + 1];
		Если СоставТогда.Строки.Количество() > 0 Тогда
			РазобратьВыражение(СоставТогда.Строки, ОписаниеКогдаТогда.Значение, Контекст);
			
		ИначеЕсли ЗначениеЗаполнено(СоставТогда.Символы) Тогда
			УстановитьОшибкуВСтроке(Когда.Строки[0], СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'После ключевого слова ""%1"" должно быть указано логическое выражение'"), СоставТогда.Символы));
		КонецЕсли;
		
		Индекс = Индекс + 2;
	КонецЦикла;
	
	РазобратьВыражение(Строка.Строки[Индекс].Строки, НовоеОписание.Иначе, Контекст);
	
	ДобавитьАргументФункциюВыборОператор(Контекст, НовоеОписание);
	
КонецПроцедуры

// Для процедуры РазобратьВыражение.
Процедура РазобратьОшибочноеКлючевоеСлово(Контекст)
	
	Строка = Контекст.Строка;
	Контекст.Описание = Неопределено;
	
	Если Строка.Тип = "Неопределен" Тогда
		// Для зарезервированных слов ошибка уже установлена.
		Возврат;
	КонецЕсли;
	
	Если Строка.Тип = "ЗначениеСравнения" Тогда
		Если Строка.Уточнение = "Отключено" Тогда
			// "Отключено".
			УстановитьОшибкуВСтроке(Строка, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Значение ""%1"" может использоваться только как уточняемое значение
				           |в параметрах функции ""%2""'"),
				Строка.Символы,
				КлючевоеСловоСУчетомЯзыка("ЗначениеРазрешено", Контекст)));
		Иначе
			// "ПустаяСсылка" или "Null".
			УстановитьОшибкуВСтроке(Строка, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Значение ""%1"" может использоваться только как уточняемое значение
				           |в параметрах функций проверки разрешений'"),
				Строка.Символы));
		КонецЕсли;
		
	ИначеЕсли Строка.Тип = "ИмяТипа" Тогда
		// "Число", "Строка", "Дата", "Булево".
		УстановитьОшибкуВСтроке(Строка, ПодставитьКлючевыеСловаВСтроку(Контекст,
			НСтр("ru = 'Имя типа ""%1"" может использоваться только, как параметр функции ""%2"" или
			           |как уточняемое значение в параметрах функций проверки разрешений'"),
			Строка.Символы,
			"Тип"));
	Иначе
		УстановитьОшибкуВСтроке(Строка, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Обработка ключевого слова ""%1"" не определена'"), Строка.Символы));
	КонецЕсли;
	
КонецПроцедуры

// Для процедур РазобратьВыражение, РазобратьОператор, РазобратьФункцию, РазобратьВыбор.
Процедура ДобавитьАргументФункциюВыборОператор(Контекст, ДобавляемоеОписание)
	
	// Текущий узел: Любой.
	// Добавляемое описание: Поле, Значение, Константа, Не, Выбор, любая функция.
	
	Описание = Контекст.Описание;
	
	Если Описание = Неопределено Тогда
		Контекст.Описание = ДобавляемоеОписание;
		
	ИначеЕсли Описание.Узел = "И"
	      Или Описание.Узел = "Или" Тогда
		
		Если Описание.Аргументы.Количество() = 1 Тогда
			Описание.Аргументы.Добавить(ДобавляемоеОписание);
		Иначе
			ОбработатьПропущеннуюЛогическуюОперацию(Контекст, Описание.Аргументы[1], ДобавляемоеОписание);
		КонецЕсли;
		
	ИначеЕсли Описание.Узел = "Не" Тогда
		
		Если Не ЗначениеЗаполнено(Описание.Аргумент) Тогда
			Описание.Аргумент = ДобавляемоеОписание;
		Иначе
			ОбработатьПропущеннуюЛогическуюОперацию(Контекст, Описание.Аргумент, ДобавляемоеОписание);
		КонецЕсли;
		
	ИначеЕсли Описание.Источник.Вид = "Операция" Тогда
		
		Если Не ЗначениеЗаполнено(Описание.ВторойАргумент) Тогда
			Описание.ВторойАргумент = ДобавляемоеОписание;
			// Проверка корректности аргументов выполняется
			// в процедуре ОтметитьНекорректныеАргументыИЗапрещенныеУзлы.
		Иначе
			ОбработатьПропущеннуюЛогическуюОперацию(Контекст, Описание.ВторойАргумент, ДобавляемоеОписание);
		КонецЕсли;
		
	ИначеЕсли СтрНайти(",Поле,Значение,Константа,В,ЕстьNull,Выбор,", "," + Описание.Узел + ",") > 0
	      Или Описание.Источник.Тип = "Функция" Тогда
		// Второй аргумент операции В уже разобран в процедуре РазобратьОперациюВ.
		// Второй аргумент Null операции Есть уже разобран в функции ФункцииСВыражениямиВСкобках.
		// Остальные узлы не имеют второго аргумента.
		ОбработатьПропущеннуюЛогическуюОперацию(Контекст, Неопределено, ДобавляемоеОписание);
	Иначе
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не определена обработка узла ""%1""'"), Описание.Узел);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ДобавитьАргументФункциюВыборОператор
Процедура ОбработатьПропущеннуюЛогическуюОперацию(Контекст, ПоследнийАргументОписания, ДобавляемоеОписание)
	
	УстановитьОшибкуВСтроке(Контекст.Строка, НСтр("ru = 'Не указана логическая операция'"));
	
	// Восстановление.
	ДополнительнаяСтрока = ДополнительнаяСтрока(Контекст.Строка, "И", Контекст);
	
	НовоеОписание = Новый Структура("Источник, Узел, Аргументы", ДополнительнаяСтрока, "И", Новый Массив);
	НовоеОписание.Аргументы.Добавить();
	
	ТекущаяСтрока = Контекст.Строка;
	Контекст.Строка = ДополнительнаяСтрока;
	
	ВставитьСоединительСУчетомПриоритета(Контекст,
		ПоследнийАргументОписания, НовоеОписание, НовоеОписание.Аргументы[0]);
	
	Контекст.Строка = ТекущаяСтрока;
	
	НовоеОписание.Аргументы.Добавить(ДобавляемоеОписание);
	
КонецПроцедуры

// Для процедуры РазобратьУсловие.
Функция ВыраженияВСкобкахВоВложениях(Строки)
	
	Результат = Новый Массив;
	
	ТекущееВложение = Новый Структура("Строки", Результат);
	Вложения = Новый Массив;
	Вложения.Добавить(ТекущееВложение);
	
	Для Каждого Строка Из Строки Цикл
		Если Строка.Символы = "(" Тогда
			ДобавитьВложение(Строка, Вложения, ТекущееВложение);
			
		ИначеЕсли Строка.Символы = ")" Тогда
			Если Вложения.Количество() = 1 Тогда
				УстановитьОшибкуВСтроке(Строка,
					НСтр("ru = 'Указана закрывающаяся скобка до открывающейся скобки'"));
			Иначе
				УдалитьПоследнееВложение(Вложения, ТекущееВложение, Строка);
			КонецЕсли;
		Иначе
			ТекущееВложение.Строки.Добавить(Строка);
		КонецЕсли;
	КонецЦикла;
	
	Пока Вложения.Количество() > 1 Цикл
		ИндексПоследнегоВложения = Вложения.Количество() - 1;
		Вложение = Вложения[ИндексПоследнегоВложения];
		Вложение.КонечнаяСтрока = Строка;
		Вложения.Удалить(ИндексПоследнегоВложения);
		УстановитьОшибкуВСтроке(Вложение,
			НСтр("ru = 'Указана открывающаяся скобка без закрывающейся скобки'"), Истина);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Для процедуры РазобратьУсловие.
Функция ВыраженияВыборКогдаТогдаВоВложениях(Строки, Контекст)
	
	Результат = Новый Массив;
	
	ТекущееВложение = Новый Структура("Строки, Уточнение", Результат, "");
	Вложения = Новый Массив;
	Вложения.Добавить(ТекущееВложение);
	
	Для Каждого Строка Из Строки Цикл
		
		Если Строка.Вид <> "КлючевоеСлово"
		 Или Строка.Тип <> "СловоВыбора" Тогда
			
			Если ТекущееВложение.Уточнение = "Выбор" Тогда
				ТекущееВложение.Строки[0].Строки.Добавить(Строка);
			Иначе
				ТекущееВложение.Строки.Добавить(Строка);
				Если Строка.Символы = "(" Тогда
					Строка.Строки = ВыраженияВыборКогдаТогдаВоВложениях(Строка.Строки, Контекст);
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли Строка.Уточнение = "Выбор" Тогда
			Если Вложения.Количество() = 1 Тогда
				// Стандартная обработка после условия.
			Иначе
				Если ТекущееВложение.Уточнение = "Выбор" Тогда
					УстановитьОшибкуВСтроке(ТекущееВложение, ПодставитьКлючевыеСловаВСтроку(Контекст,
						НСтр("ru = 'После ключевого слова ""%1"" не указано ключевое слова ""%2""'"), "Выбор,Когда"), Истина);
					ВосстановитьСтруктуруВыбора(ТекущееВложение, Вложения, ТекущееВложение, "Когда", Контекст);
				КонецЕсли;
			КонецЕсли;
			ДобавитьВложение(Строка, Вложения, ТекущееВложение);
			ТекущееВложение.Строки.Добавить(ДополнительнаяСтрока(ТекущееВложение, "Выбор", Контекст));
			
		ИначеЕсли Строка.Уточнение = "Когда" Тогда
			
			Если Вложения.Количество() = 1 Тогда
				УстановитьОшибкуВСтроке(Строка, ПодставитьКлючевыеСловаВСтроку(Контекст,
					НСтр("ru = 'Ключевое слово ""%1"" указано до ключевого слова ""%2""'"), "Когда,Выбор"));
				ВосстановитьСтруктуруВыбора(Строка, Вложения, ТекущееВложение, "Выбор", Контекст);
				
			ИначеЕсли ТекущееВложение.Уточнение = "Выбор" Тогда
				// Стандартная обработка после условия.
				
			ИначеЕсли ТекущееВложение.Уточнение = "Когда" Тогда
				УстановитьОшибкуВСтроке(ТекущееВложение, ПодставитьКлючевыеСловаВСтроку(Контекст,
					НСтр("ru = 'После ключевого слова ""%1"" не указано ключевое слова ""%2""'"), "Когда,Тогда"), Истина);
				ВосстановитьСтруктуруВыбора(ТекущееВложение, Вложения, ТекущееВложение, "Тогда", Контекст);
				
			ИначеЕсли ТекущееВложение.Уточнение = "Тогда" Тогда
				УдалитьПоследнееВложение(Вложения, ТекущееВложение);
				
			Иначе // ТекущееВложение.Уточнение = "Иначе"
				УстановитьОшибкуВСтроке(Строка, ПодставитьКлючевыеСловаВСтроку(Контекст,
					НСтр("ru = 'Ключевое слово ""%1"" должно быть до ключевого слова ""%2""'"), "Когда,Иначе"));
				УдалитьПоследнееВложение(Вложения, ТекущееВложение);
			КонецЕсли;
			ДобавитьВложение(Строка, Вложения, ТекущееВложение);
			
		ИначеЕсли Строка.Уточнение = "Тогда" Тогда
			
			Если Вложения.Количество() = 1 Тогда
				УстановитьОшибкуВСтроке(Строка, ПодставитьКлючевыеСловаВСтроку(Контекст,
					НСтр("ru = 'Ключевое слово ""%1"" указано до ключевых слов ""%2"" и ""%3""'"), "Тогда,Выбор,Когда"));
				ВосстановитьСтруктуруВыбора(Строка, Вложения, ТекущееВложение, "Выбор,Когда", Контекст);
			
			ИначеЕсли ТекущееВложение.Уточнение = "Выбор" Тогда
				УстановитьОшибкуВСтроке(Строка, ПодставитьКлючевыеСловаВСтроку(Контекст,
					НСтр("ru = 'Ключевое слово ""%1"" указано до ключевого слова ""%2""'"), "Тогда,Когда"));
				ВосстановитьСтруктуруВыбора(Строка, Вложения, ТекущееВложение, "Когда", Контекст);
				
			ИначеЕсли ТекущееВложение.Уточнение = "Когда" Тогда
				// Стандартная обработка после условия.
				
			ИначеЕсли ТекущееВложение.Уточнение = "Тогда" Тогда
				УстановитьОшибкуВСтроке(ТекущееВложение, ПодставитьКлючевыеСловаВСтроку(Контекст,
					НСтр("ru = 'После ключевого слова ""%1"" не указано ключевое слова ""%2""'"), "Тогда,Когда"), Истина);
				ВосстановитьСтруктуруВыбора(ТекущееВложение, Вложения, ТекущееВложение, "Когда", Контекст);
				
			Иначе // ТекущееВложение.Уточнение = "Иначе"
				УстановитьОшибкуВСтроке(Строка, ПодставитьКлючевыеСловаВСтроку(Контекст,
					НСтр("ru = 'Ключевое слово ""%1"" должно быть до ключевого слова ""%2""'"), "Тогда,Иначе"));
				УдалитьПоследнееВложение(Вложения, ТекущееВложение);
				ВосстановитьСтруктуруВыбора(Строка, Вложения, ТекущееВложение, "Когда", Контекст);
			КонецЕсли;
			УдалитьПоследнееВложение(Вложения, ТекущееВложение);
			ДобавитьВложение(Строка, Вложения, ТекущееВложение);
			
		ИначеЕсли Строка.Уточнение = "Иначе" Тогда
			
			Если Вложения.Количество() = 1 Тогда
				УстановитьОшибкуВСтроке(Строка, ПодставитьКлючевыеСловаВСтроку(Контекст,
					НСтр("ru = 'Ключевое слово ""%1"" указано до ключевых слов ""%2"", ""%3"" и ""%4""'"), "Иначе,Выбор,Когда,Тогда"));
				ВосстановитьСтруктуруВыбора(Строка, Вложения, ТекущееВложение, "Выбор,Когда,Тогда", Контекст);
			
			ИначеЕсли ТекущееВложение.Уточнение = "Выбор" Тогда
				УстановитьОшибкуВСтроке(Строка, ПодставитьКлючевыеСловаВСтроку(Контекст,
					НСтр("ru = 'Ключевое слово ""%1"" указано до ключевых слов ""%2"" и ""%3""'"), "Иначе,Когда,Тогда"));
				ВосстановитьСтруктуруВыбора(Строка, Вложения, ТекущееВложение, "Когда,Тогда", Контекст);
				
			ИначеЕсли ТекущееВложение.Уточнение = "Когда" Тогда
				УстановитьОшибкуВСтроке(Строка, ПодставитьКлючевыеСловаВСтроку(Контекст,
					НСтр("ru = 'Ключевое слово ""%1"" указано до ключевого слова ""%2""'"), "Иначе,Тогда"));
				УдалитьПоследнееВложение(Вложения, ТекущееВложение);
				ВосстановитьСтруктуруВыбора(Строка, Вложения, ТекущееВложение, "Тогда", Контекст);
				
			ИначеЕсли ТекущееВложение.Уточнение = "Тогда" Тогда
				// Стандартная обработка после условия.
				
			Иначе // ТекущееВложение.Уточнение = "Иначе"
				УстановитьОшибкуВСтроке(Строка, ПодставитьКлючевыеСловаВСтроку(Контекст,
					НСтр("ru = 'Ключевое слово ""%1"" указано повторно'"), "Иначе"));
			КонецЕсли;
			УдалитьПоследнееВложение(Вложения, ТекущееВложение);
			ДобавитьВложение(Строка, Вложения, ТекущееВложение);
			
		Иначе // Строка.Уточнение = "Конец"
			
			Если Вложения.Количество() = 1 Тогда
				УстановитьОшибкуВСтроке(Строка, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Ключевое слово ""%1"" указано до ключевых слов ""%2"", ""%3"", ""%4"" и ""%5""'"), "Конец,Выбор,Когда,Тогда,Иначе"));
				ВосстановитьСтруктуруВыбора(Строка, Вложения, ТекущееВложение, "Выбор,Когда,Тогда,Иначе", Контекст);
				
			ИначеЕсли ТекущееВложение.Уточнение = "Выбор" Тогда
				УстановитьОшибкуВСтроке(Строка, ПодставитьКлючевыеСловаВСтроку(Контекст,
					НСтр("ru = 'Ключевое слово ""%1"" указано до ключевых слов ""%2"", ""%3"" и ""%4""'"), "Конец,Когда,Тогда,Иначе"));
				ВосстановитьСтруктуруВыбора(Строка, Вложения, ТекущееВложение, "Когда,Тогда,Иначе", Контекст);
				
			ИначеЕсли ТекущееВложение.Уточнение = "Когда" Тогда
				УстановитьОшибкуВСтроке(Строка, ПодставитьКлючевыеСловаВСтроку(Контекст,
					НСтр("ru = 'Ключевое слово ""%1"" указано до ключевых слов ""%2"" и ""%3""'"), "Конец,Тогда,Иначе"));
				УдалитьПоследнееВложение(Вложения, ТекущееВложение);
				ВосстановитьСтруктуруВыбора(Строка, Вложения, ТекущееВложение, "Тогда,Иначе", Контекст);
				
			ИначеЕсли ТекущееВложение.Уточнение = "Тогда" Тогда
				УстановитьОшибкуВСтроке(Строка, ПодставитьКлючевыеСловаВСтроку(Контекст,
					НСтр("ru = 'Ключевое слово ""%1"" указано до ключевого слова ""%2""'"), "Конец,Иначе"));
				УдалитьПоследнееВложение(Вложения, ТекущееВложение);
				ВосстановитьСтруктуруВыбора(Строка, Вложения, ТекущееВложение, "Иначе", Контекст);
				
			Иначе // ТекущееВложение.Уточнение = "Иначе".
				// Стандартная обработка после условия.
			КонецЕсли;
			УдалитьПоследнееВложение(Вложения, ТекущееВложение);
			УдалитьПоследнееВложение(Вложения, ТекущееВложение);
		КонецЕсли;
	КонецЦикла;
	
	Пока Вложения.Количество() > 1 Цикл
		ТекущееВложение = Вложения[Вложения.Количество() - 1];
		
		Если ТекущееВложение.Уточнение = "Выбор" Тогда
			ТекстОшибки = ПодставитьКлючевыеСловаВСтроку(Контекст,
				НСтр("ru = 'После ключевого слова ""%1"" не указаны ключевые слова ""%2"", ""%3"", ""%4"" и ""%5""'"), "Выбор,Когда,Тогда,Иначе,Конец");
			ВосстановитьСтруктуруВыбора(ТекущееВложение, Вложения, ТекущееВложение, "Когда,Тогда,Иначе", Контекст);
			
		ИначеЕсли ТекущееВложение.Уточнение = "Когда" Тогда
			ТекстОшибки = ПодставитьКлючевыеСловаВСтроку(Контекст,
				НСтр("ru = 'После ключевого слова ""%1"" не указаны ключевые слова ""%2"", ""%3"", ""%4""'"), "Когда,Тогда,Иначе,Конец");
			УдалитьПоследнееВложение(Вложения, ТекущееВложение);
			ВосстановитьСтруктуруВыбора(ТекущееВложение, Вложения, ТекущееВложение, "Тогда,Иначе", Контекст);
			
		ИначеЕсли ТекущееВложение.Уточнение = "Тогда" Тогда
			ТекстОшибки = ПодставитьКлючевыеСловаВСтроку(Контекст,
				НСтр("ru = 'После ключевого слова ""%1"" не указаны ключевые слова ""%2"" и ""%3""'"), "Тогда,Иначе,Конец");
			УдалитьПоследнееВложение(Вложения, ТекущееВложение);
			ВосстановитьСтруктуруВыбора(ТекущееВложение, Вложения, ТекущееВложение, "Иначе", Контекст);
			
		Иначе // ТекущееВложение.Уточнение = "Иначе"
			ТекстОшибки = ПодставитьКлючевыеСловаВСтроку(Контекст,
				НСтр("ru = 'После ключевого слова ""%1"" не указано ключевое слово ""%2""'"), "Иначе,Конец");
		КонецЕсли;
		УстановитьОшибкуВСтроке(ТекущееВложение, ТекстОшибки, Истина);
		УдалитьПоследнееВложение(Вложения, ТекущееВложение);
		УдалитьПоследнееВложение(Вложения, ТекущееВложение);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Для процедуры РазобратьУсловие.
Функция ФункцииСВыражениямиВСкобках(Строки, ВнутренниеДанные)
	
	Результат = Новый Массив;
	КоличествоСтрок = Строки.Количество();
	
	Строка = Неопределено;
	Индекс = 0;
	Пока Индекс < КоличествоСтрок Цикл
		ПредыдущаяСтрока = Строка;
		Строка = Строки[Индекс];
		
		Если Строка.Символы = "(" Тогда
			Строка.Строки = ФункцииСВыражениямиВСкобках(Строка.Строки, ВнутренниеДанные);
			
		ИначеЕсли Строка.Вид = "КлючевоеСлово"
		        И (    Строка.Тип = "Функция"
		           Или Строка.Уточнение = "В" ) Тогда
			
			Если Индекс + 1 < Строки.Количество()
			   И Строки[Индекс + 1].Символы = "(" Тогда
				
				Индекс = Индекс + 1;
				Строка.Строки = ФункцииСВыражениямиВСкобках(Строки[Индекс].Строки, ВнутренниеДанные);
				Строка.КонечнаяСтрока = Строки[Индекс].КонечнаяСтрока;
				
				Если Строка.Строки.Количество() = 0 Тогда
					Если Строка.Тип = "Функция" Тогда
						УстановитьОшибкуВСтроке(Строки[Индекс], СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
							НСтр("ru = 'У функции ""%1"" не указано ни одного параметра'"), Строка.Символы), Истина);
					Иначе
						УстановитьОшибкуВСтроке(Строки[Индекс], СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
							НСтр("ru = 'В списке значений операции ""%1"" не указано ни одного значения'"), Строка.Символы), Истина);
					КонецЕсли;
				КонецЕсли;
			Иначе
				Строка.Строки = Новый Массив;
				Если Строка.Тип = "Функция" Тогда
					УстановитьОшибкуВСтроке(Строка, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'После функции ""%1"" не указаны параметры в скобках'"), Строка.Символы), Истина);
				Иначе
					УстановитьОшибкуВСтроке(Строка, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'После ключевого слова ""%1"" не указаны значения в скобках'"), Строка.Символы), Истина);
				КонецЕсли;
			КонецЕсли;
			
		ИначеЕсли Строка.Вид = "КлючевоеСлово"
		        И Строка.Уточнение = "Есть"  Тогда
			
			Если Индекс + 1 < Строки.Количество()
			   И Строки[Индекс + 1].Вид = "КлючевоеСлово"
			   И Строки[Индекс + 1].Уточнение = "Null" Тогда
				
				Индекс = Индекс + 1;
				Строка.Строки.Добавить(Строки[Индекс]);
			Иначе
				Строка.Строки = Новый Массив;
				УстановитьОшибкуВСтроке(Строка, ПодставитьКлючевыеСловаВСтроку(ВнутренниеДанные,
						НСтр("ru = 'После ключевого слова ""%2"" не указано ключевое слово ""%1""'"),
						"Null",
						Строка.Символы),
					Истина);
			КонецЕсли;
			
		ИначеЕсли Строка.Вид = "Имя"
		        И СтрНачинаетсяС(Строка.Символы, ".")
		        И ПредыдущаяСтрока <> Неопределено Тогда
			
			Если ПредыдущаяСтрока <> Неопределено
			   И ПредыдущаяСтрока.Вид = "КлючевоеСлово"
			   И ПредыдущаяСтрока.Уточнение = "Выразить" Тогда
				
				Строка.Тип = "ДополнениеКВыразить";
				ПредыдущаяСтрока.Строки.Добавить(Строка);
				Индекс = Индекс + 1;
				Продолжить;
			Иначе
				УстановитьОшибкуВСтроке(Строка, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Имя поля не может начинаться с символа "".""'"), Строка.Символы));
			КонецЕсли;
		КонецЕсли;
		
		Результат.Добавить(Строка);
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Для функций ВыраженияВСкобкахВоВложениях, ВыраженияВыборКогдаТогдаВоВложениях.
Процедура ДобавитьВложение(Строка, Вложения, ТекущееВложение)
	
	ТекущееВложение.Строки.Добавить(Строка);
	ТекущееВложение = Строка;
	Вложения.Добавить(ТекущееВложение);
	
КонецПроцедуры

// Для функций ВыраженияВСкобкахВоВложениях, ВыраженияВыборКогдаТогдаВоВложениях.
Процедура УдалитьПоследнееВложение(Вложения, ТекущееВложение, КонечнаяСтрока = Неопределено)
	
	Если КонечнаяСтрока = Неопределено Тогда
		Если ТекущееВложение.Строки.Количество() = 0 Тогда
			КонечнаяСтрока = ТекущееВложение;
		Иначе
			КонечнаяСтрока = ТекущееВложение.Строки[ТекущееВложение.Строки.Количество() - 1];
			Если КонечнаяСтрока.КонечнаяСтрока <> Неопределено Тогда
				КонечнаяСтрока = КонечнаяСтрока.КонечнаяСтрока;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	ТекущееВложение.КонечнаяСтрока = КонечнаяСтрока;
	
	ИндексПоследнегоВложения = Вложения.Количество() - 1;
	Вложения.Удалить(ИндексПоследнегоВложения);
	ТекущееВложение = Вложения[ИндексПоследнегоВложения - 1];
	
КонецПроцедуры

// Для функции ВыраженияВыборКогдаТогдаВоВложениях.
Процедура ВосстановитьСтруктуруВыбора(Строка, Вложения, ТекущееВложение, СписокНедостающихСлов, Контекст)
	
	НедостающиеСлова = СтрРазделить(СписокНедостающихСлов, ",", Ложь);
	
	Для Каждого НедостающееСлово Из НедостающиеСлова Цикл
		НоваяСтрока = ДополнительнаяСтрока(Строка, НедостающееСлово, Контекст);
		ТекущееВложение.Строки.Добавить(НоваяСтрока);
		
		Если НедостающееСлово = "Выбор" Тогда
			ТекущееВложение = НоваяСтрока;
			Вложения.Добавить(ТекущееВложение);
		КонецЕсли;
	КонецЦикла;
	
	Если НедостающееСлово <> "Выбор" Тогда
		ТекущееВложение = НоваяСтрока;
		Вложения.Добавить(ТекущееВложение);
	КонецЕсли;
	
КонецПроцедуры

// Для процедур ОбработатьПропущеннуюЛогическуюОперацию, ВыраженияВыборКогдаТогдаВоВложениях,
// ВосстановитьСтруктуруВыбора и для функции ПараметрыРазделенныеЗапятыми.
//
Функция ДополнительнаяСтрока(Строка, Уточнение = "", Контекст = Неопределено)
	
	Поля = "Символы, Вид, Тип, Приоритет, Уточнение, ИсходнаяСтрока, Строки, КонечнаяСтрока, ПозицияОшибки, ТекстОшибки";
	
	НоваяСтрока = Новый Структура(Поля);
	НоваяСтрока.Уточнение      = Уточнение;
	НоваяСтрока.Строки         = Новый Массив;
	НоваяСтрока.ИсходнаяСтрока = Строка;
	
	СвойстваСлова = ?(Контекст = Неопределено,
		Неопределено, Контекст.СинтаксисЯзыка.СловаЯзыка.Получить(ВРег(Уточнение)));
	
	Если СвойстваСлова <> Неопределено Тогда
		НоваяСтрока.Вид       = "КлючевоеСлово";
		НоваяСтрока.Тип       = СвойстваСлова.Тип;
		НоваяСтрока.Приоритет = СвойстваСлова.Приоритет;
	КонецЕсли;
	
	Возврат НоваяСтрока;
	
КонецФункции

// Для процедур РазобратьДополнительныеТаблицы, РазобратьУсловиеОграничения.
Процедура ИзменитьВидКлючевогоСловаСписокНаИмя(СтрокиЧасти, ИсключаемаяСтрока = Неопределено)
	
	Для Каждого Строка Из СтрокиЧасти Цикл
		Если Строка = ИсключаемаяСтрока
		 Или Строка.Вид <> "КлючевоеСлово"
		 Или Строка.Уточнение <> "ЭтотСписок" Тогда
			Продолжить;
		КонецЕсли;
		Строка.Вид = "Имя";
		Строка.Уточнение = "";
	КонецЦикла;
	
КонецПроцедуры

// Для процедур РазобратьДополнительныеТаблицы, РазобратьСоединение.
Процедура УстановитьПсевдоним(СтрокаЧасти, ОписаниеСоединения, ВнутренниеДанные)
	
	Если ЗначениеЗаполнено(СтрокаЧасти.ТекстОшибки) Тогда
		Возврат;
	КонецЕсли;
	
	ПозицияТочки = СтрНайти(СтрокаЧасти.Символы, ".");
	Если ПозицияТочки > 0 Тогда
		СтрокаЧасти.ПозицияОшибки = ПозицияТочки - 1;
		СтрокаЧасти.ТекстОшибки =
			НСтр("ru = 'Псевдоним не может содержать символа "".""'");
			
	ИначеЕсли ТипЗнч(ОписаниеСоединения) = Тип("Строка") Тогда
		ОписаниеСоединения = СтрокаЧасти.Символы;
		ВнутренниеДанные.Псевдонимы.Вставить(ВРег(СтрокаЧасти.Символы),
			Новый Структура("Псевдоним, Таблица", СтрокаЧасти.Символы));
	Иначе
		ОписаниеСоединения.Псевдоним = СтрокаЧасти.Символы + "Псевдоним";
		Если ВнутренниеДанные.Псевдонимы.Получить(ВРег(СтрокаЧасти.Символы)) = Неопределено Тогда
			Если ЗначениеЗаполнено(ОписаниеСоединения.Таблица) Тогда
				ВнутренниеДанные.Псевдонимы.Вставить(ВРег(СтрокаЧасти.Символы),
					Новый Структура("Псевдоним, Таблица",
						ОписаниеСоединения.Псевдоним, ОписаниеСоединения.Таблица));
			КонецЕсли;
		Иначе
			СтрокаЧасти.ТекстОшибки = НСтр("ru = 'Псевдоним повторяется'");
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры РазобратьСоединение.
Процедура УстановитьИмяТаблицы(СтрокаЧасти, ОписаниеСоединения, ВнутренниеДанные)
	
	Если ЗначениеЗаполнено(СтрокаЧасти.ТекстОшибки) Тогда
		Возврат;
	КонецЕсли;
	
	Если СтрНачинаетсяС(СтрокаЧасти.Символы, ".") Тогда
		СтрокаЧасти.ТекстОшибки =
			НСтр("ru = 'Имя таблицы не может начинаться с символа "".""'");
		Возврат;
	КонецЕсли;
	
	Если СтрЧислоВхождений(СтрокаЧасти.Символы, ".") > 2 Тогда
		
		ПозицияТочки = СтрНайти(СтрокаЧасти.Символы, ".");
		ПозицияТочки = ПозицияТочки + СтрНайти(Сред(СтрокаЧасти.Символы, ПозицияТочки + 1), ".");
		
		ПозицияТочки = ПозицияТочки + СтрНайти(Сред(СтрокаЧасти.Символы, ПозицияТочки + 1), ".");
		СтрокаЧасти.ТекстОшибки =
			НСтр("ru = 'Полное имя таблицы не может содержать более двух символов "".""'");
		
		СтрокаЧасти.ПозицияОшибки = ПозицияТочки - 1;
		Возврат;
	КонецЕсли;
	
	ОписаниеСоединения.Таблица = СтрокаЧасти.Символы;
	
	ДобавитьТребуемуюТаблицуКакИсточникДанных(ВнутренниеДанные, ОписаниеСоединения.Таблица, СтрокаЧасти);
	
КонецПроцедуры

// Для процедуры УстановитьИмяТаблицы.
Процедура ДобавитьТребуемуюТаблицуКакИсточникДанных(Контекст, Таблица, Источник)
	
	Если ЗначениеЗаполнено(Источник.ТекстОшибки) Тогда
		Возврат;
	КонецЕсли;
	
	СвойстваИмени = СвойстваИмениТаблицы(Контекст, Таблица);
	
	Если СвойстваИмени.ЧислоЧастейИмени < 2
	 Или СвойстваИмени.ЧислоЧастейИмени > 3 Тогда
		УстановитьОшибкуВСтроке(Источник,
			НСтр("ru = 'В имени присоединяемой таблицы должна быть одна или две точки'"));
		Возврат;
	КонецЕсли;
	
	Если СвойстваИмени.СвойстваТипаТаблиц = Неопределено Тогда
		УстановитьОшибкуВСтроке(Источник, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Некорректное начало ""%1"" имени таблицы ""%2""'"), СвойстваИмени.ИмяТипа, Таблица));
		Возврат;
	КонецЕсли;
	
	Если СвойстваИмени.ЧислоЧастейИмени = 3 Тогда
		СвойстваУточнения = СвойстваИмени.СвойстваТипаТаблиц.УточнениеТаблиц.Получить(
			ВРег(СвойстваИмени.Расширение));
		
		Если СвойстваУточнения <> Неопределено
		   И СвойстваУточнения.Использование <> "Разрешено" Тогда
			
			Если СвойстваУточнения.Использование = "Недопустимо" Тогда
				УстановитьОшибкуВСтроке(Источник, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Недопустимо использовать таблицы ""%1"" группы таблиц ""%2""'"),
					СвойстваИмени.Расширение, СвойстваИмени.ИмяТипа));
			Иначе
				УстановитьОшибкуВСтроке(Источник, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Запрещено присоединять таблицы ""%1"" группы таблиц ""%2""'"),
					СвойстваИмени.Расширение, СвойстваИмени.ИмяТипа));
			КонецЕсли;
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	Свойства = СвойстваТребуемойТаблицы(Контекст, СвойстваИмени);
	Свойства.Источники.Добавить(Источник);
	
КонецПроцедуры

// Для процедур ВыделитьПсевдонимПоля, РазобратьПервыйПараметрПроверочнойФункции,
// РазобратьДополнительныйПараметрПроверочнойФункции, РазобратьПараметрыФункцииЗначениеИлиФункцииТип.
//
Процедура ДобавитьТребуемуюТаблицуКакСсылочныйТип(Контекст, Таблица, Источник)
	
	Если ЗначениеЗаполнено(Источник.ТекстОшибки) Тогда
		Возврат;
	КонецЕсли;
	
	СвойстваИмени = СвойстваИмениТаблицы(Контекст, Таблица);
	
	Если СвойстваИмени.ЧислоЧастейИмени <> 2 Тогда
		УстановитьОшибкуВСтроке(Источник,
			НСтр("ru = 'В имени таблицы, указанной в качестве типа, должна быть одна точка'"));
		Возврат;
	КонецЕсли;
	
	Если СвойстваИмени.СвойстваТипаТаблиц = Неопределено Тогда
		УстановитьОшибкуВСтроке(Источник, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Некорректное начало ""%1"" имени таблицы ""%2""'"), СвойстваИмени.ИмяТипа, Таблица));
		Возврат;
	КонецЕсли;
	
	Если Не СвойстваИмени.СвойстваТипаТаблиц.ЭтоСсылочныйТип Тогда
		УстановитьОшибкуВСтроке(Источник, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Группа таблиц ""%1"" не входит в состав ссылочных типов'"), СвойстваИмени.ИмяТипа, Таблица));
		Возврат;
	КонецЕсли;
	
	Свойства = СвойстваТребуемойТаблицы(Контекст, СвойстваИмени);
	Свойства.Источники.Добавить(Источник);
	
КонецПроцедуры

// Для процедуры РазобратьПараметрыФункцииЗначениеИлиФункцииТип.
Процедура ДобавитьТребуемыйПредопределенныйЭлемент(Контекст, ПолноеИмяПредопределенного, Источник)
	
	Если ЗначениеЗаполнено(Источник.ТекстОшибки) Тогда
		Возврат;
	КонецЕсли;
	
	СвойстваИмени = СвойстваИмениТаблицы(Контекст, ПолноеИмяПредопределенного);
	
	Если СвойстваИмени.ЧислоЧастейИмени <> 3 Тогда
		УстановитьОшибкуВСтроке(Источник,
			НСтр("ru = 'В имени предопределенного значения должно быть две точки'"));
		Возврат;
	КонецЕсли;
	
	Если СвойстваИмени.СвойстваТипаТаблиц = Неопределено Тогда
		УстановитьОшибкуВСтроке(Источник, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Некорректное начало ""%1"" имени таблицы ""%2""'"),
			СвойстваИмени.ИмяТипа,
			СвойстваИмени.ИмяТипа + "." + СвойстваИмени.ИмяБезТипа));
		Возврат;
	КонецЕсли;
	
	Если Не СвойстваИмени.СвойстваТипаТаблиц.ЭтоСсылочныйТип Тогда
		УстановитьОшибкуВСтроке(Источник, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Группа таблиц ""%1"" не входит в состав ссылочных типов'"), СвойстваИмени.ИмяТипа));
		Возврат;
	КонецЕсли;
	
	СвойстваСлова = Контекст.СинтаксисЯзыка.СловаЯзыка.Получить(ВРег(СвойстваИмени.Расширение));
	
	Если Не СвойстваИмени.СвойстваТипаТаблиц.ЕстьПредопределенные
	   И Не СвойстваИмени.ИмяТипа = "Перечисление"
	   И (    СвойстваСлова = Неопределено
	      Или СвойстваСлова.Идентификатор <> "ПустаяСсылка") Тогда
		
		УстановитьОшибкуВСтроке(Источник, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В группе таблиц ""%1"" нет предопределенных элементов'"), СвойстваИмени.ИмяТипа));
		Возврат;
	КонецЕсли;
	
	Свойства = СвойстваТребуемойТаблицы(Контекст, СвойстваИмени, Истина);
	
	СвойстваПредопределенного = Свойства.Предопределенные.Получить(ВРег(СвойстваИмени.Расширение));
	Если СвойстваПредопределенного = Неопределено Тогда
		СвойстваПредопределенного = Новый Структура;
		СвойстваПредопределенного.Вставить("ИмяСуществует", Ложь);
		СвойстваПредопределенного.Вставить("Источники", Новый Массив);
		Свойства.Предопределенные.Вставить(ВРег(СвойстваИмени.Расширение), СвойстваПредопределенного);
	КонецЕсли;
	СвойстваПредопределенного.Источники.Добавить(Источник);
	
КонецПроцедуры

// Для процедур ОтметитьНекорректныеАргументыИЗапрещенныеУзлы, ВыделитьПсевдонимПоля,
// ДобавитьТипыВидовДоступаПользователиИВнешниеПользователиДляПроверкиОтсутствия.
//
Процедура ДобавитьТребуемоеПолеТаблицы(Контекст, Таблица, ИмяПоля, Источник,
			ТипПоля = "", ИсточникТипаПоля = Неопределено, УзелПоле = Неопределено)
	
	Если ЗначениеЗаполнено(Источник.ТекстОшибки) Тогда
		Возврат;
	КонецЕсли;
	
	СвойстваИмени = СвойстваИмениТаблицы(Контекст, Таблица);
	Если СвойстваИмени.СвойстваТипаТаблиц = Неопределено Тогда
		
		Если СвойстваИмени.ЭтоОсновнаяТаблица
		   И Не Контекст.Свойство("ОшибкаНаПервоеПолеОсновнойТаблицыУстановлена") Тогда
			
			Контекст.Вставить("ОшибкаНаПервоеПолеОсновнойТаблицыУстановлена");
			УстановитьОшибкуВСтрокеИмениПоля(Контекст, Источник,
				НСтр("ru = 'Поле не найдено, так как не найдена таблица ""%1""'"), 0, ,
				Контекст.ОсновнаяТаблица);
		КонецЕсли;
		
		Возврат;
	КонецЕсли;
	
	Свойства = СвойстваТребуемойТаблицы(Контекст, СвойстваИмени);
	
	СвойстваПоля = Свойства.Поля.Получить(ВРег(ИмяПоля));
	Если СвойстваПоля = Неопределено Тогда
		СвойстваПоля = Новый Структура;
		СвойстваПоля.Вставить("ПолеСОшибкой", 0);
		СвойстваПоля.Вставить("ВидОшибки",    "");
		СвойстваПоля.Вставить("Коллекция",    "");
		СвойстваПоля.Вставить("СодержитТипы", Новый Соответствие);
		СвойстваПоля.Вставить("Источники",    Новый Соответствие);
		СвойстваПоля.Вставить("УзлыПоле",     Новый Массив);
		Свойства.Поля.Вставить(ВРег(ИмяПоля), СвойстваПоля);
		
		Если Свойства.Свойство("ПервоеПоле")
		   И Свойства.ПервоеПоле = Неопределено
		   И Источник <> Неопределено Тогда
			
			СвойстваПоля.Вставить("ПервыйИсточник", Новый Структура("Ключ,Значение", Источник, Таблица));
			Свойства.ПервоеПоле = СвойстваПоля;
		КонецЕсли;
	КонецЕсли;
	СвойстваПоля.Источники.Вставить(Источник, Таблица);
	Если УзелПоле <> Неопределено Тогда
		СвойстваПоля.УзлыПоле.Добавить(УзелПоле);
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ТипПоля) Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(ИсточникТипаПоля) = Тип("СтрокаТаблицыЗначений")
	   И ЗначениеЗаполнено(ИсточникТипаПоля.ТекстОшибки) Тогда
		Возврат;
	КонецЕсли;
	
	СвойстваТипа = СвойстваПоля.СодержитТипы.Получить(ВРег(ТипПоля));
	Если СвойстваТипа = Неопределено Тогда
		СоставИмени = СтрРазделить(ТипПоля, ".");
		СвойстваТипаТаблиц = Контекст.СинтаксисЯзыка.ТипыТаблиц.ПоИменам.Получить(ВРег(СоставИмени[0]));
		Если СвойстваТипаТаблиц = Неопределено Тогда
			ИмяТипа = ТипПоля;
			ИмяКоллекцииТипа = "";
			ИмяОбъектаКоллекцииТипа = "";
		Иначе
			ИмяТипа = СвойстваТипаТаблиц.ЯзыкРусский + "Ссылка." + СоставИмени[1];
			ИмяКоллекцииТипа = СвойстваТипаТаблиц.ИмяКоллекции;
			ИмяОбъектаКоллекцииТипа = СоставИмени[1];
		КонецЕсли;
		СвойстваТипа = Новый Структура;
		СвойстваТипа.Вставить("СодержитТип", Ложь);
		СвойстваТипа.Вставить("ИмяТипа", ИмяТипа);
		СвойстваТипа.Вставить("ИмяКоллекцииТипа", ИмяКоллекцииТипа);
		СвойстваТипа.Вставить("ИмяОбъектаКоллекцииТипа", ИмяОбъектаКоллекцииТипа);
		СвойстваТипа.Вставить("Источники", Новый Соответствие);
		СвойстваПоля.СодержитТипы.Вставить(ВРег(ТипПоля), СвойстваТипа);
	КонецЕсли;
	СвойстваТипа.Источники.Вставить(ИсточникТипаПоля, Источник);
	
КонецПроцедуры

// Для процедур ДобавитьТребуемуюТаблицуКакИсточникДанных, ДобавитьТребуемуюТаблицуКакСсылочныйТип,
// ДобавитьТребуемыйПредопределенныйЭлемент, ДобавитьТребуемоеПолеТаблицы.
//
Функция СвойстваИмениТаблицы(Контекст, ПолноеИмя)
	
	Если ЗначениеЗаполнено(ПолноеИмя) Тогда
		Таблица = ПолноеИмя;
	Иначе
		Таблица = Контекст.ОсновнаяТаблица;
	КонецЕсли;
	
	СоставИмени = СтрРазделить(Таблица, ".", Ложь);
	
	Свойства = Новый Структура;
	Свойства.Вставить("ЧислоЧастейИмени", СоставИмени.Количество());
	Свойства.Вставить("ИмяТипа",    СоставИмени[0]);
	Свойства.Вставить("ИмяБезТипа", ?(СоставИмени.Количество() > 1, СоставИмени[1], Неопределено));
	Свойства.Вставить("Расширение", ?(СоставИмени.Количество() = 3, СоставИмени[2], Неопределено));
	Свойства.Вставить("ЭтоОсновнаяТаблица", ВРег(Таблица) = ВРег(Контекст.ОсновнаяТаблица));
	Свойства.Вставить("СвойстваТипаТаблиц",
		Контекст.СинтаксисЯзыка.ТипыТаблиц.ПоИменам.Получить(ВРег(СоставИмени[0])));
	
	Возврат Свойства;
	
КонецФункции

// Для процедур ДобавитьТребуемуюТаблицуКакИсточникДанных, ДобавитьТребуемуюТаблицуКакСсылочныйТип,
// ДобавитьТребуемыйПредопределенныйЭлемент, ДобавитьТребуемоеПолеТаблицы.
//
Функция СвойстваТребуемойТаблицы(Контекст, СвойстваИмени, БезРасширения = Ложь)
	
	ИмяКоллекции = СвойстваИмени.СвойстваТипаТаблиц.ИмяКоллекции;
	
	СвойстваКоллекции = Контекст.ПоляТаблиц.Получить(ИмяКоллекции);
	Если СвойстваКоллекции = Неопределено Тогда
		СвойстваКоллекции = Новый Соответствие;
		Контекст.ПоляТаблиц.Вставить(ИмяКоллекции, СвойстваКоллекции);
	КонецЕсли;
	
	Свойства = СвойстваКоллекции.Получить(ВРег(СвойстваИмени.ИмяБезТипа));
	Если Свойства = Неопределено Тогда
		Свойства = Новый Структура;
		Свойства.Вставить("ТаблицаСуществует",  Ложь);
		Свойства.Вставить("ЭтоОсновнаяТаблица", СвойстваИмени.ЭтоОсновнаяТаблица);
		Свойства.Вставить("Источники",          Новый Массив);
		Свойства.Вставить("Поля",               Новый Соответствие);
		Свойства.Вставить("Предопределенные",   Новый Соответствие);
		Свойства.Вставить("Расширения",         Новый Соответствие);
		Если СвойстваИмени.ЭтоОсновнаяТаблица И СвойстваИмени.Расширение = Неопределено Тогда
			Свойства.Вставить("ПервоеПоле");
		КонецЕсли;
		СвойстваКоллекции.Вставить(ВРег(СвойстваИмени.ИмяБезТипа), Свойства);
	КонецЕсли;
	
	Если СвойстваИмени.Расширение = Неопределено Или БезРасширения Тогда
		Возврат Свойства;
	КонецЕсли;
	
	СвойстваРасширения = Свойства.Расширения.Получить(ВРег(СвойстваИмени.Расширение));
	Если СвойстваРасширения = Неопределено Тогда
		СвойстваРасширения = Новый Структура;
		СвойстваРасширения.Вставить("ТаблицаСуществует", Ложь);
		СвойстваРасширения.Вставить("Источники",         Новый Массив);
		СвойстваРасширения.Вставить("Поля",              Новый Соответствие);
		Если СвойстваИмени.ЭтоОсновнаяТаблица Тогда
			СвойстваРасширения.Вставить("ПервоеПоле");
		КонецЕсли;
		Свойства.Расширения.Вставить(ВРег(СвойстваИмени.Расширение), СвойстваРасширения);
	КонецЕсли;
	
	Возврат СвойстваРасширения;
	
КонецФункции

// Для процедур и функций ЧастиОграничения, РазобратьДополнительныеТаблицы, РазобратьСоединение,
// РазобратьУсловиеОграничения, ВыраженияВыборКогдаТогдаВоВложениях.
Функция ПодставитьКлючевыеСловаВСтроку(Контекст, Строка, СписокСлов, ПараметрОдин = "", ПараметрДва = "", ПараметрТри = "")
	
	Слова = СтрРазделить(СписокСлов, ",", Ложь);
	СловаДляПодстановки = Новый Соответствие;
	
	Для Каждого Слово Из Слова Цикл
		СловаДляПодстановки.Вставить(Слова.Найти(Слово),
			КлючевоеСловоСУчетомЯзыка(СокрЛП(Слово), Контекст));
	КонецЦикла;
	
	Индекс = СловаДляПодстановки.Количество();
	СловаДляПодстановки.Вставить(Индекс,     ПараметрОдин);
	СловаДляПодстановки.Вставить(Индекс + 1, ПараметрДва);
	СловаДляПодстановки.Вставить(Индекс + 2, ПараметрТри);
	
	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(Строка,
		СловаДляПодстановки[0], СловаДляПодстановки[1], СловаДляПодстановки[2],
		СловаДляПодстановки[3], СловаДляПодстановки[4], СловаДляПодстановки[5],
		СловаДляПодстановки[6], СловаДляПодстановки[7], СловаДляПодстановки[8]);
	
КонецФункции

// Для процедур РазобратьДополнительныеТаблицы, РазобратьСоединение, РазобратьУсловиеОграничения.
Функция КлючевоеСловоСУчетомЯзыка(ИдентификаторСлова, Контекст)
	
	СвойстваСлова = Контекст.СинтаксисЯзыка.СловаЯзыка.Получить(ВРег(ИдентификаторСлова));
	
	Если ВариантВстроенногоЯзыкаРусский() Тогда
		Слово = СвойстваСлова.ЯзыкРусский;
	Иначе
		Слово = СвойстваСлова.ЯзыкАнглийский;
	КонецЕсли;
	
	Если СвойстваСлова.ВерхнийРегистр Тогда
		Слово = ВРег(Слово);
	КонецЕсли;
	
	Возврат Слово;
	
КонецФункции

// Для функций ОписаниеДопустимыхШаблонов, КлючевоеСловоСУчетомЯзыка.
Функция ВариантВстроенногоЯзыкаРусский()
	
	Возврат Метаданные.ВариантВстроенногоЯзыка = Метаданные.СвойстваОбъектов.ВариантВстроенногоЯзыка.Русский;
	
КонецФункции

#КонецОбласти

#Область АнализИменТаблицИПолейТаблиц

// Проверка таблиц, полей таблиц и типов полей, найденных при разборе текста ограничения.
// Аналогичная процедура реализуется в СППР.
//
// Параметры:
//  РазобранноеОграничение - Структура - возвращается функцией РазобранноеОграничение.
//
Процедура ПроверитьТаблицыПоляИТипыПолей(РазобранноеОграничение)
	
	Контекст = Новый Структура;
	Контекст.Вставить("ТипыТаблиц", УправлениеДоступомСлужебныйПовтИсп.СинтаксисЯзыка().ТипыТаблиц);
	
	Для Каждого ТипТаблиц Из РазобранноеОграничение.ПоляТаблиц Цикл
		КоллекцияТаблиц = Метаданные[ТипТаблиц.Ключ];
		
		Для Каждого ПоляТаблицы Из ТипТаблиц.Значение Цикл
			
			МетаданныеТаблицы = КоллекцияТаблиц.Найти(ПоляТаблицы.Ключ);
			Если МетаданныеТаблицы = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			ПоляТаблицы.Значение.ТаблицаСуществует = Истина;
			
			Контекст.Вставить("МетаданныеТаблицы",  МетаданныеТаблицы);
			Контекст.Вставить("СвойстваТипаТаблиц", Контекст.ТипыТаблиц.ПоКоллекциям.Получить(ТипТаблиц.Ключ));
			Контекст.Вставить("ЭтоОсновнаяТаблица", ПоляТаблицы.Значение.ЭтоОсновнаяТаблица);
			
			Для Каждого ПолеТаблицы Из ПоляТаблицы.Значение.Поля Цикл
				ОписаниеПоля = Новый Структура;
				ОписаниеПоля.Вставить("СоставИмени", СтрРазделить(ПолеТаблицы.Ключ, "."));
				ОписаниеПоля.Вставить("Свойства",    ПолеТаблицы.Значение);
				ОписаниеПоля.Вставить("ТипПоля",     Новый ОписаниеТипов);
				ПроверитьПолеТаблицы(ОписаниеПоля, Контекст);
				Если ОписаниеПоля.Свойства.ПолеСОшибкой = 0 Тогда
					ПроверитьТипыПоля(ОписаниеПоля, Контекст);
				КонецЕсли;
			КонецЦикла;
			
			ПроверитьРасширенияТаблицы(ПоляТаблицы, Контекст);
			ПроверитьПредопределенныеЗначенияТаблицы(ПоляТаблицы, Контекст);
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

// Для процедур ПроверитьТаблицыПоляИТипыПолей, ПроверитьСледующееПолеЧерезТочку.
Процедура ПроверитьПолеТаблицы(ОписаниеПоля, Контекст, Индекс = 0, ПервыйВызов = Истина)
	
	СоставИмени  = ОписаниеПоля.СоставИмени;
	СвойстваПоля = ОписаниеПоля.Свойства;
	
	УточнениеПоля = Контекст.СвойстваТипаТаблиц.УточнениеПолей.Получить(ВРег(СоставИмени[Индекс]));
	
	Если УточнениеПоля <> Неопределено
	   И УточнениеПоля.Использование <> "Разрешено" Тогда
		
		СвойстваПоля.ПолеСОшибкой = Индекс + 1;
		СвойстваПоля.ВидОшибки = УточнениеПоля;
		Возврат;
	КонецЕсли;
	
	Свойства = СвойстваПоляИлиТабличнойЧасти(СоставИмени[Индекс], Контекст, Индекс = 0);
	Если Свойства = Неопределено Тогда
		СвойстваПоля.ПолеСОшибкой = Индекс + 1;
		СвойстваПоля.ВидОшибки = "НеНайдено";
		Возврат;
	КонецЕсли;
	Если Индекс = 0 Тогда
		СвойстваПоля.Коллекция = Свойства.Коллекция;
	КонецЕсли;
	
	Если Свойства.ЭтоТабличнаяЧасть Тогда
		Если Индекс > 0 Тогда
			СвойстваПоля.ПолеСОшибкой = Индекс + 1;
			СвойстваПоля.ВидОшибки = "ТабличнаяЧастьПослеТочки";
			Возврат;
		КонецЕсли;
		Если Не Контекст.ЭтоОсновнаяТаблица Тогда
			СвойстваПоля.ПолеСОшибкой = Индекс + 1;
			СвойстваПоля.ВидОшибки = "ТабличнаяЧастьДополнительнойТаблицы";
			Возврат;
		КонецЕсли;
		Если Индекс + 1 = СоставИмени.Количество() Тогда
			СвойстваПоля.ПолеСОшибкой = Индекс + 1;
			СвойстваПоля.ВидОшибки = "ТабличнаяЧастьБезПоля";
			Возврат;
		КонецЕсли;
		Индекс = Индекс + 1;
		Свойства = СвойстваПоляТабличнойЧасти(СоставИмени[Индекс],
			Свойства.Метаданные, Свойства.Коллекция, Контекст.МетаданныеТаблицы);
		Если Свойства = Неопределено Тогда
			СвойстваПоля.ПолеСОшибкой = Индекс + 1;
			СвойстваПоля.ВидОшибки = "НеНайдено";
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ПроверитьСледующееПолеЧерезТочку(ОписаниеПоля, Индекс, Свойства, Контекст);
	
	Если ПервыйВызов Тогда
		ЗаполнитьТипыПоляСтрокойДополнительно(ОписаниеПоля);
	КонецЕсли;
	
КонецПроцедуры

// Для процедур ПроверитьПолеТаблицы и ПроверитьРасширенияТаблицы.
Процедура ПроверитьСледующееПолеЧерезТочку(ОписаниеПоля, Индекс, СвойстваТекущегоПоля, Контекст)
	
	ДобавитьТипыПоляДополнительно(ОписаниеПоля, Индекс, СвойстваТекущегоПоля, Контекст);
	
	Индекс = Индекс + 1;
	Если Индекс = ОписаниеПоля.СоставИмени.Количество() Тогда
		ОписаниеПоля.ТипПоля = Новый ОписаниеТипов(ОписаниеПоля.ТипПоля, СвойстваТекущегоПоля.Тип.Типы());
		Возврат;
	КонецЕсли;
	
	СвойстваПоля = ОписаниеПоля.Свойства;
	ПолеНайдено = Ложь;
	
	Если ОписаниеПоля.Свойство("ТаблицыСледующегоПоля") Тогда
		// См. процедуру ДобавитьТипыПоляДополнительно.
		Если ОписаниеПоля.ТаблицыСледующегоПоля.Количество() < Индекс + 1 Тогда
			ТаблицыСледующегоПоля = Новый Массив;
			ОписаниеПоля.ТаблицыСледующегоПоля.Добавить(ТаблицыСледующегоПоля);
		Иначе
			ТаблицыСледующегоПоля = ОписаниеПоля.ТаблицыСледующегоПоля[Индекс];
		КонецЕсли;
	КонецЕсли;
	
	Для Каждого Тип Из СвойстваТекущегоПоля.Тип.Типы() Цикл
		Если Не ОбщегоНазначения.ЭтоСсылка(Тип) Тогда
			Продолжить;
		КонецЕсли;
		СвойстваПоля.ПолеСОшибкой = 0;
		СвойстваПоля.ВидОшибки = "";
		
		// Сохранение текущего контекста.
		ТекущиеМетаданныеТаблицы  = Контекст.МетаданныеТаблицы;
		ТекущиеСвойстваТипаТаблиц = Контекст.СвойстваТипаТаблиц;
		
		Контекст.МетаданныеТаблицы = Метаданные.НайтиПоТипу(Тип);
		ПолноеИмя = Контекст.МетаданныеТаблицы.ПолноеИмя();
		СоставПолногоИмени = СтрРазделить(ПолноеИмя, ".", Ложь);
		Контекст.СвойстваТипаТаблиц = Контекст.ТипыТаблиц.ПоИменам.Получить(ВРег(СоставПолногоИмени[0]));
		
		ТекущийИндекс = Индекс;
		ПроверитьПолеТаблицы(ОписаниеПоля, Контекст, ТекущийИндекс, Ложь);
		
		// Восстановление текущего контекста.
		Контекст.МетаданныеТаблицы  = ТекущиеМетаданныеТаблицы;
		Контекст.СвойстваТипаТаблиц = ТекущиеСвойстваТипаТаблиц;
		
		Если СвойстваПоля.ПолеСОшибкой = 0 Тогда
			ПолеНайдено = Истина;
			Если ТаблицыСледующегоПоля <> Неопределено Тогда
				// См. процедуру ДобавитьТипыПоляДополнительно.
				ТаблицыСледующегоПоля.Добавить(ПолноеИмя);
			КонецЕсли;
		ИначеЕсли СвойстваПоля.ВидОшибки <> "НеНайдено" Тогда
			Возврат;
		КонецЕсли;
	КонецЦикла;
	
	Если ПолеНайдено Тогда
		СвойстваПоля.ПолеСОшибкой = 0;
		СвойстваПоля.ВидОшибки = "";
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ПроверитьПолеТаблицы.
Функция СвойстваПоляИлиТабличнойЧасти(ИмяПоляИлиТабличнойЧасти, Контекст, ЭтоПервоеПоле)
	
	Результат = Новый Структура;
	Результат.Вставить("ЭтоТабличнаяЧасть", Ложь);
	Результат.Вставить("Коллекция");
	Результат.Вставить("Метаданные");
	Результат.Вставить("Тип");
	
	МетаданныеТаблицы  = Контекст.МетаданныеТаблицы;
	СвойстваТипаТаблиц = Контекст.СвойстваТипаТаблиц;
	
	Для Каждого КоллекцияТабличныхЧастей Из СвойстваТипаТаблиц.КоллекцииТабличныхЧастей Цикл
		Если КоллекцияТабличныхЧастей.Ключ = "СтандартныеТабличныеЧасти" Тогда
			Для Каждого СтандартнаяТабличнаяЧасть Из МетаданныеТаблицы.СтандартныеТабличныеЧасти Цикл
				Если ВРег(ИмяПоляИлиТабличнойЧасти) = ВРег(СтандартнаяТабличнаяЧасть.Имя) Тогда
					Результат.Метаданные = СтандартнаяТабличнаяЧасть;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		Иначе
			Результат.Метаданные = МетаданныеТаблицы[КоллекцияТабличныхЧастей.Ключ].Найти(ИмяПоляИлиТабличнойЧасти);
		КонецЕсли;
		Если Результат.Метаданные <> Неопределено Тогда
			Результат.ЭтоТабличнаяЧасть = Истина;
			Результат.Коллекция = КоллекцияТабличныхЧастей.Ключ;
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого КоллекцияПолей Из СвойстваТипаТаблиц.КоллекцииПолей Цикл
		Если КоллекцияПолей.Ключ = "СтандартныеРеквизиты" Тогда
			Номер = 0;
			Для Каждого СтандартныйРеквизит Из МетаданныеТаблицы.СтандартныеРеквизиты Цикл
				Номер = Номер + 1;
				Если ВРег(ИмяПоляИлиТабличнойЧасти) = ВРег(СтандартныйРеквизит.Имя) Тогда
					Результат.Метаданные = СтандартныйРеквизит;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		Иначе
			Результат.Метаданные = МетаданныеТаблицы[КоллекцияПолей.Ключ].Найти(ИмяПоляИлиТабличнойЧасти);
		КонецЕсли;
		Если Результат.Метаданные <> Неопределено Тогда
			Результат.Коллекция = КоллекцияПолей.Ключ;
			Если Результат.Коллекция = "Графы" Тогда
				Результат.Тип = Новый ОписаниеТипов;
				Для Каждого МетаданныеСсылки Из Результат.Метаданные.Ссылки Цикл
					Результат.Тип = Новый ОписаниеТипов(Результат.Тип, МетаданныеСсылки.Тип.Типы());
				КонецЦикла;
			Иначе
				Результат.Тип = Результат.Метаданные.Тип;
			КонецЕсли;
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	
	Если СвойстваТипаТаблиц.ОбщиеРеквизиты <> "Отсутствуют" Тогда
		Результат.Метаданные = Метаданные.ОбщиеРеквизиты.Найти(ИмяПоляИлиТабличнойЧасти);
		Если Результат.Метаданные <> Неопределено Тогда
			Результат.Коллекция = "ОбщиеРеквизиты";
			Результат.Тип = Результат.Метаданные.Тип;
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	
	Если СвойстваТипаТаблиц.ИмяКоллекции = "Константы" Тогда
		
		Если ВРег(ИмяПоляИлиТабличнойЧасти) = ВРег("Значение")
		 Или ВРег(ИмяПоляИлиТабличнойЧасти) = ВРег("Value") Тогда
			
			Результат.Коллекция = "СпециальныеПоля";
			Результат.Тип = МетаданныеТаблицы.Тип;
			Результат.Вставить("ОсновнойПорядок", "001"); // См. процедуру ДобавитьОсновнойПорядокПоля.
			Возврат Результат;
		КонецЕсли;
		
	ИначеЕсли СвойстваТипаТаблиц.ИмяКоллекции = "Последовательности" Тогда
		
		Если ВРег(ИмяПоляИлиТабличнойЧасти) = ВРег("Период")
		 Или ВРег(ИмяПоляИлиТабличнойЧасти) = ВРег("Period") Тогда
		
			Результат.Коллекция = "СпециальныеПоля";
			Результат.Тип = Новый ОписаниеТипов("Дата");
			Результат.Вставить("ОсновнойПорядок", "001"); // См. процедуру ДобавитьОсновнойПорядокПоля.
			Возврат Результат;
		КонецЕсли;
		
		Если ВРег(ИмяПоляИлиТабличнойЧасти) = ВРег("Регистратор")
		 Или ВРег(ИмяПоляИлиТабличнойЧасти) = ВРег("Recorder") Тогда
			
			Результат.Коллекция = "СпециальныеПоля";
			Результат.Тип = Новый ОписаниеТипов;
			Для Каждого ДокументМетаданные Из МетаданныеТаблицы.Документы Цикл
				Результат.Тип = Новый ОписаниеТипов(Результат.Тип, "ДокументСсылка." + ДокументМетаданные.Имя);
			КонецЦикла;
			Результат.Вставить("ОсновнойПорядок", "002"); // См. процедуру ДобавитьОсновнойПорядокПоля.
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Для процедур ПроверитьРасширенияТаблицы, ПроверитьПолеТаблицы.
Функция СвойстваПоляТабличнойЧасти(ИмяПоляТабличнойЧасти, МетаданныеТабличнойЧасти, ИмяКоллекции, МетаданныеТаблицы)
	
	Результат = Новый Структура;
	Результат.Вставить("Тип");
	Результат.Вставить("ИмяТабличнойЧасти", МетаданныеТабличнойЧасти.Имя);
	
	Если ВРег(ИмяПоляТабличнойЧасти) = ВРег("Ссылка")
	 Или ВРег(ИмяПоляТабличнойЧасти) = ВРег("Ref") Тогда
		
		Для Каждого СтандартныйРеквизит Из МетаданныеТаблицы.СтандартныеРеквизиты Цикл
			Если ВРег(ИмяПоляТабличнойЧасти) = ВРег(СтандартныйРеквизит.Имя) Тогда
				Результат.Тип = СтандартныйРеквизит.Тип;
				Возврат Результат;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Для Каждого СтандартныйРеквизит Из МетаданныеТабличнойЧасти.СтандартныеРеквизиты Цикл
		Если ВРег(ИмяПоляТабличнойЧасти) = ВРег(СтандартныйРеквизит.Имя) Тогда
			Результат.Тип = СтандартныйРеквизит.Тип;
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	
	Если ИмяКоллекции = "ТабличныеЧасти" Тогда
		МетаданныеПоля = МетаданныеТабличнойЧасти.Реквизиты.Найти(ИмяПоляТабличнойЧасти);
		Если МетаданныеПоля <> Неопределено Тогда
			Результат.Тип = МетаданныеПоля.Тип;
			Результат.Вставить("МетаданныеТабличнойЧасти", МетаданныеТабличнойЧасти);
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Для процедур ПроверитьРасширенияТаблицы, ПроверитьПолеТаблицы.
Функция СвойстваПоляПерерасчета(ИмяПоляПерерасчета, МетаданныеПерерасчета, МетаданныеТаблицы)
	
	Результат = Новый Структура;
	Результат.Вставить("Тип");
	Результат.Вставить("Коллекция");
	Результат.Вставить("Метаданные");
	
	Если ВРег(ИмяПоляПерерасчета) = ВРег("ОбъектПерерасчета")
	 Или ВРег(ИмяПоляПерерасчета) = ВРег("RecalculationObject") Тогда
		
		ИмяПоля = "Регистратор";
		
	ИначеЕсли ВРег(ИмяПоляПерерасчета) = ВРег("ВидРасчета")
	      Или ВРег(ИмяПоляПерерасчета) = ВРег("CalculationType") Тогда
	
		ИмяПоля = "ВидРасчета";
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		Для Каждого СтандартныйРеквизит Из МетаданныеТаблицы.СтандартныеРеквизиты Цикл
			Если ВРег(ИмяПоля) = ВРег(СтандартныйРеквизит.Имя) Тогда
				Результат.Коллекция = "СтандартныеРеквизиты";
				Результат.Метаданные = СтандартныйРеквизит;
				Результат.Тип = СтандартныйРеквизит.Тип;
				Возврат Результат;
			КонецЕсли;
		КонецЦикла;
		Возврат Неопределено;
	КонецЕсли;
	
	МетаданныеПоля = МетаданныеПерерасчета.Измерения.Найти(ИмяПоляПерерасчета);
	Если МетаданныеПоля <> Неопределено Тогда
		Результат.Тип = МетаданныеПоля.ИзмерениеРегистра.Тип;
		Результат.Коллекция = "СпециальныеПоля";
		Номер = 200 + МетаданныеТаблицы.Измерения.Индекс(МетаданныеПоля) + 1;
		Результат.Вставить("ОсновнойПорядок", Номер); // См. процедуру ДобавитьОсновнойПорядокПоля.
		Возврат Результат;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Для процедуры ПроверитьПолеТаблицы.
Процедура ДобавитьТипыПоляДополнительно(ОписаниеПоля, Индекс, СвойстваТекущегоПоля, Контекст)
	
	// Дополнительный сбор типов для использования в служебных процедурах.
	
	// Расширение свойств узла Поле для использования в служебных процедурах.
	Если Индекс = 0 Или Индекс = 1 И СвойстваТекущегоПоля.Свойство("ИмяТабличнойЧасти") Тогда
		Если ОписаниеПоля.СоставИмени.Количество() > 1 Тогда
			ОписаниеПоля.Вставить("ТаблицыСледующегоПоля", Новый Массив);
			Если Индекс = 1 Тогда
				ОписаниеПоля.ТаблицыСледующегоПоля.Добавить(Неопределено);
			КонецЕсли;
		КонецЕсли;
		Если Индекс = 0 И Не Контекст.СвойстваТипаТаблиц.ЭтоСсылочныйТип Тогда
			ДобавитьОсновнойПорядокПоля(СвойстваТекущегоПоля, Контекст);
		КонецЕсли;
	КонецЕсли;
	
	Для Каждого УзелПоле Из ОписаниеПоля.Свойства.УзлыПоле Цикл
		Если СвойстваТекущегоПоля.Свойство("ОсновнойПорядок")
		   И Не УзелПоле.Свойство("ОсновнойПорядок") Тогда
			УзелПоле.Вставить("ОсновнойПорядок", СвойстваТекущегоПоля.ОсновнойПорядок);
		КонецЕсли;
		Если ОписаниеПоля.Свойство("ТаблицыСледующегоПоля")
		   И Не УзелПоле.Свойство("ТаблицыСледующегоПоля") Тогда
			УзелПоле.Вставить("ТаблицыСледующегоПоля", ОписаниеПоля.ТаблицыСледующегоПоля);
		КонецЕсли;
		Если Не УзелПоле.Свойство("ТипыПоля") Тогда
			УзелПоле.Вставить("ТипыПоля", Новый Массив);
			УстановитьПолеСодержитNull(УзелПоле, СвойстваТекущегоПоля, Контекст);
		КонецЕсли;
		Если СвойстваТекущегоПоля.Свойство("ИмяТабличнойЧасти")
		   И ВРег(СвойстваТекущегоПоля.ИмяТабличнойЧасти) = ВРег(ОписаниеПоля.СоставИмени[0]) Тогда
			
			УзелПоле.ТипыПоля.Добавить(СвойстваТекущегоПоля.ИмяТабличнойЧасти);
		КонецЕсли;
		Если Индекс > УзелПоле.ТипыПоля.Количество() - 1 Тогда
			УзелПоле.ТипыПоля.Добавить(СвойстваТекущегоПоля.Тип);
		КонецЕсли;
		УзелПоле.ТипыПоля[Индекс] = Новый ОписаниеТипов(УзелПоле.ТипыПоля[Индекс],
			СвойстваТекущегоПоля.Тип.Типы());
	КонецЦикла;
	
	// Добавление типов поля строкой для проверки изменения в служебных процедурах.
	ПолноеИмяПоля = Контекст.СвойстваТипаТаблиц.ЯзыкРусский + "." + ВРег(Контекст.МетаданныеТаблицы.Имя);
	
	Если СвойстваТекущегоПоля.Свойство("ИмяТабличнойЧасти") Тогда
		ПолноеИмяПоля = ПолноеИмяПоля + "." + ВРег(СвойстваТекущегоПоля.ИмяТабличнойЧасти);
	КонецЕсли;
	
	ПолноеИмяПоля = ПолноеИмяПоля + "." + ОписаниеПоля.СоставИмени[Индекс];
	
	Если Не ОписаниеПоля.Свойство("ВсеПоля") Тогда
		ОписаниеПоля.Вставить("ВсеПоля",       Новый Соответствие);
		ОписаниеПоля.Вставить("ТипыВсехПолей", Новый СписокЗначений);
	КонецЕсли;
	Если ОписаниеПоля.ВсеПоля.Получить(ПолноеИмяПоля) <> Неопределено Тогда
		Возврат;
	КонецЕсли;
	ОписаниеПоля.ВсеПоля.Вставить(ПолноеИмяПоля, Истина);
	
	ТипыСтрокой = СтрокаДанныхДляХеширования(СвойстваТекущегоПоля.Тип);
	ОписаниеПоля.ТипыВсехПолей.Добавить(ТипыСтрокой, ПолноеИмяПоля);
	
КонецПроцедуры

// Для процедуры ПроверитьПолеТаблицы.
Процедура ЗаполнитьТипыПоляСтрокойДополнительно(ОписаниеПоля)
	
	Если ОписаниеПоля.ТипыВсехПолей.Количество() > 1 Тогда
		ОписаниеПоля.ТипыВсехПолей.СортироватьПоПредставлению();
	КонецЕсли;
	ТипыСтрокой = СтрСоединить(ОписаниеПоля.ТипыВсехПолей.ВыгрузитьЗначения(), Символы.ПС);
	УзлыПоле = ОписаниеПоля.Свойства.УзлыПоле;
	
	Для Каждого УзелПоле Из УзлыПоле Цикл
		УзелПоле.Вставить("ТипыСтрокой", ТипыСтрокой);
	КонецЦикла;
	
	ОписаниеПоля.Удалить("ВсеПоля");
	ОписаниеПоля.Удалить("ТипыВсехПолей");
	
КонецПроцедуры

// Для процедуры ДобавитьТипыПоляДополнительно.
Процедура ДобавитьОсновнойПорядокПоля(СвойстваТекущегоПоля, Контекст)
	
	Если СвойстваТекущегоПоля.Коллекция = "СпециальныеПоля" Тогда
		Возврат; // Установлен в функции СвойстваПоляИлиТабличнойЧасти.
	КонецЕсли;
	
	МетаданныеТаблицы = Контекст.МетаданныеТаблицы;
	МетаданныеПоля    = СвойстваТекущегоПоля.Метаданные;
	
	Если СвойстваТекущегоПоля.Коллекция = "СтандартныеРеквизиты" Тогда
		Индекс = 0;
		Для Каждого СтандартныйРеквизит Из МетаданныеТаблицы.СтандартныеРеквизиты Цикл
			Если СтандартныйРеквизит = МетаданныеПоля Тогда
				Прервать;
			КонецЕсли;
			Индекс = Индекс + 1;
		КонецЦикла;
		Номер = 100 + Индекс + 1;
		
	ИначеЕсли СвойстваТекущегоПоля.Коллекция = "Измерения" Тогда
		Номер = 200 + МетаданныеТаблицы.Измерения.Индекс(МетаданныеПоля) + 1;
		
	ИначеЕсли СвойстваТекущегоПоля.Коллекция = "Ресурсы" Тогда
		Номер = 300 + МетаданныеТаблицы.Ресурсы.Индекс(МетаданныеПоля) + 1;
		
	ИначеЕсли СвойстваТекущегоПоля.Коллекция = "Реквизиты" Тогда
		Номер = 400 + МетаданныеТаблицы.Реквизиты.Индекс(МетаданныеПоля) + 1;
		
	ИначеЕсли СвойстваТекущегоПоля.Коллекция = "ОбщиеРеквизиты" Тогда
		Номер = 500 + Контекст.СвойстваТипаТаблиц.ОбщиеРеквизиты.Индекс(МетаданныеПоля) + 1;
	КонецЕсли;
	
	СвойстваТекущегоПоля.Вставить("ОсновнойПорядок", Строка(Номер));
	
КонецПроцедуры

// Для процедуры ДобавитьТипыПоляДополнительно.
Процедура УстановитьПолеСодержитNull(УзелПоле, СвойстваТекущегоПоля, Контекст)
	
	Если Контекст.СвойстваТипаТаблиц.ИмяКоллекции <> "Справочники"
	   И Контекст.СвойстваТипаТаблиц.ИмяКоллекции <> "ПланыВидовХарактеристик"
	 Или Не Контекст.МетаданныеТаблицы.Иерархический Тогда
		
		Возврат;
	КонецЕсли;
	
	Если Контекст.СвойстваТипаТаблиц.ИмяКоллекции = "Справочники"
	   И Контекст.МетаданныеТаблицы.ВидИерархии
	       <> Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов Тогда
		
		Возврат;
	КонецЕсли;
	
	Если СвойстваТекущегоПоля.Свойство("ИмяТабличнойЧасти") Тогда
		Если СвойстваТекущегоПоля.Свойство("МетаданныеТабличнойЧасти")
		   И СвойстваТекущегоПоля.МетаданныеТабличнойЧасти.Использование
		      <> Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппыИЭлемента Тогда
			
			УзелПоле.Вставить("ПолеСодержитNull");
		КонецЕсли;
		
		Возврат;
	КонецЕсли;
	
	Если СвойстваТекущегоПоля.Коллекция = "Реквизиты"
	   И СвойстваТекущегоПоля.Метаданные.Использование
	      <> Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппыИЭлемента Тогда
		
		УзелПоле.Вставить("ПолеСодержитNull");
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ПроверитьТаблицыПоляИТипыПолей.
Процедура ПроверитьРасширенияТаблицы(ПоляТаблицы, Контекст)
	
	СвойстваТипаТаблиц = Контекст.СвойстваТипаТаблиц;
	
	Если СвойстваТипаТаблиц.КоллекцииТабличныхЧастей.Количество() = 0
	   И СвойстваТипаТаблиц.ИмяКоллекции <> "РегистрыРасчета" Тогда
		Возврат;
	КонецЕсли;
	
	МетаданныеТаблицы = Контекст.МетаданныеТаблицы;
	
	Для Каждого РасширениеТаблицы Из ПоляТаблицы.Значение.Расширения Цикл
		
		Если СвойстваТипаТаблиц.ИмяКоллекции = "РегистрыРасчета" Тогда
			МетаданныеРасширения = МетаданныеТаблицы.Перерасчеты.Найти(РасширениеТаблицы.Ключ);
		Иначе
			Для Каждого КоллекцияТабличныхЧастей Из СвойстваТипаТаблиц.КоллекцииТабличныхЧастей Цикл
				Если КоллекцияТабличныхЧастей.Ключ = "СтандартныеТабличныеЧасти" Тогда
					Для Каждого СтандартнаяТабличнаяЧасть Из МетаданныеТаблицы.СтандартныеТабличныеЧасти Цикл
						Если ВРег(РасширениеТаблицы.Ключ) = ВРег(СтандартнаяТабличнаяЧасть.Имя) Тогда
							МетаданныеРасширения = СтандартнаяТабличнаяЧасть;
							Прервать;
						КонецЕсли;
					КонецЦикла;
				Иначе
					МетаданныеРасширения = МетаданныеТаблицы[КоллекцияТабличныхЧастей.Ключ].Найти(РасширениеТаблицы.Ключ);
				КонецЕсли;
				Если МетаданныеРасширения <> Неопределено Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Если МетаданныеРасширения = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		РасширениеТаблицы.Значение.ТаблицаСуществует = Истина;
		
		Для Каждого ПолеТаблицы Из РасширениеТаблицы.Значение.Поля Цикл
			ОписаниеПоля = Новый Структура;
			ОписаниеПоля.Вставить("СоставИмени", СтрРазделить(ПолеТаблицы.Ключ, "."));
			ОписаниеПоля.Вставить("Свойства",    ПолеТаблицы.Значение);
			ОписаниеПоля.Вставить("ТипПоля",     Новый ОписаниеТипов);
			
			Индекс = 0;
			Если СвойстваТипаТаблиц.ИмяКоллекции = "РегистрыРасчета" Тогда
				СвойстваПоля = СвойстваПоляПерерасчета(ОписаниеПоля.СоставИмени[Индекс],
					МетаданныеРасширения, МетаданныеТаблицы);
			Иначе
				СвойстваПоля = СвойстваПоляТабличнойЧасти(ОписаниеПоля.СоставИмени[Индекс],
					МетаданныеРасширения, КоллекцияТабличныхЧастей.Ключ, МетаданныеТаблицы);
			КонецЕсли;
			
			Если СвойстваПоля = Неопределено Тогда
				ОписаниеПоля.Свойства.ПолеСОшибкой = Индекс + 1;
				ОписаниеПоля.Свойства.ВидОшибки = "НеНайдено";
				Продолжить;
			КонецЕсли;
			ПроверитьСледующееПолеЧерезТочку(ОписаниеПоля, Индекс, СвойстваПоля, Контекст);
			ЗаполнитьТипыПоляСтрокойДополнительно(ОписаниеПоля);
			Если ОписаниеПоля.Свойства.ПолеСОшибкой = 0 Тогда
				ПроверитьТипыПоля(ОписаниеПоля, Контекст);
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

// Для процедур ПроверитьТаблицыПоляИТипыПолей и ПроверитьРасширенияТаблицы.
Процедура ПроверитьТипыПоля(ОписаниеПоля, Контекст)
	
	ОписаниеТиповПоля = ОписаниеПоля.ТипПоля;
	
	Для Каждого ОписаниеТипа Из ОписаниеПоля.Свойства.СодержитТипы Цикл
		СвойстваТипа = ОписаниеТипа.Значение;
		Если ЗначениеЗаполнено(СвойстваТипа.ИмяКоллекцииТипа)
		   И Метаданные[СвойстваТипа.ИмяКоллекцииТипа].Найти(СвойстваТипа.ИмяОбъектаКоллекцииТипа) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Тип = Тип(ОписаниеТипа.Значение.ИмяТипа);
		СвойстваТипа.СодержитТип = ОписаниеТиповПоля.СодержитТип(Тип);
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ПроверитьТаблицыПоляИТипыПолей.
Процедура ПроверитьПредопределенныеЗначенияТаблицы(ПоляТаблицы, Контекст)
	
	СвойстваТипаТаблиц = Контекст.СвойстваТипаТаблиц;
	
	Если ПоляТаблицы.Значение.Предопределенные.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если СвойстваТипаТаблиц.ЕстьПредопределенные Тогда
		МетаданныеТаблицы = Контекст.МетаданныеТаблицы;
		
		Если СвойстваТипаТаблиц.ИмяКоллекции = "Перечисления" Тогда
			ИменаПредопределенных = Новый Массив;
			Для Каждого ЗначениеПеречисления Из МетаданныеТаблицы.ЗначенияПеречисления Цикл
				ИменаПредопределенных.Добавить(ЗначениеПеречисления.Имя);
			КонецЦикла;
		Иначе
			ИменаПредопределенных = Новый Массив(МетаданныеТаблицы.ПолучитьИменаПредопределенных());
		КонецЕсли;
	Иначе
		ИменаПредопределенных = Новый Массив;
	КонецЕсли;
	
	ИменаПредопределенных.Добавить("ПустаяСсылка");
	ИменаПредопределенных.Добавить("EmptyRef");
	
	Для Каждого Предопределенный Из ПоляТаблицы.Значение.Предопределенные Цикл
		Для Каждого ИмяПредопределенного Из ИменаПредопределенных Цикл
			Если ВРег(ИмяПредопределенного) = Предопределенный.Ключ Тогда
				Предопределенный.Значение.ИмяСуществует = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры


// Для функции СтруктураОграничения.
Процедура ОтметитьНекорректныеИменаТаблицПолейИТиповПолей(ПоляТаблиц, Контекст)
	
	Для Каждого ТипТаблиц Из ПоляТаблиц Цикл
		Для Каждого ОписаниеТаблицы Из ТипТаблиц.Значение Цикл
			СвойстваТаблицы = ОписаниеТаблицы.Значение;
			
			Если Не СвойстваТаблицы.ТаблицаСуществует Тогда
				Для Каждого Источник Из СвойстваТаблицы.Источники Цикл
					УстановитьОшибкуВСтроке(Источник, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
							НСтр("ru = 'Не найдена таблица ""%1""'"), Источник.Символы), , 2);
				КонецЦикла;
				Если СвойстваТаблицы.Свойство("ПервоеПоле")
				   И СвойстваТаблицы.ПервоеПоле.ПервыйИсточник <> Неопределено Тогда
					
					УстановитьОшибкуВСтрокеИмениПоля(Контекст, СвойстваТаблицы.ПервоеПоле.ПервыйИсточник.Ключ,
						НСтр("ru = 'Поле не найдено, так как не найдена таблица ""%1""'"), 0, ,
						СвойстваТаблицы.ПервоеПоле.ПервыйИсточник.Значение);
				КонецЕсли;
				Для Каждого ОписаниеПредопределенного Из СвойстваТаблицы.Предопределенные Цикл
					Для Каждого Источник Из ОписаниеПредопределенного.Значение.Источники Цикл
						СоставИмени = СтрРазделить(Источник.Символы, ".");
						
						УстановитьОшибкуВСтроке(Источник, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
								НСтр("ru = 'Предопределенное значение не найдено, так как не найдена таблица ""%1""'"),
								СоставИмени[0] + "." + СоставИмени[1]), , 2);
					КонецЦикла;
				КонецЦикла;
				Продолжить;
			КонецЕсли;
			
			Для Каждого ОписаниеПредопределенного Из СвойстваТаблицы.Предопределенные Цикл
				СвойстваПредопределенного = ОписаниеПредопределенного.Значение;
				Если СвойстваПредопределенного.ИмяСуществует Тогда
					Продолжить;
				КонецЕсли;
				Для Каждого Источник Из СвойстваПредопределенного.Источники Цикл
					СоставИмени = СтрРазделить(Источник.Символы, ".");
					Источник.ПозицияОшибки = СтрДлина(СоставИмени[0] + "." + СоставИмени[1]) + 1;
					Источник.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Не найдено предопределенное значение ""%1""'"), СоставИмени[2]);
				КонецЦикла;
			КонецЦикла;
			
			Для Каждого ОписаниеПоля Из СвойстваТаблицы.Поля Цикл
				ОтметитьНекорректноеПолеИТипыПоля(ОписаниеПоля, Контекст);
			КонецЦикла;
			
			Для Каждого ОписаниеРасширения Из СвойстваТаблицы.Расширения Цикл
				СвойстваРасширения = ОписаниеРасширения.Значение;
				Если Не СвойстваРасширения.ТаблицаСуществует Тогда
					Для Каждого Источник Из СвойстваРасширения.Источники Цикл
						УстановитьОшибкуВСтроке(Источник,
							СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
								НСтр("ru = 'Не найдена таблица ""%1""'"), Источник.Символы), , 2);
					КонецЦикла;
					Если СвойстваРасширения.Свойство("ПервоеПоле")
					   И СвойстваРасширения.ПервоеПоле.ПервыйИсточник <> Неопределено Тогда
						
						УстановитьОшибкуВСтрокеИмениПоля(Контекст, СвойстваРасширения.ПервоеПоле.ПервыйИсточник.Ключ,
							НСтр("ru = 'Поле не найдено, так как не найдена таблица ""%1""'"), 0, ,
							СвойстваРасширения.ПервоеПоле.ПервыйИсточник.Значение);
					КонецЕсли;
					Продолжить;
				КонецЕсли;
				Для Каждого ОписаниеПоля Из СвойстваРасширения.Поля Цикл
					ОтметитьНекорректноеПолеИТипыПоля(ОписаниеПоля, Контекст);
				КонецЦикла;
			КонецЦикла;
			
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ОтметитьНекорректныеИменаТаблицПолейИТиповПолей.
Процедура ОтметитьНекорректноеПолеИТипыПоля(ОписаниеПоля, Контекст)
	
	СвойстваПоля = ОписаниеПоля.Значение;
	Если СвойстваПоля.ПолеСОшибкой = 1 Тогда
		Для Каждого ОписаниеИсточника Из ОписаниеПоля.Значение.Источники Цикл
			ВКонце = Ложь;
			Если СвойстваПоля.ВидОшибки = "ТабличнаяЧастьБезПоля" Тогда
				ВКонце = Истина;
				ШаблонОшибки = НСтр("ru = 'Не указано поле после табличной части ""%1"" таблицы ""%2""'");
				
			ИначеЕсли СвойстваПоля.ВидОшибки = "ТабличнаяЧастьДополнительнойТаблицы" Тогда
				ШаблонОшибки = НСтр("ru = 'Табличная часть ""%1"" не поддерживается для дополнительной таблицы ""%2""'");
				
			ИначеЕсли СвойстваПоля.ВидОшибки = "Недопустимо" Тогда
				ШаблонОшибки = НСтр("ru = 'Недопустимо использовать поле ""%1"" таблицы ""%2""'");
				
			ИначеЕсли СвойстваПоля.ВидОшибки = "Запрещено" Тогда
				ШаблонОшибки = НСтр("ru = 'Запрещено использовать поле ""%1"" таблицы ""%2""'");
			Иначе
				ШаблонОшибки = НСтр("ru = 'Не найдено поле ""%1"" таблицы ""%2""'");
			КонецЕсли;
			УстановитьОшибкуВСтрокеИмениПоля(Контекст,
				 ОписаниеИсточника.Ключ, ШаблонОшибки, 1, Истина, ОписаниеИсточника.Значение, ВКонце);
		КонецЦикла;
		Возврат;
	КонецЕсли;
	
	Если СвойстваПоля.ПолеСОшибкой > 1 Тогда
		Для Каждого ОписаниеИсточника Из ОписаниеПоля.Значение.Источники Цикл
			Если СвойстваПоля.ВидОшибки = "ТабличнаяЧастьПослеТочки" Тогда
				ШаблонОшибки = НСтр("ru = 'Табличная часть ""%1"" не поддерживается ""через точку"" от поля'");
				
			ИначеЕсли СвойстваПоля.ВидОшибки = "Недопустимо" Тогда
				ШаблонОшибки = НСтр("ru = 'Недопустимо использовать поле ""%1""'");
				
			ИначеЕсли СвойстваПоля.ВидОшибки = "Запрещено" Тогда
				ШаблонОшибки = НСтр("ru = 'Запрещено использовать поле ""%1""'");
			Иначе
				ШаблонОшибки = НСтр("ru = 'Не найдено поле ""%1""'");
			КонецЕсли;
			УстановитьОшибкуВСтрокеИмениПоля(Контекст,
				ОписаниеИсточника.Ключ, ШаблонОшибки, СвойстваПоля.ПолеСОшибкой, Истина);
		КонецЦикла;
		Возврат;
	КонецЕсли;
	
	СоставИмени = СтрРазделить(ОписаниеПоля.Ключ, ".");
	Если СоставИмени.Количество() > 1
	   И (    СоставИмени[1] = ВРег("Ссылка")
	      Или СоставИмени[1] = ВРег("Ref") )
	   И СвойстваПоля.Коллекция <> "ТабличныеЧасти"
	   И СвойстваПоля.Коллекция <> "СтандартныеТабличныеЧасти" Тогда
		
			Для Каждого ОписаниеИсточника Из ОписаниеПоля.Значение.Источники Цикл
				ШаблонОшибки = НСтр("ru = 'Поле ""%1"" избыточно указывать ""через точку"" от любого поля'");
				УстановитьОшибкуВСтрокеИмениПоля(Контекст,
					ОписаниеИсточника.Ключ, ШаблонОшибки, 2, Истина);
		КонецЦикла;
		Возврат;
	КонецЕсли;
	
	Для Каждого ОписаниеТипа Из СвойстваПоля.СодержитТипы Цикл
		СвойстваТипа = ОписаниеТипа.Значение;
		Для Каждого ОписаниеИсточника Из ОписаниеТипа.Значение.Источники Цикл
			Если ТипЗнч(ОписаниеИсточника.Ключ) = Тип("СтрокаТаблицыЗначений") Тогда
				Если Не СвойстваТипа.СодержитТип Тогда
					УстановитьОшибкуВСтроке(ОписаниеИсточника.Ключ,
						СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
							НСтр("ru = 'У поля ""%1"" не найден тип ""%2""'"),
							ОписаниеИсточника.Значение.Символы,
							ОписаниеИсточника.Ключ.Символы),
						, 2);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ОтметитьНекорректныеИменаТаблицПолейИТиповПолей.
Процедура УстановитьОшибкуВСтрокеИмениПоля(Контекст, Строка, ШаблонОшибки, ПолеСОшибкой,
			ВставитьИмя = Ложь, Таблица = Null, ВКонце = Ложь)
	
	Если ЗначениеЗаполнено(Строка.ТекстОшибки) Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(ВставитьИмя) = Тип("Строка") Тогда
		СоставИмени = СтрРазделить(ВставитьИмя, ".");
		ВставитьИмя = Истина;
	Иначе
		СоставИмени = СтрРазделить(Строка.Символы, ".");
	КонецЕсли;
	
	Если СоставИмени.Количество() > 1
	   И Контекст.Псевдонимы.Получить(ВРег(СоставИмени[0])) <> Неопределено Тогда
		
		Строка.ПозицияОшибки = СтрДлина(СоставИмени[0]) + 1;
		СоставИмени.Удалить(0);
	КонецЕсли;
	
	Для Номер = 1 По ПолеСОшибкой - 1 Цикл
		Строка.ПозицияОшибки = Строка.ПозицияОшибки + СтрДлина(СоставИмени[0]) + 1;
		СоставИмени.Удалить(0);
	КонецЦикла;
	Если ВКонце Тогда
		Строка.ПозицияОшибки = Строка.ПозицияОшибки + СтрДлина(СоставИмени[0]);
	КонецЕсли;
	ИмяПоля = СоставИмени[0];
	
	Если ВставитьИмя И Таблица <> Null Тогда
		Строка.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонОшибки,
			ИмяПоля, ?(ЗначениеЗаполнено(Таблица), Таблица, Контекст.ОсновнаяТаблица));
			
	ИначеЕсли ВставитьИмя Тогда
		Строка.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонОшибки, ИмяПоля);
		
	ИначеЕсли Таблица <> Null Тогда
		Строка.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонОшибки,
			?(ЗначениеЗаполнено(Таблица), Таблица, Контекст.ОсновнаяТаблица));
	Иначе
		Строка.ТекстОшибки = ШаблонОшибки;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область ОбновлениеПрогрессаОбновленияДоступа

Процедура ОбновитьПрогрессВФоне(Контекст, АдресРезультата) Экспорт
	
	Попытка
		ОбновитьПрогресс(Контекст);
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Контекст.Вставить("ТекстОшибки", ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
	КонецПопытки;
	
	ПоместитьВоВременноеХранилище(Контекст, АдресРезультата);
	
КонецПроцедуры

Процедура ОбновитьПрогресс(Контекст)
	
	ДатаНачалаОбновленияПрогресса = ТекущаяДатаСеанса();
	ДлительныеОперации.СообщитьПрогресс(0); // Обновление прогресса выполняется.
	
	СтрокиСписков   = Контекст.ХранимыеДанные.СтрокиСписков;
	СвойстваСписков = Контекст.ХранимыеДанные.СвойстваСписков;
	Если Не Контекст.ЭтоПовторноеОбновлениеПрогресса Тогда
		Контекст.ХранимыеДанные.ДатаПоследнегоОбновления = '00010101';
	КонецЕсли;
	
	ДействующиеПараметры = Неопределено;
	ИдентификаторыТаблиц = ИдентификаторыСписковСОграничением(ДействующиеПараметры);
	
	Для Каждого КлючИЗначение Из ИдентификаторыТаблиц Цикл
		Если Не Контекст.ПоказыватьОбработанныеСписки Тогда
			Продолжить;
		КонецЕсли;
		Если СтрокиСписков.Получить(КлючИЗначение.Значение) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ДобавитьНовуюСтрокуСписка(Контекст, КлючИЗначение.Значение, КлючИЗначение.Ключ);
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("МаксимальнаяДата", МаксимальнаяДатаПриПродолжении());
	Запрос.УстановитьПараметр("ДатаПоследнегоОбновления", Контекст.ХранимыеДанные.ДатаПоследнегоОбновления);
	Запрос.УстановитьПараметр("ПустойУникальныйИдентификатор",
		ОбщегоНазначенияКлиентСервер.ПустойУникальныйИдентификатор());
	
	Контекст.ХранимыеДанные.ДатаПоследнегоОбновления = ДатаНачалаОбновленияПрогресса;
	
	ТекстыЗапросов = Новый Массив;
	ТекстыЗапросов.Добавить(
	"ВЫБРАТЬ
	|	ВсеСпискиОбновления.Список КАК Список,
	|	МАКСИМУМ(ВсеСпискиОбновления.ОбновлениеЭлементов) КАК ОбновлениеЭлементов,
	|	МАКСИМУМ(ВсеСпискиОбновления.ОбновлениеКлючейДоступа) КАК ОбновлениеКлючейДоступа
	|ИЗ
	|	(ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		ОбновлениеКлючейДоступаКДанным.Список КАК Список,
	|		ИСТИНА КАК ОбновлениеЭлементов,
	|		ЛОЖЬ КАК ОбновлениеКлючейДоступа
	|	ИЗ
	|		РегистрСведений.ОбновлениеКлючейДоступаКДанным КАК ОбновлениеКлючейДоступаКДанным
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		ОбновлениеКлючейДоступаПользователей.Список,
	|		ЛОЖЬ,
	|		ИСТИНА
	|	ИЗ
	|		РегистрСведений.ОбновлениеКлючейДоступаПользователей КАК ОбновлениеКлючейДоступаПользователей) КАК ВсеСпискиОбновления
	|
	|СГРУППИРОВАТЬ ПО
	|	ВсеСпискиОбновления.Список");
	
	ТекстыЗапросов.Добавить(
	"ВЫБРАТЬ
	|	ОбновлениеКлючей.Список КАК Список,
	|	ОбновлениеКлючей.ДляВнешнихПользователей КАК ДляВнешнихПользователей,
	|	ОбновлениеКлючей.КлючУникальности = &ПустойУникальныйИдентификатор КАК ЭтоОсновнаяЗапись,
	|	МАКСИМУМ(ОбновлениеКлючей.РазмерЗадания) КАК РазмерЗадания,
	|	МАКСИМУМ(ОбновлениеКлючей.ДатаИзмененияЗаписиРегистра) КАК МаксимальнаяДатаИзменения,
	|	МИНИМУМ(ОбновлениеКлючей.ДатаИзмененияЗаписиРегистра) КАК МинимальнаяДатаИзменения
	|ИЗ
	|	РегистрСведений.ОбновлениеКлючейДоступаКДанным КАК ОбновлениеКлючей
	|ГДЕ
	|	ОбновлениеКлючей.ДатаИзмененияЗаписиРегистра >= &ДатаПоследнегоОбновления
	|	И ОбновлениеКлючей.Список <> НЕОПРЕДЕЛЕНО
	|
	|СГРУППИРОВАТЬ ПО
	|	ОбновлениеКлючей.Список,
	|	ОбновлениеКлючей.ДляВнешнихПользователей,
	|	ОбновлениеКлючей.КлючУникальности = &ПустойУникальныйИдентификатор
	|ИТОГИ ПО
	|	Список,
	|	ДляВнешнихПользователей");
	
	ТекстыЗапросов.Добавить(СтрЗаменить(ТекстыЗапросов[1],
		"РегистрСведений.ОбновлениеКлючейДоступаКДанным",
		"РегистрСведений.ОбновлениеКлючейДоступаПользователей"));
	
	Если Контекст.РассчитыватьПоКоличествуДанных Тогда
		ТекстыЗапросов.Добавить(
		"ВЫБРАТЬ
		|	ОбновлениеКлючей.Список КАК Список,
		|	ОбновлениеКлючей.ДляВнешнихПользователей КАК ДляВнешнихПользователей,
		|	ОбновлениеКлючей.ПараметрыЗадания КАК ПараметрыЗадания
		|ИЗ
		|	РегистрСведений.ОбновлениеКлючейДоступаКДанным КАК ОбновлениеКлючей
		|ГДЕ
		|	ОбновлениеКлючей.ДатаИзмененияЗаписиРегистра >= &ДатаПоследнегоОбновления
		|	И ОбновлениеКлючей.КлючУникальности = &ПустойУникальныйИдентификатор
		|	И ОбновлениеКлючей.Список <> НЕОПРЕДЕЛЕНО
		|ИТОГИ ПО
		|	Список");
		
		ТекстыЗапросов.Добавить(СтрЗаменить(ТекстыЗапросов[3],
			"РегистрСведений.ОбновлениеКлючейДоступаКДанным",
			"РегистрСведений.ОбновлениеКлючейДоступаПользователей"));
		
		ТекстыЗапросов.Добавить(
		"ВЫБРАТЬ
		|	КОЛИЧЕСТВО(*) КАК Количество
		|ИЗ
		|	Справочник.КлючиДоступа КАК КлючиДоступа");
	КонецЕсли;
	
	Запрос.Текст = СтрСоединить(ТекстыЗапросов, ОбщегоНазначения.РазделительПакетаЗапросов());
	РезультатыЗапроса = Запрос.ВыполнитьПакет();
	
	ВсеСпискиОбновления = РезультатыЗапроса[0].Выгрузить();
	СтрокиОбновленияКоличестваЭлементов = Новый Массив;
	СтрокиОбновленияКоличестваКлючейДоступа = Новый Массив;
	
	Для Каждого СписокОбновления Из ВсеСпискиОбновления Цикл
		Если Не ЗначениеЗаполнено(СписокОбновления.Список) Тогда
			Продолжить;
		КонецЕсли;
		Строка = СтрокиСписков.Получить(СписокОбновления.Список);
		Если Строка = Неопределено Тогда
			ДобавитьНовуюСтрокуСписка(Контекст, СписокОбновления.Список, "");
		КонецЕсли;
	КонецЦикла;
	
	УдаляемыеСтроки = Новый Массив;
	Для Каждого КлючИЗначение Из СтрокиСписков Цикл
		Строка = КлючИЗначение.Значение;
		СписокОбновления = ВсеСпискиОбновления.Найти(Строка.Список, "Список");
		Если СписокОбновления = Неопределено И Не Контекст.ПоказыватьОбработанныеСписки Тогда
			УдаляемыеСтроки.Добавить(Строка);
			Продолжить;
		КонецЕсли;
		СвойстваСписка = СвойстваСписков.Получить(Строка.Список);
		Если СписокОбновления = Неопределено Или Не СписокОбновления.ОбновлениеЭлементов Тогда
			СвойстваСписка.РазмерЗаданияОбновленияЭлементов = 0;
			СвойстваСписка.ПоследнийОбновленныйЭлемент = Null;
			СвойстваСписка.РазмерЗаданияОбновленияЭлементовДляВнешнихПользователей = 0;
			СвойстваСписка.ПоследнийОбновленныйЭлементДляВнешнихПользователей = Null;
			Строка.ДоляОбработанныхЭлементовДляПользователей = 1;
			Строка.ДоляОбработанныхЭлементовДляВнешнихПользователей = 1;
			Если Контекст.РассчитыватьПоКоличествуДанных Тогда
				Если Строка.ОбработаноЭлементов <> 100 Тогда
					СтрокиОбновленияКоличестваЭлементов.Добавить(Строка);
				КонецЕсли;
			Иначе
				ОбнулитьКоличествоЭлементов(Строка, Контекст);
			КонецЕсли;
			ОбновитьЗначениеВСтроке(Строка.ОбработаноЭлементов, 100, Строка, Контекст);
		КонецЕсли;
		Если СписокОбновления = Неопределено Или Не СписокОбновления.ОбновлениеКлючейДоступа Тогда
			СвойстваСписка.РазмерЗаданияОбновленияКлючейДоступа = 0;
			СвойстваСписка.ПоследнийОбновленныйКлючДоступа = Null;
			СвойстваСписка.РазмерЗаданияОбновленияКлючейДоступаДляВнешнихПользователей = 0;
			СвойстваСписка.ПоследнийОбновленныйКлючДоступаДляВнешнихПользователей = Null;
			Строка.ДоляОбработанныхКлючейДоступаДляПользователей = 1;
			Строка.ДоляОбработанныхКлючейДоступаДляВнешнихПользователей = 1;
			Если Контекст.РассчитыватьПоКоличествуДанных Тогда
				Если Строка.ОбработаноКлючейДоступа <> 100 Тогда
					СтрокиОбновленияКоличестваКлючейДоступа.Добавить(Строка);
				КонецЕсли;
			Иначе
				ОбнулитьКоличествоКлючейДоступа(Строка, Контекст);
			КонецЕсли;
			ОбновитьЗначениеВСтроке(Строка.ОбработаноКлючейДоступа, 100, Строка, Контекст);
		КонецЕсли;
		Если СписокОбновления = Неопределено Тогда
			ОбновитьЗначениеВСтроке(Строка.ПоследнееОбновление, '00010101', Строка, Контекст);
			ОбновитьЗначениеВСтроке(Строка.ПервоеПланированиеОбновления, МаксимальнаяДата(), Строка, Контекст);
		КонецЕсли;
	КонецЦикла;
	
	Если Контекст.РассчитыватьПоКоличествуДанных Тогда
		ВыборкаПоСпискам = РезультатыЗапроса[3].Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
		Пока ВыборкаПоСпискам.Следующий() Цикл
			СвойстваСписка = СвойстваСписков.Получить(ВыборкаПоСпискам.Список);
			Если СвойстваСписка = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			ВыборкаПоВидамПользователей = ВыборкаПоСпискам.Выбрать();
			Пока ВыборкаПоВидамПользователей.Следующий() Цикл
				Если ВыборкаПоВидамПользователей.ДляВнешнихПользователей Тогда
					СвойстваСписка.ПоследнийОбновленныйЭлементДляВнешнихПользователей
						= ВыборкаПоВидамПользователей.ПараметрыЗадания;
				Иначе
					СвойстваСписка.ПоследнийОбновленныйЭлемент
						= ВыборкаПоВидамПользователей.ПараметрыЗадания;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
		ВыборкаПоСпискам = РезультатыЗапроса[4].Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
		Пока ВыборкаПоСпискам.Следующий() Цикл
			СвойстваСписка = СвойстваСписков.Получить(ВыборкаПоСпискам.Список);
			Если СвойстваСписка = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			ВыборкаПоВидамПользователей = ВыборкаПоСпискам.Выбрать();
			Пока ВыборкаПоВидамПользователей.Следующий() Цикл
				Если ВыборкаПоВидамПользователей.ДляВнешнихПользователей Тогда
					СвойстваСписка.ПоследнийОбновленныйКлючДоступаДляВнешнихПользователей
						= ВыборкаПоВидамПользователей.ПараметрыЗадания;
				Иначе
					СвойстваСписка.ПоследнийОбновленныйКлючДоступа
						= ВыборкаПоВидамПользователей.ПараметрыЗадания;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	
	СпискиОбновленияЭлементов = РезультатыЗапроса[1].Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкам);
	ОбъектыМетаданныхПоИдентификаторам = ОбщегоНазначения.ОбъектыМетаданныхПоИдентификаторам(
		СпискиОбновленияЭлементов.Строки.ВыгрузитьКолонку("Список"), Ложь);
	
	Для Каждого ОписаниеОбновления Из СпискиОбновленияЭлементов.Строки Цикл
		Строка = СтрокиСписков.Получить(ОписаниеОбновления.Список);
		Если Строка = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ОбъектМетаданных = ОбъектыМетаданныхПоИдентификаторам.Получить(ОписаниеОбновления.Список);
		Если ОбъектМетаданных = Неопределено Или Не ЗначениеЗаполнено(Строка.Список) Тогда
			Если УдаляемыеСтроки.Найти(Строка) = Неопределено Тогда
				УдаляемыеСтроки.Добавить(Строка);
			КонецЕсли;
			Продолжить;
		ИначеЕсли ТипЗнч(ОбъектМетаданных) = Тип("ОбъектМетаданных")
		        И Не ЗначениеЗаполнено(Строка.ИмяТаблицы) Тогда
			Строка.ИмяТаблицы = ОбъектМетаданных.ПолноеИмя();
		КонецЕсли;
		СвойстваСписка = СвойстваСписков.Получить(Строка.Список);
		ЗаполнитьДолиОбработанных(Строка, ОписаниеОбновления, СвойстваСписка, Истина, Контекст);
		Если Не Контекст.РассчитыватьПоКоличествуДанных Тогда
			Обработано = ОбработаноПоДолям(Строка.ДоляОбработанныхЭлементовДляПользователей,
				Строка.ДоляОбработанныхЭлементовДляВнешнихПользователей, Строка.ИмяТаблицы, ДействующиеПараметры);
			ОбновитьЗначениеВСтроке(Строка.ОбработаноЭлементов, Обработано, Строка, Контекст);
			ОбнулитьКоличествоЭлементов(Строка, Контекст);
		Иначе
			Если Контекст.ЭтоПовторноеОбновлениеПрогресса Тогда
				СтрокиОбновленияКоличестваЭлементов.Добавить(Строка);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	СпискиОбновленияКлючейДоступа = РезультатыЗапроса[2].Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкам);
	ОбъектыМетаданныхПоИдентификаторам = ОбщегоНазначения.ОбъектыМетаданныхПоИдентификаторам(
		СпискиОбновленияКлючейДоступа.Строки.ВыгрузитьКолонку("Список"), Ложь);
	
	Для Каждого ОписаниеОбновления Из СпискиОбновленияКлючейДоступа.Строки Цикл
		ОбъектМетаданных = ОбъектыМетаданныхПоИдентификаторам.Получить(ОписаниеОбновления.Список);
		Строка = СтрокиСписков.Получить(ОписаниеОбновления.Список);
		Если Строка = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если ОбъектМетаданных = Неопределено Или Не ЗначениеЗаполнено(Строка.Список) Тогда
			Если УдаляемыеСтроки.Найти(Строка) = Неопределено Тогда
				УдаляемыеСтроки.Добавить(Строка);
			КонецЕсли;
			Продолжить;
		ИначеЕсли ТипЗнч(ОбъектМетаданных) = Тип("ОбъектМетаданных")
		        И Не ЗначениеЗаполнено(Строка.ИмяТаблицы) Тогда
			Строка.ИмяТаблицы = ОбъектМетаданных.ПолноеИмя();
		КонецЕсли;
		СвойстваСписка = СвойстваСписков.Получить(Строка.Список);
		ЗаполнитьДолиОбработанных(Строка, ОписаниеОбновления, СвойстваСписка, Ложь, Контекст);
		Если Не Контекст.РассчитыватьПоКоличествуДанных Тогда
			Обработано = ОбработаноПоДолям(Строка.ДоляОбработанныхКлючейДоступаДляПользователей,
				Строка.ДоляОбработанныхКлючейДоступаДляВнешнихПользователей, Строка.ИмяТаблицы, ДействующиеПараметры);
			ОбновитьЗначениеВСтроке(Строка.ОбработаноКлючейДоступа, Обработано, Строка, Контекст);
			ОбнулитьКоличествоКлючейДоступа(Строка, Контекст);
		Иначе
			Если Контекст.ЭтоПовторноеОбновлениеПрогресса Тогда
				СтрокиОбновленияКоличестваКлючейДоступа.Добавить(Строка);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого УдаляемаяСтрока Из УдаляемыеСтроки Цикл
		СтрокиСписков.Удалить(УдаляемаяСтрока.Список);
		СвойстваСписков.Удалить(УдаляемаяСтрока.Список);
		Индекс = Контекст.ДобавленныеСтроки.Найти(УдаляемаяСтрока);
		Если Индекс <> Неопределено Тогда
			Контекст.ДобавленныеСтроки.Удалить(Индекс);
			Продолжить;
		КонецЕсли;
		Контекст.УдаленныеСтроки.Вставить(УдаляемаяСтрока.Список, Истина);
	КонецЦикла;
	
	Индекс = Контекст.ДобавленныеСтроки.Количество() - 1;
	Пока Индекс >= 0 Цикл
		Если Не ЗначениеЗаполнено(Контекст.ДобавленныеСтроки[Индекс].ИмяТаблицы) Тогда
			Контекст.ДобавленныеСтроки.Удалить(Индекс);
		КонецЕсли;
		Индекс = Индекс - 1;
	КонецЦикла;
	
	Если Не Контекст.ЭтоПовторноеОбновлениеПрогресса Тогда
		Для Каждого ОписаниеСтроки Из СтрокиСписков Цикл
			СтрокиОбновленияКоличестваЭлементов.Добавить(ОписаниеСтроки.Значение);
			СтрокиОбновленияКоличестваКлючейДоступа.Добавить(ОписаниеСтроки.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Если Контекст.РассчитыватьПоКоличествуДанных Тогда
		КоличествоКлючей = РезультатыЗапроса[5].Выгрузить()[0].Количество;
		Если Контекст.ЭтоПовторноеОбновлениеПрогресса
		   И Контекст.ХранимыеДанные.КоличествоКлючей <> КоличествоКлючей Тогда
			
			Для Каждого ОписаниеСтроки Из СтрокиСписков Цикл
				Если СтрокиОбновленияКоличестваКлючейДоступа.Найти(ОписаниеСтроки.Значение) = Неопределено Тогда
					СтрокиОбновленияКоличестваКлючейДоступа.Добавить(ОписаниеСтроки.Значение);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Контекст.ХранимыеДанные.КоличествоКлючей = КоличествоКлючей;
	Иначе
		Контекст.ХранимыеДанные.КоличествоКлючей = 0;
	КонецЕсли;
	
	Если Контекст.РассчитыватьПоКоличествуДанных Тогда
		ТекущийКонтекст = Новый Структура;
		ТекущийКонтекст.Вставить("ДобавленныеСтроки",                       Контекст.ДобавленныеСтроки);
		ТекущийКонтекст.Вставить("ИзмененныеСтроки",                        Контекст.ИзмененныеСтроки);
		ТекущийКонтекст.Вставить("СвойстваСписков",                         СвойстваСписков);
		ТекущийКонтекст.Вставить("СтрокиСписков",                           СтрокиСписков);
		ТекущийКонтекст.Вставить("ДействующиеПараметры",                    ДействующиеПараметры);
		ТекущийКонтекст.Вставить("СтрокиОбновленияКоличестваЭлементов",     СтрокиОбновленияКоличестваЭлементов);
		ТекущийКонтекст.Вставить("СтрокиОбновленияКоличестваКлючейДоступа", СтрокиОбновленияКоличестваКлючейДоступа);
		ТекущийКонтекст.Вставить("ИдентификаторыТаблиц",                    ИдентификаторыТаблиц);
		ТекущийКонтекст.Вставить("ХранимыеДанные",                          Контекст.ХранимыеДанные);
		ВсегоОбновлено = 100;
		РассчитатьВсегоОбновленоПоКоличествуДанных(ТекущийКонтекст, ВсегоОбновлено);
	Иначе
		Если Контекст.ХранимыеДанные.Свойство("КоличествоЭлементовПоСпискам") Тогда
			Контекст.ХранимыеДанные.Удалить("КоличествоЭлементовПоСпискам");
			Контекст.ХранимыеДанные.Удалить("КоличествоКлючейДоступаПоСпискам");
		КонецЕсли;
		ВсегоКоличество = ИдентификаторыТаблиц.Количество();
		Если СтрокиСписков.Количество() > ВсегоКоличество Тогда
			ВсегоКоличество = СтрокиСписков.Количество();
		КонецЕсли;
		ВсегоОбновлено = (100 + 100) * (ВсегоКоличество - СтрокиСписков.Количество());
		Для Каждого КлючИЗначение Из СтрокиСписков Цикл
			Строка = КлючИЗначение.Значение;
			ВсегоОбновлено = ВсегоОбновлено + Строка.ОбработаноЭлементов + Строка.ОбработаноКлючейДоступа;
		КонецЦикла;
		ВсегоОбновлено = ВсегоОбновлено / 2 / ВсегоКоличество;
	КонецЕсли;
	Если ВсегоОбновлено > 100 Тогда
		ВсегоОбновлено = 100;
	КонецЕсли;
	Контекст.ВсегоОбновлено = Цел(ВсегоОбновлено);
	
	ВремяОбновления = ТекущаяДатаСеанса() - ДатаНачалаОбновленияПрогресса;
	
	Если Контекст.ЭтоПовторноеОбновлениеПрогресса
	   И ВремяОбновления > Контекст.ПериодОбновленияПрогресса Тогда
		
		Контекст.ПериодОбновленияПрогресса = ВремяОбновления;
	Иначе
		Контекст.Удалить("ПериодОбновленияПрогресса");
	КонецЕсли;
	
	Если Не Контекст.ЭтоПовторноеОбновлениеПрогресса И ВремяОбновления > 60 Тогда
		Контекст.АвтообновлениеПрогресса = Ложь;
	Иначе
		Контекст.Удалить("АвтообновлениеПрогресса");
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаполнитьДолиОбработанных(Строка, ОписаниеОбновления, СвойстваСписка, ЭтоОбработкаЭлементов, Контекст)
	
	Для Каждого СвойстваОбновления Из ОписаниеОбновления.Строки Цикл
		Если ЭтоОбработкаЭлементов Тогда
			Если СвойстваОбновления.ДляВнешнихПользователей Тогда
				ИмяПоляРазмераЗадания    = "РазмерЗаданияОбновленияЭлементовДляВнешнихПользователей";
				ИмяПоляПараметровЗадания = "ПоследнийОбновленныйЭлементДляВнешнихПользователей";
				ИмяПоляДоли              = "ДоляОбработанныхЭлементовДляВнешнихПользователей";
			Иначе
				ИмяПоляРазмераЗадания    = "РазмерЗаданияОбновленияЭлементов";
				ИмяПоляПараметровЗадания = "ПоследнийОбновленныйЭлемент";
				ИмяПоляДоли              = "ДоляОбработанныхЭлементовДляПользователей";
			КонецЕсли;
		Иначе
			Если СвойстваОбновления.ДляВнешнихПользователей Тогда
				ИмяПоляРазмераЗадания    = "РазмерЗаданияОбновленияКлючейДоступаДляВнешнихПользователей";
				ИмяПоляПараметровЗадания = "ПоследнийОбновленныйКлючДоступаДляВнешнихПользователей";
				ИмяПоляДоли              = "ДоляОбработанныхКлючейДоступаДляВнешнихПользователей";
			Иначе
				ИмяПоляРазмераЗадания    = "РазмерЗаданияОбновленияКлючейДоступа";
				ИмяПоляПараметровЗадания = "ПоследнийОбновленныйКлючДоступа";
				ИмяПоляДоли              = "ДоляОбработанныхКлючейДоступаДляПользователей";
			КонецЕсли;
		КонецЕсли;
		РазмерЗаданияОсновнаяЗапись = СвойстваСписка[ИмяПоляРазмераЗадания];
		РазмерЗаданияНовыеЗаписи = 0;
		Для Каждого СвойстваЗадания Из СвойстваОбновления.Строки Цикл
			Если СвойстваЗадания.ЭтоОсновнаяЗапись Тогда
				Если СвойстваЗадания.МаксимальнаяДатаИзменения > Строка.ПоследнееОбновление Тогда
					ОбновитьЗначениеВСтроке(Строка.ПоследнееОбновление,
						СвойстваЗадания.МаксимальнаяДатаИзменения, Строка, Контекст);
				КонецЕсли;
				РазмерЗаданияОсновнаяЗапись = СвойстваЗадания.РазмерЗадания;
			Иначе
				Если СвойстваЗадания.МинимальнаяДатаИзменения < Строка.ПервоеПланированиеОбновления Тогда
					ОбновитьЗначениеВСтроке(Строка.ПервоеПланированиеОбновления,
						СвойстваЗадания.МинимальнаяДатаИзменения, Строка, Контекст);
				КонецЕсли;
				РазмерЗаданияНовыеЗаписи = СвойстваЗадания.РазмерЗадания;
			КонецЕсли;
		КонецЦикла;
		СвойстваСписка[ИмяПоляРазмераЗадания] = РазмерЗаданияОсновнаяЗапись;
		Если РазмерЗаданияНовыеЗаписи >= РазмерЗаданияОсновнаяЗапись Тогда
			СвойстваСписка[ИмяПоляПараметровЗадания] = Истина;
			ТекущийРазмерЗадания = РазмерЗаданияНовыеЗаписи;
		Иначе
			ТекущийРазмерЗадания = РазмерЗаданияОсновнаяЗапись;
		КонецЕсли;
		Если ТекущийРазмерЗадания = 1 Тогда
			Строка[ИмяПоляДоли] = 0.99;
		ИначеЕсли ТекущийРазмерЗадания = 2 Тогда
			Строка[ИмяПоляДоли] = 0.90;
		Иначе
			Строка[ИмяПоляДоли] = 0.00;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция ОбработаноПоДолям(ДоляОбработанныхДляПользователей, ДоляОбработанныхДляВнешнихПользователей, ИмяТаблицы, ДействующиеПараметры)
	
	ЕстьКлючиДляПользователей = Ложь;
	ЕстьКлючиДляВнешнихПользователей = Ложь;
	Версии = ДействующиеПараметры.ВерсииОграниченийСписков.Получить(ИмяТаблицы);
	Если ЗначениеЗаполнено(Версии) Тогда
		ЕстьКлючиДляПользователей        = ЗначениеЗаполнено(СтрПолучитьСтроку(Версии, 1));
		ЕстьКлючиДляВнешнихПользователей = ЗначениеЗаполнено(СтрПолучитьСтроку(Версии, 2));
	КонецЕсли;
	
	Если ДоляОбработанныхДляПользователей < 1 Тогда
		ЕстьКлючиДляПользователей = Истина;
	КонецЕсли;
	Если ДоляОбработанныхДляВнешнихПользователей < 1 Тогда
		ЕстьКлючиДляВнешнихПользователей = Истина;
	КонецЕсли;
	
	Если ЕстьКлючиДляПользователей И ЕстьКлючиДляВнешнихПользователей Тогда
		Обработано = Цел((ДоляОбработанныхДляПользователей
					+ ДоляОбработанныхДляВнешнихПользователей) / 2 * 100);
		
	ИначеЕсли ЕстьКлючиДляПользователей Тогда
		Обработано = Цел(ДоляОбработанныхДляПользователей * 100);
	Иначе
		Обработано = Цел(ДоляОбработанныхДляВнешнихПользователей * 100);
	КонецЕсли;
	
	Возврат Обработано;
	
КонецФункции

Процедура ОбнулитьКоличествоЭлементов(Строка, Контекст);
	
	ОбновитьЗначениеВСтроке(Строка.КоличествоЭлементов, 0, Строка, Контекст);
	ОбновитьЗначениеВСтроке(Строка.КоличествоОбработанныхЭлементов, 0, Строка, Контекст);
	ОбновитьЗначениеВСтроке(Строка.КоличествоЭлементовДляПользователей, 0, Строка, Контекст);
	ОбновитьЗначениеВСтроке(Строка.КоличествоЭлементовДляВнешнихПользователей, 0, Строка, Контекст);
	ОбновитьЗначениеВСтроке(Строка.КоличествоОставшихсяЭлементовДляПользователей, 0, Строка, Контекст);
	ОбновитьЗначениеВСтроке(Строка.ДоляОставшихсяЭлементовДляПользователей, 0, Строка, Контекст);
	ОбновитьЗначениеВСтроке(Строка.КоличествоОставшихсяЭлементовДляВнешнихПользователей, 0, Строка, Контекст);
	ОбновитьЗначениеВСтроке(Строка.ДоляОставшихсяЭлементовДляВнешнихПользователей, 0, Строка, Контекст);
	
КонецПроцедуры

Процедура ОбнулитьКоличествоКлючейДоступа(Строка, Контекст);
	
	ОбновитьЗначениеВСтроке(Строка.КоличествоКлючейДоступа, 0, Строка, Контекст);
	ОбновитьЗначениеВСтроке(Строка.КоличествоОбработанныхКлючейДоступа, 0, Строка, Контекст);
	ОбновитьЗначениеВСтроке(Строка.КоличествоКлючейДоступаДляПользователей, 0, Строка, Контекст);
	ОбновитьЗначениеВСтроке(Строка.КоличествоКлючейДоступаДляВнешнихПользователей, 0, Строка, Контекст);
	ОбновитьЗначениеВСтроке(Строка.КоличествоОставшихсяКлючейДоступаДляПользователей, 0, Строка, Контекст);
	ОбновитьЗначениеВСтроке(Строка.ДоляОставшихсяКлючейДоступаДляПользователей, 0, Строка, Контекст);
	ОбновитьЗначениеВСтроке(Строка.КоличествоОставшихсяКлючейДоступаДляВнешнихПользователей, 0, Строка, Контекст);
	ОбновитьЗначениеВСтроке(Строка.ДоляОставшихсяКлючейДоступаДляВнешнихПользователей, 0, Строка, Контекст);
	
КонецПроцедуры

Процедура ДобавитьНовуюСтрокуСписка(Контекст, Список, ИмяТаблицы)
	
	Строка = Новый Структура;
	Строка.Вставить("Список", Список);
	Строка.Вставить("СписокПредставление", Строка(Список));
	Строка.Вставить("ИмяТаблицы", ИмяТаблицы);
	Строка.Вставить("ОбработаноЭлементов", 0);
	Строка.Вставить("ОбработаноКлючейДоступа", 0);
	Строка.Вставить("КоличествоЭлементов", 0);
	Строка.Вставить("КоличествоКлючейДоступа", 0);
	Строка.Вставить("КоличествоОбработанныхЭлементов", 0);
	Строка.Вставить("КоличествоОбработанныхКлючейДоступа", 0);
	Строка.Вставить("ПоследнееОбновление", '00010101');
	Строка.Вставить("ПервоеПланированиеОбновления", МаксимальнаяДата());
	
	Строка.Вставить("КоличествоЭлементовДляПользователей", 0);
	Строка.Вставить("ДоляОбработанныхЭлементовДляПользователей", 1);
	Строка.Вставить("КоличествоЭлементовДляВнешнихПользователей", 0);
	Строка.Вставить("ДоляОбработанныхЭлементовДляВнешнихПользователей", 1);
	Строка.Вставить("КоличествоКлючейДоступаДляПользователей", 0);
	Строка.Вставить("ДоляОбработанныхКлючейДоступаДляПользователей", 1);
	Строка.Вставить("КоличествоКлючейДоступаДляВнешнихПользователей", 0);
	Строка.Вставить("ДоляОбработанныхКлючейДоступаДляВнешнихПользователей", 1);
	
	Строка.Вставить("КоличествоОставшихсяЭлементовДляПользователей", 0);
	Строка.Вставить("ДоляОставшихсяЭлементовДляПользователей", 0);
	Строка.Вставить("КоличествоОставшихсяЭлементовДляВнешнихПользователей", 0);
	Строка.Вставить("ДоляОставшихсяЭлементовДляВнешнихПользователей", 0);
	Строка.Вставить("КоличествоОставшихсяКлючейДоступаДляПользователей", 0);
	Строка.Вставить("ДоляОставшихсяКлючейДоступаДляПользователей", 0);
	Строка.Вставить("КоличествоОставшихсяКлючейДоступаДляВнешнихПользователей", 0);
	Строка.Вставить("ДоляОставшихсяКлючейДоступаДляВнешнихПользователей", 0);
	
	Контекст.ХранимыеДанные.СтрокиСписков.Вставить(Список, Строка);
	Контекст.ДобавленныеСтроки.Добавить(Строка);
	
	Свойства = Новый Структура;
	Свойства.Вставить("РазмерЗаданияОбновленияЭлементов", 0);
	Свойства.Вставить("ПоследнийОбновленныйЭлемент", Null);
	Свойства.Вставить("РазмерЗаданияОбновленияКлючейДоступа", 0);
	Свойства.Вставить("ПоследнийОбновленныйКлючДоступа", Null);
	
	Свойства.Вставить("РазмерЗаданияОбновленияЭлементовДляВнешнихПользователей", 0);
	Свойства.Вставить("ПоследнийОбновленныйЭлементДляВнешнихПользователей", Null);
	Свойства.Вставить("РазмерЗаданияОбновленияКлючейДоступаДляВнешнихПользователей", 0);
	Свойства.Вставить("ПоследнийОбновленныйКлючДоступаДляВнешнихПользователей", Null);
	
	Контекст.ХранимыеДанные.СвойстваСписков.Вставить(Список, Свойства);
	
КонецПроцедуры

Процедура РассчитатьВсегоОбновленоПоКоличествуДанных(Контекст, ВсегоОбновлено)
	
	ТипыТаблицПоИменам = УправлениеДоступомСлужебныйПовтИсп.СинтаксисЯзыка().ТипыТаблиц.ПоИменам;
	Контекст.Вставить("ТипыТаблицПоИменам", ТипыТаблицПоИменам);
	
	Если Не Контекст.ХранимыеДанные.Свойство("КоличествоЭлементовПоСпискам") Тогда
		ЗаполнитьКоличествоЭлементовИКлючейДоступаПоСпискам(Контекст);
	КонецЕсли;
	
	ОбновитьКоличествоЭлементовИКлючейДоступа(Контекст);
	
	КоличествоЭлементовПоСпискам     = Контекст.ХранимыеДанные.КоличествоЭлементовПоСпискам;
	КоличествоКлючейДоступаПоСпискам = Контекст.ХранимыеДанные.КоличествоКлючейДоступаПоСпискам;
	
	ОбщееКоличествоЭлементов = 0;
	Для Каждого КлючИЗначение Из КоличествоЭлементовПоСпискам Цикл
		ОбщееКоличествоЭлементов = ОбщееКоличествоЭлементов + КлючИЗначение.Значение;
	КонецЦикла;
	ОбщееКоличествоЭлементов = ?(ОбщееКоличествоЭлементов = 0, 100, ОбщееКоличествоЭлементов);
	
	ОбщееКоличествоКлючейДоступа = 0;
	Для Каждого КлючИЗначение Из КоличествоКлючейДоступаПоСпискам Цикл
		ОбщееКоличествоКлючейДоступа = ОбщееКоличествоКлючейДоступа + КлючИЗначение.Значение;
	КонецЦикла;
	ОбщееКоличествоКлючейДоступа = ?(ОбщееКоличествоКлючейДоступа = 0, 100, ОбщееКоличествоКлючейДоступа);
	
	ВсегоОбновленоЭлементов = 0;
	ВсегоОбновленоКлючейДоступа = 0;
	
	ДобавкаОбщегоКоличестваЭлементов = 0;
	ДобавкаОбщегоКоличестваКлючейДоступа = 0;
	
	ИменаТаблицСОбновлениемЭлементов     = Новый Соответствие;
	ИменаТаблицСОбновлениемКлючейДоступа = Новый Соответствие;
	
	Для Каждого КлючИЗначение Из Контекст.СтрокиСписков Цикл
		Строка = КлючИЗначение.Значение;
		
		КоличествоЭлементов = КоличествоЭлементовПоСпискам.Получить(КлючИЗначение.Значение.ИмяТаблицы);
		Если КоличествоЭлементов = Неопределено Тогда
			Если КоличествоЭлементовПоСпискам.Количество() = 0 Тогда
				Добавка = 1;
			Иначе
				Добавка = Цел(ОбщееКоличествоЭлементов / КоличествоЭлементовПоСпискам.Количество() / 10);
				Добавка = ?(Добавка = 0, 1, Добавка);
			КонецЕсли;
			ДобавкаОбщегоКоличестваЭлементов = ДобавкаОбщегоКоличестваЭлементов + Добавка;
			ВсегоОбновленоЭлементов = ВсегоОбновленоЭлементов + 100 * Добавка;
		Иначе
			ВсегоОбновленоЭлементов = ВсегоОбновленоЭлементов + Строка.ОбработаноЭлементов * КоличествоЭлементов;
			ИменаТаблицСОбновлениемЭлементов.Вставить(КлючИЗначение.Значение.ИмяТаблицы, Истина);
		КонецЕсли;
		
		КоличествоКлючейДоступа = КоличествоКлючейДоступаПоСпискам.Получить(КлючИЗначение.Значение.ИмяТаблицы);
		Если КоличествоКлючейДоступа = Неопределено Тогда
			Если КоличествоКлючейДоступаПоСпискам.Количество() = 0 Тогда
				Добавка = 1;
			Иначе
				Добавка = Цел(ОбщееКоличествоКлючейДоступа / КоличествоКлючейДоступаПоСпискам.Количество() / 10);
				Добавка = ?(Добавка = 0, 1, Добавка);
			КонецЕсли;
			ДобавкаОбщегоКоличестваКлючейДоступа = ДобавкаОбщегоКоличестваКлючейДоступа + Добавка;
			ВсегоОбновленоКлючейДоступа = ВсегоОбновленоКлючейДоступа + 100 * Добавка;
		Иначе
			ВсегоОбновленоКлючейДоступа = ВсегоОбновленоКлючейДоступа + Строка.ОбработаноКлючейДоступа * КоличествоКлючейДоступа;
			ИменаТаблицСОбновлениемКлючейДоступа.Вставить(КлючИЗначение.Значение.ИмяТаблицы, Истина);
		КонецЕсли;
	КонецЦикла;
	
	КоличествоОбновленныхЭлементов = 0;
	Для Каждого КлючИЗначение Из КоличествоЭлементовПоСпискам Цикл
		Если ИменаТаблицСОбновлениемЭлементов.Получить(КлючИЗначение.Ключ) = Неопределено Тогда
			КоличествоОбновленныхЭлементов = КоличествоОбновленныхЭлементов + КлючИЗначение.Значение;
		КонецЕсли;
	КонецЦикла;
	ВсегоОбновленоЭлементов = ВсегоОбновленоЭлементов + КоличествоОбновленныхЭлементов  * 100;
		
	КоличествоОбновленныхКлючейДоступа = 0;
	Для Каждого КлючИЗначение Из КоличествоКлючейДоступаПоСпискам Цикл
		Если ИменаТаблицСОбновлениемКлючейДоступа.Получить(КлючИЗначение.Ключ) = Неопределено Тогда
			КоличествоОбновленныхКлючейДоступа = КоличествоОбновленныхКлючейДоступа + КлючИЗначение.Значение;
		КонецЕсли;
	КонецЦикла;
	ВсегоОбновленоКлючейДоступа = ВсегоОбновленоКлючейДоступа + КоличествоОбновленныхКлючейДоступа * 100;
	
	ВсегоОбновленоЭлементов = ВсегоОбновленоЭлементов
		/ (ОбщееКоличествоЭлементов + ДобавкаОбщегоКоличестваЭлементов);
	
	ВсегоОбновленоКлючейДоступа = ВсегоОбновленоКлючейДоступа
		/ (ОбщееКоличествоКлючейДоступа + ДобавкаОбщегоКоличестваКлючейДоступа);
	
	ВсегоОбновлено = (ВсегоОбновленоЭлементов + ВсегоОбновленоКлючейДоступа) / 2;
	
КонецПроцедуры

Процедура ЗаполнитьКоличествоЭлементовИКлючейДоступаПоСпискам(Контекст)
	
	КоличествоЭлементовПоСпискам     = Новый Соответствие;
	КоличествоКлючейДоступаПоСпискам = Новый Соответствие;
	Контекст.ХранимыеДанные.Вставить("КоличествоЭлементовПоСпискам",     КоличествоЭлементовПоСпискам);
	Контекст.ХранимыеДанные.Вставить("КоличествоКлючейДоступаПоСпискам", КоличествоКлючейДоступаПоСпискам);
	
	ОписаниеЗапроса = Новый Структура("Запрос, ТекстыПакетаЗапросов", Новый Запрос, Новый Массив);
	
	ОбновляемыеТаблицы = Новый Соответствие;
	ИдентификаторыТаблиц = Контекст.ИдентификаторыТаблиц;
	Для Каждого Строка Из Контекст.СтрокиОбновленияКоличестваЭлементов Цикл
		Если ИдентификаторыТаблиц.Получить(Строка.ИмяТаблицы) = Строка.Список Тогда
			ОбновляемыеТаблицы.Вставить(Строка.ИмяТаблицы, Строка.Список);
		КонецЕсли;
	КонецЦикла;
	Для Каждого Строка Из Контекст.СтрокиОбновленияКоличестваКлючейДоступа Цикл
		Если ИдентификаторыТаблиц.Получить(Строка.ИмяТаблицы) = Строка.Список Тогда
			ОбновляемыеТаблицы.Вставить(Строка.ИмяТаблицы, Строка.Список);
		КонецЕсли;
	КонецЦикла;
	
	Индекс = 0;
	ИменаТаблиц = Новый Массив;
	Для Каждого КлючИЗначение Из Контекст.ИдентификаторыТаблиц Цикл
		Если ОбновляемыеТаблицы.Получить(КлючИЗначение.Ключ) = КлючИЗначение.Значение Тогда
			Продолжить;
		КонецЕсли;
		ИменаТаблиц.Добавить(КлючИЗначение.Ключ);
		Строка = Новый Структура("Список, ИмяТаблицы", КлючИЗначение.Значение, КлючИЗначение.Ключ);
		ДобавитьТекстЗапросаКоличестваЭлементов(ОписаниеЗапроса, Строка, Индекс, Контекст, Ложь);
		ДобавитьТекстЗапросаКоличестваЭлементов(ОписаниеЗапроса, Строка, Индекс, Контекст, Истина);
		ДобавитьТекстЗапросаКоличестваКлючейДоступа(ОписаниеЗапроса, Строка, Индекс, Ложь);
		ДобавитьТекстЗапросаКоличестваКлючейДоступа(ОписаниеЗапроса, Строка, Индекс, Истина);
	КонецЦикла;
	
	Если ОписаниеЗапроса.ТекстыПакетаЗапросов.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	РезультатыЗапроса = ВыполнитьПакетЗапросовПоЧастям(ОписаниеЗапроса);
	
	Индекс = 0;
	Для Каждого ИмяТаблицы Из ИменаТаблиц Цикл
		Выборка = РезультатыЗапроса[Индекс].Выбрать();
		КоличествоЭлементовДляПользователей = ?(Выборка.Следующий(), Выборка.Количество, 0);
		Индекс = Индекс + 1;
		
		Выборка = РезультатыЗапроса[Индекс].Выбрать();
		КоличествоЭлементовДляВнешнихПользователей = ?(Выборка.Следующий(), Выборка.Количество, 0);
		Индекс = Индекс + 1;
		
		КоличествоЭлементовПоСпискам[ИмяТаблицы] = КоличествоЭлементовДляПользователей
			+ КоличествоЭлементовДляВнешнихПользователей;
		
		Выборка = РезультатыЗапроса[Индекс].Выбрать();
		КоличествоКлючейДоступаДляПользователей = ?(Выборка.Следующий(), Выборка.Количество, 0);
		Индекс = Индекс + 1;
		
		Выборка = РезультатыЗапроса[Индекс].Выбрать();
		КоличествоКлючейДоступаДляВнешнихПользователей = ?(Выборка.Следующий(), Выборка.Количество, 0);
		Индекс = Индекс + 1;
		
		КоличествоКлючейДоступаПоСпискам[ИмяТаблицы] = КоличествоКлючейДоступаДляПользователей
			+ КоличествоКлючейДоступаДляВнешнихПользователей;
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбновитьКоличествоЭлементовИКлючейДоступа(Контекст)
	
	ОписаниеЗапроса = Новый Структура("Запрос, ТекстыПакетаЗапросов", Новый Запрос, Новый Массив);
	Индекс = 0;
	Для Каждого Строка Из Контекст.СтрокиОбновленияКоличестваЭлементов Цикл
		ДобавитьТекстЗапросаКоличестваЭлементов(ОписаниеЗапроса, Строка, Индекс, Контекст, Ложь);
		ДобавитьТекстЗапросаКоличестваЭлементов(ОписаниеЗапроса, Строка, Индекс, Контекст, Истина);
		ДобавитьТекстЗапросаКоличестваОставшихсяЭлементов(ОписаниеЗапроса, Строка, Индекс, Контекст, Ложь);
		ДобавитьТекстЗапросаКоличестваОставшихсяЭлементов(ОписаниеЗапроса, Строка, Индекс, Контекст, Истина);
	КонецЦикла;
	Для Каждого Строка Из Контекст.СтрокиОбновленияКоличестваКлючейДоступа Цикл
		ДобавитьТекстЗапросаКоличестваКлючейДоступа(ОписаниеЗапроса, Строка, Индекс, Ложь);
		ДобавитьТекстЗапросаКоличестваКлючейДоступа(ОписаниеЗапроса, Строка, Индекс, Истина);
		ДобавитьТекстЗапросаКоличестваОставшихсяКлючейДоступа(ОписаниеЗапроса, Строка, Индекс, Контекст, Ложь);
		ДобавитьТекстЗапросаКоличестваОставшихсяКлючейДоступа(ОписаниеЗапроса, Строка, Индекс, Контекст, Истина);
	КонецЦикла;
	
	Если ОписаниеЗапроса.ТекстыПакетаЗапросов.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	РезультатыЗапроса = ВыполнитьПакетЗапросовПоЧастям(ОписаниеЗапроса);

	КоличествоЭлементовПоСпискам     = Контекст.ХранимыеДанные.КоличествоЭлементовПоСпискам;
	КоличествоКлючейДоступаПоСпискам = Контекст.ХранимыеДанные.КоличествоКлючейДоступаПоСпискам;
	ВерсииОграниченийСписков         = Контекст.ДействующиеПараметры.ВерсииОграниченийСписков;
	ТипыТаблицПоИменам               = Контекст.ТипыТаблицПоИменам;
	
	Индекс = 0;
	Для Каждого Строка Из Контекст.СтрокиОбновленияКоличестваЭлементов Цикл
		Выборка = РезультатыЗапроса[Индекс].Выбрать();
		Строка.КоличествоЭлементовДляПользователей = ?(Выборка.Следующий(), Выборка.Количество, 0);
		Индекс = Индекс + 1;
		
		Выборка = РезультатыЗапроса[Индекс].Выбрать();
		Строка.КоличествоЭлементовДляВнешнихПользователей = ?(Выборка.Следующий(), Выборка.Количество, 0);
		Индекс = Индекс + 1;
		
		КоличествоЭлементов = Строка.КоличествоЭлементовДляПользователей + Строка.КоличествоЭлементовДляВнешнихПользователей;
		Если ЗначениеЗаполнено(Строка.ИмяТаблицы) Тогда
			КоличествоЭлементовПоСпискам.Вставить(Строка.ИмяТаблицы, КоличествоЭлементов);
		КонецЕсли;
		
		Если КоличествоЭлементов = 0 Тогда
			ОбнулитьКоличествоЭлементов(Строка, Контекст);
			ОбновитьЗначениеВСтроке(Строка.ОбработаноЭлементов, 100, Строка, Контекст);
			Индекс = Индекс + 2;
		Иначе
			КоличествоОбработанныхЭлементов = 0;
			СвойстваСписка = Контекст.СвойстваСписков.Получить(Строка.Список);
			ЕстьКлючиДляПользователей = Ложь;
			ЕстьКлючиДляВнешнихПользователей = Ложь;
			Версии = ВерсииОграниченийСписков.Получить(Строка.ИмяТаблицы);
			Если ЗначениеЗаполнено(Версии) Тогда
				ЕстьКлючиДляПользователей        = ЗначениеЗаполнено(СтрПолучитьСтроку(Версии, 1));
				ЕстьКлючиДляВнешнихПользователей = ЗначениеЗаполнено(СтрПолучитьСтроку(Версии, 2));
			КонецЕсли;
			СоставИмени = СтрРазделить(Строка.ИмяТаблицы, ".", Ложь);
			СвойстваТипа = ТипыТаблицПоИменам.Получить(ВРег(СоставИмени[0]));
			Для ВидПользователей = 0 По 1 Цикл
				Если ВидПользователей = 0 Тогда
					ПоследнийОбновленныйЭлемент = СвойстваСписка.ПоследнийОбновленныйЭлемент;
				Иначе
					ПоследнийОбновленныйЭлемент = СвойстваСписка.ПоследнийОбновленныйЭлементДляВнешнихПользователей;
				КонецЕсли;
				Если ПоследнийОбновленныйЭлемент = Null Или ПоследнийОбновленныйЭлемент = Истина Тогда
					КоличествоОставшихсяЭлементов = -1;
				КонецЕсли;
				Если ПоследнийОбновленныйЭлемент <> Null Тогда
					Если ВидПользователей = 0 Тогда
						ЕстьКлючиДляПользователей = Истина;
					Иначе
						ЕстьКлючиДляВнешнихПользователей = Истина;
					КонецЕсли;
					Если ПоследнийОбновленныйЭлемент <> Истина Тогда
						Выборка = РезультатыЗапроса[Индекс].Выбрать();
						КоличествоОставшихсяЭлементов = ?(Выборка.Следующий(), Выборка.Количество, 0);
					КонецЕсли;
				КонецЕсли;
				Если КоличествоОставшихсяЭлементов = -1 Тогда
					Если ВидПользователей = 0 Тогда
						Строка.ДоляОставшихсяЭлементовДляПользователей = 0;
					Иначе
						Строка.ДоляОставшихсяЭлементовДляВнешнихПользователей = 0;
					КонецЕсли;
					КоличествоОставшихсяЭлементов = 0;
				КонецЕсли;
				Если ВидПользователей = 0 Тогда
					Если Не ЕстьКлючиДляПользователей Тогда
						Строка.КоличествоОставшихсяЭлементовДляПользователей = 0;
						Строка.КоличествоЭлементовДляПользователей = 0;
					ИначеЕсли ТипЗнч(КоличествоОставшихсяЭлементов) = Тип("Число") Тогда
						Строка.КоличествоОставшихсяЭлементовДляПользователей
							= Цел(Строка.КоличествоЭлементовДляПользователей * (1 - Строка.ДоляОбработанныхЭлементовДляПользователей
								- Строка.ДоляОставшихсяЭлементовДляПользователей) + 0.99)
							+ Цел(КоличествоОставшихсяЭлементов * Строка.ДоляОставшихсяЭлементовДляПользователей);
					КонецЕсли;
					КоличествоОбработанныхЭлементов = КоличествоОбработанныхЭлементов
						+ (Строка.КоличествоЭлементовДляПользователей
							- Строка.КоличествоОставшихсяЭлементовДляПользователей);
				Иначе
					Если Не ЕстьКлючиДляВнешнихПользователей Тогда
						Строка.КоличествоОставшихсяЭлементовДляВнешнихПользователей = 0;
						Строка.КоличествоЭлементовДляВнешнихПользователей = 0;
					ИначеЕсли ТипЗнч(КоличествоОставшихсяЭлементов) = Тип("Число") Тогда
						Строка.КоличествоОставшихсяЭлементовДляВнешнихПользователей
							= Цел(Строка.КоличествоЭлементовДляВнешнихПользователей * (1 - Строка.ДоляОбработанныхЭлементовДляВнешнихПользователей
								- Строка.ДоляОставшихсяЭлементовДляВнешнихПользователей) + 0.99)
							+ Цел(КоличествоОставшихсяЭлементов * Строка.ДоляОставшихсяЭлементовДляВнешнихПользователей);
					КонецЕсли;
					КоличествоОбработанныхЭлементов = КоличествоОбработанныхЭлементов
						+ (Строка.КоличествоЭлементовДляВнешнихПользователей
							- Строка.КоличествоОставшихсяЭлементовДляВнешнихПользователей);
				КонецЕсли;
				Индекс = Индекс + 1;
			КонецЦикла;
			КоличествоЭлементов = Строка.КоличествоЭлементовДляПользователей + Строка.КоличествоЭлементовДляВнешнихПользователей;
			Если ЕстьКлючиДляПользователей И ЕстьКлючиДляВнешнихПользователей И СвойстваТипа.ЭтоСсылочныйТип Тогда
				КоличествоЭлементов             = КоличествоЭлементов / 2;
				КоличествоОбработанныхЭлементов = КоличествоОбработанныхЭлементов / 2;
			КонецЕсли;
			ОбновитьЗначениеВСтроке(Строка.КоличествоЭлементов, КоличествоЭлементов, Строка, Контекст);
			ОбновитьЗначениеВСтроке(Строка.КоличествоОбработанныхЭлементов,
				Цел(КоличествоОбработанныхЭлементов), Строка, Контекст);
			Если Строка.КоличествоОбработанныхЭлементов > Строка.КоличествоЭлементов Тогда
				ОбновитьЗначениеВСтроке(Строка.КоличествоОбработанныхЭлементов,
					Строка.КоличествоЭлементов, Строка, Контекст);
			КонецЕсли;
			ОбновитьЗначениеВСтроке(Строка.ОбработаноЭлементов, ?(Строка.КоличествоЭлементов = 0, 100,
				Цел(Строка.КоличествоОбработанныхЭлементов / Строка.КоличествоЭлементов * 100)), Строка, Контекст);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого Строка Из Контекст.СтрокиОбновленияКоличестваКлючейДоступа Цикл
		Выборка = РезультатыЗапроса[Индекс].Выбрать();
		КоличествоКлючейДоступаДляПользователей = ?(Выборка.Следующий(), Выборка.Количество, 0);
		Индекс = Индекс + 1;
		
		Выборка = РезультатыЗапроса[Индекс].Выбрать();
		КоличествоКлючейДоступаДляВнешнихПользователей = ?(Выборка.Следующий(), Выборка.Количество, 0);
		Индекс = Индекс + 1;
		
		КоличествоКлючейДоступа = КоличествоКлючейДоступаДляПользователей + КоличествоКлючейДоступаДляВнешнихПользователей;
		ОбновитьЗначениеВСтроке(Строка.КоличествоКлючейДоступа, КоличествоКлючейДоступа, Строка, Контекст);
		Если ЗначениеЗаполнено(Строка.ИмяТаблицы) Тогда
			КоличествоКлючейДоступаПоСпискам.Вставить(Строка.ИмяТаблицы, КоличествоКлючейДоступа);
		КонецЕсли;
		
		Если Строка.КоличествоКлючейДоступа = 0 Тогда
			ОбнулитьКоличествоКлючейДоступа(Строка, Контекст);
			ОбновитьЗначениеВСтроке(Строка.ОбработаноКлючейДоступа, 100, Строка, Контекст);
			Индекс = Индекс + 2;
		Иначе
			КоличествоОбработанныхКлючейДоступа = 0;
			СвойстваСписка = Контекст.СвойстваСписков.Получить(Строка.Список);
			Для ВидПользователей = 0 По 1 Цикл
				Если ВидПользователей = 0 Тогда
					ПоследнийОбновленныйКлючДоступа = СвойстваСписка.ПоследнийОбновленныйКлючДоступа;
				Иначе
					ПоследнийОбновленныйКлючДоступа = СвойстваСписка.ПоследнийОбновленныйКлючДоступаДляВнешнихПользователей;
				КонецЕсли;
				Если ПоследнийОбновленныйКлючДоступа = Null Или ПоследнийОбновленныйКлючДоступа = Истина Тогда
					КоличествоОставшихсяКлючейДоступа = -1;
				Иначе
					Выборка = РезультатыЗапроса[Индекс].Выбрать();
					КоличествоОставшихсяКлючейДоступа = ?(Выборка.Следующий(), Выборка.Количество, 0);
				КонецЕсли;
				Если КоличествоОставшихсяКлючейДоступа = -1 Тогда
					Если ВидПользователей = 0 Тогда
						Строка.ДоляОставшихсяКлючейДоступаДляПользователей = 0;
					Иначе
						Строка.ДоляОставшихсяКлючейДоступаДляВнешнихПользователей = 0;
					КонецЕсли;
					КоличествоОставшихсяКлючейДоступа = 0;
				КонецЕсли;
				Если ВидПользователей = 0 Тогда
					Если ТипЗнч(КоличествоОставшихсяКлючейДоступа) = Тип("Число") Тогда
						Строка.КоличествоКлючейДоступаДляПользователей = КоличествоКлючейДоступаДляПользователей;
						Строка.КоличествоОставшихсяКлючейДоступаДляПользователей
							= Цел(Строка.КоличествоКлючейДоступаДляПользователей * (1 - Строка.ДоляОбработанныхКлючейДоступаДляПользователей
								- Строка.ДоляОставшихсяКлючейДоступаДляПользователей) + 0.99)
							+ Цел(КоличествоОставшихсяКлючейДоступа * Строка.ДоляОставшихсяКлючейДоступаДляПользователей);
					КонецЕсли;
					КоличествоОбработанныхКлючейДоступа = КоличествоОбработанныхКлючейДоступа
						+ (Строка.КоличествоКлючейДоступаДляПользователей
							- Строка.КоличествоОставшихсяКлючейДоступаДляПользователей);
				Иначе
					Если ТипЗнч(КоличествоОставшихсяКлючейДоступа) = Тип("Число") Тогда
						Строка.КоличествоКлючейДоступаДляВнешнихПользователей = КоличествоКлючейДоступаДляВнешнихПользователей;
						Строка.КоличествоОставшихсяКлючейДоступаДляВнешнихПользователей
							= Цел(Строка.КоличествоКлючейДоступаДляВнешнихПользователей * (1 - Строка.ДоляОбработанныхКлючейДоступаДляВнешнихПользователей
								- Строка.ДоляОставшихсяКлючейДоступаДляВнешнихПользователей) + 0.99)
							+ Цел(КоличествоОставшихсяКлючейДоступа * Строка.ДоляОставшихсяКлючейДоступаДляВнешнихПользователей);
					КонецЕсли;
					КоличествоОбработанныхКлючейДоступа = КоличествоОбработанныхКлючейДоступа
						+ (Строка.КоличествоКлючейДоступаДляВнешнихПользователей
							- Строка.КоличествоОставшихсяКлючейДоступаДляВнешнихПользователей);
				КонецЕсли;
				Индекс = Индекс + 1;
			КонецЦикла;
			ОбновитьЗначениеВСтроке(Строка.КоличествоОбработанныхКлючейДоступа,
				Цел(КоличествоОбработанныхКлючейДоступа), Строка, Контекст);
			Если Строка.КоличествоОбработанныхКлючейДоступа > Строка.КоличествоКлючейДоступа Тогда
				ОбновитьЗначениеВСтроке(Строка.КоличествоОбработанныхКлючейДоступа,
					Строка.КоличествоКлючейДоступа, Строка, Контекст);
			КонецЕсли;
			ОбновитьЗначениеВСтроке(Строка.ОбработаноКлючейДоступа,
				Цел(Строка.КоличествоОбработанныхКлючейДоступа / Строка.КоличествоКлючейДоступа * 100), Строка, Контекст);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция ВыполнитьПакетЗапросовПоЧастям(ОписаниеЗапроса)
	
	РезультатыПакетаЗапросов = Новый Массив;
	
	ТекстыПорцииЗапросов = Новый Массив;
	Для Каждого ТекстЗапроса Из ОписаниеЗапроса.ТекстыПакетаЗапросов Цикл
		Если ТекстыПорцииЗапросов.Количество() = 200 Тогда
			ДобавитьРезультатыЗапроса(РезультатыПакетаЗапросов, ТекстыПорцииЗапросов, ОписаниеЗапроса);
			ТекстыПорцииЗапросов = Новый Массив;
		КонецЕсли;
		ТекстыПорцииЗапросов.Добавить(ТекстЗапроса);
	КонецЦикла;
	ДобавитьРезультатыЗапроса(РезультатыПакетаЗапросов, ТекстыПорцииЗапросов, ОписаниеЗапроса);
	
	Возврат РезультатыПакетаЗапросов;
	
КонецФункции

Процедура ДобавитьРезультатыЗапроса(РезультатыПакетаЗапросов, ТекстыПорцииЗапросов, ОписаниеЗапроса)
	
	Запрос = ОписаниеЗапроса.Запрос;
	
	Запрос.Текст = СтрСоединить(ТекстыПорцииЗапросов, ОбщегоНазначения.РазделительПакетаЗапросов());
	РезультатыЗапроса = Запрос.ВыполнитьПакет();
	Запрос.Текст = "";
	
	Для Каждого РезультатЗапроса Из РезультатыЗапроса Цикл
		РезультатыПакетаЗапросов.Добавить(РезультатЗапроса);
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбновитьЗначениеВСтроке(СтароеЗначение, НовоеЗначение, Строка, Контекст)
	
	Если СтароеЗначение = НовоеЗначение Тогда
		Возврат;
	КонецЕсли;
	СтароеЗначение = НовоеЗначение;
	
	Если Контекст.ДобавленныеСтроки.Найти(Строка) = Неопределено
	   И Контекст.ИзмененныеСтроки.Получить(Строка) = Неопределено Тогда
		
		Контекст.ИзмененныеСтроки.Вставить(Строка.Список, Строка);
	КонецЕсли;
	
КонецПроцедуры

Процедура ДобавитьТекстЗапросаКоличестваЭлементов(ОписаниеЗапроса, Строка, Индекс, Контекст, ДляВнешнихПользователей)
	
	Версии = Контекст.ДействующиеПараметры.ВерсииОграниченийСписков.Получить(Строка.ИмяТаблицы);
	
	Если ЗначениеЗаполнено(Версии)
	   И ЗначениеЗаполнено(Строка.ИмяТаблицы)
	 Или Строка.ИмяТаблицы = "Справочник.НаборыГруппДоступа" Тогда
		
		СоставИмени = СтрРазделить(Строка.ИмяТаблицы, ".", Ложь);
		СвойстваТипа = Контекст.ТипыТаблицПоИменам.Получить(ВРег(СоставИмени[0]));
		Если СвойстваТипа.ЭтоСсылочныйТип Тогда
			ТекстЗапроса =
			"ВЫБРАТЬ
			|	КОЛИЧЕСТВО(*) КАК Количество
			|ИЗ
			|	&ТекущаяТаблица КАК ТекущаяТаблица";
		Иначе
			ТекстЗапроса = ТекстЗапросаКоличестваЭлементовРегистра(Контекст, Строка, Индекс, ДляВнешнихПользователей);
		КонецЕсли;
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ТекущаяТаблица", Строка.ИмяТаблицы);
	Иначе
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	0 КАК Количество";
	КонецЕсли;
	
	ОписаниеЗапроса.ТекстыПакетаЗапросов.Добавить(ТекстЗапроса);
	Индекс = Индекс + 1;
	
КонецПроцедуры

Функция ТекстЗапросаКоличестваЭлементовРегистра(Контекст, Строка, Индекс, ДляВнешнихПользователей)
	
	Свойства = Контекст.ДействующиеПараметры.ДополнительныйКонтекст[?(ДляВнешнихПользователей,
		"ДляВнешнихПользователей", "ДляПользователей")].СвойстваОграниченияСписков.Получить(Строка.ИмяТаблицы);
	
	Если Свойства = Неопределено
	 Или Свойства.ОпорныеПоля = Неопределено
	 Или Свойства.ОпорныеПоля.Используемые.Количество() = 0 Тогда
	
		Возврат
		"ВЫБРАТЬ
		|	0 КАК Количество";
	КонецЕсли;
	
	ПоляВыбора = "";
	Для Каждого ИмяПоля Из Свойства.ОпорныеПоля.Используемые Цикл
		ПоляВыбора = ПоляВыбора + ?(ПоляВыбора = "", "", ",
		|		") + "ТекущаяТаблица." + ИмяПоля;
	КонецЦикла;
	
	Если Свойства.ОпорныеПоля.Используемые.Количество() = 1 Тогда
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	КОЛИЧЕСТВО(РАЗЛИЧНЫЕ &ПоляВыбора) КАК Количество
		|ИЗ
		|	&ТекущаяТаблица КАК ТекущаяТаблица";
	Иначе
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	КОЛИЧЕСТВО(*) КАК Количество
		|ИЗ
		|	(ВЫБРАТЬ РАЗЛИЧНЫЕ
		|		&ПоляВыбора КАК ПоляВыбора
		|	ИЗ
		|		&ТекущаяТаблица КАК ТекущаяТаблица) КАК Комбинации";
		ПоляВыбора = ТекстСОтступом(ПоляВыбора, "	");
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляВыбора", ПоляВыбора);
	
	Возврат ТекстЗапроса;
	
КонецФункции

Процедура ДобавитьТекстЗапросаКоличестваОставшихсяЭлементов(ОписаниеЗапроса, Строка, Индекс, Контекст, ДляВнешнихПользователей)
	
	СвойстваСписка = Контекст.СвойстваСписков.Получить(Строка.Список);
	СпискиСДатой = Контекст.ДействующиеПараметры.СпискиСДатой;
	
	Если ЗначениеЗаполнено(Строка.ИмяТаблицы) Тогда
		СоставИмени = СтрРазделить(Строка.ИмяТаблицы, ".", Ложь);
		СвойстваТипа = Контекст.ТипыТаблицПоИменам.Получить(ВРег(СоставИмени[0]));
	Иначе
		СвойстваСписка = Неопределено;
	КонецЕсли;
	
	Если СвойстваСписка = Неопределено Тогда
		ПараметрыЗадания = Неопределено;
		
	ИначеЕсли ДляВнешнихПользователей Тогда
		ПараметрыЗадания = СвойстваСписка.ПоследнийОбновленныйЭлементДляВнешнихПользователей;
	Иначе
		ПараметрыЗадания = СвойстваСписка.ПоследнийОбновленныйЭлемент;
	КонецЕсли;
	
	Если ТипЗнч(ПараметрыЗадания) <> Тип("ХранилищеЗначения") Тогда
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	НЕОПРЕДЕЛЕНО КАК Количество";
	Иначе
		ДолиКоличестваЭлементов = Новый Структура("Обработанных, Оставшихся", 0, 1);
		ПараметрыЗадания = ПараметрыЗадания.Получить();
		ЭтоСписокСДатой = СпискиСДатой.Получить(Строка.ИмяТаблицы) <> Неопределено;
		
		Если ТипЗнч(ПараметрыЗадания) = Тип("Структура")
		   И ПараметрыЗадания.Свойство("ПоследнийОбновленныйЭлемент")
		   И ТипЗнч(ПараметрыЗадания.ПоследнийОбновленныйЭлемент) = Тип("Структура")
		   И ПараметрыЗадания.ПоследнийОбновленныйЭлемент.Свойство("ВидКлючаДанных")
		   И ПорядокВидаКлючаДанных(ПараметрыЗадания.ПоследнийОбновленныйЭлемент.ВидКлючаДанных) <> Неопределено
		   И ПараметрыЗадания.ПоследнийОбновленныйЭлемент.Свойство("КлючДанных")
		   И ПараметрыЗадания.ПоследнийОбновленныйЭлемент.Свойство("ОбработатьУстаревшиеЭлементы")
		   И ТипЗнч(ПараметрыЗадания.ПоследнийОбновленныйЭлемент.ОбработатьУстаревшиеЭлементы) = Тип("Булево") Тогда
			
			ПоследнийОбновленныйЭлемент = ПараметрыЗадания.ПоследнийОбновленныйЭлемент;
		Иначе
			ПоследнийОбновленныйЭлемент = Новый Структура;
			ПоследнийОбновленныйЭлемент.Вставить("ВидКлючаДанных", "ЭлементыДанныхСУстаревшимиКлючами");
			ПоследнийОбновленныйЭлемент.Вставить("КлючДанных");
		КонецЕсли;
		
		УсловиеОтбора = "";
		Если СвойстваТипа.ЭтоСсылочныйТип Тогда
			КлючДанных = ПоследнийОбновленныйЭлемент.КлючДанных;
			Если СпискиСДатой.Получить(Строка.ИмяТаблицы) <> Неопределено Тогда
				
				Если ПоследнийОбновленныйЭлемент.Свойство("Дата")
				   И ТипЗнч(ПоследнийОбновленныйЭлемент.Дата) = Тип("Дата") Тогда
					
					ИмяПараметра = "ПоследняяДата" + Формат(Индекс, "ЧГ=");
					УсловиеОтбора = "ТекущаяТаблица.Дата <= &" + ИмяПараметра;
					ОписаниеЗапроса.Запрос.УстановитьПараметр(ИмяПараметра, ПоследнийОбновленныйЭлемент.Дата);
				КонецЕсли;
				
			ИначеЕсли ЗначениеЗаполнено(КлючДанных) Тогда
				ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗнч(КлючДанных));
				Если ОбъектМетаданных <> Неопределено
				   И ОбъектМетаданных.ПолноеИмя() = Строка.ИмяТаблицы Тогда
					
					ИмяПараметра = "ПоследняяСсылка" + Формат(Индекс, "ЧГ=");
					УсловиеОтбора = "ТекущаяТаблица.Ссылка > &" + ИмяПараметра;
					ОписаниеЗапроса.Запрос.УстановитьПараметр(ИмяПараметра, КлючДанных);
				КонецЕсли;
			КонецЕсли;
			Если ЗначениеЗаполнено(УсловиеОтбора) Тогда
				ТекстЗапроса =
				"ВЫБРАТЬ
				|	КОЛИЧЕСТВО(*) КАК Количество
				|ИЗ
				|	&ТекущаяТаблица КАК ТекущаяТаблица
				|ГДЕ
				|	&УсловиеОтбора";
				ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбора", УсловиеОтбора);
			Иначе
				ТекстЗапроса =
				"ВЫБРАТЬ
				|	-1 КАК Количество";
			КонецЕсли;
			ЗаполнитьДолиКоличествоЭлементовСсылочногоТипа(ДолиКоличестваЭлементов,
				ПоследнийОбновленныйЭлемент, Строка.ИмяТаблицы);
		Иначе
			СвойстваОграничения = Контекст.ДействующиеПараметры.ДополнительныйКонтекст[?(ДляВнешнихПользователей,
				"ДляВнешнихПользователей", "ДляПользователей")].СвойстваОграниченияСписков.Получить(Строка.ИмяТаблицы);
			
			ЗаполнитьДолиКоличестваЭлементовРегистра(ДолиКоличестваЭлементов,
				ПоследнийОбновленныйЭлемент, СвойстваОграничения);
			
			ТекстЗапроса = ТекстЗапросаКоличестваОставшихсяЭлементовРегистра(ОписаниеЗапроса, Строка, Индекс,
				ДляВнешнихПользователей, ПоследнийОбновленныйЭлемент, СвойстваОграничения, СвойстваТипа);
		КонецЕсли;
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ТекущаяТаблица", Строка.ИмяТаблицы);
		
		Если ДляВнешнихПользователей Тогда
			Строка.ДоляОбработанныхЭлементовДляВнешнихПользователей = ДолиКоличестваЭлементов.Обработанных;
			Строка.ДоляОставшихсяЭлементовДляВнешнихПользователей   = ДолиКоличестваЭлементов.Оставшихся;
		Иначе
			Строка.ДоляОбработанныхЭлементовДляПользователей = ДолиКоличестваЭлементов.Обработанных;
			Строка.ДоляОставшихсяЭлементовДляПользователей   = ДолиКоличестваЭлементов.Оставшихся;
		КонецЕсли;
	КонецЕсли;
	
	ОписаниеЗапроса.ТекстыПакетаЗапросов.Добавить(ТекстЗапроса);
	Индекс = Индекс + 1;
	
КонецПроцедуры

Процедура ЗаполнитьДолиКоличествоЭлементовСсылочногоТипа(ДолиКоличестваЭлементов, Элемент, ИмяТаблицы)
	
	Если ИмяТаблицы = "Справочник.НаборыГруппДоступа" Тогда
		Если Элемент.ВидКлючаДанных = "НовыеНаборыИзОдногоПользователя" Тогда
			
			ДолиКоличестваЭлементов.Обработанных = 0.0;
			ДолиКоличестваЭлементов.Оставшихся   = 0.1;
			
		ИначеЕсли Элемент.ВидКлючаДанных = "НаборыГруппДоступаНазначенныеПользователям" Тогда
			
			ДолиКоличестваЭлементов.Обработанных = 0.1;
			ДолиКоличестваЭлементов.Оставшихся   = 0.1;
			
		ИначеЕсли Элемент.ВидКлючаДанных = "НаборыГруппПользователейНазначенныеПользователям" Тогда
			
			ДолиКоличестваЭлементов.Обработанных = 0.2;
			ДолиКоличестваЭлементов.Оставшихся   = 0.1;
			
		ИначеЕсли Элемент.ВидКлючаДанных = "НовыеНаборыГруппСУстаревшимиПравами" Тогда
			
			ДолиКоличестваЭлементов.Обработанных = 0.3;
			ДолиКоличестваЭлементов.Оставшихся   = 0.2;
			
		ИначеЕсли Элемент.ВидКлючаДанных = "НаборыГруппРазрешенныеПользователям" Тогда
			
			ДолиКоличестваЭлементов.Обработанных = 0.5;
			ДолиКоличестваЭлементов.Оставшихся   = 0.1;
			
		ИначеЕсли Элемент.ВидКлючаДанных = "НаборыГруппСУстаревшимиПравами" Тогда
			
			Если Элемент.ОбработатьУстаревшиеЭлементы Тогда
				ДолиКоличестваЭлементов.Обработанных = 0.6;
				ДолиКоличестваЭлементов.Оставшихся   = 0.3;
			Иначе
				ДолиКоличестваЭлементов.Обработанных = 0.6;
				ДолиКоличестваЭлементов.Оставшихся   = 0.4;
			КонецЕсли;
			
		Иначе // УстаревшиеЭлементы.
			ДолиКоличестваЭлементов.Обработанных = 0.9;
			ДолиКоличестваЭлементов.Оставшихся   = 0.1;
		КонецЕсли;
		Возврат;
	КонецЕсли;
	
	Если Элемент.ВидКлючаДанных = "ЭлементыСУстаревшимиКлючами" Тогда
		Если Элемент.ОбработатьУстаревшиеЭлементы Тогда
			ДолиКоличестваЭлементов.Обработанных = 0.0;
			ДолиКоличестваЭлементов.Оставшихся   = 0.9;
		Иначе
			ДолиКоличестваЭлементов.Обработанных = 0.0;
			ДолиКоличестваЭлементов.Оставшихся   = 1.0;
		КонецЕсли;
	Иначе // УстаревшиеЭлементы.
		ДолиКоличестваЭлементов.Обработанных = 0.9;
		ДолиКоличестваЭлементов.Оставшихся   = 0.1;
	КонецЕсли;
	
КонецПроцедуры

Функция ТекстЗапросаКоличестваОставшихсяЭлементовРегистра(ОписаниеЗапроса, Строка, Индекс,
			ДляВнешнихПользователей, ПоследнийОбновленныйЭлемент, СвойстваОграничения, СвойстваТипа)
	
	ВидКлючаДанных = ПоследнийОбновленныйЭлемент.ВидКлючаДанных;
	КлючДанных     = ПоследнийОбновленныйЭлемент.КлючДанных;
	
	Если СвойстваОграничения = Неопределено
	 Или СвойстваОграничения.ОпорныеПоля = Неопределено
	 Или СвойстваОграничения.ОпорныеПоля.Используемые.Количество() = 0
	 Или ТипЗнч(КлючДанных) <> Тип("Структура")
	 Или ВидКлючаДанных = "ЭлементыБезКлючейПоПериоду"
	   И (Не ПоследнийОбновленныйЭлемент.Свойство("Дата")
	      Или ТипЗнч(ПоследнийОбновленныйЭлемент.Дата) <> Тип("Дата"))
	 Или ВидКлючаДанных = "ЭлементыБезКлючейПоЗначениямПолей"
	   И СвойстваОграничения.ОпорныеПоля.Используемые.Количество() <> КлючДанных.Количество()
	 Или ВидКлючаДанных <> "ЭлементыБезКлючейПоПериоду"
	   И ВидКлючаДанных <> "ЭлементыБезКлючейПоЗначениямПолей"
	   И СвойстваОграничения.ОпорныеПоля.Используемые.Количество() > КлючДанных.Количество() Тогда
	
		Возврат
		"ВЫБРАТЬ
		|	-1 КАК Количество";
	КонецЕсли;
	
	ПоляВыбора = "";
	УсловиеОтбора = "";
	УсловиеСоединения = "";
	
	Если ЗначениеЗаполнено(СвойстваОграничения.ИмяОтдельногоРегистраКлючей) Тогда
		ИмяРегистраКлючей = СвойстваОграничения.ИмяОтдельногоРегистраКлючей;
		МаксимальноеКоличествоПолей =
			УправлениеДоступомСлужебныйПовтИсп.КоличествоОпорныхПолейРегистра(ИмяРегистраКлючей);
	Иначе
		ИмяРегистраКлючей = "КлючиДоступаКРегистрам";
		МаксимальноеКоличествоПолей = УправлениеДоступомСлужебныйПовтИсп.КоличествоОпорныхПолейРегистра();
		ИмяПараметра = "ИдентификаторРегистра" + Формат(Индекс, "ЧГ=");
		УсловиеСоединения = "(КлючиДоступаКРегистрам.Регистр = &" + ИмяПараметра + ")";
		ОписаниеЗапроса.Запрос.УстановитьПараметр(ИмяПараметра, Строка.Список);
	КонецЕсли;
	
	ОпорныеПоля = СвойстваОграничения.ОпорныеПоля;
	ОтборПоТипуПользователей = ?(ДляВнешнихПользователей, "ИСТИНА", "ЛОЖЬ");
	УсловиеСоединения = УсловиеСоединения + ?(УсловиеСоединения = "", "", "
	|			И ") + "(КлючиДоступаКРегистрам.ДляВнешнихПользователей = " + ОтборПоТипуПользователей + ")";
	
	НомерПоля = 1;
	Для Каждого ИмяПоля Из ОпорныеПоля.Используемые Цикл
		ИмяПоляВКлючеДанных = "Поле" + НомерПоля;
		ИмяПараметра = ИмяПоля + Формат(Индекс, "ЧГ=");
		
		УсловиеСоединения = УсловиеСоединения + ?(УсловиеСоединения = "", "", "
		|			И ") + "(КлючиДоступаКРегистрам.Поле" + НомерПоля + " = ТекущаяТаблица." + ИмяПоля + ")";
		
		Отбор = "";
		Для ТекущийИндекс = 0 По НомерПоля - 2 Цикл
			ТекущееИмяПоля = ОпорныеПоля.Используемые[ТекущийИндекс];
			ТекущееИмяПараметра = ТекущееИмяПоля + Формат(Индекс, "ЧГ=");
			Отбор = Отбор + ?(Отбор = "", "", "
			|	И ") + "ТекущаяТаблица." + ТекущееИмяПоля + " = &" + ТекущееИмяПараметра;
		КонецЦикла;
		Отбор = Отбор + ?(Отбор = "", "", "
		|	И ") + "ТекущаяТаблица." + ИмяПоля + " > &" + ИмяПараметра;
		
		УсловиеОтбора = УсловиеОтбора + ?(НомерПоля = 1, ?(ОпорныеПоля.Используемые.Количество() > 1, "(", "") + Отбор, "
		|		ИЛИ " + ТекстСОтступом(Отбор, "		"));
	
		Если КлючДанных.Свойство(ИмяПоляВКлючеДанных) Тогда
			ОписаниеЗапроса.Запрос.УстановитьПараметр(ИмяПараметра, КлючДанных[ИмяПоляВКлючеДанных]);
		Иначе
			ОписаниеЗапроса.Запрос.УстановитьПараметр(ИмяПараметра, Неопределено);
		КонецЕсли;
		ПоляВыбора = ПоляВыбора + ?(ПоляВыбора = "", "", ",
		|	") + "ТекущаяТаблица." + ИмяПоля;
		НомерПоля = НомерПоля + 1;
	КонецЦикла;
	
	Если ОпорныеПоля.Используемые.Количество() > 1 Тогда
		УсловиеОтбора  = УсловиеОтбора  + ")";
	КонецЕсли;
	
	НачальныйНомер = НомерПоля + 1;
	Для НомерПоля = НачальныйНомер По МаксимальноеКоличествоПолей Цикл
		УсловиеСоединения = УсловиеСоединения + ?(УсловиеСоединения = "", "", "
		|			И ") + "(КлючиДоступаКРегистрам.Поле" + НомерПоля + " = ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.Null))";
	КонецЦикла;
	
	Если ВидКлючаДанных = "ЭлементыБезКлючейПоПериоду" Тогда
		ИмяПоляПериода = ?(СвойстваТипа.ИмяКоллекции = "РегистрыРасчета", "ПериодРегистрации", "Период");
		ИмяПараметра = ИмяПоляПериода + Формат(Индекс, "ЧГ=");
		УсловиеОтбора = "(ТекущаяТаблица." + ИмяПоляПериода + " < &" + ИмяПараметра + "
		|	ИЛИ ТекущаяТаблица." + ИмяПоляПериода + " = &" + ИмяПараметра + "
		|		И " + ТекстСОтступом(УсловиеОтбора, "	") + ")";
		ОписаниеЗапроса.Запрос.УстановитьПараметр(ИмяПараметра, ПоследнийОбновленныйЭлемент.Дата);
	КонецЕсли;
	
	Если СвойстваОграничения.ОпорныеПоля.Используемые.Количество() = 1 Тогда
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	КОЛИЧЕСТВО(РАЗЛИЧНЫЕ &ПоляВыбора) КАК Количество
		|ИЗ
		|	&ТекущаяТаблица КАК ТекущаяТаблица
		|		ЛЕВОЕ СОЕДИНЕНИЕ ТекущийСписок КАК КлючиДоступаКРегистрам
		|		ПО (&УсловиеСоединения)
		|ГДЕ
		|	&УсловиеОтбора
		|	И КлючиДоступаКРегистрам.ДляВнешнихПользователей ЕСТЬ NULL";
	Иначе
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	КОЛИЧЕСТВО(*) КАК Количество
		|ИЗ
		|	(ВЫБРАТЬ РАЗЛИЧНЫЕ
		|		&ПоляВыбора КАК ПоляВыбора
		|	ИЗ
		|		&ТекущаяТаблица КАК ТекущаяТаблица
		|			ЛЕВОЕ СОЕДИНЕНИЕ ТекущийСписок КАК КлючиДоступаКРегистрам
		|			ПО (&УсловиеСоединения)
		|	ГДЕ
		|		&УсловиеОтбора
		|		И КлючиДоступаКРегистрам.ДляВнешнихПользователей ЕСТЬ NULL) КАК Комбинации";
		ПоляВыбора    = ТекстСОтступом(ПоляВыбора, "	");
		УсловиеОтбора = ТекстСОтступом(УсловиеОтбора, "	");
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "(&УсловиеСоединения)", УсловиеСоединения);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляВыбора",    ПоляВыбора);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбора", УсловиеОтбора);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ТекущийСписок", "РегистрСведений." + ИмяРегистраКлючей);
	
	Возврат ТекстЗапроса;
	
КонецФункции

Процедура ЗаполнитьДолиКоличестваЭлементовРегистра(ДолиКоличестваЭлементов, Элемент, СвойстваОграничения)
	
	Если Элемент.ВидКлючаДанных = "ЭлементыСУстаревшимиКлючами" Тогда
		
		ДолиКоличестваЭлементов.Обработанных = 0.0;
		ДолиКоличестваЭлементов.Оставшихся   = 0.5;
		
	ИначеЕсли Элемент.ВидКлючаДанных = "ЭлементыБезКлючейПоЗначениямПолей"
	      Или Элемент.ВидКлючаДанных = "ЭлементыБезКлючейПоПериоду" Тогда
		
		Если Элемент.ОбработатьУстаревшиеЭлементы Тогда
			ДолиКоличестваЭлементов.Обработанных = 0.5;
			ДолиКоличестваЭлементов.Оставшихся   = 0.4;
		Иначе
			ДолиКоличестваЭлементов.Обработанных = 0.5;
			ДолиКоличестваЭлементов.Оставшихся   = 0.5;
		КонецЕсли;
		
	ИначеЕсли Элемент.ВидКлючаДанных = "УстаревшиеЭлементы" Тогда
		
		Если ЗначениеЗаполнено(СвойстваОграничения.ИмяОтдельногоРегистраКлючей) Тогда
			ДолиКоличестваЭлементов.Обработанных = 0.90;
			ДолиКоличестваЭлементов.Оставшихся   = 0.09;
		Иначе
			ДолиКоличестваЭлементов.Обработанных = 0.9;
			ДолиКоличестваЭлементов.Оставшихся   = 0.1;
		КонецЕсли;
		
	Иначе // УстаревшиеЭлементыОбщегоРегистра.
		ДолиКоличестваЭлементов.Обработанных = 0.99;
		ДолиКоличестваЭлементов.Оставшихся   = 0.01;
	КонецЕсли;
	
КонецПроцедуры

Процедура ДобавитьТекстЗапросаКоличестваКлючейДоступа(ОписаниеЗапроса, Строка, Индекс, ДляВнешнихПользователей)
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	КОЛИЧЕСТВО(КлючиДоступа.Ссылка) КАК Количество
	|ИЗ
	|	Справочник.КлючиДоступа КАК КлючиДоступа
	|ГДЕ
	|	КлючиДоступа.Список = &Список
	|	И КлючиДоступа.ДляВнешнихПользователей = ЛОЖЬ";
	
	ИмяПараметра = "СписокКлючей" + Формат(Индекс, "ЧГ=");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Список", "&" + ИмяПараметра);
	ОписаниеЗапроса.Запрос.УстановитьПараметр(ИмяПараметра, Строка.Список);
	
	Если ДляВнешнихПользователей Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ЛОЖЬ", "ИСТИНА");
	КонецЕсли;
	
	ОписаниеЗапроса.ТекстыПакетаЗапросов.Добавить(ТекстЗапроса);
	Индекс = Индекс + 1;
	
КонецПроцедуры

Процедура ДобавитьТекстЗапросаКоличестваОставшихсяКлючейДоступа(ОписаниеЗапроса, Строка, Индекс, Контекст, ДляВнешнихПользователей)
	
	СвойстваСписка = Контекст.СвойстваСписков.Получить(Строка.Список);
	
	Если СвойстваСписка = Неопределено Тогда
		ПараметрыЗадания = Неопределено;
		
	ИначеЕсли ДляВнешнихПользователей Тогда
		ПараметрыЗадания = СвойстваСписка.ПоследнийОбновленныйКлючДоступаДляВнешнихПользователей;
	Иначе
		ПараметрыЗадания = СвойстваСписка.ПоследнийОбновленныйКлючДоступа;
	КонецЕсли;
	
	Если ТипЗнч(ПараметрыЗадания) <> Тип("ХранилищеЗначения") Тогда
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	НЕОПРЕДЕЛЕНО КАК Количество";
	Иначе
		ДолиКоличестваКлючейДоступа = Новый Структура("Обработанных, Оставшихся", 0, 1);
		ПараметрыЗадания = ПараметрыЗадания.Получить();
		
		Если ТипЗнч(ПараметрыЗадания) = Тип("Структура")
		   И ПараметрыЗадания.Свойство("ПоследнийОбновленныйЭлемент")
		   И ТипЗнч(ПараметрыЗадания.ПоследнийОбновленныйЭлемент) = Тип("Структура")
		   И ПараметрыЗадания.ПоследнийОбновленныйЭлемент.Свойство("ВидКлючаДанных")
		   И ПорядокВидаКлючаДанных(ПараметрыЗадания.ПоследнийОбновленныйЭлемент.ВидКлючаДанных) <> Неопределено
		   И ПараметрыЗадания.ПоследнийОбновленныйЭлемент.Свойство("КлючДанных") Тогда
			
			ПоследнийКлючДоступа = ПараметрыЗадания.ПоследнийОбновленныйЭлемент.КлючДанных;
			ЗаполнитьДолиКоличестваКлючейДоступа(ДолиКоличестваКлючейДоступа,
				ПараметрыЗадания.ПоследнийОбновленныйЭлемент);
		КонецЕсли;
		УсловиеОтбора = "";
		Если ТипЗнч(ПоследнийКлючДоступа) = Тип("СправочникСсылка.КлючиДоступа") Тогда
			ИмяПараметра = "СписокОбработанныхКлючей" + Формат(Индекс, "ЧГ=");
			УсловиеОтбора = "КлючиДоступа.Список = &" + ИмяПараметра;
			ОписаниеЗапроса.Запрос.УстановитьПараметр(ИмяПараметра, Строка.Список);
			
			УсловиеОтбора = УсловиеОтбора + "
			|	И КлючиДоступа.ДляВнешнихПользователей = " + ?(ДляВнешнихПользователей, "ИСТИНА", "ЛОЖЬ");
			
			ИмяПараметра = "ПоследнийКлючДоступа" + Формат(Индекс, "ЧГ=");
			УсловиеОтбора = УсловиеОтбора + "
			|	И КлючиДоступа.Ссылка > &" + ИмяПараметра;
			ОписаниеЗапроса.Запрос.УстановитьПараметр(ИмяПараметра, ПоследнийКлючДоступа);
		КонецЕсли;
		
		Если ЗначениеЗаполнено(УсловиеОтбора) Тогда
			ТекстЗапроса =
			"ВЫБРАТЬ
			|	КОЛИЧЕСТВО(*) КАК Количество
			|ИЗ
			|	Справочник.КлючиДоступа КАК КлючиДоступа
			|ГДЕ
			|	&УсловиеОтбора";
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбора", УсловиеОтбора);
		Иначе
			ТекстЗапроса =
			"ВЫБРАТЬ
			|	-1 КАК Количество";
		КонецЕсли;
		
		Если ДляВнешнихПользователей Тогда
			Строка.ДоляОбработанныхКлючейДоступаДляВнешнихПользователей = ДолиКоличестваКлючейДоступа.Обработанных;
			Строка.ДоляОставшихсяКлючейДоступаДляВнешнихПользователей   = ДолиКоличестваКлючейДоступа.Оставшихся;
		Иначе
			Строка.ДоляОбработанныхКлючейДоступаДляПользователей = ДолиКоличестваКлючейДоступа.Обработанных;
			Строка.ДоляОставшихсяКлючейДоступаДляПользователей   = ДолиКоличестваКлючейДоступа.Оставшихся;
		КонецЕсли;
	КонецЕсли;
	
	ОписаниеЗапроса.ТекстыПакетаЗапросов.Добавить(ТекстЗапроса);
	Индекс = Индекс + 1;
	
КонецПроцедуры

Процедура ЗаполнитьДолиКоличестваКлючейДоступа(ДолиКоличестваКлючейДоступа, Элемент)
	
	Если Элемент.ВидКлючаДанных = "ЭлементыСУстаревшимиПравами" Тогда
		Если Элемент.ОбработатьУстаревшиеЭлементы Тогда
			ДолиКоличестваКлючейДоступа.Обработанных = 0.0;
			ДолиКоличестваКлючейДоступа.Оставшихся   = 0.9;
		Иначе
			ДолиКоличестваКлючейДоступа.Обработанных = 0.0;
			ДолиКоличестваКлючейДоступа.Оставшихся   = 1.0;
		КонецЕсли;
	Иначе // УстаревшиеЭлементы.
		ДолиКоличестваКлючейДоступа.Обработанных = 0.9;
		ДолиКоличестваКлючейДоступа.Оставшихся   = 0.1;
	КонецЕсли;
	
КонецПроцедуры

Функция ИдентификаторыСписковСОграничением(ДействующиеПараметры)
	
	ДействующиеПараметры = ДействующиеПараметрыОграниченияДоступа(Неопределено, Неопределено, Ложь);
	
	Списки = Новый Массив;
	Для Каждого ОписаниеВерсии Из ДействующиеПараметры.ВерсииОграниченийСписков Цикл
		Списки.Добавить(ОписаниеВерсии.Ключ);
	КонецЦикла;
	
	Возврат ОбщегоНазначения.ИдентификаторыОбъектовМетаданных(Списки, Ложь);
	
КонецФункции

Функция ТекущаяДатаНаСервере() Экспорт
	
	// АПК:143-выкл - №643.2.1 Требуется ТекущаяДата сервера, а не ТекущаяДатаСеанса,
	// так как именно ТекущаяДата записывается в журнал регистрации.
	Возврат ТекущаяДата();
	// АПК:143-вкл.
	
КонецФункции

#КонецОбласти

#КонецОбласти

#КонецОбласти
