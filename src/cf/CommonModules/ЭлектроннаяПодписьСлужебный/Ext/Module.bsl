///////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2021, ООО 1С-Софт
// Все права защищены. Эта программа и сопроводительные материалы предоставляются 
// в соответствии с условиями лицензии Attribution 4.0 International (CC BY 4.0)
// Текст лицензии доступен по ссылке:
// https://creativecommons.org/licenses/by/4.0/legalcode
///////////////////////////////////////////////////////////////////////////////////////////////////////

#Область СлужебныйПрограммныйИнтерфейс

// Добавляет сертификаты к переданному объекту.
Процедура ДобавитьСертификатыШифрования(ОбъектСсылка, МассивОтпечатков) Экспорт
	УстановитьПривилегированныйРежим(Истина);
	
	ПорядковыйНомер = 1;
	Для Каждого ОтпечатокСтруктура Из МассивОтпечатков Цикл
		МенеджерЗаписи = РегистрыСведений.СертификатыШифрования.СоздатьМенеджерЗаписи();
		МенеджерЗаписи.ЗашифрованныйОбъект = ОбъектСсылка;
		МенеджерЗаписи.Отпечаток = ОтпечатокСтруктура.Отпечаток;
		МенеджерЗаписи.Представление = ОтпечатокСтруктура.Представление;
		МенеджерЗаписи.Сертификат = Новый ХранилищеЗначения(ОтпечатокСтруктура.Сертификат);
		МенеджерЗаписи.ПорядковыйНомер = ПорядковыйНомер;
		ПорядковыйНомер = ПорядковыйНомер + 1;
		МенеджерЗаписи.Записать();
	КонецЦикла;

КонецПроцедуры

// Очищает записи о сертификатах шифрования после расшифровка объекта.
Процедура ОчиститьСертификатыШифрования(ОбъектСсылка) Экспорт
	УстановитьПривилегированныйРежим(Истина);
	
	НаборЗаписей = РегистрыСведений.СертификатыШифрования.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.ЗашифрованныйОбъект.Установить(ОбъектСсылка);
	НаборЗаписей.Записать(Истина);

КонецПроцедуры

// Только для внутреннего использования.
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//
Процедура ОформитьСписокПодписей(Форма, ИмяСпискаПодписей) Экспорт
	
	Элемент = Форма.УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяСпискаПодписей);
	
	ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяСпискаПодписей + ".ПодписьВерна");
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Ложь;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветаСтиля.ЦветОсобогоТекста);
	
КонецПроцедуры

// Определяет доступность электронной подписи для объекта (по его типу)
Функция ДоступнаЭлектроннаяПодпись(ТипОбъекта) Экспорт
	
	Возврат ЭлектроннаяПодписьСлужебныйПовтИсп.ТипыВладельцев().Получить(ТипОбъекта) <> Неопределено;
	
КонецФункции

// Возвращает адрес сертификата во временном хранилище и его расширение.
//
// Параметры:
//  СведенияОЭлектроннойПодписи - Структура - строка с подписями из массива полученного методом ЭлектроннаяПодпись.УстановленныеПодписи.
//  УникальныйИдентификатор     - УникальныйИдентификатор - идентификатор формы.
// 
// Возвращаемое значение:
//  Структура:
//   * РасширениеСертификата - Строка - расширение файла сертификата.
//   * АдресСертификата      - Строка - адрес во временном хранилище, по которому был помещен сертификат.
//
Функция ДанныеПоСертификату(СведенияОЭлектроннойПодписи, УникальныйИдентификатор) Экспорт
	
	Результат = Новый Структура("РасширениеСертификата, АдресСертификата");
	ДанныеСертификата = СведенияОЭлектроннойПодписи.Сертификат.Получить();
		
		Если ТипЗнч(ДанныеСертификата) = Тип("Строка") Тогда
			Результат.РасширениеСертификата = "txt";
			Результат.АдресСертификата = ПоместитьВоВременноеХранилище(
				ДвоичныеДанныеСтроки(ДанныеСертификата), УникальныйИдентификатор);
		Иначе
			Результат.РасширениеСертификата = "cer";
			Результат.АдресСертификата = ПоместитьВоВременноеХранилище(
				ДанныеСертификата, УникальныйИдентификатор);
		КонецЕсли;
		
	Возврат Результат;
	
КонецФункции

// Возвращает признак возможности интерактивного использования электронных подписей и шифрования 
// для текущего пользователя.
//
// Возвращаемое значение:
//  Булево - если Истина, то интерактивное использование электронных подписей и шифрование возможно.
//
Функция ИспользоватьИнтерактивноеДобавлениеЭлектронныхПодписейИШифрование() Экспорт
	Возврат ПравоДоступа("ИнтерактивноеДобавление", Метаданные.Справочники.СертификатыКлючейЭлектроннойПодписиИШифрования);
КонецФункции

// Из переданных имен файлов выделяются имена файлов данных и имена файлов их подписей.
// Сопоставление происходит по правилам формирования имени подписи и расширения файла подписи (p7s).
// Например:
//  Имя файла данных:  "example.txt"
//  имя файла подписи: "example-Ivanov Petr.p7s"
//  имя файла подписи: "example-Ivanov Petr (1).p7s".
//
// Параметры:
//  ИменаФайлов - Массив - имена файлов типа Строка.
//
// Возвращаемое значение:
//  Соответствие из КлючИЗначение:
//   * Ключ     - Строка - имя файла.
//   * Значение - Массив - имена файлов подписей типа Строка.
// 
Функция ИменаФайловПодписейИменФайловДанных(ИменаФайлов) Экспорт
	
	РасширениеДляФайловПодписи = ЭлектроннаяПодпись.ПерсональныеНастройки().РасширениеДляФайловПодписи;
	
	Результат = Новый Соответствие;
	
	// Разделяем файлы по расширению.
	ИменаФайловДанных = Новый Массив;
	ИменаФайловПодписей = Новый Массив;
	
	Для Каждого ИмяФайла Из ИменаФайлов Цикл
		Если СтрЗаканчиваетсяНа(ИмяФайла, РасширениеДляФайловПодписи) Тогда
			ИменаФайловПодписей.Добавить(ИмяФайла);
		Иначе
			ИменаФайловДанных.Добавить(ИмяФайла);
		КонецЕсли;
	КонецЦикла;
	
	// Отсортируем имена файлов данных по убыванию числа символов в строке.
	
	Для ИндексА = 1 По ИменаФайловДанных.Количество() Цикл
		ИндексМАКС = ИндексА; // Считаем что текущий файл имеет самое большое число символов.
		Для ИндексБ = ИндексА+1 По ИменаФайловДанных.Количество() Цикл
			Если СтрДлина(ИменаФайловДанных[ИндексМАКС-1]) > СтрДлина(ИменаФайловДанных[ИндексБ-1]) Тогда
				ИндексМАКС = ИндексБ;
			КонецЕсли;
		КонецЦикла;
		своп = ИменаФайловДанных[ИндексА-1];
		ИменаФайловДанных[ИндексА-1] = ИменаФайловДанных[ИндексМАКС-1];
		ИменаФайловДанных[ИндексМАКС-1] = своп;
	КонецЦикла;
	
	// Поиск соответствий имен файлов.
	Для Каждого ИмяФайлаДанных Из ИменаФайловДанных Цикл
		Результат.Вставить(ИмяФайлаДанных, НайтиИменаФайловПодписей(ИмяФайлаДанных, ИменаФайловПодписей));
	КонецЦикла;
	
	// Оставшиеся файлы подписей не распознаны как подписи относящиеся к какому то файлу.
	Для Каждого ИмяФайлаПодписи Из ИменаФайловПодписей Цикл
		Результат.Вставить(ИмяФайлаПодписи, Новый Массив);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Только для внутреннего использования.
Функция СертификатыПоПорядкуДоКорневого(ДанныеСертификатов) Экспорт
	
	ПоПорядку = Новый Массив;
	Сертификаты = Новый Соответствие;
	Для Каждого ДанныеСертификата Из ДанныеСертификатов Цикл
		ПоПорядку.Добавить(ДанныеСертификата);
		Сертификаты.Вставить(Новый СертификатКриптографии(ДанныеСертификата), ДанныеСертификата);
	КонецЦикла;
	
	СертификатыПоСубъектам = Новый Соответствие;
	Для Каждого ОписаниеСертификата Из Сертификаты Цикл
		СертификатыПоСубъектам.Вставить(ОписаниеСертификата.Ключ.Субъект.CN, ОписаниеСертификата.Ключ);
	КонецЦикла;
	
	Для Каждого ОписаниеСертификата Из Сертификаты Цикл
		Сертификат         = ОписаниеСертификата.Ключ;
		ДанныеСертификата  = ОписаниеСертификата.Значение;
		СертификатИздателя = СертификатыПоСубъектам.Получить(Сертификат.Издатель.CN);
		Если СертификатИздателя = Неопределено Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'В сертификатах подписи не удалось найти сертификат издателя
				           |%1
				           |сертификата %2'"),
				Сертификат.Издатель.CN,
				Сертификат.Субъект.CN);
		КонецЕсли;
		Позиция = ПоПорядку.Найти(ДанныеСертификата);
		Если Сертификат.Издатель.CN = Сертификат.Субъект.CN Тогда
			Если Позиция <> ПоПорядку.Количество() - 1 Тогда
				ПоПорядку.Удалить(Позиция);
				ПоПорядку.Добавить(ДанныеСертификата);
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		ПозицияИздателя = ПоПорядку.Найти(Сертификаты.Получить(СертификатИздателя));
		Если Позиция + 1 = ПозицияИздателя Тогда
			Продолжить;
		КонецЕсли;
		ПоПорядку.Удалить(Позиция);
		ПозицияИздателя = ПоПорядку.Найти(Сертификаты.Получить(СертификатИздателя));
		ПоПорядку.Вставить(ПозицияИздателя, ДанныеСертификата);
	КонецЦикла;
	
	Возврат ПоПорядку;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обработчики событий подсистем конфигурации.

// См. ОбновлениеИнформационнойБазыБСП.ПриДобавленииОбработчиковОбновления.
Процедура ПриДобавленииОбработчиковОбновления(Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.НачальноеЗаполнение = Истина;
	Обработчик.Процедура = "Справочники.ПрограммыЭлектроннойПодписиИШифрования.ЗаполнитьНачальныеНастройки";
	Обработчик.РежимВыполнения = "Монопольно";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "3.1.3.241";
	Обработчик.Комментарий =
		НСтр("ru = 'Обновление справочника Программы электронной подписи и шифрования.'");
	Обработчик.Идентификатор = Новый УникальныйИдентификатор("8e76369a-e16c-415d-bfeb-95e7e5f07a00");
	Обработчик.Процедура = "Справочники.ПрограммыЭлектроннойПодписиИШифрования.ОбработатьДанныеДляПереходаНаНовуюВерсию";
	Обработчик.РежимВыполнения = "Отложенно";
	Обработчик.ПроцедураЗаполненияДанныхОбновления = "Справочники.ПрограммыЭлектроннойПодписиИШифрования.ЗарегистрироватьДанныеКОбработкеДляПереходаНаНовуюВерсию";
	Обработчик.ЧитаемыеОбъекты      = "Справочник.ПрограммыЭлектроннойПодписиИШифрования";
	Обработчик.ИзменяемыеОбъекты    = "Справочник.ПрограммыЭлектроннойПодписиИШифрования";
	Обработчик.ОчередьОтложеннойОбработки = 1;
	Обработчик.ПроцедураПроверки    = "ОбновлениеИнформационнойБазы.ДанныеОбновленыНаНовуюВерсиюПрограммы";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "3.1.3.190";
	Обработчик.Комментарий = НСтр("ru = 'Удаление путей из заполненных имен файлов подписей.'");
	Обработчик.Идентификатор = Новый УникальныйИдентификатор("781a39e1-48e9-4145-8d98-93c1040c2755");
	Обработчик.Процедура = "РегистрыСведений.ЭлектронныеПодписи.ОбработатьДанныеДляПереходаНаНовуюВерсию";
	Обработчик.РежимВыполнения = "Отложенно";
	Обработчик.ПроцедураЗаполненияДанныхОбновления = "РегистрыСведений.ЭлектронныеПодписи.ЗарегистрироватьДанныеКОбработкеДляПереходаНаНовуюВерсию";
	Обработчик.ЧитаемыеОбъекты      = "РегистрСведений.ЭлектронныеПодписи";
	Обработчик.ИзменяемыеОбъекты    = "РегистрСведений.ЭлектронныеПодписи";
	Обработчик.ОчередьОтложеннойОбработки = 10;
	Обработчик.ПроцедураПроверки    = "ОбновлениеИнформационнойБазы.ДанныеОбновленыНаНовуюВерсиюПрограммы";
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
		Обработчик.ПриоритетыВыполнения = ОбновлениеИнформационнойБазы.ПриоритетыВыполненияОбработчика();
		Приоритет = Обработчик.ПриоритетыВыполнения.Добавить();
		Приоритет.Порядок = "После";
		Приоритет.Процедура = "РаботаСФайлами.ПеренестиЭлектронныеПодписиИСертификатыШифрованияВРегистрыСведений";
	КонецЕсли;

	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ВнешниеКомпоненты")
		И Не ОбщегоНазначения.РазделениеВключено() Тогда
		Обработчик = Обработчики.Добавить();
		Обработчик.НачальноеЗаполнение = Истина;
		Обработчик.Версия = "3.1.5.220";
		Обработчик.Комментарий =
			НСтр("ru = 'Добавление внешней компоненты ExtraCryptoAPI в справочник Внешние компоненты.'");
		Обработчик.Идентификатор = Новый УникальныйИдентификатор("9fcfccd5-ec23-4ba9-8b2c-8f0ae269c271");
		Обработчик.Процедура = "ЭлектроннаяПодписьСлужебный.ДобавитьКомпонентуExtraCryptoAPI";
		Обработчик.РежимВыполнения = "Оперативно";
	КонецЕсли;

КонецПроцедуры

// См. ОбщегоНазначенияПереопределяемый.ПриДобавленииПереименованийОбъектовМетаданных.
Процедура ПриДобавленииПереименованийОбъектовМетаданных(Итог) Экспорт
	
	Библиотека = "СтандартныеПодсистемы";
	
	СтароеИмя = "Роль.ИспользованиеЭЦП";
	НовоеИмя  = "Роль.ИспользованиеЭП";
	ОбщегоНазначения.ДобавитьПереименование(Итог, "2.2.1.7", СтароеИмя, НовоеИмя, Библиотека);
	
	СтароеИмя = "Подсистема.СтандартныеПодсистемы.Подсистема.ЭлектроннаяЦифроваяПодпись";
	НовоеИмя  = "Подсистема.СтандартныеПодсистемы.Подсистема.ЭлектроннаяПодпись";
	ОбщегоНазначения.ДобавитьПереименование(Итог, "2.2.1.7", СтароеИмя, НовоеИмя, Библиотека);
	
	СтароеИмя = "Роль.ИспользованиеЭП";
	НовоеИмя  = "Роль.ИспользованиеЭлектроннойПодписиИШифрования";
	ОбщегоНазначения.ДобавитьПереименование(Итог, "2.3.1.10", СтароеИмя, НовоеИмя, Библиотека);
	
	СтароеИмя = "Роль.ИспользованиеЭлектроннойПодписиИШифрования";
	НовоеИмя  = "Роль.ДобавлениеИзменениеЭлектронныхПодписейИШифрование";
	ОбщегоНазначения.ДобавитьПереименование(Итог, "2.3.3.2", СтароеИмя, НовоеИмя, Библиотека);
	
КонецПроцедуры

// См. ОбщегоНазначенияПереопределяемый.ПриДобавленииПараметровРаботыКлиента.
Процедура ПриДобавленииПараметровРаботыКлиента(Параметры) Экспорт
	
	Если ОбщегоНазначения.ДоступноИспользованиеРазделенныхДанных() Тогда
		НастройкиПодсистемы = Новый Структура;
		НастройкиПодсистемы.Вставить("ПерсональныеНастройки", ЭлектроннаяПодпись.ПерсональныеНастройки());
		НастройкиПодсистемы.Вставить("ОбщиеНастройки",        ЭлектроннаяПодпись.ОбщиеНастройки());
		НастройкиПодсистемы = Новый ФиксированнаяСтруктура(НастройкиПодсистемы);
		Параметры.Вставить("ЭлектроннаяПодпись", НастройкиПодсистемы);
	КонецЕсли;
	
КонецПроцедуры

// См. ЗагрузкаДанныхИзФайлаПереопределяемый.ПриОпределенииСправочниковДляЗагрузкиДанных.
Процедура ПриОпределенииСправочниковДляЗагрузкиДанных(ЗагружаемыеСправочники) Экспорт
	
	// Загрузка в справочник ПрограммыЭлектроннойПодписиИШифрования запрещена.
	СтрокаТаблицы = ЗагружаемыеСправочники.Найти(Метаданные.Справочники.ПрограммыЭлектроннойПодписиИШифрования.ПолноеИмя(), "ПолноеИмя");
	Если СтрокаТаблицы <> Неопределено Тогда 
		ЗагружаемыеСправочники.Удалить(СтрокаТаблицы);
	КонецЕсли;
	
	// Загрузка в справочник СертификатыКлючейЭлектроннойПодписиИШифрования запрещена.
	СтрокаТаблицы = ЗагружаемыеСправочники.Найти(Метаданные.Справочники.СертификатыКлючейЭлектроннойПодписиИШифрования.ПолноеИмя(), "ПолноеИмя");
	Если СтрокаТаблицы <> Неопределено Тогда 
		ЗагружаемыеСправочники.Удалить(СтрокаТаблицы);
	КонецЕсли;
	
КонецПроцедуры

// См. ГрупповоеИзменениеОбъектовПереопределяемый.ПриОпределенииОбъектовСРедактируемымиРеквизитами.
Процедура ПриОпределенииОбъектовСРедактируемымиРеквизитами(Объекты) Экспорт
	Объекты.Вставить(Метаданные.Справочники.ПрограммыЭлектроннойПодписиИШифрования.ПолноеИмя(), "РеквизитыРедактируемыеВГрупповойОбработке");
	Объекты.Вставить(Метаданные.Справочники.СертификатыКлючейЭлектроннойПодписиИШифрования.ПолноеИмя(), "РеквизитыНеРедактируемыеВГрупповойОбработке");
КонецПроцедуры

// См. ПолучениеВнешнихКомпонентВМоделиСервисаПереопределяемый.ПриОпределенииИспользуемыхВерсийВнешнихКомпонент.
Процедура ПриОпределенииИспользуемыхВерсийВнешнихКомпонент(Идентификаторы) Экспорт

	Идентификаторы.Добавить(ЭлектроннаяПодписьСлужебныйКлиентСервер.ОписаниеКомпоненты().ИмяОбъекта);

КонецПроцедуры

#Область ПоставляемыеДанные

// См. ПоставляемыеДанныеПереопределяемый.ПолучитьОбработчикиПоставляемыхДанных
Процедура ПриОпределенииОбработчиковПоставляемыхДанных(Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.ВидДанных = "ОшибкиКриптографии";
	Обработчик.КодОбработчика = "ОшибкиКриптографии";
	Обработчик.Обработчик = ЭлектроннаяПодписьСлужебный;
	
КонецПроцедуры

// Вызывается при получении уведомления о новых данных.
// В теле следует проверить, необходимы ли эти данные приложению, 
// и если да - установить флажок Загружать.
// 
// Параметры:
//   Дескриптор - ОбъектXDTO
//   Загружать - Булево - Истина, если загружать, Ложь - иначе.
//
Процедура ДоступныНовыеДанные(Знач Дескриптор, Загружать) Экспорт
	
	Загружать = Дескриптор.DataType = "ОшибкиКриптографии";
	
КонецПроцедуры

// Вызывается после вызова ДоступныНовыеДанные, позволяет разобрать данные.
//
// Параметры:
//   Дескриптор - ОбъектXDTO
//   ПутьКФайлу - Строка - полное имя извлеченного файла. Файл будет автоматически удален 
//                  после завершения процедуры. Если в менеджере сервиса не был
//                  указан файл - значение аргумента равно Неопределено.
//
Процедура ОбработатьНовыеДанные(Знач Дескриптор, Знач ПутьКФайлу) Экспорт
	
	Если Дескриптор.DataType = "ОшибкиКриптографии" Тогда
		ЗаписатьДанныеКлассификатора(Новый ДвоичныеДанные(ПутьКФайлу));
	КонецЕсли;
	
КонецПроцедуры

// Вызывается при отмене обработки данных в случае сбоя.
//
// Параметры:
//   Дескриптор - ОбъектXDTO
//
Процедура ОбработкаДанныхОтменена(Знач Дескриптор) Экспорт 
	
КонецПроцедуры

#КонецОбласти

#Область ОблачнаяПодпись

// Определяет доступность подсистемы облачной подписи
//
// Возвращаемое значение:
//  Булево
//
Функция ИспользоватьСервисОблачнойПодписи() Экспорт
	
	Результат = Ложь;
	
	// Локализация
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ЭлектроннаяОблачнаяПодпись") Тогда
		МодульСервисКриптографииDSS = ОбщегоНазначения.ОбщийМодуль("СервисКриптографииDSS");
		Результат = МодульСервисКриптографииDSS.ИспользоватьСервисОблачнойПодписи();
	КонецЕсли;
	// Конец Локализация
	
	Возврат Результат;
	
КонецФункции

// Определяет тип программы облачной подписи.
//
// Возвращаемое значение:
//  Неопределено 
//  Тип
//
Функция ПолучитьТипОблачнойПодписи() Экспорт
	
	Результат = Неопределено;
	
	// Локализация
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ЭлектроннаяОблачнаяПодпись") Тогда
		МодульСервисКриптографииDSSКлиентСервер = ОбщегоНазначения.ОбщийМодуль("СервисКриптографииDSSКлиентСервер");
		Результат = МодульСервисКриптографииDSSКлиентСервер.ПолучитьТипОблачнойПодписи();
	КонецЕсли;
	// Конец Локализация
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Возвращает дополнительные параметры создания менеджера криптографии.
//
// Возвращаемое значение:
//   Структура:
//    * ПоказатьОшибку - Булево - если Истина, тогда будет вызвано исключение, содержащее описание ошибки.
//
//    * ОписаниеОшибки - Строка - возвращаемое описание ошибки, когда функция возвратила значение Неопределено.
//                     - Структура - см. ЭлектроннаяПодписьСлужебныйКлиентСервер.НовоеОписаниеОшибок
//
//    * Программа       - Неопределено - возвращает менеджер криптографии первой
//                      программы из справочника для которой удалось его создать.
//                      - СправочникСсылка.ПрограммыЭлектроннойПодписиИШифрования - программа
//                      для которой нужно создать и вернуть менеджер криптографии.
//                      - Структура - см. ЭлектроннаяПодпись.НовоеОписаниеПрограммы
//
//    * АлгоритмПодписи - Строка - если параметр заполнен, возвращает программу с указанным алгоритмом подписи.
//
Функция ПараметрыСозданияМенеджераКриптографии() Экспорт
	
	ПараметрыСозданияМенеджераКриптографии = Новый Структура;
	ПараметрыСозданияМенеджераКриптографии.Вставить("Программа", Неопределено);
	ПараметрыСозданияМенеджераКриптографии.Вставить("ПоказатьОшибку", Ложь);
	ПараметрыСозданияМенеджераКриптографии.Вставить("ОписаниеОшибки", "");
	ПараметрыСозданияМенеджераКриптографии.Вставить("АлгоритмПодписи", "");
	
	Возврат ПараметрыСозданияМенеджераКриптографии;
	
КонецФункции

// Возвращает менеджер криптографии (на сервере) для указанной программы.
//
// Параметры:
//  Операция                       - Строка - если не пустая, то должна содержать одну из строк, которые определяют
//                                 операцию для вставки в описание ошибки: Подписание, ПроверкаПодписи, Шифрование,
//                                 Расшифровка, ПроверкаСертификата, ПолучениеСертификатов.
//  ПараметрыМенеджераКриптографии - см. ЭлектроннаяПодписьСлужебный.ПараметрыСозданияМенеджераКриптографии.
//
// Возвращаемое значение:
//   МенеджерКриптографии - менеджер криптографии.
//   Неопределено - произошла ошибка, описание которой в параметре ОписаниеОшибки.
//
Функция МенеджерКриптографии(Операция, ПараметрыСозданияМенеджераКриптографии = Неопределено) Экспорт
	
	Если ПараметрыСозданияМенеджераКриптографии = Неопределено Тогда
		ПараметрыСозданияМенеджераКриптографии = ПараметрыСозданияМенеджераКриптографии();
	КонецЕсли;
	
	Программа = ПараметрыСозданияМенеджераКриптографии.Программа;
	ПоказатьОшибку = ПараметрыСозданияМенеджераКриптографии.ПоказатьОшибку;
	АлгоритмПодписи = ПараметрыСозданияМенеджераКриптографии.АлгоритмПодписи;
	
	ИмяКомпьютера = ИмяКомпьютера();
	ОписаниеОшибок = ЭлектроннаяПодписьСлужебныйКлиентСервер.НовоеОписаниеОшибок(ИмяКомпьютера);
	Менеджер = НовыйМенеджерКриптографии(Программа,
		ОписаниеОшибок.Ошибки, АлгоритмПодписи, Операция);
	
	Если Менеджер <> Неопределено Тогда
		Возврат Менеджер;
	КонецЕсли;
	
	Если Операция = "Подписание" Тогда
		ЗаголовокОшибки = НСтр("ru = 'Не удалось подписать данные на сервере %1 по причине:'");
		
	ИначеЕсли Операция = "ПроверкаПодписи" Тогда
		ЗаголовокОшибки = НСтр("ru = 'Не удалось проверить подпись на сервере %1 по причине:'");
		
	ИначеЕсли Операция = "Шифрование" Тогда
		ЗаголовокОшибки = НСтр("ru = 'Не удалось зашифровать данные на сервере %1 по причине:'");
		
	ИначеЕсли Операция = "Расшифровка" Тогда
		ЗаголовокОшибки = НСтр("ru = 'Не удалось расшифровать данные на сервере %1 по причине:'");
		
	ИначеЕсли Операция = "ПроверкаСертификата" Тогда
		ЗаголовокОшибки = НСтр("ru = 'Не удалось проверить сертификат на сервере %1 по причине:'");
		
	ИначеЕсли Операция = "ПолучениеСертификатов" Тогда
		ЗаголовокОшибки = НСтр("ru = 'Не удалось получить сертификаты на сервере %1 по причине:'");
		
	ИначеЕсли Операция <> "" Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка в функции МенеджерКриптографии.
			           |Неверное значение параметра Операция ""%1"".'"), Операция);
		
	ИначеЕсли ТипЗнч(ПараметрыСозданияМенеджераКриптографии.ОписаниеОшибки) = Тип("Структура")
		И ПараметрыСозданияМенеджераКриптографии.ОписаниеОшибки.Свойство("ЗаголовокОшибки") Тогда
		
		ЗаголовокОшибки = ПараметрыСозданияМенеджераКриптографии.ОписаниеОшибки.ЗаголовокОшибки;
	Иначе
		ЗаголовокОшибки = НСтр("ru = 'Не удалось выполнить операцию на сервере %1 по причине:'");
	КонецЕсли;
	
	ЗаголовокОшибки = СтрЗаменить(ЗаголовокОшибки, "%1", ИмяКомпьютера);
	ОписаниеОшибок.ЗаголовокОшибки = ЗаголовокОшибки;
	
	ЭлектроннаяПодписьСлужебныйКлиентСервер.МенеджерКриптографииЗаполнитьПредставлениеОшибок(
		ОписаниеОшибок,
		Программа,
		АлгоритмПодписи,
		Пользователи.ЭтоПолноправныйПользователь(,, Ложь),
		Истина);
	
	Если ТипЗнч(ПараметрыСозданияМенеджераКриптографии.ОписаниеОшибки) = Тип("Структура") Тогда
		ПараметрыСозданияМенеджераКриптографии.ОписаниеОшибки = ОписаниеОшибок;
	Иначе
		ПараметрыСозданияМенеджераКриптографии.ОписаниеОшибки = ОписаниеОшибок.ОписаниеОшибки;
	КонецЕсли;
	
	Если ПоказатьОшибку Тогда
		ВызватьИсключение ОписаниеОшибок.ОписаниеОшибки;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Находит сертификат на компьютере по строке отпечатка.
//
// Параметры:
//   Отпечаток              - Строка - Base64 кодированный отпечаток сертификата.
//   ТолькоВЛичномХранилище - Булево - если Истина, тогда искать в личном хранилище, иначе везде.
//
// Возвращаемое значение:
//   СертификатКриптографии - сертификат электронной подписи и шифрования.
//   Неопределено - сертификат не существует.
//
Функция ПолучитьСертификатПоОтпечатку(Отпечаток, ТолькоВЛичномХранилище,
			ПоказатьОшибку = Истина, Программа = Неопределено, ОписаниеОшибки = "") Экспорт
	
	ПараметрыСоздания = ПараметрыСозданияМенеджераКриптографии();
	ПараметрыСоздания.Программа = Программа;
	ПараметрыСоздания.ПоказатьОшибку = ПоказатьОшибку;
	ПараметрыСоздания.ОписаниеОшибки = ОписаниеОшибки;
	
	МенеджерКриптографии = МенеджерКриптографии("ПолучениеСертификатов", ПараметрыСоздания);
	
	ОписаниеОшибки = ПараметрыСоздания.ОписаниеОшибки;
	Если МенеджерКриптографии = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ТипХранилища = ЭлектроннаяПодписьСлужебныйКлиентСервер.ТипХранилищаДляПоискаСертификата(ТолькоВЛичномХранилище);
	
	Попытка
		ДвоичныеДанныеОтпечатка = Base64Значение(Отпечаток);
	Исключение
		Если ПоказатьОшибку Тогда
			ВызватьИсключение;
		КонецЕсли;
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
	КонецПопытки;
	
	Если Не ЗначениеЗаполнено(ПредставлениеОшибки) Тогда
		Попытка
			ХранилищеСертификатовКриптографии = МенеджерКриптографии.ПолучитьХранилищеСертификатов(ТипХранилища);
		Исключение
			Если ПоказатьОшибку Тогда
				ВызватьИсключение;
			КонецЕсли;
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			ПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
		КонецПопытки;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ПредставлениеОшибки) Тогда
		Попытка
			Сертификат = ХранилищеСертификатовКриптографии.НайтиПоОтпечатку(ДвоичныеДанныеОтпечатка);
		Исключение
			Если ПоказатьОшибку Тогда
				ВызватьИсключение;
			КонецЕсли;
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			ПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
		КонецПопытки;
	КонецЕсли;
	
	Если ТипЗнч(Сертификат) = Тип("СертификатКриптографии") Тогда
		Возврат Сертификат;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПредставлениеОшибки) Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Сертификат не установлен на сервере по причине:
			           |%1'")
			+ Символы.ПС,
			ПредставлениеОшибки);
	Иначе
		ТекстОшибки = НСтр("ru = 'Сертификат не установлен на сервере.'");
	КонецЕсли;
		
	Если Не Пользователи.ЭтоПолноправныйПользователь(,, Ложь) Тогда
		ТекстОшибки = ТекстОшибки + Символы.ПС + НСтр("ru = 'Обратитесь к администратору.'")
	КонецЕсли;
	
	ТекстОшибки = СокрП(ТекстОшибки);
	
	Если ТипЗнч(ОписаниеОшибки) = Тип("Структура") Тогда
		ОписаниеОшибки = Новый Структура;
		ОписаниеОшибки.Вставить("ОписаниеОшибки", ТекстОшибки);
	Иначе
		ОписаниеОшибки = ПредставлениеОшибки;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Только для внутреннего использования.
Функция ДобавкаВремени() Экспорт
	
	Возврат ТекущаяДатаСеанса() - ТекущаяУниверсальнаяДата();
	
КонецФункции

// Сохраняет настройки текущего пользователя для работы с электронной подписью.
Процедура СохранитьПерсональныеНастройки(ПерсональныеНастройки) Экспорт
	
	КлючПодсистемы = КлючХраненияНастроек();
	
	Для Каждого КлючИЗначение Из ПерсональныеНастройки Цикл
		ОбщегоНазначения.ХранилищеОбщихНастроекСохранить(КлючПодсистемы, КлючИЗначение.Ключ,
			КлючИЗначение.Значение);
	КонецЦикла;
	
КонецПроцедуры

// Ключ, который используется для хранения настроек подсистемы.
Функция КлючХраненияНастроек() Экспорт
	
	Возврат "ЭЦП"; // Не заменять на "ЭП". Используется для обратной совместимости.
	
КонецФункции

// Возвращаемое значение:
//  Структура:
//   * ТолькоПросмотр     - Булево - если установить Истина, редактирование будет запрещено.
//   * ПроверкаЗаполнения - Булево - если установить Истина, заполнение будет проверяться.
//   * Видимость          - Булево - если установить Истина, реквизит станет невидимым.
//   * ЗначениеЗаполнения - Произвольный - начальное значение реквизита нового объекта.
//                        - Неопределено - заполнение не требуется.
//
Функция НовыеПараметрыРеквизитаСертификата()
	
	Параметры = Новый Структура;
	Параметры.Вставить("ТолькоПросмотр", Ложь);
	Параметры.Вставить("ПроверкаЗаполнения", Ложь);
	Параметры.Вставить("Видимость", Ложь);
	Параметры.Вставить("ЗначениеЗаполнения", Неопределено);
	
	Возврат Параметры;
	
КонецФункции

// Возвращаемое значение:
//  Структура:
//   * Наименование - см. НовыеПараметрыРеквизитаСертификата
//   * Организация  - см. НовыеПараметрыРеквизитаСертификата
//   * УсиленнаяЗащитаЗакрытогоКлюча - см. НовыеПараметрыРеквизитаСертификата
//
Функция НовыеПараметрыРеквизитовСертификата() Экспорт
	
	Возврат Новый Структура;
	
КонецФункции

// Только для внутреннего использования.
// Параметры:
//  Ссылка - СправочникСсылка.СертификатыКлючейЭлектроннойПодписиИШифрования
//  Сертификат - СертификатКриптографии
//  ПараметрыРеквизитов - см. НовыеПараметрыРеквизитовСертификата
//
Процедура ПередНачаломРедактированияСертификатаКлюча(Ссылка, Сертификат, ПараметрыРеквизитов) Экспорт
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("ИмяРеквизита",       Новый ОписаниеТипов("Строка"));
	Таблица.Колонки.Добавить("ТолькоПросмотр",     Новый ОписаниеТипов("Булево"));
	Таблица.Колонки.Добавить("ПроверкаЗаполнения", Новый ОписаниеТипов("Булево"));
	Таблица.Колонки.Добавить("Видимость",          Новый ОписаниеТипов("Булево"));
	Таблица.Колонки.Добавить("ЗначениеЗаполнения");
	
	ЭлектроннаяПодписьПереопределяемый.ПередНачаломРедактированияСертификатаКлюча(Ссылка, Сертификат, Таблица);
	
	ПараметрыРеквизитов = НовыеПараметрыРеквизитовСертификата();
	
	Для Каждого Строка Из Таблица Цикл
		Параметры = НовыеПараметрыРеквизитаСертификата();
		ЗаполнитьЗначенияСвойств(Параметры, Строка);
		ПараметрыРеквизитов.Вставить(Строка.ИмяРеквизита, Параметры);
	КонецЦикла;
	
КонецПроцедуры

// Только для внутреннего использования.
Процедура ПроверитьУникальностьПредставления(Представление, СертификатСсылка, Поле, Отказ) Экспорт
	
	Если Не ЗначениеЗаполнено(Представление) Тогда
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка",       СертификатСсылка);
	Запрос.УстановитьПараметр("Наименование", Представление);
	
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ИСТИНА КАК ЗначениеИстина
	|ИЗ
	|	Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования КАК Сертификаты
	|ГДЕ
	|	Сертификаты.Ссылка <> &Ссылка
	|	И Сертификаты.Наименование = &Наименование";
	
	Если Не Запрос.Выполнить().Пустой() Тогда
		ТекстСообщения = НСтр("ru = 'Сертификат с таким представлением уже существует.'");
		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения,, Поле,, Отказ);
	КонецЕсли;
	
КонецПроцедуры

// Только для внутреннего использования.
Функция СведенияОПодписиДляЖурналаРегистрации(ДатаПодписи, СвойстваПодписи, ЭтоОшибкаПодписания = Ложь) Экспорт
	
	Если СвойстваПодписи.Свойство("ОписаниеСертификата") Тогда
		СвойстваСертификата = СвойстваПодписи.ОписаниеСертификата;
	Иначе
		СвойстваСертификата = Новый Структура;
		СвойстваСертификата.Вставить("СерийныйНомер", Base64Значение(""));
		СвойстваСертификата.Вставить("КемВыдан",      "");
		СвойстваСертификата.Вставить("КомуВыдан",     "");
		СвойстваСертификата.Вставить("ДатаНачала",    '00010101');
		СвойстваСертификата.Вставить("ДатаОкончания", '00010101');
		
		Если ТипЗнч(СвойстваПодписи.Сертификат) = Тип("Строка")
		   И ЭтоАдресВременногоХранилища(СвойстваПодписи.Сертификат) Тогда
			Сертификат = ПолучитьИзВременногоХранилища(СвойстваПодписи.Сертификат);
		Иначе
			Сертификат = СвойстваПодписи.Сертификат;
		КонецЕсли;
		
		Если ТипЗнч(Сертификат) = Тип("ДвоичныеДанные") Тогда
			СертификатКриптографии = Новый СертификатКриптографии(Сертификат);
			СвойстваСертификата = ЭлектроннаяПодпись.СвойстваСертификата(СертификатКриптографии);
			
		ИначеЕсли СвойстваПодписи.Свойство("КомуВыданСертификат") Тогда
			СвойстваСертификата.КомуВыдан = СвойстваПодписи.КомуВыданСертификат;
		КонецЕсли;
	КонецЕсли;
	
	Если ЭтоОшибкаПодписания Тогда
		СведенияОПодписи = "";
	Иначе
		СведенияОПодписи = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Дата подписи: %1'"), Формат(ДатаПодписи, "ДЛФ=DT")) + Символы.ПС;
	КонецЕсли;
	
	СведенияОПодписи = СведенияОПодписи + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Сертификат: %1
		           |Кем выдан: %2
		           |Владелец: %3
		           |Действителен: с %4 по %5'"),
		Строка(СвойстваСертификата.СерийныйНомер),
		СвойстваСертификата.КемВыдан,
		СвойстваСертификата.КомуВыдан,
		Формат(СвойстваСертификата.ДатаНачала,    "ДЛФ=D"),
		Формат(СвойстваСертификата.ДатаОкончания, "ДЛФ=D"));
	
	Возврат СведенияОПодписи;
	
КонецФункции

// Только для внутреннего использования.
Процедура ЗарегистрироватьПодписаниеДанныхВЖурнале(ЭлементДанных, ОписаниеОшибки = "") Экспорт
	
	ЭтоОшибкаПодписания = ЗначениеЗаполнено(ОписаниеОшибки);
	
	Если ТипЗнч(ЭлементДанных.СвойстваПодписи) = Тип("Строка") Тогда
		СвойстваПодписи = ПолучитьИзВременногоХранилища(ЭлементДанных.СвойстваПодписи);
	Иначе
		СвойстваПодписи = ЭлементДанных.СвойстваПодписи;
	КонецЕсли;
	
	СообщениеЖурналаРегистрации = СведенияОПодписиДляЖурналаРегистрации(
		СвойстваПодписи.ДатаПодписи, СвойстваПодписи, ЭтоОшибкаПодписания);
	
	Если ЭтоОшибкаПодписания Тогда
		ИмяСобытия = НСтр("ru = 'Электронная подпись.Ошибка подписания данных'",
			ОбщегоНазначения.КодОсновногоЯзыка());
		
		СообщениеЖурналаРегистрации = СообщениеЖурналаРегистрации + "
		|
		|" + ОписаниеОшибки;
	Иначе
		ИмяСобытия = НСтр("ru = 'Электронная подпись.Подписание данных'",
			ОбщегоНазначения.КодОсновногоЯзыка());
	КонецЕсли;
	
	Если ОбщегоНазначения.ЭтоСсылка(ТипЗнч(ЭлементДанных.ПредставлениеДанных)) Тогда
		МетаданныеЭлементаДанных = ЭлементДанных.ПредставлениеДанных.Метаданные();
	Иначе
		МетаданныеЭлементаДанных = Неопределено;
	КонецЕсли;
	
	ЗаписьЖурналаРегистрации(ИмяСобытия,
		УровеньЖурналаРегистрации.Информация,
		МетаданныеЭлементаДанных,
		ЭлементДанных.ПредставлениеДанных,
		СообщениеЖурналаРегистрации);
	
КонецПроцедуры

// Только для внутреннего использования.
Процедура ОбновитьСписокСертификатов(Сертификаты, СвойстваСертификатовНаКлиенте, КромеУжеДобавленных,
				Личные, Ошибка, БезОтбора, ДополнительныеПараметры = Неопределено) Экспорт
	
	Если ТипЗнч(ДополнительныеПараметры) = Тип("Структура") Тогда
		ОтборПоОрганизации = ДополнительныеПараметры.ОтборПоОрганизации;
		ВыполнятьНаСервере = ДополнительныеПараметры.ВыполнятьНаСервере;
	Иначе
		ОтборПоОрганизации = Неопределено;
		ВыполнятьНаСервере = Неопределено;
	КонецЕсли;
	
	ТаблицаСвойствСертификатов = Новый ТаблицаЗначений;
	ТаблицаСвойствСертификатов.Колонки.Добавить("Отпечаток", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(255)));
	ТаблицаСвойствСертификатов.Колонки.Добавить("КемВыдан");
	ТаблицаСвойствСертификатов.Колонки.Добавить("Представление");
	ТаблицаСвойствСертификатов.Колонки.Добавить("НаКлиенте",        Новый ОписаниеТипов("Булево"));
	ТаблицаСвойствСертификатов.Колонки.Добавить("НаСервере",        Новый ОписаниеТипов("Булево"));
	ТаблицаСвойствСертификатов.Колонки.Добавить("ЭтоЗаявление",     Новый ОписаниеТипов("Булево"));
	ТаблицаСвойствСертификатов.Колонки.Добавить("ВОблачномСервисе", Новый ОписаниеТипов("Булево"));
	ТаблицаСвойствСертификатов.Колонки.Добавить("ТипРазмещения",	Новый ОписаниеТипов("Число"));
	
	Для Каждого СвойстваСертификата Из СвойстваСертификатовНаКлиенте Цикл
		НоваяСтрока = ТаблицаСвойствСертификатов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СвойстваСертификата);
		НоваяСтрока.НаКлиенте = Истина;
	КонецЦикла;
	
	ТаблицаСвойствСертификатов.Индексы.Добавить("Отпечаток");
	
	Если ЭлектроннаяПодпись.СоздаватьЭлектронныеПодписиНаСервере()
	   И ВыполнятьНаСервере <> Ложь Тогда
		
		ПараметрыСоздания = ПараметрыСозданияМенеджераКриптографии();
		ПараметрыСоздания.ОписаниеОшибки = Ошибка;
		
		МенеджерКриптографии = МенеджерКриптографии("ПолучениеСертификатов", ПараметрыСоздания);
		
		Ошибка = ПараметрыСоздания.ОписаниеОшибки;
		Если МенеджерКриптографии <> Неопределено Тогда
			
			МассивСертификатов = МенеджерКриптографии.ПолучитьХранилищеСертификатов(
				ТипХранилищаСертификатовКриптографии.ПерсональныеСертификаты).ПолучитьВсе();
			
			ЭлектроннаяПодписьСлужебныйКлиентСервер.ДобавитьСвойстваСертификатов(ТаблицаСвойствСертификатов,
				МассивСертификатов, БезОтбора, ДобавкаВремени(), ТекущаяДатаСеанса());
			
			Если Не Личные Тогда
				МассивСертификатов = МенеджерКриптографии.ПолучитьХранилищеСертификатов(
					ТипХранилищаСертификатовКриптографии.СертификатыПолучателей).ПолучитьВсе();
				
				ЭлектроннаяПодписьСлужебныйКлиентСервер.ДобавитьСвойстваСертификатов(ТаблицаСвойствСертификатов,
					МассивСертификатов, БезОтбора, ДобавкаВремени(), ТекущаяДатаСеанса());
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если ИспользоватьЭлектроннуюПодписьВМоделиСервиса() Тогда
		
		МодульХранилищеСертификатов = ОбщегоНазначения.ОбщийМодуль("ХранилищеСертификатов");
		МассивСертификатов = МодульХранилищеСертификатов.Получить("ПерсональныеСертификаты");
		
		ПараметрыДобавленияСвойств = Новый Структура("ВОблачномСервисе", Истина);
		ЭлектроннаяПодписьСлужебныйКлиентСервер.ДобавитьСвойстваСертификатов(ТаблицаСвойствСертификатов,
			МассивСертификатов, БезОтбора, ДобавкаВремени(), ТекущаяДатаСеанса(), ПараметрыДобавленияСвойств);
		
		Если Не Личные Тогда
			МассивСертификатов = МодульХранилищеСертификатов.Получить("СертификатыПолучателей");
			
			ЭлектроннаяПодписьСлужебныйКлиентСервер.ДобавитьСвойстваСертификатов(ТаблицаСвойствСертификатов,
				МассивСертификатов, БезОтбора, ДобавкаВремени(), ТекущаяДатаСеанса(), ПараметрыДобавленияСвойств);
		КонецЕсли;
		
	КонецЕсли;
	
	Если ИспользоватьСервисОблачнойПодписи() Тогда
		// Локализация
		МодульСервисКриптографииDSSСлужебный = ОбщегоНазначения.ОбщийМодуль("СервисКриптографииDSSСлужебный");
		МассивСертификатов = МодульСервисКриптографииDSSСлужебный.ПолучитьДанныеСертификатов(Ложь);
		
		ПараметрыДобавленияСвойств = Новый Структура("ОблачнаяПодпись", Истина);
		
		ЭлектроннаяПодписьСлужебныйКлиентСервер.ДобавитьСвойстваСертификатов(ТаблицаСвойствСертификатов,
			МассивСертификатов, БезОтбора, ДобавкаВремени(), ТекущаяДатаСеанса(), ПараметрыДобавленияСвойств);
		// Конец Локализация
	КонецЕсли;
	
	ОбработатьДобавленныеСертификаты(ТаблицаСвойствСертификатов, Не БезОтбора И КромеУжеДобавленных, ОтборПоОрганизации);
	
	ТаблицаСвойствСертификатов.Индексы.Добавить("Представление");
	ТаблицаСвойствСертификатов.Сортировать("Представление Возр");
	
	ОбработанныеСтроки  = Новый Соответствие;
	Индекс = 0;
	Отбор = Новый Структура("Отпечаток", "");
	
	Для каждого СвойстваСертификата Из ТаблицаСвойствСертификатов Цикл
		Отбор.Отпечаток = СвойстваСертификата.Отпечаток;
		Строки = Сертификаты.НайтиСтроки(Отбор);
		Если Строки.Количество() = 0 Тогда
			Если Сертификаты.Количество()-1 < Индекс Тогда
				Строка = Сертификаты.Добавить();
			Иначе
				Строка = Сертификаты.Вставить(Индекс);
			КонецЕсли;
		Иначе
			Строка = Строки[0];
			ИндексСтроки = Сертификаты.Индекс(Строка);
			Если ИндексСтроки <> Индекс Тогда
				Сертификаты.Сдвинуть(ИндексСтроки, Индекс - ИндексСтроки);
			КонецЕсли;
		КонецЕсли;
		// Обновление только измененных значений, чтобы таблица формы не обновлялась лишний раз.
		ОбновитьЗначение(Строка.Отпечаток,          СвойстваСертификата.Отпечаток);
		ОбновитьЗначение(Строка.Представление,      СвойстваСертификата.Представление);
		ОбновитьЗначение(Строка.КемВыдан,           СвойстваСертификата.КемВыдан);
		ОбновитьЗначение(Строка.НаКлиенте,          СвойстваСертификата.НаКлиенте);
		ОбновитьЗначение(Строка.НаСервере,          СвойстваСертификата.НаСервере);
		ОбновитьЗначение(Строка.ЭтоЗаявление,       СвойстваСертификата.ЭтоЗаявление);
		ОбновитьЗначение(Строка.ВОблачномСервисе,   СвойстваСертификата.ВОблачномСервисе);
		ОбновитьЗначение(Строка.ТипРазмещения,		СвойстваСертификата.ТипРазмещения);
		ОбработанныеСтроки.Вставить(Строка, Истина);
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Индекс = Сертификаты.Количество()-1;
	Пока Индекс >=0 Цикл
		Строка = Сертификаты.Получить(Индекс);
		Если ОбработанныеСтроки.Получить(Строка) = Неопределено Тогда
			Сертификаты.Удалить(Индекс);
		КонецЕсли;
		Индекс = Индекс-1;
	КонецЦикла;
	
КонецПроцедуры

// Только для внутреннего использования.
//
// Параметры:
//   Контекст - Структура:
//     * ОшибкаНаСервере - Структура:
//         ** Ошибки - Массив
//
Функция ЗаписатьСертификатПослеПроверки(Контекст) Экспорт
	
	ПараметрыСоздания = ПараметрыСозданияМенеджераКриптографии();
	ПараметрыСоздания.ОписаниеОшибки = Новый Структура;
	ПараметрыСоздания.АлгоритмПодписи = Контекст.АлгоритмПодписи;
	
	МенеджерКриптографии = МенеджерКриптографии("", ПараметрыСоздания);
	
	Контекст.Вставить("ОшибкаНаСервере",
		ЭлектроннаяПодписьСлужебныйКлиентСервер.НовоеОписаниеОшибок());
	
	ЗаголовокОшибкиПрограммы = ЭлектроннаяПодписьСлужебныйКлиентСервер.ЗаголовокОшибкиДобавленияСертификата(
			?(Контекст.ДляШифрования = Истина, "Шифрование", "Подписание"), ИмяКомпьютера());
	
	Если ТипЗнч(МенеджерКриптографии) <> Тип("МенеджерКриптографии")
		И ПараметрыСоздания.ОписаниеОшибки.Общая Тогда
		
		Контекст.ОшибкаНаСервере = ПараметрыСоздания.ОписаниеОшибки;
		Контекст.ОшибкаНаСервере.ЗаголовокОшибки = ЗаголовокОшибкиПрограммы;
		Возврат Неопределено;
	КонецЕсли;
	
	ОписанияПрограмм = ЭлектроннаяПодпись.ОбщиеНастройки().ОписанияПрограмм;
	СертификатКриптографии = Новый СертификатКриптографии(Контекст.ДанныеСертификата);
	ЭтоПолноправныйПользователь = Пользователи.ЭтоПолноправныйПользователь(,, Ложь);
	
	Для Каждого ОписаниеПрограммы Из ОписанияПрограмм Цикл
		
		ПараметрыСоздания = ПараметрыСозданияМенеджераКриптографии();
		ПараметрыСоздания.Программа = ОписаниеПрограммы.Ссылка;
		ПараметрыСоздания.ОписаниеОшибки = Новый Структура;
		ПараметрыСоздания.АлгоритмПодписи = Контекст.АлгоритмПодписи;
		
		МенеджерКриптографии = МенеджерКриптографии("", ПараметрыСоздания);
		
		Если МенеджерКриптографии = Неопределено Тогда
			Ошибки = ПараметрыСоздания.ОписаниеОшибки.Ошибки;
			
			Если Ошибки.Количество() > 0
			   И Не (ЗначениеЗаполнено(Контекст.АлгоритмПодписи)
			         И Ошибки[0].НетАлгоритма) Тогда
				
				Ошибки[0].ЗаголовокОшибки = ЗаголовокОшибкиПрограммы;
				Контекст.ОшибкаНаСервере.Ошибки.Добавить(Ошибки[0]);
			КонецЕсли;
			
			Продолжить;
			
		КонецЕсли;
		
		МенеджерКриптографии.ПарольДоступаКЗакрытомуКлючу = Контекст.ПарольСертификата;
		
		Если Контекст.ДляШифрования = Истина Тогда
			Успех = ПроверитьШифрованиеИРасшифровку(МенеджерКриптографии, Контекст.ДанныеСертификата,
				СертификатКриптографии, ОписаниеПрограммы, Контекст.ОшибкаНаСервере, ЭтоПолноправныйПользователь);
		Иначе
			Успех = ПроверитьПодписание(МенеджерКриптографии, Контекст.ДанныеСертификата,
				СертификатКриптографии, ОписаниеПрограммы, Контекст.ОшибкаНаСервере, ЭтоПолноправныйПользователь);
		КонецЕсли;
		
		Если Не Успех Тогда
			Продолжить;
		КонецЕсли;
		
		Контекст.Вставить("ОписаниеПрограммы", ОписаниеПрограммы);
		Возврат ЭлектроннаяПодписьСлужебныйКлиентСервер.ЗаписатьСертификатВСправочник(Контекст,
			Контекст.ОшибкаНаСервере);
		
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Только для внутреннего использования.
Функция ПрограммаОблачногоСервиса() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	Программы.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.ПрограммыЭлектроннойПодписиИШифрования КАК Программы
	|ГДЕ
	|	Программы.ЭтоПрограммаОблачногоСервиса
	|	И НЕ Программы.ПометкаУдаления
	|
	|УПОРЯДОЧИТЬ ПО
	|	Программы.Наименование";
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		ПрограммаОблачногоСервиса = Выборка.Ссылка;
	Иначе
		ПрограммаОблачногоСервиса = Неопределено;
	КонецЕсли;
	
	Возврат ПрограммаОблачногоСервиса;
	
КонецФункции

// Только для внутреннего использования.
Функция ОблачныйПарольПодтвержден(Сертификат)
	
	Если Не ИспользоватьЭлектроннуюПодписьВМоделиСервиса() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипЗнч(Сертификат) = Тип("ДвоичныеДанные") Тогда
		ДанныеСертификата = Сертификат;
		
	ИначеЕсли ТипЗнч(Сертификат) = Тип("СертификатКриптографии") Тогда
		ДанныеСертификата = Сертификат.Выгрузить();
	Иначе
		ДанныеСертификата = ПолучитьИзВременногоХранилища(Сертификат);
	КонецЕсли;
	
	МодульСервисКриптографии = ОбщегоНазначения.ОбщийМодуль("СервисКриптографии");
	СвойстваСертификата = МодульСервисКриптографии.ПолучитьСвойстваСертификата(ДанныеСертификата);
	
	МаркерыБезопасности = МаркерыБезопасности(СвойстваСертификата.Идентификатор);
	
	Возврат ЗначениеЗаполнено(МаркерыБезопасности.МаркерБезопасности);
	
КонецФункции

// Для функции ОблачныйПарольПодтвержден.
Функция МаркерыБезопасности(ИдентификаторСертификата)

	Результат = Новый Структура();
	Результат.Вставить("МаркерБезопасности");
	
	УстановитьПривилегированныйРежим(Истина);
	Результат.МаркерБезопасности = ПараметрыСеанса["МаркерыБезопасности"].Получить(ИдентификаторСертификата);
	
	УстановитьПривилегированныйРежим(Ложь);
	
	// Незаполненные значения заменим пустыми строками для передачи в сервис криптографии.
	Если Не ЗначениеЗаполнено(Результат.МаркерБезопасности) Тогда
		Результат.МаркерБезопасности = "";
	КонецЕсли;
	
	Возврат Результат;

КонецФункции

// В ОС Linux и MacOS при создании менеджера криптографии
// требуется указывать путь к программе.
//
// Возвращаемое значение:
//  Булево
//
Функция ТребуетсяПутьКПрограмме(НаКлиенте = Ложь) Экспорт
	
	Если НаКлиенте Тогда
		Возврат ОбщегоНазначения.ЭтоLinuxКлиент()
		    Или ОбщегоНазначения.ЭтоMacOSКлиент();
	КонецЕсли;
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	
	Возврат ОбщегоНазначения.ЭтоLinuxСервер()
		Или СистемнаяИнформация.ТипПлатформы = ТипПлатформы.MacOS_x86
		Или СистемнаяИнформация.ТипПлатформы = ТипПлатформы.MacOS_x86_64;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции управляемых форм.

// Только для внутреннего использования.
Процедура НастроитьФормуПодписанияШифрованияРасшифровки(Форма, Шифрование = Ложь, Расшифровка = Ложь) Экспорт
	
	Элементы  = Форма.Элементы;
	Параметры = Форма.Параметры;
	
	Элементы.Сертификат.КнопкаВыпадающегоСписка = Истина;
	Элементы.Сертификат.ОтображениеКнопкиВыбора = ОтображениеКнопкиВыбора.ОтображатьВВыпадающемСписке;
	
	Форма.Заголовок = Параметры.Операция;
	Форма.ВыполнятьНаСервере = Параметры.ВыполнятьНаСервере;
	
	Если Шифрование Тогда
		Если Форма.УказанНеизменяемыйНаборСертификатов Тогда
			Форма.БезПодтверждения = Параметры.БезПодтверждения;
		КонецЕсли;
	Иначе
		Форма.ОтборСертификатов = Новый СписокЗначений;
		Если ТипЗнч(Параметры.ОтборСертификатов) = Тип("Массив") Тогда
			Форма.ОтборСертификатов.ЗагрузитьЗначения(Параметры.ОтборСертификатов);
		ИначеЕсли ТипЗнч(Параметры.ОтборСертификатов) = Тип("Структура") Тогда
			Форма.ОтборСертификатов = Параметры.ОтборСертификатов.Организация;
		КонецЕсли;
		Форма.БезПодтверждения = Параметры.БезПодтверждения;
	КонецЕсли;
	
	ЭлементПредставлениеДанных = Элементы.ПредставлениеДанных; // ПолеФормы, РасширениеПоляФормыДляПоляНадписи
	Если ЗначениеЗаполнено(Параметры.ЗаголовокДанных) Тогда
		ЭлементПредставлениеДанных.Заголовок = Параметры.ЗаголовокДанных;
	Иначе
		ЭлементПредставлениеДанных.ПоложениеЗаголовка = ПоложениеЗаголовкаЭлементаФормы.Нет;
	КонецЕсли;
	
	Форма.ПредставлениеДанных = Параметры.ПредставлениеДанных;
	ЭлементПредставлениеДанных.Гиперссылка = Параметры.ПредставлениеДанныхОткрывается;
	
	Если Не ЗначениеЗаполнено(Форма.ПредставлениеДанных) Тогда
		ЭлементПредставлениеДанных.Видимость = Ложь;
	КонецЕсли;
	
	Если Расшифровка Тогда
		ЗаполнитьОтборОтпечатков(Форма);
	ИначеЕсли Не Шифрование Тогда // Подписание
		Элементы.Комментарий.Видимость = Параметры.ПоказатьКомментарий И Не Форма.БезПодтверждения;
	КонецЕсли;
	
	ЗаполнитьСуществующиеСертификатыПользователя(Форма.СертификатСписокВыбора,
		Параметры.ОтпечаткиСертификатовНаКлиенте, Форма.ОтборСертификатов,
		Форма.ОтборОтпечатков, Расшифровка, Форма.ВыполнятьНаСервере);
	
	Сертификат = Неопределено;
	
	Если Расшифровка Тогда
		Для каждого ЭлементСписка Из Форма.СертификатСписокВыбора Цикл
			Если ТипЗнч(ЭлементСписка.Значение) = Тип("Строка") Тогда
				Продолжить;
			КонецЕсли;
			Сертификат = ЭлементСписка.Значение;
			Прервать;
		КонецЦикла;
		
	ИначеЕсли ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Если Шифрование Тогда
			Сертификат = ХранилищеОбщихНастроек.Загрузить("Криптография", "СертификатДляШифрования");
		Иначе
			Сертификат = ХранилищеОбщихНастроек.Загрузить("Криптография", "СертификатДляПодписания");
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(Форма.ОтборСертификатов) = Тип("СписокЗначений") Тогда
		Если Форма.СертификатСписокВыбора.Количество() = 0 Тогда
			Сертификат = Неопределено;
		Иначе
			Сертификат = Форма.СертификатСписокВыбора[0].Значение;
		КонецЕсли;
	КонецЕсли;
	
	Если Не (Шифрование И Форма.УказанНеизменяемыйНаборСертификатов) Тогда
		Форма.Сертификат = Сертификат;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Форма.Сертификат)
	   И ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Форма.Сертификат, "Ссылка") <> Форма.Сертификат Тогда
		
		Форма.Сертификат = Неопределено;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Форма.Сертификат) Тогда
		Если Шифрование Тогда
			Форма.ИмяПоляАктивизироватьПоУмолчанию = "СертификатыШифрования";
		Иначе
			Форма.ИмяПоляАктивизироватьПоУмолчанию = "Пароль";
		КонецЕсли;
	Иначе
		Если Не (Шифрование И Форма.УказанНеизменяемыйНаборСертификатов) Тогда
			Форма.ИмяПоляАктивизироватьПоУмолчанию = "Сертификат";
		КонецЕсли;
	КонецЕсли;
	
	ЗаполнитьДополнительныеСвойстваСертификата(Форма);
	
	Форма.МенеджерКриптографииНаСервереОписаниеОшибки = Новый Структура;
	Если ЭлектроннаяПодпись.СоздаватьЭлектронныеПодписиНаСервере() Тогда
		
		ПараметрыСоздания = ПараметрыСозданияМенеджераКриптографии();
		ПараметрыСоздания.ОписаниеОшибки = Новый Структура;
		
		МенеджерКриптографии("ПолучениеСертификатов", ПараметрыСоздания);
		Форма.МенеджерКриптографииНаСервереОписаниеОшибки = ПараметрыСоздания.ОписаниеОшибки;
		
	КонецЕсли;
	
	Если Не Шифрование Тогда
		ЭлектроннаяПодписьПереопределяемый.ПередНачаломОперации(?(Расшифровка, "Расшифровка", "Подписание"),
			Параметры.ПараметрыДополнительныхДействий, Форма.ВыходныеПараметрыДополнительныхДействий);
	КонецЕсли;
	
КонецПроцедуры

// Только для внутреннего использования.
Процедура СертификатПриИзмененииНаСервере(Форма, ОтпечаткиСертификатовНаКлиенте, Шифрование = Ложь, Расшифровка = Ложь) Экспорт
	
	Если ТипЗнч(Форма.ОтборСертификатов) <> Тип("СписокЗначений") И ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		
		Если Шифрование Тогда
			ХранилищеОбщихНастроек.Сохранить("Криптография", "СертификатДляШифрования", Форма.Сертификат);
		ИначеЕсли Не Расшифровка Тогда
			ХранилищеОбщихНастроек.Сохранить("Криптография", "СертификатДляПодписания", Форма.Сертификат);
		КонецЕсли;
		
	КонецЕсли;
	
	ЗаполнитьСуществующиеСертификатыПользователя(Форма.СертификатСписокВыбора,
		ОтпечаткиСертификатовНаКлиенте, Форма.ОтборСертификатов,
		Форма.ОтборОтпечатков, Расшифровка, Форма.ВыполнятьНаСервере);
	
	ЗаполнитьДополнительныеСвойстваСертификата(Форма);
	
КонецПроцедуры

// Только для внутреннего использования.
Функция СохраненныеСвойстваСертификата(Отпечаток, Адрес, ПараметрыРеквизитов, ДляШифрования = Ложь) Экспорт
	
	СохраненныеСвойства = Новый Структура;
	СохраненныеСвойства.Вставить("Ссылка");
	СохраненныеСвойства.Вставить("Наименование");
	СохраненныеСвойства.Вставить("Пользователь");
	СохраненныеСвойства.Вставить("Организация");
	СохраненныеСвойства.Вставить("УсиленнаяЗащитаЗакрытогоКлюча");
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Отпечаток", Отпечаток);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Сертификаты.Ссылка КАК Ссылка,
	|	Сертификаты.Наименование КАК Наименование,
	|	Сертификаты.Пользователь,
	|	Сертификаты.Организация,
	|	Сертификаты.УсиленнаяЗащитаЗакрытогоКлюча,
	|	Сертификаты.ДанныеСертификата
	|ИЗ
	|	Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования КАК Сертификаты
	|ГДЕ
	|	Сертификаты.Отпечаток = &Отпечаток";
	
	СертификатКриптографии = Новый СертификатКриптографии(ПолучитьИзВременногоХранилища(Адрес));
	
	ЗначенияЗаполнения = ПараметрыРеквизитов;
	ПараметрыРеквизитов = Неопределено; // Заполняется в процедуре ПередНачаломРедактированияСертификатаКлюча.
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		ЗаполнитьЗначенияСвойств(СохраненныеСвойства, Выборка);
	Иначе
		СохраненныеСвойства.Ссылка = Справочники.СертификатыКлючейЭлектроннойПодписиИШифрования.ПустаяСсылка();
		
		Если ТипЗнч(ЗначенияЗаполнения) = Тип("Структура")
		   И ЗначенияЗаполнения.Свойство("Организация")
		   И ЗначениеЗаполнено(ЗначенияЗаполнения.Организация) Тогда
			
			СохраненныеСвойства.Организация = ЗначенияЗаполнения.Организация;
			
		ИначеЕсли Не Метаданные.ОпределяемыеТипы.Организация.Тип.СодержитТип(Тип("Строка")) Тогда
			ПолноеИмя = Метаданные.НайтиПоТипу(Метаданные.ОпределяемыеТипы.Организация.Тип.Типы()[0]).ПолноеИмя();
			ИмяСправочникаОрганизации = "Справочники." + СтрРазделить(ПолноеИмя, ".")[1];
			МодульОрганизации = ОбщегоНазначения.ОбщийМодуль(ИмяСправочникаОрганизации);
			Если Не ДляШифрования Тогда
				СохраненныеСвойства.Организация = МодульОрганизации.ОрганизацияПоУмолчанию();
			КонецЕсли;
		КонецЕсли;
		СохраненныеСвойства.Наименование = ЭлектроннаяПодпись.ПредставлениеСертификата(СертификатКриптографии);
		Если Не ДляШифрования Тогда
			СохраненныеСвойства.Пользователь = Пользователи.ТекущийПользователь();
		КонецЕсли;
	КонецЕсли;
	
	ПередНачаломРедактированияСертификатаКлюча(
		СохраненныеСвойства.Ссылка, СертификатКриптографии, ПараметрыРеквизитов);
	
	Если Не ЗначениеЗаполнено(СохраненныеСвойства.Ссылка) Тогда
		ЗаполнитьРеквизит(СохраненныеСвойства, ПараметрыРеквизитов, "Наименование");
		ЗаполнитьРеквизит(СохраненныеСвойства, ПараметрыРеквизитов, "Пользователь");
		ЗаполнитьРеквизит(СохраненныеСвойства, ПараметрыРеквизитов, "Организация");
		ЗаполнитьРеквизит(СохраненныеСвойства, ПараметрыРеквизитов, "УсиленнаяЗащитаЗакрытогоКлюча");
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(СохраненныеСвойства.Ссылка)
	   И ТипЗнч(ЗначенияЗаполнения) = Тип("Структура")
	   И ЗначенияЗаполнения.Свойство("Организация")
	   И ЗначениеЗаполнено(ЗначенияЗаполнения.Организация)
	   И Не ПараметрыРеквизитов.Свойство("Организация") Тогда
	
		Параметры = Новый Структура;
		Параметры.Вставить("ТолькоПросмотр",     Истина);
		Параметры.Вставить("ПроверкаЗаполнения", Ложь);
		Параметры.Вставить("Видимость",          Истина);
		ПараметрыРеквизитов.Вставить("Организация", Параметры);
	КонецЕсли;
	
	Возврат СохраненныеСвойства;
	
КонецФункции

// Только для внутреннего использования.
// 
// Параметры:
//  Форма - ФормаКлиентскогоПриложения:
//    * СертификатПараметрыРеквизитов - см. НовыеПараметрыРеквизитовСертификата
//  Программа - Неопределено
//  ДляШифрования - Булево
//
Процедура ЗаписатьСертификатВСправочник(Форма, Программа = Неопределено, ДляШифрования = Ложь) Экспорт
	
	ДополнительныеПараметры = Новый Структура;
	ДополнительныеПараметры.Вставить("Наименование", Форма.СертификатНаименование);
	ДополнительныеПараметры.Вставить("Пользователь", Форма.СертификатПользователь);
	ДополнительныеПараметры.Вставить("Организация",  Форма.СертификатОрганизация);
	
	Если Не ДляШифрования Тогда
		ДополнительныеПараметры.Вставить("Программа", Программа);
		ДополнительныеПараметры.Вставить("УсиленнаяЗащитаЗакрытогоКлюча",
			Форма.СертификатУсиленнаяЗащитаЗакрытогоКлюча);
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(Форма.Сертификат) Тогда
		ПропускаемыеРеквизиты = Новый Соответствие;
		ПропускаемыеРеквизиты.Вставить("Ссылка",       Истина);
		ПропускаемыеРеквизиты.Вставить("Наименование", Истина);
		ПропускаемыеРеквизиты.Вставить("Организация",  Истина);
		ПропускаемыеРеквизиты.Вставить("УсиленнаяЗащитаЗакрытогоКлюча", Истина);
		Если Не ДляШифрования И Форма.ЛичныйСписокПриДобавлении Тогда
			ПропускаемыеРеквизиты.Вставить("Пользователь",  Истина);
		КонецЕсли;
		Для каждого КлючИЗначение Из Форма.СертификатПараметрыРеквизитов Цикл
			ИмяРеквизита = КлючИЗначение.Ключ;
			Свойства     = КлючИЗначение.Значение; // см. НовыеПараметрыРеквизитаСертификата
			Если ПропускаемыеРеквизиты.Получить(ИмяРеквизита) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			Если Свойства.ЗначениеЗаполнения = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			ДополнительныеПараметры.Вставить(ИмяРеквизита, Свойства.ЗначениеЗаполнения);
		КонецЦикла;
	КонецЕсли;
	
	Форма.Сертификат = ЭлектроннаяПодпись.ЗаписатьСертификатВСправочник(Форма.СертификатАдрес,
		ДополнительныеПараметры);
	
КонецПроцедуры

// Только для внутреннего использования.
//
// Параметры:
//   Список - ДинамическийСписок
//
Процедура УстановитьУсловноеОформлениеСпискаСертификатов(Список, ИсключитьЗаявления = Ложь) Экспорт
	
	ЭлементУсловногоОформления = Список.УсловноеОформление.Элементы.Добавить();
	
	ЭлементЦветаОформления = ЭлементУсловногоОформления.Оформление.Элементы.Найти("TextColor");
	ЭлементЦветаОформления.Значение = Метаданные.ЭлементыСтиля.ТекстЗапрещеннойЯчейкиЦвет.Значение;
	ЭлементЦветаОформления.Использование = Истина;
	
	Если ИсключитьЗаявления И Метаданные.Обработки.Найти("ЗаявлениеНаВыпускНовогоКвалифицированногоСертификата") <> Неопределено Тогда
		ОбработкаЗаявлениеНаВыпускНовогоКвалифицированногоСертификата =
			ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(
				"Обработка.ЗаявлениеНаВыпускНовогоКвалифицированногоСертификата");
		ОбработкаЗаявлениеНаВыпускНовогоКвалифицированногоСертификата.УстановитьУсловноеОформлениеСпискаСертификатов(
			ЭлементУсловногоОформления);
	КонецЕсли;
	
	ГруппаЭлементовОтбора = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
	ГруппаЭлементовОтбора.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе;
	
	ЭлементОтбораДанных = ГруппаЭлементовОтбора.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ЭлементОтбораДанных.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных("Отозван");
	ЭлементОтбораДанных.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
	ЭлементОтбораДанных.ПравоеЗначение = Ложь;
	ЭлементОтбораДанных.Использование  = Истина;
	
	ЭлементОтбораДанных = ГруппаЭлементовОтбора.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ЭлементОтбораДанных.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных("ДействителенДо");
	ЭлементОтбораДанных.ВидСравнения   = ВидСравненияКомпоновкиДанных.Больше;
	ЭлементОтбораДанных.ПравоеЗначение = Новый СтандартнаяДатаНачала(ВариантСтандартнойДатыНачала.НачалоЭтогоДня);
	ЭлементОтбораДанных.Использование  = Истина;
	
	ЭлементОформляемогоПоля = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ЭлементОформляемогоПоля.Поле = Новый ПолеКомпоновкиДанных("");
	ЭлементОформляемогоПоля.Использование = Истина;
	
КонецПроцедуры

// Только для внутреннего использования.
//
// Параметры:
//   ДанныеСертификата - ДвоичныеДанные
//
Функция СертификатИзДвоичныхДанных(ДанныеСертификата) Экспорт
	
	Если ТипЗнч(ДанныеСертификата) <> Тип("ДвоичныеДанные") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		СертификатКриптографии = Новый СертификатКриптографии(ДанныеСертификата);
	Исключение
		СертификатКриптографии = Неопределено;
	КонецПопытки;
	
	Если СертификатКриптографии <> Неопределено Тогда
		Возврат СертификатКриптографии;
	КонецЕсли;
	
	ПолноеИмяВременногоФайла = ПолучитьИмяВременногоФайла("cer");
	ДанныеСертификата.Записать(ПолноеИмяВременногоФайла);
	Текст = Новый ТекстовыйДокумент;
	Текст.Прочитать(ПолноеИмяВременногоФайла);
	
	Попытка
		УдалитьФайлы(ПолноеИмяВременногоФайла);
	Исключение
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Электронная подпись.Удаление временного файла'",
				ОбщегоНазначения.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, , ,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Если Текст.КоличествоСтрок() < 3
	 Или Текст.ПолучитьСтроку(1) <> "-----BEGIN CERTIFICATE-----"
	 Или Текст.ПолучитьСтроку(Текст.КоличествоСтрок()) <> "-----END CERTIFICATE-----" Тогда
		
		Возврат Неопределено;
	КонецЕсли;
	
	Текст.УдалитьСтроку(1);
	Текст.УдалитьСтроку(Текст.КоличествоСтрок());
	СтрокаBase64 = Текст.ПолучитьТекст();
	
	Попытка
		ДанныеСертификата = Base64Значение(СтрокаBase64);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	Если ТипЗнч(ДанныеСертификата) <> Тип("ДвоичныеДанные") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		СертификатКриптографии = Новый СертификатКриптографии(ДанныеСертификата);
	Исключение
		СертификатКриптографии = Неопределено;
	КонецПопытки;
	
	Возврат СертификатКриптографии;
	
КонецФункции

// Только для внутреннего использования.
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//
Процедура НастроитьПояснениеВводаПароля(Форма, ИмяЭлементаУсиленнаяЗащитаЗакрытогоКлюча = "", ИмяЭлементаПояснениеУсиленногоПароля = "") Экспорт
	
	Если ЗначениеЗаполнено(ИмяЭлементаУсиленнаяЗащитаЗакрытогоКлюча) Тогда
		Элемент = Форма.Элементы[ИмяЭлементаУсиленнаяЗащитаЗакрытогоКлюча]; // ПолеФормы
		Элемент.Заголовок = НСтр("ru = 'Вводить пароль в программе электронной подписи'");
		Элемент.Подсказка =
			НСтр("ru = '- Включается интерактивный режим работы программы электронной подписи,
			           |  при котором она запрашивает пароль и позволяет его сохранить.
			           |- Отключается запрос пароля в форме 1С:Предприятия.
			           |
			           |Обязательно для закрытых ключей сертификатов, для которых в ОС включена усиленная защита.'");
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ИмяЭлементаПояснениеУсиленногоПароля) Тогда
		Элемент = Форма.Элементы[ИмяЭлементаПояснениеУсиленногоПароля];
		Элемент.Подсказка =
			НСтр("ru = 'Пароль запрашивает программа электронной подписи, а не программа 1С:Предприятие,
			           |так как для выбранного сертификата включен режим ""Вводить пароль в программе электронной подписи"".'");
	КонецЕсли;
	
КонецПроцедуры

// Параметры:
//  Форма - ФормаКлиентскогоПриложения
//  Заголовок - Строка
//
Процедура УстановитьЗаголовокОшибки(Форма, Заголовок) Экспорт
	
	Форма.Заголовок = Заголовок;
	
	ШиринаЗаголовка = СтрДлина(Форма.Заголовок);
	Если ШиринаЗаголовка > 80 Тогда
		ШиринаЗаголовка = 80;
	КонецЕсли;
	Если ШиринаЗаголовка > Форма.Ширина Тогда
		Форма.Ширина = ШиринаЗаголовка;
	КонецЕсли;
	
КонецПроцедуры

Процедура СброситьРазмерыИПоложениеОкна(Форма) Экспорт
	
	Если Не ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	ИмяФормы = Форма.ИмяФормы;
	НовыйКлючСохраненияПоложенияОкна = СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "_");
	КлючОбъектаХранения = ИмяФормы + "/ВременныеКлючиСохраненияПоложенияОкна";
	ИмяПользователя = ИмяПользователя();
	НачалоДня = НачалоДня(ТекущаяУниверсальнаяДата());
	ГраницаУстаревания = НачалоДня - 2*24*60*60;
	
	Ключи = ХранилищеСистемныхНастроек.Загрузить(КлючОбъектаХранения);
	
	Если ТипЗнч(Ключи) = Тип("Соответствие") Тогда
		ИменаНастроек = Новый Массив;
		ИменаНастроек.Добавить("/НастройкиОкна");
		ИменаНастроек.Добавить("/НастройкиОкнаВебКлиента");
		ИменаНастроек.Добавить("/НастройкиОкнаМобильногоКлиента");
		ИменаНастроек.Добавить("/Такси/НастройкиОкна");
		ИменаНастроек.Добавить("/Такси/НастройкиОкнаВебКлиента");
		ИменаНастроек.Добавить("/Такси/НастройкиОкнаМобильногоКлиента");
		Для Каждого КлючИЗначение Из Ключи Цикл
			ТекущийДень = КлючИЗначение.Ключ;
			Если ТипЗнч(ТекущийДень) <> Тип("Дата") Тогда
				Ключи = Неопределено;
				Прервать;
			КонецЕсли;
			Если ТекущийДень > ГраницаУстаревания Тогда
				Продолжить;
			КонецЕсли;
			КлючиТекущегоДня = КлючИЗначение.Значение;
			Если ТипЗнч(КлючиТекущегоДня) <> Тип("Массив") Тогда
				Ключи = Неопределено;
				Прервать;
			КонецЕсли;
			Для Каждого ТекущийКлюч Из КлючиТекущегоДня Цикл
				НачалоКлючаОбъекта = ИмяФормы + "/" + ТекущийКлюч;
				Для Каждого ИмяНастройки Из ИменаНастроек Цикл
					ХранилищеСистемныхНастроек.Удалить(НачалоКлючаОбъекта + ИмяНастройки, "", ИмяПользователя);
				КонецЦикла;
			КонецЦикла;
			Ключи.Удалить(ТекущийДень);
		КонецЦикла;
	КонецЕсли;
	
	ОчиститьСтарыеКлючи = ТипЗнч(Ключи) <> Тип("Соответствие");
	Если ОчиститьСтарыеКлючи Тогда
		Ключи = Новый Соответствие;
	КонецЕсли;
	
	КлючиДня = Ключи.Получить(НачалоДня);
	Если ТипЗнч(КлючиДня) <> Тип("Массив") Тогда
		КлючиДня = Новый Массив;
		Ключи.Вставить(НачалоДня, КлючиДня);
	КонецЕсли;
	КлючиДня.Добавить(НовыйКлючСохраненияПоложенияОкна);
	ХранилищеСистемныхНастроек.Сохранить(КлючОбъектаХранения,, Ключи);
	
	Форма.КлючСохраненияПоложенияОкна = НовыйКлючСохраненияПоложенияОкна;
	
	Если Не ОчиститьСтарыеКлючи Тогда
		Возврат;
	КонецЕсли;
	
	Отбор = Новый Структура("Пользователь", ИмяПользователя);
	Выборка = ХранилищеСистемныхНастроек.Выбрать(Отбор);
	Пока Истина Цикл
		Попытка
			ЕстьСледующей = Выборка.Следующий();
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			ЗаписьЖурналаРегистрации(
				НСтр("ru = 'Ошибка выполнения'", ОбщегоНазначения.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,,,
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
			Прервать;
		КонецПопытки;
		Если Не ЕстьСледующей Тогда
			Прервать;
		КонецЕсли;
		Если Не СтрНачинаетсяС(Выборка.КлючОбъекта, ИмяФормы)
		 Или Выборка.КлючНастроек <> ""
		 Или Выборка.КлючОбъекта = КлючОбъектаХранения Тогда
			Продолжить;
		КонецЕсли;
		ЧастиКлючаОбъекта = СтрРазделить(Выборка.КлючОбъекта, "/");
		Если ЧастиКлючаОбъекта.Количество() < 2 Тогда
			Продолжить;
		КонецЕсли;
		ПоследняяЧастьКлюча = ЧастиКлючаОбъекта[ЧастиКлючаОбъекта.ВГраница()];
		Если СтрНайти(ПоследняяЧастьКлюча, "НастройкиОкна") > 0
		 Или СтрНайти(ПоследняяЧастьКлюча, "WindowSettings") > 0 Тогда
			ХранилищеСистемныхНастроек.Удалить(Выборка.КлючОбъекта, "", ИмяПользователя);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обновление информационной базы.

////////////////////////////////////////////////////////////////////////////////
// Работа с XMLDSig

// Подписывает сообщение, подставляя в КонвертXML данные подписи.
//
// Параметры:
//  КонвертXML             - см. ЭлектроннаяПодписьКлиент.КонвертXML
//  ПараметрыXMLDSig       - см. ЭлектроннаяПодписьКлиент.ПараметрыXMLDSig
//  СертификатКриптографии - СертификатКриптографии - используемый сертификат криптографии.
//  МенеджерКриптографии   - МенеджерКриптографии   - менеджер криптографии,
//                           который соответствует закрытому ключу сертификата с установленным паролем.
//
// Возвращаемое значение:
//  Строка - подписанный КонвертXML.
//
Функция Подписать(Знач КонвертXML, ПараметрыXMLDSig, СертификатКриптографии, МенеджерКриптографии) Экспорт
	
	Пароль = МенеджерКриптографии.ПарольДоступаКЗакрытомуКлючу;
	
	ОбъектКомпоненты = ОбъектВнешнейКомпонентыExtraCryptoAPI();
	
	СвойстваКриптопровайдера = СвойстваКриптопровайдера(МенеджерКриптографии);
	ОбъектКомпоненты.ПутьККриптопровайдеру = СвойстваКриптопровайдера.Путь;
	
	СвойстваКонвертаXML = СвойстваКонвертаXML(КонвертXML, ПараметрыXMLDSig, Ложь);
	Если СвойстваКонвертаXML <> Неопределено
	   И ЗначениеЗаполнено(СвойстваКонвертаXML.ТекстОшибки) Тогда
		ВызватьИсключение СвойстваКонвертаXML.ТекстОшибки;
	КонецЕсли;
	
	СертификатКриптографииBase64 = ЭлектроннаяПодписьСлужебныйКлиентСервер.СертификатКриптографииBase64(
		СертификатКриптографии.Выгрузить());
	
	ДанныеАлгоритмаПодписания = Новый Структура(Новый ФиксированнаяСтруктура(ПараметрыXMLDSig));
	ЭлектроннаяПодписьСлужебныйКлиентСервер.ПроверитьВыбратьАлгоритмПодписи(
		СертификатКриптографииBase64, ДанныеАлгоритмаПодписания, Истина, СвойстваКонвертаXML);
	
	КонвертXML = СтрЗаменить(КонвертXML, "%BinarySecurityToken%", СертификатКриптографииBase64);
	КонвертXML = СтрЗаменить(КонвертXML, "%SignatureMethod%", ДанныеАлгоритмаПодписания.ВыбранныйАлгоритмПодписи);
	КонвертXML = СтрЗаменить(КонвертXML, "%DigestMethod%",    ДанныеАлгоритмаПодписания.ВыбранныйАлгоритмХеширования);
	
	Если СвойстваКонвертаXML = Неопределено Тогда
		КанонизированныйТекстXMLBody = C14N(ОбъектКомпоненты,
			КонвертXML, ДанныеАлгоритмаПодписания.XPathПодписываемыйТег);
	Иначе
		КанонизированныйТекстXMLBody = КанонизированныйТекстXML(ОбъектКомпоненты,
			СвойстваКонвертаXML.ОбластьBody, СвойстваКонвертаXML.ХешируемаяОбласть.АлгоритмыТрансформации);
	КонецЕсли;
	
	АтрибутDigestValue = РезультатHash(ОбъектКомпоненты,
		КанонизированныйТекстXMLBody,
		ДанныеАлгоритмаПодписания.OIDВыбранногоАлгоритмаХеширования,
		СвойстваКриптопровайдера.Тип);
	
	КонвертXML = СтрЗаменить(КонвертXML, "%DigestValue%", АтрибутDigestValue);
	
	Если СвойстваКонвертаXML = Неопределено Тогда
		КанонизированныйТекстXMLSignedInfo = C14N(ОбъектКомпоненты,
			КонвертXML, ДанныеАлгоритмаПодписания.XPathSignedInfo);
	Иначе
		ОбластьSignedInfo = ЭлектроннаяПодписьСлужебныйКлиентСервер.ОбластьXML(КонвертXML,
			СвойстваКонвертаXML.ОбластьSignedInfo.ИмяЭлемента);
		ОбластьSignedInfo.ПространстваИменДоУзла =
			СвойстваКонвертаXML.ОбластьSignedInfo.ПространстваИменДоУзла;
		
		Если ЗначениеЗаполнено(ОбластьSignedInfo.ТекстОшибки) Тогда
			ВызватьИсключение ОбластьSignedInfo.ТекстОшибки;
		КонецЕсли;
		
		КанонизированныйТекстXMLSignedInfo = КанонизированныйТекстXML(ОбъектКомпоненты,
			ОбластьSignedInfo,
			ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(СвойстваКонвертаXML.АлгоритмКанонизации));
	КонецЕсли;
	
	АтрибутSignatureValue = РезультатSign(ОбъектКомпоненты,
		КанонизированныйТекстXMLSignedInfo,
		СертификатКриптографии,
		Пароль);
	
	КонвертXML = СтрЗаменить(КонвертXML, "%SignatureValue%", АтрибутSignatureValue);
	
	Возврат КонвертXML;
	
КонецФункции

// Возвращается сертификат, с помощью которого была произведена подпись.
// Если проверка подписи завершилась неудачно, генерируется исключительная ситуация.
//
// Параметры:
//  КонвертXML           - см. ЭлектроннаяПодписьКлиент.КонвертXML
//  ПараметрыXMLDSig     - см. ЭлектроннаяПодписьКлиент.ПараметрыXMLDSig
//  МенеджерКриптографии - МенеджерКриптографии - менеджер криптографии,
//                         который поддерживает алгоритмы проверяемой подписи.
//  СвойстваКонвертаXML  - см. СвойстваКонвертаXML
//
// Возвращаемое значение:
//  Структура:
//   * Сертификат     - СертификатКриптографии
//   * ДатаПодписания - Дата
//
Функция ПроверитьПодпись(Знач КонвертXML, ПараметрыXMLDSig, МенеджерКриптографии, СвойстваКонвертаXML = Неопределено) Экспорт
	
	ОбъектКомпоненты = ОбъектВнешнейКомпонентыExtraCryptoAPI();
	
	СвойстваКриптопровайдера = СвойстваКриптопровайдера(МенеджерКриптографии);
	ОбъектКомпоненты.ПутьККриптопровайдеру = СвойстваКриптопровайдера.Путь;
	ДанныеАлгоритмаПодписания = Новый Структура(Новый ФиксированнаяСтруктура(ПараметрыXMLDSig));
	
	Если СвойстваКонвертаXML = Неопределено Тогда
		КанонизированныйТекстXMLSignedInfo = C14N(ОбъектКомпоненты,
			КонвертXML, ДанныеАлгоритмаПодписания.XPathSignedInfo);
		КанонизированныйТекстXMLBody = C14N(ОбъектКомпоненты,
			КонвертXML, ДанныеАлгоритмаПодписания.XPathПодписываемыйТег);
		СертификатКриптографииBase64 = ЭлектроннаяПодписьСлужебныйКлиентСервер.СертификатИзКонвертаSOAP(КонвертXML);
		ЗначениеПодписи = ЭлектроннаяПодписьСлужебныйКлиентСервер.НайтиВXML(КонвертXML, "SignatureValue");
		ЗначениеХеша    = ЭлектроннаяПодписьСлужебныйКлиентСервер.НайтиВXML(КонвертXML, "DigestValue");
	Иначе
		КанонизированныйТекстXMLSignedInfo = КанонизированныйТекстXML(ОбъектКомпоненты,
			СвойстваКонвертаXML.ОбластьSignedInfo,
			ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(СвойстваКонвертаXML.АлгоритмКанонизации));
		КанонизированныйТекстXMLBody = КанонизированныйТекстXML(ОбъектКомпоненты,
			СвойстваКонвертаXML.ОбластьBody, СвойстваКонвертаXML.ХешируемаяОбласть.АлгоритмыТрансформации);
		СертификатКриптографииBase64 = СвойстваКонвертаXML.Сертификат.ЗначениеСертификата;
		ЗначениеПодписи = СвойстваКонвертаXML.ЗначениеПодписи;
		ЗначениеХеша    = СвойстваКонвертаXML.ХешируемаяОбласть.ЗначениеХеша;
	КонецЕсли;
	
	ЭлектроннаяПодписьСлужебныйКлиентСервер.ПроверитьВыбратьАлгоритмПодписи(
		СертификатКриптографииBase64, ДанныеАлгоритмаПодписания, Истина, СвойстваКонвертаXML);
	
	ПодписьВерна = РезультатVerifySign(ОбъектКомпоненты,
		КанонизированныйТекстXMLSignedInfo,
		ЗначениеПодписи,
		СертификатКриптографииBase64,
		СвойстваКриптопровайдера.Тип);
	
	АтрибутDigestValue = РезультатHash(ОбъектКомпоненты,
		КанонизированныйТекстXMLBody,
		ДанныеАлгоритмаПодписания.OIDВыбранногоАлгоритмаХеширования,
		СвойстваКриптопровайдера.Тип);
	
	ХешСовпадает = (АтрибутDigestValue = ЗначениеХеша);
	
	Если ХешСовпадает И ПодписьВерна Тогда
		
		ДвоичныеДанные = Base64Значение(СертификатКриптографииBase64);
		
		ДатаПодписания = ЭлектроннаяПодпись.ДатаПодписания(ДвоичныеДанные);
		Если Не ЗначениеЗаполнено(ДатаПодписания) Тогда
			ДатаПодписания = Неопределено;
		КонецЕсли;
		
		ВозвращаемоеЗначение = Новый Структура;
		ВозвращаемоеЗначение.Вставить("Сертификат", Новый СертификатКриптографии(ДвоичныеДанные));
		ВозвращаемоеЗначение.Вставить("ДатаПодписания", ДатаПодписания);
		
		Возврат ВозвращаемоеЗначение;
	Иначе
		Если ПодписьВерна Тогда
			ТекстОшибки = НСтр("ru = 'Подпись неверна (SignatureValue корректно, DigestValue некорректно).'")
		ИначеЕсли ХешСовпадает Тогда
			ТекстОшибки = НСтр("ru = 'Подпись неверна (SignatureValue некорректно, DigestValue корректно).'");
		Иначе
			ТекстОшибки = НСтр("ru = 'Подпись неверна (SignatureValue некорректно, DigestValue некорректно).'");
		КонецЕсли;
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
КонецФункции

// Вычисляет и проверят свойства конверта XML для подписания и проверки подписи.
//
// Параметры:
//  КонвертXML             - см. ЭлектроннаяПодписьКлиент.КонвертXML
//  ПараметрыXMLDSig       - см. ЭлектроннаяПодписьКлиент.ПараметрыXMLDSig
//  ПроверкаПодписи  - Булево - когда Ложь, тогда в конверте проверяется наличие
//                                параметров для подстановки и алгоритмов канонизации.
//                              Когда Истина, тогда - в конверте корректность алгоритмов
//                                канонизации, подписания и хеширования, а также заполненность
//                                значений подписи, хеша и сертификата.
//
// Возвращаемое значение:
//   см. ВозвращаемыеСвойстваКонвертаXML
//
Функция СвойстваКонвертаXML(КонвертXML, ПараметрыXMLDSig, ПроверкаПодписи) Экспорт
	
	Если ЗначениеЗаполнено(ПараметрыXMLDSig.XPathSignedInfo)
	 Или ЗначениеЗаполнено(ПараметрыXMLDSig.XPathПодписываемыйТег) Тогда
		Возврат Неопределено; // Обратная совместимость.
	КонецЕсли;
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(КонвертXML);
	
	ПостроительDOM = Новый ПостроительDOM;
	ДокументDOM = ПостроительDOM.Прочитать(ЧтениеXML);
	
	ЧтениеXML.Закрыть();
	
	СвойстваКонвертаXML = СлужебныеСвойстваКонвертаXML(ПроверкаПодписи);
	
	ИмяУзлаПодписи = "Signature";
	ИмяПространстваИменУзлаПодписи = "http://www.w3.org/2000/09/xmldsig#";
	ПространстваИменДоУзлаSignatureВключительно = Новый Массив;
	
	УзелSignature = НайтиУзелПоИмени(ДокументDOM,
		ИмяУзлаПодписи, ИмяПространстваИменУзлаПодписи,
		СвойстваКонвертаXML.ТекстОшибки, , ПространстваИменДоУзлаSignatureВключительно);
	Если УзелSignature = Неопределено Тогда
		Возврат ВозвращаемыеСвойстваКонвертаXML(СвойстваКонвертаXML);
	КонецЕсли;
	
	Для Каждого ДочернийУзел Из УзелSignature.ДочерниеУзлы Цикл
		Если ДочернийУзел.ЛокальноеИмя = "SignedInfo" Тогда
			Если Не ОбработатьУзелSignedInfo(ДочернийУзел, СвойстваКонвертаXML) Тогда
				Прервать;
			КонецЕсли;
		ИначеЕсли ДочернийУзел.ЛокальноеИмя = "SignatureValue" Тогда
			Если Не ПолучитьЗначение(ДочернийУзел, СвойстваКонвертаXML, "ЗначениеПодписи") Тогда
				Возврат ВозвращаемыеСвойстваКонвертаXML(СвойстваКонвертаXML);
			КонецЕсли;
		ИначеЕсли ДочернийУзел.ЛокальноеИмя = "KeyInfo" Тогда
			Если Не ОбработатьУзелKeyInfo(ДочернийУзел, СвойстваКонвертаXML) Тогда
				Прервать;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если ЗначениеЗаполнено(СвойстваКонвертаXML.ТекстОшибки) Тогда
		Возврат ВозвращаемыеСвойстваКонвертаXML(СвойстваКонвертаXML);
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из СвойстваКонвертаXML.ОбязательныеУзлы Цикл
		Если КлючИЗначение.Значение <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ЧастиИмени = СтрРазделить(КлючИЗначение.Ключ, "_");
		Если ЧастиИмени.Количество() > 1 Тогда
			СвойстваКонвертаXML.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'В документе XML не найден узел ""%1"" в узле ""%2"".'"), КлючИЗначение.Ключ);
		Иначе
			СвойстваКонвертаXML.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'В документе XML не найден узел ""%1"".'"), ЧастиИмени[0]);
		КонецЕсли;
		Возврат ВозвращаемыеСвойстваКонвертаXML(СвойстваКонвертаXML);
	КонецЦикла;
	
	Если ЗначениеЗаполнено(СвойстваКонвертаXML.Сертификат.ИдентификаторУзла)
	   И ЗначениеЗаполнено(СвойстваКонвертаXML.Сертификат.ЗначениеСертификата) Тогда
		
		СвойстваКонвертаXML.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В документе XML сертификат объявлен дважды:
			           |- в виде URI ссылки на элемент ""%1"";
			           |- в виде данных ""%2"".'"),
			СвойстваКонвертаXML.Сертификат.ИдентификаторУзла,
			СвойстваКонвертаXML.Сертификат.ЗначениеСертификата);
		
		Возврат ВозвращаемыеСвойстваКонвертаXML(СвойстваКонвертаXML);
		
	ИначеЕсли Не ЗначениеЗаполнено(СвойстваКонвертаXML.Сертификат.ИдентификаторУзла)
	        И Не ЗначениеЗаполнено(СвойстваКонвертаXML.Сертификат.ЗначениеСертификата) Тогда
		
		СвойстваКонвертаXML.ТекстОшибки =
			НСтр("ru = 'В документе XML не найден сертификат.'");
		
		Возврат ВозвращаемыеСвойстваКонвертаXML(СвойстваКонвертаXML);
	КонецЕсли;
	
	ИсключаемыеУзлы = Новый Массив;
	ИсключаемыеУзлы.Добавить(УзелSignature);
	
	Если ЗначениеЗаполнено(СвойстваКонвертаXML.Сертификат.ИдентификаторУзла) Тогда
		УзелСертификат = НайтиУзелПоИдентификатору(ДокументDOM,
			СвойстваКонвертаXML.Сертификат.ИдентификаторУзла,
			СвойстваКонвертаXML.ТекстОшибки,
			ИсключаемыеУзлы);
		Если ЗначениеЗаполнено(СвойстваКонвертаXML.ТекстОшибки) Тогда
			Возврат ВозвращаемыеСвойстваКонвертаXML(СвойстваКонвертаXML);
		КонецЕсли;
		Если Не ПолучитьЗначение(УзелСертификат, СвойстваКонвертаXML,
					"ЗначениеСертификата", СвойстваКонвертаXML.Сертификат) Тогда
			Возврат ВозвращаемыеСвойстваКонвертаXML(СвойстваКонвертаXML);
		КонецЕсли;
		ИсключаемыеУзлы.Добавить(УзелСертификат);
	КонецЕсли;
	
	ПространстваИменДоУзлаBody = Новый Массив;
	УзелBody = НайтиУзелПоИдентификатору(ДокументDOM,
		СвойстваКонвертаXML.ХешируемаяОбласть.ИдентификаторУзла,
		СвойстваКонвертаXML.ТекстОшибки,
		ИсключаемыеУзлы,
		ПространстваИменДоУзлаBody);
	
	Если ЗначениеЗаполнено(СвойстваКонвертаXML.ТекстОшибки) Тогда
		Возврат ВозвращаемыеСвойстваКонвертаXML(СвойстваКонвертаXML);
	КонецЕсли;
	
	ИсключаемыеУзлы.Добавить(УзелBody);
	
	УзелSignature2 = НайтиУзелПоИмени(ДокументDOM,
		ИмяУзлаПодписи, ИмяПространстваИменУзлаПодписи,
		СвойстваКонвертаXML.ТекстОшибки, ИсключаемыеУзлы, , Истина);
	Если УзелSignature2 <> Неопределено Тогда
		Возврат ВозвращаемыеСвойстваКонвертаXML(СвойстваКонвертаXML);
	КонецЕсли;
	
	УзелBody2 = НайтиУзелПоИдентификатору(ДокументDOM,
		СвойстваКонвертаXML.ХешируемаяОбласть.ИдентификаторУзла,
		СвойстваКонвертаXML.ТекстОшибки, ИсключаемыеУзлы, , Истина);
	Если УзелBody2 <> Неопределено Тогда
		Возврат ВозвращаемыеСвойстваКонвертаXML(СвойстваКонвертаXML);
	КонецЕсли;
	
	УзелSignedInfo = СвойстваКонвертаXML.УникальныеУзлы.SignedInfo; // ЭлементDOM
	ОбластьSignedInfo = ЭлектроннаяПодписьСлужебныйКлиентСервер.ОбластьXML(КонвертXML,
		УзелSignedInfo.ИмяЭлемента);
	Если ЗначениеЗаполнено(ОбластьSignedInfo.ТекстОшибки) Тогда
		СвойстваКонвертаXML.ТекстОшибки = ОбластьSignedInfo.ТекстОшибки;
		Возврат ВозвращаемыеСвойстваКонвертаXML(СвойстваКонвертаXML);
	КонецЕсли;
	ОбластьSignedInfo.ПространстваИменДоУзла = ПространстваИменДоУзлаSignatureВключительно;
	СвойстваКонвертаXML.ОбластьSignedInfo = ОбластьSignedInfo;
	
	ОбластьBody = ЭлектроннаяПодписьСлужебныйКлиентСервер.ОбластьXML(КонвертXML,
		УзелBody.ИмяЭлемента);
	Если ЗначениеЗаполнено(ОбластьBody.ТекстОшибки) Тогда
		СвойстваКонвертаXML.ТекстОшибки = ОбластьBody.ТекстОшибки;
		Возврат ВозвращаемыеСвойстваКонвертаXML(СвойстваКонвертаXML);
	КонецЕсли;
	ОбластьBody.ПространстваИменДоУзла = ПространстваИменДоУзлаBody;
	СвойстваКонвертаXML.ОбластьBody = ОбластьBody;
	
	Возврат ВозвращаемыеСвойстваКонвертаXML(СвойстваКонвертаXML);
	
КонецФункции

Функция ОбъектВнешнейКомпонентыExtraCryptoAPI()
	
	ОписаниеКомпоненты = ЭлектроннаяПодписьСлужебныйКлиентСервер.ОписаниеКомпоненты();
	ОбъектКомпоненты = ОбщегоНазначения.ПодключитьКомпонентуИзМакета(ОписаниеКомпоненты.ИмяОбъекта,
		ОписаниеКомпоненты.ПолноеИмяМакета);
	
	Если ОбъектКомпоненты = Неопределено Тогда
		ТекстОшибки = НСтр("ru = 'Не удалось подключить внешнюю компоненту ExtraCryptoAPI.'");
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	НастроитьКомпоненту(ОбъектКомпоненты);
	
	Возврат ОбъектКомпоненты;
	
КонецФункции

Процедура НастроитьКомпоненту(ОбъектКомпоненты)
	
	Попытка
		ОбъектКомпоненты.СоответствиеOID =
			ЭлектроннаяПодписьСлужебныйКлиентСервер.ИдентификаторыАлгоритмовХешированияИОткрытогоКлюча();
	Исключение
		ТекстОшибки = НСтр("ru = 'При установке свойства СоответствиеOID компоненты ExtraCryptoAPI произошла ошибка:'")
			+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
КонецПроцедуры

// Подписывает данные и возвращает подпись с данными или без них.
//
// Параметры:
//  Данные - Строка - произвольная строка для подписания,
//         - ДвоичныеДанные - двоичные данные для подписания.
//
//  ПараметрыCMS            - Структура - возвращается функцией ЭлектроннаяПодпись.ПараметрыCMS.
//  СертификатКриптографии  - СертификатКриптографии - используемый сертификат криптографии.
//  МенеджерКриптографии    - МенеджерКриптографии   - используемый менеджер криптографии.
// 
// Возвращаемое значение:
//  Строка - строка в формате Base64.
//
Функция ПодписатьCMS(Знач Данные, ПараметрыCMS, СертификатКриптографии, МенеджерКриптографии) Экспорт
	
	Пароль = МенеджерКриптографии.ПарольДоступаКЗакрытомуКлючу;
	
	ОбъектКомпоненты = ОбъектВнешнейКомпонентыExtraCryptoAPI();
	
	СвойстваКриптопровайдера = СвойстваКриптопровайдера(МенеджерКриптографии);
	ОбъектКомпоненты.ПутьККриптопровайдеру = СвойстваКриптопровайдера.Путь;
	
	АтрибутSignatureValue = РезультатCMSSign(ОбъектКомпоненты,
		Данные,
		ПараметрыCMS,
		СертификатКриптографии,
		Пароль);
	
	Возврат АтрибутSignatureValue;
	
КонецФункции

Функция ПроверитьПодписьCMS(Подпись, Данные, ПараметрыCMS, МенеджерКриптографии) Экспорт
	
	ОбъектКомпоненты = ОбъектВнешнейКомпонентыExtraCryptoAPI();
	
	СвойстваКриптопровайдера = СвойстваКриптопровайдера(МенеджерКриптографии);
	ОбъектКомпоненты.ПутьККриптопровайдеру = СвойстваКриптопровайдера.Путь;
	
	Результат = РезультатCMSVerifySign(ОбъектКомпоненты,
		Подпись,
		Данные,
		ПараметрыCMS,
		СвойстваКриптопровайдера.Тип);
	
	Возврат Результат;
	
КонецФункции

Функция СвойстваКриптопровайдера(МенеджерКриптографии)
	
	ИнформацияМодуляКриптографии = МенеджерКриптографии.ПолучитьИнформациюМодуляКриптографии();
	
	ИмяКриптопровайдера = ИнформацияМодуляКриптографии.Имя;
	ОписаниеПрограммы = ЭлектроннаяПодписьСлужебныйКлиентСервер.ОписаниеПрограммыПоИмениКриптопровайдера(ИмяКриптопровайдера,
		ЭлектроннаяПодпись.ОбщиеНастройки().ОписанияПрограмм); // см. ЭлектроннаяПодписьСлужебныйПовтИсп.ОписаниеПрограммы
	
	Если ОписаниеПрограммы = Неопределено Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось определить тип криптопровайдера %1'"), ИмяКриптопровайдера);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	ОписаниеПути = ПутьКПрограмме(ОписаниеПрограммы.Ссылка);
	Если ЗначениеЗаполнено(ОписаниеПути.ТекстОшибки) Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось определить путь к программе электронной подписи
			           |""%1"" по причине:
			           |%2'"),
			ОписаниеПрограммы.Ссылка,
			ОписаниеПути.ТекстОшибки);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Свойства = Новый Структура("Тип, Путь", ОписаниеПрограммы.ТипПрограммы, "");
	Свойства.Путь = ОписаниеПути.ПутьКПрограмме;
	
	Возврат Свойства;
	
КонецФункции

Функция C14N(ОбъектКомпоненты, КонвертXML, XPath)
	
	Попытка
		КанонизированныйТекстXML = ОбъектКомпоненты.C14N(КонвертXML, XPath);
	Исключение
		ТекстОшибки = НСтр("ru = 'Ошибка вызова метода C14N компоненты ExtraCryptoAPI.'")
			+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	Если КанонизированныйТекстXML = Неопределено Тогда
		ТекстОшибки = НСтр("ru = 'Ошибка вызова метода C14N компоненты ExtraCryptoAPI.'")
			+ Символы.ПС + ОбъектКомпоненты.GetLastError();
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Возврат КанонизированныйТекстXML;
	
КонецФункции

Функция КанонизированныйТекстXML(ОбъектКомпоненты, ОбластьXML, Алгоритмы)
	
	Результат = Неопределено;
	ВышестоящиеПространстваИменДобавлены = Ложь;
	
	Для Каждого Алгоритм Из Алгоритмы Цикл
		Если Алгоритм.Вид = "envsig" Тогда
			Продолжить;
		ИначеЕсли Алгоритм.Вид = "c14n"
		      Или Алгоритм.Вид = "smev" Тогда
			
			Если Не ВышестоящиеПространстваИменДобавлены Тогда
				ОписаниеНачалаОбласти = ЭлектроннаяПодписьСлужебныйКлиентСервер.РасширенноеНачалоОбластиXML(
					ОбластьXML, Алгоритм, Результат);
				Если ЗначениеЗаполнено(ОписаниеНачалаОбласти.ТекстОшибки) Тогда
					ВызватьИсключение ОписаниеНачалаОбласти.ТекстОшибки;
				КонецЕсли;
				ТекстXML = ЭлектроннаяПодписьСлужебныйКлиентСервер.ТекстОбластиXML(ОбластьXML,
					ОписаниеНачалаОбласти.Начало);
				ВышестоящиеПространстваИменДобавлены = Истина;
				
			ИначеЕсли Результат = Неопределено Тогда
				ТекстXML = ЭлектроннаяПодписьСлужебныйКлиентСервер.ТекстОбластиXML(ОбластьXML);
			Иначе
				ТекстXML = Результат;
			КонецЕсли;
			
			Если Алгоритм.Вид = "c14n" Тогда
				Результат = C14N_body(ОбъектКомпоненты, ТекстXML, Алгоритм);
			Иначе
				Результат = TransformSMEV(ОбъектКомпоненты, ТекстXML);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если Результат = Неопределено Тогда
		Результат = ЭлектроннаяПодписьСлужебныйКлиентСервер.ТекстОбластиXML(ОбластьXML);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция C14N_body(ОбъектКомпоненты, ТекстXML, Алгоритм)
	
	Попытка
		КанонизированныйТекстXML = ОбъектКомпоненты.c14n_body(ТекстXML,
			Алгоритм.Версия, Алгоритм.СКомментариями);
	Исключение
		ТекстОшибки = НСтр("ru = 'Ошибка вызова метода C14N_body компоненты ExtraCryptoAPI.'")
			+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	Если КанонизированныйТекстXML = Неопределено Тогда
		ТекстОшибки = НСтр("ru = 'Ошибка вызова метода C14N_body компоненты ExtraCryptoAPI.'")
			+ Символы.ПС + ОбъектКомпоненты.GetLastError();
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Возврат КанонизированныйТекстXML;
	
КонецФункции

Функция TransformSMEV(ОбъектКомпоненты, ТекстXML)
	
	Попытка
		КанонизированныйТекстXML = ОбъектКомпоненты.TransformSMEV(ТекстXML);
	Исключение
		ТекстОшибки = НСтр("ru = 'Ошибка вызова метода TransformSMEV компоненты ExtraCryptoAPI.'")
			+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	Если КанонизированныйТекстXML = Неопределено Тогда
		ТекстОшибки = НСтр("ru = 'Ошибка вызова метода TransformSMEV компоненты ExtraCryptoAPI.'")
			+ Символы.ПС + ОбъектКомпоненты.GetLastError();
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Возврат КанонизированныйТекстXML;
	
КонецФункции

Функция РезультатHash(ОбъектКомпоненты, КанонизированныйТекстXMLBody, OIDАлгоритмаХеширования, ТипКриптопровайдера)
	
	Попытка
		АтрибутDigestValue = ОбъектКомпоненты.Hash(
			КанонизированныйТекстXMLBody,
			OIDАлгоритмаХеширования,
			ТипКриптопровайдера);
	Исключение
		ТекстОшибки = НСтр("ru = 'Ошибка вызова метода Hash компоненты ExtraCryptoAPI.'")
			+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	Если АтрибутDigestValue = Неопределено Тогда
		ТекстОшибки = НСтр("ru = 'Ошибка вызова метода Hash компоненты ExtraCryptoAPI.'")
			+ Символы.ПС + ОбъектКомпоненты.GetLastError();
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Возврат АтрибутDigestValue;
	
КонецФункции

Функция РезультатSign(ОбъектКомпоненты, КанонизированныйТекстXMLSignedInfo,
	СертификатКриптографии, ПарольДоступаКЗакрытомуКлючу)
	
	СертификатКриптографииBase64 = ЭлектроннаяПодписьСлужебныйКлиентСервер.СертификатКриптографииBase64(
		СертификатКриптографии.Выгрузить());
	
	Попытка
		АтрибутSignatureValue = ОбъектКомпоненты.Sign(
			КанонизированныйТекстXMLSignedInfo,
			СертификатКриптографииBase64,
			ПарольДоступаКЗакрытомуКлючу);
	Исключение
		ТекстОшибки = НСтр("ru = 'Ошибка вызова метода Sign компоненты ExtraCryptoAPI.'")
			+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	Если АтрибутSignatureValue = Неопределено Тогда
		ТекстОшибки = НСтр("ru = 'Ошибка вызова метода Sign компоненты ExtraCryptoAPI.'")
			+ Символы.ПС + ОбъектКомпоненты.GetLastError();
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Возврат АтрибутSignatureValue;
	
КонецФункции

Функция РезультатVerifySign(ОбъектКомпоненты, КанонизированныйТекстXMLSignedInfo,
	АтрибутSignatureValue, СертификатКриптографииBase64, ТипКриптопровайдера)
	
	Попытка
		ПодписьВерна = ОбъектКомпоненты.VerifySign(
			КанонизированныйТекстXMLSignedInfo,
			АтрибутSignatureValue,
			СертификатКриптографииBase64,
			ТипКриптопровайдера);
	Исключение
		ТекстОшибки = НСтр("ru = 'Ошибка вызова метода VerifySign компоненты ExtraCryptoAPI.'")
			+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	Если ПодписьВерна = Неопределено Тогда
		ТекстОшибки = НСтр("ru = 'Ошибка вызова метода VerifySign компоненты ExtraCryptoAPI.'")
			+ Символы.ПС + ОбъектКомпоненты.GetLastError();
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Возврат ПодписьВерна;
	
КонецФункции

Функция РезультатCMSSign(ОбъектКомпоненты, ДанныеДляПодписания, ПараметрыCMS, СертификатКриптографии, ПарольДоступаКЗакрытомуКлючу)
	
	ПараметрыКомпоненты = ЭлектроннаяПодписьСлужебныйКлиентСервер.ПараметрыКомпонентыCMSSign(ПараметрыCMS, ДанныеДляПодписания);
	
	СертификатКриптографииBase64 = ЭлектроннаяПодписьСлужебныйКлиентСервер.СертификатКриптографииBase64(
		СертификатКриптографии.Выгрузить());
	
	Попытка
		АтрибутSignatureValue = ОбъектКомпоненты.CMSSign(
			ПараметрыКомпоненты.Данные,
			СертификатКриптографииBase64,
			ПарольДоступаКЗакрытомуКлючу,
			ПараметрыКомпоненты.ТипПодписи,
			ПараметрыКомпоненты.Открепленная,
			ПараметрыКомпоненты.ВключениеСертификатовВПодпись);
	Исключение
		ТекстОшибки = НСтр("ru = 'Ошибка вызова метода CMSSign компоненты ExtraCryptoAPI.'")
			+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	Если Не ЗначениеЗаполнено(АтрибутSignatureValue) Тогда
		ТекстОшибки = НСтр("ru = 'Ошибка вызова метода CMSSign компоненты ExtraCryptoAPI.'")
			+ Символы.ПС + ОбъектКомпоненты.GetLastError();
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Возврат АтрибутSignatureValue;
	
КонецФункции

Функция РезультатCMSVerifySign(ОбъектКомпоненты, Подпись, Данные, ПараметрыCMS, ТипКриптопровайдера)
	
	Сертификат = Null;
	Попытка
		ПодписьВерна = ОбъектКомпоненты.CMSVerifySign(Подпись,
			ПараметрыCMS.Открепленная, Данные, ТипКриптопровайдера, Сертификат);
	Исключение
		ТекстОшибки = НСтр("ru = 'Ошибка вызова метода CMSVerifySign компоненты ExtraCryptoAPI.'")
			+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	Если ПодписьВерна = Неопределено Тогда
		ТекстОшибки = НСтр("ru = 'Ошибка вызова метода CMSVerifySign компоненты ExtraCryptoAPI.'")
			+ Символы.ПС + ОбъектКомпоненты.GetLastError();
		ВызватьИсключение ТекстОшибки;
		
	ИначеЕсли Не ПодписьВерна Тогда
		ТекстОшибки = НСтр("ru = 'Подпись неверна.'");
		ВызватьИсключение ТекстОшибки;
		
	ИначеЕсли ТипЗнч(Сертификат) <> Тип("ДвоичныеДанные") Тогда
		ТекстОшибки = НСтр("ru = 'Подпись верна, но не содержит данных сертификата.'");
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	ДатаПодписания = ЭлектроннаяПодпись.ДатаПодписания(Подпись);
	Если Не ЗначениеЗаполнено(ДатаПодписания) Тогда
		ДатаПодписания = Неопределено;
	КонецЕсли;
	
	ВозвращаемоеЗначение = Новый Структура;
	ВозвращаемоеЗначение.Вставить("Сертификат", Новый СертификатКриптографии(Сертификат));
	ВозвращаемоеЗначение.Вставить("ДатаПодписания", ДатаПодписания);
	
	Возврат ВозвращаемоеЗначение;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Вспомогательные процедуры и функции.

// Для процедуры ОбновитьСписокСертификатов.
Процедура ОбработатьДобавленныеСертификаты(ТаблицаСвойствСертификатов, КромеУжеДобавленных, ОтборПоОрганизации = Неопределено)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Отпечатки", ТаблицаСвойствСертификатов.Скопировать(, "Отпечаток"));
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Отпечатки.Отпечаток
	|ПОМЕСТИТЬ Отпечатки
	|ИЗ
	|	&Отпечатки КАК Отпечатки
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Сертификаты.Отпечаток,
	|	Сертификаты.Наименование КАК Представление,
	|	ЛОЖЬ КАК ЭтоЗаявление,
	|	Сертификаты.Организация
	|ИЗ
	|	Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования КАК Сертификаты
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Отпечатки КАК Отпечатки
	|		ПО Сертификаты.Отпечаток = Отпечатки.Отпечаток";
	
	Если Метаданные.Обработки.Найти("ЗаявлениеНаВыпускНовогоКвалифицированногоСертификата") <> Неопределено Тогда
		ОбработкаЗаявлениеНаВыпускНовогоКвалифицированногоСертификата =
			ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(
				"Обработка.ЗаявлениеНаВыпускНовогоКвалифицированногоСертификата");
		ОбработкаЗаявлениеНаВыпускНовогоКвалифицированногоСертификата.ДополнитьЗапросПриДобавленииСертификатов(
			Запрос.Текст);
	КонецЕсли;
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Строка = ТаблицаСвойствСертификатов.Найти(Выборка.Отпечаток, "Отпечаток");
		Если КромеУжеДобавленных Тогда
			Если Строка <> Неопределено Тогда // Защита от ошибки в данных (дубли сертификатов).
				ТаблицаСвойствСертификатов.Удалить(Строка);
			КонецЕсли;
		ИначеЕсли ЗначениеЗаполнено(ОтборПоОрганизации) Тогда
			Если Строка <> Неопределено И Выборка.Организация <> ОтборПоОрганизации Тогда // Защита от ошибки в данных (дубли сертификатов).
				ТаблицаСвойствСертификатов.Удалить(Строка);
			КонецЕсли;
		Иначе
			Строка.Представление = Выборка.Представление;
			Строка.ЭтоЗаявление  = Выборка.ЭтоЗаявление;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ОбновитьСписокСертификатов.
Процедура ОбновитьЗначение(СтароеЗначение, НовоеЗначение, ПропускатьНеопределенныеЗначения = Ложь)
	
	Если НовоеЗначение = Неопределено И ПропускатьНеопределенныеЗначения Тогда
		Возврат;
	КонецЕсли;
	
	Если СтароеЗначение <> НовоеЗначение Тогда
		СтароеЗначение = НовоеЗначение;
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаполнитьРеквизит(СохраненныеСвойства, ПараметрыРеквизитов, ИмяРеквизита)
	
	Если ПараметрыРеквизитов.Свойство(ИмяРеквизита) Тогда
		ПараметрыРеквизита =  ПараметрыРеквизитов[ИмяРеквизита]; // Структура
		Если ПараметрыРеквизита.ЗначениеЗаполнения <> Неопределено Тогда

			СохраненныеСвойства[ИмяРеквизита] = ПараметрыРеквизита.ЗначениеЗаполнения;
			
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры НастроитьФормуПодписанияШифрованияРасшифровки.
Процедура ЗаполнитьОтборОтпечатков(Форма)
	
	Параметры = Форма.Параметры;
	
	Отбор = Новый Соответствие;
	
	Если ТипЗнч(Параметры.СертификатыШифрования) = Тип("Массив") Тогда
		Описания = Новый Соответствие;
		Отпечатки = Новый Соответствие;
		ПредставленияОтпечатков = Новый Соответствие;
		
		Для каждого Описание Из Параметры.СертификатыШифрования Цикл
			Если Описания[Описание] <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			Описания.Вставить(Описание, Истина);
			Сертификаты = СертификатыШифрованияИзОписания(Описание);
			
			Для каждого Свойства Из Сертификаты Цикл
				Значение = Отпечатки[Свойства.Отпечаток];
				Значение = ?(Значение = Неопределено, 1, Значение + 1);
				Отпечатки.Вставить(Свойства.Отпечаток, Значение);
				ПредставленияОтпечатков.Вставить(Свойства.Отпечаток, Свойства.Представление);
			КонецЦикла;
		КонецЦикла;
		КоличествоЭлементовДанных = Параметры.СертификатыШифрования.Количество();
		Для каждого КлючИЗначение Из Отпечатки Цикл
			Если КлючИЗначение.Значение = КоличествоЭлементовДанных Тогда
				Отбор.Вставить(КлючИЗначение.Ключ, ПредставленияОтпечатков[КлючИЗначение.Ключ]);
			КонецЕсли;
		КонецЦикла;
		
	ИначеЕсли Параметры.СертификатыШифрования <> Неопределено Тогда
		
		Сертификаты = СертификатыШифрованияИзОписания(Параметры.СертификатыШифрования);
		Для каждого Свойства Из Сертификаты Цикл
			Отбор.Вставить(Свойства.Отпечаток, Свойства.Представление);
		КонецЦикла;
	КонецЕсли;
	
	Форма.ОтборОтпечатков = ПоместитьВоВременноеХранилище(Отбор, Форма.УникальныйИдентификатор);
	
КонецПроцедуры

// Для процедуры ЗаполнитьОтборОтпечатков.
Функция СертификатыШифрованияИзОписания(Описание)
	
	Если ТипЗнч(Описание) = Тип("Строка") Тогда
		Возврат ПолучитьИзВременногоХранилища(Описание);
	КонецЕсли;
	
	Сертификаты = Новый Массив;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	СертификатыШифрования.Представление,
		|	СертификатыШифрования.Отпечаток,
		|	СертификатыШифрования.Сертификат
		|ИЗ
		|	РегистрСведений.СертификатыШифрования КАК СертификатыШифрования
		|ГДЕ
		|	СертификатыШифрования.ЗашифрованныйОбъект = &ЗашифрованныйОбъект";
	
	Запрос.УстановитьПараметр("ЗашифрованныйОбъект", Описание);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		СвойстваСертификата = Новый Структура("Отпечаток, Представление, Сертификат");
		ЗаполнитьЗначенияСвойств(СвойстваСертификата, ВыборкаДетальныеЗаписи);
		СвойстваСертификата.Сертификат = СвойстваСертификата.Сертификат.Получить();
		Сертификаты.Добавить(СвойстваСертификата);
	КонецЦикла;
	
	Возврат Сертификаты;
	
КонецФункции

Функция ДвоичныеДанныеСтроки(ДанныеСтроки)
	
	ВременныйФайл = ПолучитьИмяВременногоФайла();
	
	ЗаписьТекста = Новый ЗаписьТекста(ВременныйФайл, КодировкаТекста.UTF8);
	ЗаписьТекста.Записать(ДанныеСтроки);
	ЗаписьТекста.Закрыть();
	
	ДвоичныеДанныеСертификата = Новый ДвоичныеДанные(ВременныйФайл);
	
	УдалитьФайлы(ВременныйФайл);
	
	Возврат ДвоичныеДанныеСертификата;
	
КонецФункции

// Для процедур НастроитьФормуПодписанияШифрованияРасшифровки, СертификатПриИзмененииНаСервере.

Процедура ЗаполнитьСуществующиеСертификатыПользователя(СписокВыбора, ОтпечаткиСертификатовНаКлиенте,
			ОтборСертификатов, ОтборОтпечатков, Расшифровка, ВыполнятьНаСервере)
	
	СписокВыбора.Очистить();
	ТекущаяДатаСеанса = ?(Расшифровка И ЗначениеЗаполнено(ОтборОтпечатков), Неопределено, ТекущаяДатаСеанса());
	
	Если ЭлектроннаяПодпись.СоздаватьЭлектронныеПодписиНаСервере()
	   И ВыполнятьНаСервере <> Ложь Тогда
		
		МенеджерКриптографии = МенеджерКриптографии("ПолучениеСертификатов");
		
		Если МенеджерКриптографии <> Неопределено Тогда
			ТипХранилища = ТипХранилищаСертификатовКриптографии.ПерсональныеСертификаты;
			МассивСертификатов = МенеджерКриптографии.ПолучитьХранилищеСертификатов(ТипХранилища).ПолучитьВсе();
			
			ЭлектроннаяПодписьСлужебныйКлиентСервер.ДобавитьОтпечаткиСертификатов(ОтпечаткиСертификатовНаКлиенте,
				МассивСертификатов, ДобавкаВремени(), ТекущаяДатаСеанса);
		КонецЕсли;
		
	КонецЕсли;
	
	Если ИспользоватьЭлектроннуюПодписьВМоделиСервиса() Тогда
		МодульХранилищеСертификатов = ОбщегоНазначения.ОбщийМодуль("ХранилищеСертификатов");
		МассивСертификатов = МодульХранилищеСертификатов.Получить("ПерсональныеСертификаты");
		
		ЭлектроннаяПодписьСлужебныйКлиентСервер.ДобавитьОтпечаткиСертификатов(
			ОтпечаткиСертификатовНаКлиенте, МассивСертификатов, ДобавкаВремени(), ТекущаяДатаСеанса);
	КонецЕсли;
	
	Если ИспользоватьСервисОблачнойПодписи() Тогда
		
		// Локализация
		МодульСервисКриптографииDSSСлужебный = ОбщегоНазначения.ОбщийМодуль("СервисКриптографииDSSСлужебный");
		ВсеСертификаты = МодульСервисКриптографииDSSСлужебный.ПолучитьВсеСертификаты(Ложь);
		
		МассивСертификатов = Новый ТаблицаЗначений;
		МассивСертификатов.Колонки.Добавить("Отпечаток");
		МассивСертификатов.Колонки.Добавить("ДатаНачала");
		МассивСертификатов.Колонки.Добавить("ДатаОкончания");
		
		Для каждого СтрокаТаблицы Из ВсеСертификаты Цикл
			НоваяСтрока = МассивСертификатов.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаТаблицы);
			НоваяСтрока.Отпечаток = ПолучитьДвоичныеДанныеИзHexСтроки(СтрокаТаблицы.Отпечаток);
		КонецЦикла;
	
		ЭлектроннаяПодписьСлужебныйКлиентСервер.ДобавитьОтпечаткиСертификатов(
			ОтпечаткиСертификатовНаКлиенте, МассивСертификатов, ДобавкаВремени(), ТекущаяДатаСеанса());
		// Конец Локализация
			
	КонецЕсли;	
	
	ОтборПоОрганизации = Ложь;
	
	Если ТипЗнч(ОтборСертификатов) = Тип("СписокЗначений") Тогда
		Если ОтборСертификатов.Количество() > 0 Тогда
			ТекущийСписок = Новый СписокЗначений;
			Для каждого ЭлементСписка Из ОтборСертификатов Цикл
				Свойства = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(
					ЭлементСписка.Значение, "Ссылка, Наименование, Отпечаток, Пользователь");
				
				Если ОтпечаткиСертификатовНаКлиенте.Найти(Свойства.Отпечаток) <> Неопределено Тогда
					ТекущийСписок.Добавить(Свойства.Ссылка, Свойства.Наименование,
						Свойства.Пользователь = Пользователи.АвторизованныйПользователь());
				КонецЕсли;
			КонецЦикла;
			Для Каждого ЭлементСписка Из ТекущийСписок Цикл
				Если ЭлементСписка.Пометка Тогда
					СписокВыбора.Добавить(ЭлементСписка.Значение, ЭлементСписка.Представление);
				КонецЕсли;
			КонецЦикла;
			Для Каждого ЭлементСписка Из ТекущийСписок Цикл
				Если Не ЭлементСписка.Пометка Тогда
					СписокВыбора.Добавить(ЭлементСписка.Значение, ЭлементСписка.Представление);
				КонецЕсли;
			КонецЦикла;
			Возврат;
		КонецЕсли;
	ИначеЕсли Метаданные.ОпределяемыеТипы.Организация.Тип.СодержитТип(ТипЗнч(ОтборСертификатов)) Тогда
		ОтборПоОрганизации = Истина;
	КонецЕсли;
	
	Если ОтборОтпечатков <> Неопределено Тогда
		Отбор = ПолучитьИзВременногоХранилища(ОтборОтпечатков);
		Для каждого Отпечаток Из ОтпечаткиСертификатовНаКлиенте Цикл
			Если Отбор[Отпечаток] = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			СписокВыбора.Добавить(Отпечаток, Отбор[Отпечаток]);
		КонецЦикла;
		Запрос = Новый Запрос;
		Запрос.Параметры.Вставить("Отпечатки", СписокВыбора.ВыгрузитьЗначения());
		Запрос.Текст =
		"ВЫБРАТЬ
		|	Сертификаты.Ссылка КАК Ссылка,
		|	Сертификаты.Наименование КАК Наименование,
		|	Сертификаты.Отпечаток
		|ИЗ
		|	Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования КАК Сертификаты
		|ГДЕ
		|	Сертификаты.Отпечаток В(&Отпечатки)";
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			ЭлементСписка = СписокВыбора.НайтиПоЗначению(Выборка.Отпечаток);
			Если ЭлементСписка <> Неопределено Тогда
				ЭлементСписка.Значение = Выборка.Ссылка;
				ЭлементСписка.Представление = Выборка.Наименование;
			КонецЕсли;
		КонецЦикла;
		СписокВыбора.СортироватьПоПредставлению();
		Возврат;
	КонецЕсли;
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	Сертификаты.Ссылка КАК Ссылка,
	|	Сертификаты.Пользователь КАК Пользователь,
	|	Сертификаты.Наименование КАК Наименование
	|ПОМЕСТИТЬ ВсеСертификаты
	|ИЗ
	|	Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования КАК Сертификаты
	|ГДЕ
	|	Сертификаты.Программа <> ЗНАЧЕНИЕ(Справочник.ПрограммыЭлектроннойПодписиИШифрования.ПустаяСсылка)
	|	И Сертификаты.Отозван = ЛОЖЬ
	|	И Сертификаты.Отпечаток В(&Отпечатки)
	|	И ИСТИНА
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВсеСертификаты.Ссылка КАК Ссылка,
	|	ВсеСертификаты.Наименование КАК Наименование
	|ИЗ
	|	ВсеСертификаты КАК ВсеСертификаты
	|ГДЕ
	|	ВсеСертификаты.Ссылка В
	|			(ВЫБРАТЬ
	|				ВсеСертификаты.Ссылка КАК Ссылка
	|			ИЗ
	|				ВсеСертификаты КАК ВсеСертификаты
	|			ГДЕ
	|				ВсеСертификаты.Пользователь = &Пользователь
	|		
	|			ОБЪЕДИНИТЬ ВСЕ
	|		
	|			ВЫБРАТЬ
	|				ВсеСертификаты.Ссылка
	|			ИЗ
	|				ВсеСертификаты КАК ВсеСертификаты
	|					ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования.Пользователи КАК СертификатыКлючейЭлектроннойПодписиИШифрованияПользователи
	|					ПО
	|						ВсеСертификаты.Ссылка = СертификатыКлючейЭлектроннойПодписиИШифрованияПользователи.Ссылка
	|			ГДЕ
	|				СертификатыКлючейЭлектроннойПодписиИШифрованияПользователи.Пользователь = &Пользователь)";
	
	Если ОтборПоОрганизации Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ИСТИНА", "Сертификаты.Организация = &Организация");
	КонецЕсли;
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("Пользователь", Пользователи.ТекущийПользователь());
	Запрос.УстановитьПараметр("Отпечатки", ОтпечаткиСертификатовНаКлиенте);
	Запрос.УстановитьПараметр("Организация", ОтборСертификатов);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		СписокВыбора.Добавить(Выборка.Ссылка, Выборка.Наименование);
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьДополнительныеСвойстваСертификата(Форма)
	
	Если Не ЗначениеЗаполнено(Форма.Сертификат) Тогда
		Возврат;
	КонецЕсли;
	
	ЗначенияРеквизитов = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Форма.Сертификат,
		"УсиленнаяЗащитаЗакрытогоКлюча, Отпечаток, Программа,
		|ДействителенДо, ПользовательОповещенОСрокеДействия, ДанныеСертификата");
	
	Попытка
		ДвоичныеДанныеСертификата = ЗначенияРеквизитов.ДанныеСертификата.Получить();
		Сертификат = Новый СертификатКриптографии(ДвоичныеДанныеСертификата);
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Сертификат = Форма.Сертификат;
		Форма.Сертификат = Неопределено;
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'При получении данных сертификата ""%1""
			           |из информационной базы возникла ошибка:
			           |%2'"),
			Сертификат,
			КраткоеПредставлениеОшибки(ИнформацияОбОшибке));
	КонецПопытки;
	
	ЭтоПрограммаОблачногоСервиса = ЗначенияРеквизитов.Программа = ПрограммаОблачногоСервиса();
	
	Если Форма.БезПодтверждения
	   И ЭтоПрограммаОблачногоСервиса Тогда
		
		Свойства = Новый Структура("ОблачныйПарольПодтвержден",
			ОблачныйПарольПодтвержден(ДвоичныеДанныеСертификата));
		
		ЗаполнитьЗначенияСвойств(Форма, Свойства);
	КонецЕсли;
	
	Форма.СертификатАдрес = ПоместитьВоВременноеХранилище(ДвоичныеДанныеСертификата, Форма.УникальныйИдентификатор);
	
	Форма.СертификатОтпечаток      = ЗначенияРеквизитов.Отпечаток;
	Форма.СертификатПрограмма      = ЗначенияРеквизитов.Программа;
	Форма.ВыполнятьВМоделиСервиса  = ЭтоПрограммаОблачногоСервиса;
	Форма.СертификатДействителенДо = ЗначенияРеквизитов.ДействителенДо;
	Форма.СертификатУсиленнаяЗащитаЗакрытогоКлюча = ЗначенияРеквизитов.УсиленнаяЗащитаЗакрытогоКлюча;
	
	Форма.ОповеститьОбОкончанииСрокаДействия =
		Не ЗначенияРеквизитов.ПользовательОповещенОСрокеДействия
		И ДобавитьМесяц(ТекущаяДатаСеанса(), 1) > Форма.СертификатДействителенДо;
	
	Форма.СертификатНаСервереОписаниеОшибки = Новый Структура;
	
	Если Не ЭлектроннаяПодпись.СоздаватьЭлектронныеПодписиНаСервере() Тогда
		Возврат;
	КонецЕсли;
	
	ПолучитьСертификатПоОтпечатку(Форма.СертификатОтпечаток,
		Истина, Ложь, Форма.СертификатПрограмма, Форма.СертификатНаСервереОписаниеОшибки);
	
КонецПроцедуры

// Для функции МенеджерКриптографии.
Функция НовыйМенеджерКриптографии(Программа, Ошибки, АлгоритмПодписи = "", Операция = "")
	
	ОписанияПрограмм = ЭлектроннаяПодписьСлужебныйКлиентСервер.МенеджерКриптографииОписанияПрограмм(
		Программа, Ошибки, ЭлектроннаяПодпись.ОбщиеНастройки().ОписанияПрограмм);
	
	Если ОписанияПрограмм = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЭтоLinux = ТребуетсяПутьКПрограмме();
	
	Менеджер = Неопределено;
	Для Каждого ОписаниеПрограммы Из ОписанияПрограмм Цикл
		
		Если ЗначениеЗаполнено(АлгоритмПодписи) Тогда
			АлгоритмПодписиПоддерживается =
				ЭлектроннаяПодписьСлужебныйКлиентСервер.МенеджерКриптографииАлгоритмПодписиПоддерживается(ОписаниеПрограммы,
					Операция, АлгоритмПодписи, Ошибки, Истина, Программа <> Неопределено);
			
			Если Не АлгоритмПодписиПоддерживается Тогда
				Менеджер = Неопределено;
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		ИдентификаторПутиКПрограмме = ?(ЗначениеЗаполнено(ОписаниеПрограммы.Ссылка),
			ОписаниеПрограммы.Ссылка, ОписаниеПрограммы.Идентификатор);
		
		СвойстваПрограммы = ЭлектроннаяПодписьСлужебныйКлиентСервер.МенеджерКриптографииСвойстваПрограммы(
			ОписаниеПрограммы, ЭтоLinux, Ошибки, Истина, ПутьКПрограмме(ИдентификаторПутиКПрограмме));
		
		Если СвойстваПрограммы = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Попытка
			ИнформацияМодуля = СредстваКриптографии.ПолучитьИнформациюМодуляКриптографии(
				СвойстваПрограммы.ИмяПрограммы,
				СвойстваПрограммы.ПутьКПрограмме,
				СвойстваПрограммы.ТипПрограммы);
		Исключение
			ЭлектроннаяПодписьСлужебныйКлиентСервер.МенеджерКриптографииДобавитьОшибку(Ошибки,
				ОписаниеПрограммы.Ссылка, КраткоеПредставлениеОшибки(ИнформацияОбОшибке()),
				Истина, Истина, Истина);
			Продолжить;
		КонецПопытки;
		
		Если ИнформацияМодуля = Неопределено Тогда
			ЭлектроннаяПодписьСлужебныйКлиентСервер.МенеджерКриптографииПрограммаНеНайдена(
				ОписаниеПрограммы, Ошибки, Истина);
			
			Менеджер = Неопределено;
			Продолжить;
		КонецЕсли;
		
		Если Не ЭтоLinux Тогда
			ИмяПрограммыПолученное = ИнформацияМодуля.Имя;
			
			ИмяПрограммыСовпадает = ЭлектроннаяПодписьСлужебныйКлиентСервер.МенеджерКриптографииИмяПрограммыСовпадает(
				ОписаниеПрограммы, ИмяПрограммыПолученное, Ошибки, Истина);
			
			Если Не ИмяПрограммыСовпадает Тогда
				Менеджер = Неопределено;
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		Попытка
			Менеджер = Новый МенеджерКриптографии(
				СвойстваПрограммы.ИмяПрограммы,
				СвойстваПрограммы.ПутьКПрограмме,
				СвойстваПрограммы.ТипПрограммы);
		Исключение
			ЭлектроннаяПодписьСлужебныйКлиентСервер.МенеджерКриптографииДобавитьОшибку(Ошибки,
				ОписаниеПрограммы.Ссылка, КраткоеПредставлениеОшибки(ИнформацияОбОшибке()),
				Истина, Истина, Истина);
			Продолжить;
		КонецПопытки;
		
		АлгоритмыУстановлены = ЭлектроннаяПодписьСлужебныйКлиентСервер.МенеджерКриптографииАлгоритмыУстановлены(
			ОписаниеПрограммы, Менеджер, Ошибки);
		
		Если Не АлгоритмыУстановлены Тогда
			Продолжить;
		КонецЕсли;
		
		Прервать; // Требуемый менеджер криптографии получен.
	КонецЦикла;
	
	Возврат Менеджер;
	
КонецФункции

Функция ИспользоватьЭлектроннуюПодписьВМоделиСервиса() Экспорт
	
	Если Не ОбщегоНазначения.ПодсистемаСуществует("ТехнологияСервиса.ЭлектроннаяПодписьВМоделиСервиса") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	МодульЭлектроннаяПодписьВМоделиСервиса =
		ОбщегоНазначения.ОбщийМодуль("ЭлектроннаяПодписьВМоделиСервиса");
	
	Возврат МодульЭлектроннаяПодписьВМоделиСервиса.ИспользованиеВозможно();
	
КонецФункции

Функция ПутьКПрограмме(ПрограммаСсылка)
	
	Результат = Новый Структура("ПутьКПрограмме, Существует, ТекстОшибки", "", Ложь, "");
	
	Если Не ТребуетсяПутьКПрограмме() Тогда
		Возврат Результат;
	КонецЕсли;
	
	ПутиКПрограммам = ЭлектроннаяПодписьСлужебныйПовтИсп.ПутиКПрограммамНаСерверахLinux(ИмяКомпьютера());
	ОписаниеПути = ПутиКПрограммам.Получить(ПрограммаСсылка);
	
	Если ОписаниеПути <> Неопределено Тогда
		Результат = ОписаниеПути;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Для функции ПолучитьСоответствиеФайловИПодписей.
Функция НайтиИменаФайловПодписей(ИмяФайлаДанных, ИменаФайловПодписей)
	
	ИменаПодписей = Новый Массив;
	
	СтруктураИмени = ОбщегоНазначенияКлиентСервер.РазложитьПолноеИмяФайла(ИмяФайлаДанных);
	ИмяБезРасширения = СтруктураИмени.ИмяБезРасширения;
	
	Для Каждого ИмяФайлаПодписи Из ИменаФайловПодписей Цикл
		Если СтрНайти(ИмяФайлаПодписи, ИмяБезРасширения) > 0 Тогда
			ИменаПодписей.Добавить(ИмяФайлаПодписи);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ИмяФайлаПодписи Из ИменаПодписей Цикл
		ИменаФайловПодписей.Удалить(ИменаФайловПодписей.Найти(ИмяФайлаПодписи));
	КонецЦикла;
	
	Возврат ИменаПодписей;
	
КонецФункции

// Для процедуры ЗаписатьСертификатПослеПроверки.

Функция ПроверитьШифрованиеИРасшифровку(МенеджерКриптографии, ДвоичныеДанныеСертификата,
			СертификатКриптографии, ОписаниеПрограммы, ОшибкаНаСервере, ЭтоПолноправныйПользователь)
	
	ПредставлениеОшибки = "";
	Попытка
		ЗашифрованныеДанные = МенеджерКриптографии.Зашифровать(ДвоичныеДанныеСертификата, СертификатКриптографии);
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
	КонецПопытки;
	
	Если ЗначениеЗаполнено(ПредставлениеОшибки) Тогда
		ЭлектроннаяПодписьСлужебныйКлиентСервер.ЗаполнитьОшибкуДобавленияСертификата(
			ОшибкаНаСервере,
			ОписаниеПрограммы,
			"Шифрование",
			ПредставлениеОшибки,
			ЭтоПолноправныйПользователь,
			Ложь,
			ИмяКомпьютера());
		
		Возврат Ложь;
	КонецЕсли;
	
	ИнформацияОбОшибке = Неопределено;
	ПредставлениеОшибки = "";
	Попытка
		РасшифрованныеДанные = МенеджерКриптографии.Расшифровать(ЗашифрованныеДанные);
		ЭлектроннаяПодписьСлужебныйКлиентСервер.ПустыеРасшифрованныеДанные(РасшифрованныеДанные, ПредставлениеОшибки);
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
	КонецПопытки;
	
	Если ЗначениеЗаполнено(ПредставлениеОшибки) Тогда
		ЭлектроннаяПодписьСлужебныйКлиентСервер.ЗаполнитьОшибкуДобавленияСертификата(
			ОшибкаНаСервере,
			ОписаниеПрограммы,
			"Расшифровка",
			ПредставлениеОшибки,
			ЭтоПолноправныйПользователь,
			ИнформацияОбОшибке = Неопределено,
			ИмяКомпьютера());
		
		Возврат Ложь;
	КонецЕсли;
		
	Возврат Истина;
	
КонецФункции

Функция ПроверитьПодписание(МенеджерКриптографии, ДвоичныеДанныеСертификата,
			СертификатКриптографии, ОписаниеПрограммы, ОшибкаНаСервере, ЭтоПолноправныйПользователь)
	
	ИнформацияОбОшибке = Неопределено;
	ПредставлениеОшибки = "";
	Попытка
		ДанныеПодписи = МенеджерКриптографии.Подписать(ДвоичныеДанныеСертификата, СертификатКриптографии);
		ЭлектроннаяПодписьСлужебныйКлиентСервер.ПустыеДанныеПодписи(ДанныеПодписи, ПредставлениеОшибки);
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
	КонецПопытки;
	
	Если ЗначениеЗаполнено(ПредставлениеОшибки) Тогда
		ЭлектроннаяПодписьСлужебныйКлиентСервер.ЗаполнитьОшибкуДобавленияСертификата(
			ОшибкаНаСервере,
			ОписаниеПрограммы,
			"Подписание",
			ПредставлениеОшибки,
			ЭтоПолноправныйПользователь,
			ИнформацияОбОшибке = Неопределено,
			ИмяКомпьютера());
		
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Возвращаемое значение:
//   ТаблицаЗначений:
//     * АлгоритмыПодписи     - Массив
//     * АлгоритмыХеширования - Массив
//     * АлгоритмыШифрования  - Массив
//     * АлгоритмыПроверкиПодписи - Массив
//     * НетВWindows - Булево
//     * НетВLinux   - Булево
//     * НетВMacOS   - Булево
//
Функция ПоставляемыеНастройкиПрограмм() Экспорт
	
	Настройки = Новый ТаблицаЗначений;
	Настройки.Колонки.Добавить("Представление");
	Настройки.Колонки.Добавить("ИмяПрограммы");
	Настройки.Колонки.Добавить("ТипПрограммы");
	Настройки.Колонки.Добавить("АлгоритмПодписи");
	Настройки.Колонки.Добавить("АлгоритмХеширования");
	Настройки.Колонки.Добавить("АлгоритмШифрования");
	Настройки.Колонки.Добавить("Идентификатор");
	
	Настройки.Колонки.Добавить("АлгоритмыПодписи",     Новый ОписаниеТипов("Массив"));
	Настройки.Колонки.Добавить("АлгоритмыХеширования", Новый ОписаниеТипов("Массив"));
	Настройки.Колонки.Добавить("АлгоритмыШифрования",  Новый ОписаниеТипов("Массив"));
	Настройки.Колонки.Добавить("АлгоритмыПроверкиПодписи", Новый ОписаниеТипов("Массив"));
	Настройки.Колонки.Добавить("НетВWindows", Новый ОписаниеТипов("Булево"));
	Настройки.Колонки.Добавить("НетВLinux",   Новый ОписаниеТипов("Булево"));
	Настройки.Колонки.Добавить("НетВMacOS",   Новый ОписаниеТипов("Булево"));
	
	Возврат Настройки;
	
КонецФункции

// Возвращаемое значение:
//   Структура:
//     * Ключ - Строка - начало идентификатора программы, например, CryptoPro.
//     * Значение - ФиксированноеСоответствие из КлючИЗначение:
//         * Ключ - ТипПлатформы
//         * Значение - ФиксированныйМассив из Строка - пути
//             с именами модулей, разделенные символом двоеточие.
//
Функция ПоставляемыеПутиКМодулямПрограмм() Экспорт
	
	Возврат Новый Структура;
	
КонецФункции

// Вызывается при переходе на версию конфигурации 3.1.5.220 и при начальном заполнении.
// 
Процедура ДобавитьКомпонентуExtraCryptoAPI() Экспорт
	
	Если Не ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ВнешниеКомпоненты") Тогда
		Возврат;
	КонецЕсли;	
	
	ОписаниеКомпоненты = ЭлектроннаяПодписьСлужебныйКлиентСервер.ОписаниеКомпоненты();
	КомпонентаПоследнейВерсииИзМакета = СтандартныеПодсистемыСервер.КомпонентаПоследнейВерсии(
		ОписаниеКомпоненты.ИмяОбъекта, ОписаниеКомпоненты.ПолноеИмяМакета);
	
	МестоположениеМакетаРазделенное = СтрРазделить(КомпонентаПоследнейВерсииИзМакета.Местоположение, ".");
	ДвоичныеДанные = Справочники.СертификатыКлючейЭлектроннойПодписиИШифрования.ПолучитьМакет(
		МестоположениеМакетаРазделенное.Получить(МестоположениеМакетаРазделенное.ВГраница()));
		
	МодульВнешниеКомпонентыСлужебный = ОбщегоНазначения.ОбщийМодуль("ВнешниеКомпонентыСлужебный");
	ПараметрыКомпоненты = МодульВнешниеКомпонентыСлужебный.ПараметрыЗагрузки();
	ПараметрыКомпоненты.Идентификатор = ОписаниеКомпоненты.ИмяОбъекта;
	ПараметрыКомпоненты.Наименование = НСтр("ru='ExtraCryptoAPI для 1С:Предприятие'", ОбщегоНазначения.КодОсновногоЯзыка());
	ПараметрыКомпоненты.Версия = КомпонентаПоследнейВерсииИзМакета.Версия;
	ПараметрыКомпоненты.ОписаниеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Добавлена обработчиком обновления %1.'", ОбщегоНазначения.КодОсновногоЯзыка()), ТекущаяДатаСеанса());
	ПараметрыКомпоненты.ОбновлятьСПортала1СИТС = Истина;
	ПараметрыКомпоненты.Данные = ДвоичныеДанные;
	
	МодульВнешниеКомпонентыСлужебный.ЗагрузитьКомпонентуИзДвоичныхДанных(ПараметрыКомпоненты, Ложь);
	
КонецПроцедуры

#Область СвойстваКонвертаXML

Функция ОбработатьУзелSignedInfo(УзелSignedInfo, СвойстваКонвертаXML)
	
	Если Не ПроверитьУникальностьУзла(УзелSignedInfo, СвойстваКонвертаXML) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Каждого ДочернийУзел Из УзелSignedInfo.ДочерниеУзлы Цикл
		Если ДочернийУзел.ЛокальноеИмя = "CanonicalizationMethod" Тогда
			Если Не ПолучитьАтрибут(ДочернийУзел, "Algorithm", СвойстваКонвертаXML,
						"АлгоритмКанонизации",,, СвойстваКонвертаXML.ПроверкаПодписи) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли ДочернийУзел.ЛокальноеИмя = "SignatureMethod" Тогда
			Если Не ПолучитьАтрибут(ДочернийУзел, "Algorithm", СвойстваКонвертаXML,
						"АлгоритмПодписи",,, СвойстваКонвертаXML.ПроверкаПодписи) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли ДочернийУзел.ЛокальноеИмя = "Reference" Тогда
			Если Не ОбработатьУзелReference(ДочернийУзел, СвойстваКонвертаXML) Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Функция ОбработатьУзелReference(УзелReference, СвойстваКонвертаXML)
	
	Если Не ПолучитьАтрибут(УзелReference, "URI", СвойстваКонвертаXML,
				"ИдентификаторУзла", СвойстваКонвертаXML.ХешируемаяОбласть, Истина) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Каждого ДочернийУзел Из УзелReference.ДочерниеУзлы Цикл
		Если ДочернийУзел.ЛокальноеИмя = "Transforms" Тогда
			Если Не ОбработатьУзелTransforms(ДочернийУзел, СвойстваКонвертаXML) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли ДочернийУзел.ЛокальноеИмя = "DigestMethod" Тогда
			Если Не ПолучитьАтрибут(ДочернийУзел, "Algorithm", СвойстваКонвертаXML, "АлгоритмХеширования",
						СвойстваКонвертаXML.ХешируемаяОбласть,, СвойстваКонвертаXML.ПроверкаПодписи) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли ДочернийУзел.ЛокальноеИмя = "DigestValue" Тогда
			Если Не ПолучитьЗначение(ДочернийУзел, СвойстваКонвертаXML,
					"ЗначениеХеша", СвойстваКонвертаXML.ХешируемаяОбласть) Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Функция ОбработатьУзелTransforms(УзелTransforms, СвойстваКонвертаXML)
	
	Если Не ПроверитьУникальностьУзла(УзелTransforms, СвойстваКонвертаXML) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Каждого ДочернийУзел Из УзелTransforms.ДочерниеУзлы Цикл
		Если ДочернийУзел.ЛокальноеИмя = "Transform" Тогда
			Если Не ПолучитьАтрибут(ДочернийУзел, "Algorithm", СвойстваКонвертаXML, "АлгоритмыТрансформации",
						СвойстваКонвертаXML.ХешируемаяОбласть,, СвойстваКонвертаXML.ПроверкаПодписи) Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Функция ОбработатьУзелKeyInfo(УзелKeyInfo, СвойстваКонвертаXML)
	
	Если Не ПроверитьУникальностьУзла(УзелKeyInfo, СвойстваКонвертаXML) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Каждого ДочернийУзел Из УзелKeyInfo.ДочерниеУзлы Цикл
		Если ДочернийУзел.ЛокальноеИмя = "X509Data" Тогда
			Если Не ОбработатьУзелX509Data(ДочернийУзел, СвойстваКонвертаXML) Тогда
				Прервать;
			КонецЕсли;
		ИначеЕсли ДочернийУзел.ЛокальноеИмя = "KeyInfoReference"
		      Или ДочернийУзел.ЛокальноеИмя = "SecurityTokenReference" Тогда
			Если Не ОбработатьУзелСоСсылкойНаСертификат(ДочернийУзел, СвойстваКонвертаXML) Тогда
				Прервать;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Функция ОбработатьУзелX509Data(УзелX509Data, СвойстваКонвертаXML)
	
	Если Не ПроверитьУникальностьУзла(УзелX509Data, СвойстваКонвертаXML) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Каждого ДочернийУзел Из УзелX509Data.ДочерниеУзлы Цикл
		Если ДочернийУзел.ЛокальноеИмя <> "X509Certificate" Тогда
			Продолжить;
		КонецЕсли;
		Если Не ПолучитьЗначение(ДочернийУзел, СвойстваКонвертаXML,
					"ЗначениеСертификата", СвойстваКонвертаXML.Сертификат) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Функция ОбработатьУзелСоСсылкойНаСертификат(УзелСоСсылкойНаСертификат, СвойстваКонвертаXML)
	
	Если Не ПроверитьУникальностьУзла(УзелСоСсылкойНаСертификат, СвойстваКонвертаXML) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Каждого ДочернийУзел Из УзелСоСсылкойНаСертификат.ДочерниеУзлы Цикл
		Если ДочернийУзел.ЛокальноеИмя <> "Reference" Тогда
			Продолжить;
		КонецЕсли;
		Если Не ПолучитьАтрибут(ДочернийУзел, "URI", СвойстваКонвертаXML,
				"ИдентификаторУзла", СвойстваКонвертаXML.Сертификат) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Параметры:
//  ДокументDOM      - ДокументDOM
//  ЛокальноеИмя     - Строка
//  ПространствоИмен - Строка
//  ТекстОшибки      - Строка
//  ИсключаемыеУзлы  - Неопределено
//                   - Массив из ЭлементDOM
//  ОшибкаЕслиНайден - Булево
//
// Возвращаемое значение:
//  ЭлементDOM
//
Функция НайтиУзелПоИмени(ДокументDOM, ЛокальноеИмя, ПространствоИмен,
			ТекстОшибки, ИсключаемыеУзлы = Неопределено,
			ПространстваИменДоУзлаВключительно = Неопределено, ОшибкаЕслиНайден = Ложь)
	
	УзелНайден = Ложь;
	ПространстваИменДоУзла =
		?(ПространстваИменДоУзлаВключительно <> Неопределено, Новый Массив, Неопределено);
	
	Для Каждого Узел Из ДокументDOM.ДочерниеУзлы Цикл
		Если ИсключаемыеУзлы <> Неопределено
		   И ИсключаемыеУзлы.Найти(Узел) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если Узел.ЛокальноеИмя = ЛокальноеИмя
		   И Узел.URIПространстваИмен = ПространствоИмен Тогда
			Результат = Узел;
			УзелНайден = Истина;
			Прервать;
		КонецЕсли;
		ПространстваИменВложенныхУзлов =
			?(ПространстваИменДоУзла <> Неопределено, Новый Массив, Неопределено);
		Результат = НайтиУзелПоИмени(Узел, ЛокальноеИмя, ПространствоИмен,
			Null, ИсключаемыеУзлы, ПространстваИменВложенныхУзлов);
		Если Результат <> Неопределено Тогда
			УзелНайден = Истина;
			ДобавитьПространстваИмен(ПространстваИменДоУзла,
				Узел, ПространстваИменВложенныхУзлов);
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если Не УзелНайден Тогда
		Результат = Неопределено;
	КонецЕсли;
	
	Если ТекстОшибки = Null Тогда
		ПространстваИменДоУзлаВключительно = ПространстваИменДоУзла;
		Возврат Результат;
	КонецЕсли;
	
	Если УзелНайден И ОшибкаЕслиНайден Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В документе XML найдено более одного узла ""%1"" с пространством имен ""%2"".'"),
			ЛокальноеИмя,
			ПространствоИмен);
	ИначеЕсли Не УзелНайден И Не ОшибкаЕслиНайден Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В документе XML не найден узел ""%1"" с пространством имен ""%2"".'"),
			ЛокальноеИмя,
			ПространствоИмен);
	КонецЕсли;
	
	Если Результат <> Неопределено
	   И ПространстваИменДоУзлаВключительно <> Неопределено Тогда
		
		ДобавитьПространстваИмен(ПространстваИменДоУзлаВключительно,
			Результат, ПространстваИменДоУзла);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Параметры:
//  ДокументDOM       - ДокументDOM
//  ИдентификаторУзла - Строка
//  ТекстОшибки       - Строка
//  ИсключаемыеУзлы   - Массив из ЭлементDOM
//  ПространстваИменДоУзла - Неопределено
//                         - Массив из Строка
//  ОшибкаЕслиНайден - Булево
//
// Возвращаемое значение:
//  ЭлементDOM
//
Функция НайтиУзелПоИдентификатору(ДокументDOM, ИдентификаторУзла, ТекстОшибки,
			ИсключаемыеУзлы = Неопределено, ПространстваИменДоУзла = Неопределено, ОшибкаЕслиНайден = Ложь)
	
	УзелНайден = Ложь;
	ИмяАтрибутаИдентификатора = "Id";
	
	Для Каждого Узел Из ДокументDOM.ДочерниеУзлы Цикл
		Если Узел.Атрибуты = Неопределено
		 Или ИсключаемыеУзлы <> Неопределено
		   И ИсключаемыеУзлы.Найти(Узел) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Для Каждого Атрибут Из Узел.Атрибуты Цикл
			Если ВРег(Атрибут.ЛокальноеИмя) = ВРег(ИмяАтрибутаИдентификатора)
			   И Атрибут.ЗначениеУзла = ИдентификаторУзла Тогда
				Результат = Узел;
				УзелНайден = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если УзелНайден Тогда
			Прервать;
		КонецЕсли;
		ПространстваИменВложенныхУзлов =
			?(ПространстваИменДоУзла <> Неопределено, Новый Массив, Неопределено);
		Результат = НайтиУзелПоИдентификатору(Узел,
			ИдентификаторУзла, Null, ИсключаемыеУзлы, ПространстваИменВложенныхУзлов);
		Если Результат <> Неопределено Тогда
			УзелНайден = Истина;
			ДобавитьПространстваИмен(ПространстваИменДоУзла,
				Узел, ПространстваИменВложенныхУзлов);
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если Не УзелНайден Тогда
		Результат = Неопределено;
	КонецЕсли;
	
	Если ТекстОшибки = Null Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если УзелНайден И ОшибкаЕслиНайден Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В документе XML найдено более одного узла с атрибутом ""%1"" и значением ""%2"".'"),
			ИмяАтрибутаИдентификатора,
			ИдентификаторУзла);
	ИначеЕсли Не УзелНайден И Не ОшибкаЕслиНайден Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В документе XML не найден узел с атрибутом ""%1"" и значением ""%2"".'"),
			ИмяАтрибутаИдентификатора,
			ИдентификаторУзла);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Процедура ДобавитьПространстваИмен(ПространстваИмен, Узел, ПространстваИменВложенныхУзлов)
	
	Если ПространстваИмен <> Неопределено Тогда
		Для Каждого Атрибут Из Узел.Атрибуты Цикл
			Если Атрибут.Префикс <> "xmlns" Тогда
				Продолжить;
			КонецЕсли;
			ПространствоИмен = Атрибут.ИмяУзла + "=""" + Атрибут.ЗначениеУзла + """";
			Если ПространстваИмен.Найти(ПространствоИмен) = Неопределено Тогда
				ПространстваИмен.Добавить(ПространствоИмен);
			КонецЕсли;
		КонецЦикла;
		Для Каждого ПространствоИмен Из ПространстваИменВложенныхУзлов Цикл
			Если ПространстваИмен.Найти(ПространствоИмен) = Неопределено Тогда
				ПространстваИмен.Добавить(ПространствоИмен);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьЗначение(ЭлементDOM, СвойстваКонвертаXML, ИмяСвойства, Свойства = Неопределено)
	
	Значение = ЭлементDOM.ТекстовоеСодержимое;
	
	Результат = ПроверитьУстановитьЗначение(Значение,
		ЭлементDOM, "", СвойстваКонвертаXML, ИмяСвойства, Свойства);
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьАтрибут(ЭлементDOM, ИмяАтрибута, СвойстваКонвертаXML, ИмяСвойства,
			Свойства = Неопределено, ИмяСРодителем = Ложь, ЗначениеВНижнийРегистр = Ложь)
	
	Атрибут = ЭлементDOM.Атрибуты.ПолучитьИменованныйЭлемент(ИмяАтрибута);
	Если Атрибут = Неопределено Тогда
		СвойстваКонвертаXML.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В документе XML для узла ""%1"" не найден атрибут ""%2"".'"),
			ЭлементDOM.ЛокальноеИмя, ИмяАтрибута);
		Возврат Ложь;
	КонецЕсли;
	Значение = Атрибут.ЗначениеУзла;
	
	Если ЗначениеВНижнийРегистр Тогда
		Значение = НРег(Значение);
	КонецЕсли;
	
	Результат = ПроверитьУстановитьЗначение(Значение,
		ЭлементDOM, ИмяАтрибута, СвойстваКонвертаXML, ИмяСвойства, Свойства, ИмяСРодителем);
	
	Возврат Результат;
	
КонецФункции

Функция ПроверитьУстановитьЗначение(Значение, ЭлементDOM, ИмяАтрибута, СвойстваКонвертаXML, ИмяСвойства, Свойства, ИмяСРодителем = Ложь)
	
	Если Не ПроверитьУникальностьУзла(ЭлементDOM, СвойстваКонвертаXML, ИмяСРодителем) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если СвойстваКонвертаXML.ДоступныеСвойства.Свойство(ИмяСвойства) Тогда
		ДоступныеЗначения = СвойстваКонвертаXML.ДоступныеСвойства[ИмяСвойства];
		Если ДоступныеЗначения.ЭтоСтрокаBase64 Или ДоступныеЗначения.ЭтоURI Тогда
			Значение = СокрЛП(Значение);
		КонецЕсли;
		
		Если Не СвойстваКонвертаXML.ПроверкаПодписи
		   И ЗначениеЗаполнено(ДоступныеЗначения.ИмяПараметра) Тогда
			
			Если Значение <> ДоступныеЗначения.ИмяПараметра Тогда
				Если ЗначениеЗаполнено(ИмяАтрибута) Тогда
					СвойстваКонвертаXML.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'В документе XML для узла ""%1"" в атрибуте ""%2"" должно быть указано значение ""%3"".'"),
						ЭлементDOM.ЛокальноеИмя, ИмяАтрибута, ДоступныеЗначения.ИмяПараметра);
				Иначе
					СвойстваКонвертаXML.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'В документе XML для узла ""%1"" должно быть указано значение ""%2"".'"),
						ЭлементDOM.ЛокальноеИмя, ДоступныеЗначения.ИмяПараметра);
				КонецЕсли;
				Возврат Ложь;
			КонецЕсли;
		
		ИначеЕсли ДоступныеЗначения.ЭтоСтрокаBase64 Тогда
			Попытка
				ЗначениеBase64 = Base64Значение(Значение);
			Исключение
				ЗначениеBase64 = "";
			КонецПопытки;
			Если Не ЗначениеЗаполнено(ЗначениеBase64) Тогда
				Если ЗначениеЗаполнено(ИмяАтрибута) Тогда
					СвойстваКонвертаXML.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'В документе XML для узла ""%1"" в атрибуте ""%2"" указано не Base64 значение ""%3"".'"),
						ЭлементDOM.ЛокальноеИмя, ИмяАтрибута, Значение);
				Иначе
					СвойстваКонвертаXML.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'В документе XML для узла ""%1"" указано не Base64 значение ""%2"".'"),
						ЭлементDOM.ЛокальноеИмя, ИмяАтрибута, Значение);
				КонецЕсли;
				Возврат Ложь;
			КонецЕсли;
			
		ИначеЕсли ДоступныеЗначения.ЭтоURI Тогда
			Если Не СтрНачинаетсяС(Значение, "#")
			 Или СтрДлина(Значение) < 2 Тогда
				Если ЗначениеЗаполнено(ИмяАтрибута) Тогда
					СвойстваКонвертаXML.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'В документе XML для узла ""%1"" в атрибуте ""%2"" указан некорректный URI ""%3"".'"),
						ЭлементDOM.ЛокальноеИмя, ИмяАтрибута, Значение);
				Иначе
					СвойстваКонвертаXML.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'В документе XML для узла ""%1"" указан некорректный URI ""%2"".'"),
						ЭлементDOM.ЛокальноеИмя, ИмяАтрибута, Значение);
				КонецЕсли;
				Возврат Ложь;
			КонецЕсли;
			Значение = Сред(Значение, 2);
			
		ИначеЕсли ЗначениеЗаполнено(ДоступныеЗначения.Значения) Тогда
			Описание = ДоступныеЗначения.Значения.Получить(Значение);
			Если Описание = Неопределено Тогда
				Если ЗначениеЗаполнено(ИмяАтрибута) Тогда
					СвойстваКонвертаXML.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'В документе XML для узла ""%1"" в атрибуте ""%2"" указано недопустимое значение ""%3"".'"),
						ЭлементDOM.ЛокальноеИмя, ИмяАтрибута, Значение);
				Иначе
					СвойстваКонвертаXML.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'В документе XML для узла ""%1"" указано недопустимое значение ""%2"".'"),
						ЭлементDOM.ЛокальноеИмя, ИмяАтрибута, Значение);
				КонецЕсли;
				Возврат Ложь;
			Иначе
				Значение = Описание;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если Свойства = Неопределено Тогда
		НаборСвойств = СвойстваКонвертаXML;
	Иначе
		НаборСвойств = Свойства
	КонецЕсли;
	
	Если ТипЗнч(НаборСвойств[ИмяСвойства]) = Тип("Массив") Тогда
		Если НаборСвойств[ИмяСвойства].Найти(Значение) = Неопределено Тогда
			НаборСвойств[ИмяСвойства].Добавить(Значение);
		КонецЕсли;
	Иначе
		НаборСвойств[ИмяСвойства] = Значение;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Функция ПроверитьУникальностьУзла(ЭлементDOM, СвойстваКонвертаXML, ИмяСРодителем = Ложь)
	
	ИмяСвойства = ЭлементDOM.ЛокальноеИмя;
	Если ИмяСРодителем Тогда
		ИмяСвойства = ЭлементDOM.РодительскийУзел.ЛокальноеИмя + "_" + ИмяСвойства;
	КонецЕсли;
	
	Если СвойстваКонвертаXML.ОбязательныеУзлы.Свойство(ИмяСвойства) Тогда
		СвойстваКонвертаXML.ОбязательныеУзлы[ИмяСвойства] = ЭлементDOM;
	КонецЕсли;
	
	Если Не СвойстваКонвертаXML.УникальныеУзлы.Свойство(ИмяСвойства) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если СвойстваКонвертаXML.УникальныеУзлы[ИмяСвойства] <> Неопределено Тогда
		Если ИмяСРодителем Тогда
			СвойстваКонвертаXML.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'В документе XML узел ""%1"" встречается более одного раза в узле ""%2"".'"),
				ЭлементDOM.ЛокальноеИмя,
				ЭлементDOM.Родитель.ЛокальноеИмя);
		Иначе
			СвойстваКонвертаXML.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'В документе XML узел ""%1"" встречается более одного раза.'"),
				ИмяСвойства);
		КонецЕсли;
		Возврат Ложь;
	КонецЕсли;
	
	СвойстваКонвертаXML.УникальныеУзлы[ИмяСвойства] = ЭлементDOM;
	
	Возврат Истина;
	
КонецФункции

// Параметры:
//  СлужебныеСвойстваКонвертаXML - см. СлужебныеСвойстваКонвертаXML
//
// Возвращаемое значение:
//  Структура:
//   * ТекстОшибки         - Строка
//   * ОбластьSignedInfo   - см. ЭлектроннаяПодписьСлужебныйКлиентСервер.ОбластьXML
//   * ОбластьBody         - см. ЭлектроннаяПодписьСлужебныйКлиентСервер.ОбластьXML
//   * АлгоритмКанонизации - см. АлгоритмКанонизации
//   * АлгоритмПодписи     - см. АлгоритмПодписиИХеширования
//   * ХешируемаяОбласть   - см. ОписаниеХешируемойОбласти
//   * ЗначениеПодписи     - Строка - Base64 строка.
//   * Сертификат          - см. ОписаниеСертификата
//   * ПроверкаПодписи     - Булево - когда Ложь, подписание.
//
Функция ВозвращаемыеСвойстваКонвертаXML(СлужебныеСвойстваКонвертаXML = Неопределено)
	
	Результат = Новый Структура;
	Результат.Вставить("ТекстОшибки", "");
	Результат.Вставить("ОбластьSignedInfo");
	Результат.Вставить("ОбластьBody");
	Результат.Вставить("АлгоритмКанонизации");
	Результат.Вставить("АлгоритмПодписи");
	Результат.Вставить("ХешируемаяОбласть", ОписаниеХешируемойОбласти());
	Результат.Вставить("ЗначениеПодписи", "");
	Результат.Вставить("Сертификат", ОписаниеСертификата());
	Результат.Вставить("ПроверкаПодписи", Ложь);
	
	Если ТипЗнч(СлужебныеСвойстваКонвертаXML) = Тип("Структура") Тогда
		ЗаполнитьЗначенияСвойств(Результат, СлужебныеСвойстваКонвертаXML);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Параметры:
//  ПроверкаПодписи - Булево
//
// Возвращаемое значение:
//  Структура:
//   * ТекстОшибки         - Строка
//   * ОбластьSignedInfo   - см. ЭлектроннаяПодписьСлужебныйКлиентСервер.ОбластьXML
//   * ОбластьBody         - см. ЭлектроннаяПодписьСлужебныйКлиентСервер.ОбластьXML
//   * АлгоритмКанонизации - см. АлгоритмКанонизации
//   * АлгоритмПодписи     - см. АлгоритмПодписиИХеширования
//   * ХешируемаяОбласть   - см. ОписаниеХешируемойОбласти
//   * ЗначениеПодписи     - Строка - Base64 строка.
//   * Сертификат          - см. ОписаниеСертификата
//   * ПроверкаПодписи     - Булево - когда Ложь, подписание.
//   * ДоступныеСвойства   - см. ДоступныеСвойстваКонвертаXML
//   * ОбязательныеУзлы    - Структура из КлючИЗначение:
//       * Ключ     - Строка - имя узла или имя узла родителя с именем узла.
//       * Значение - ЭлементDOM
//                  - Неопределено
//   * УникальныеУзлы      - Структура из КлючИЗначение:
//       * Ключ     - Строка - имя узла или имя узла родителя с именем узла.
//       * Значение - ЭлементDOM
//                  - Неопределено
//
Функция СлужебныеСвойстваКонвертаXML(ПроверкаПодписи)
	
	Результат = ВозвращаемыеСвойстваКонвертаXML();
	Результат.ПроверкаПодписи = ПроверкаПодписи;
	Результат.Вставить("ДоступныеСвойства", ДоступныеСвойстваКонвертаXML(ПроверкаПодписи));
	Результат.Вставить("ОбязательныеУзлы", Новый Структура(
		"SignedInfo,SignatureValue,KeyInfo,
		|CanonicalizationMethod,SignatureMethod,SignedInfo_Reference,
		|DigestMethod,DigestValue"));
	Результат.Вставить("УникальныеУзлы", Новый Структура(
		"SignedInfo,SignatureValue,KeyInfo,
		|CanonicalizationMethod,SignatureMethod,SignedInfo_Reference,
		|Transforms,DigestMethod,DigestValue,
		|X509Data,X509Certificate,SecurityTokenReference,Reference"));
	
	Возврат Результат;
	
КонецФункции

// Возвращаемое значение:
//  Структура:
//   * ИдентификаторУзла      - Строка
//   * АлгоритмыТрансформации - Массив из см. АлгоритмКанонизации
//   * АлгоритмХеширования    - см. АлгоритмПодписиИХеширования
//   * ЗначениеХеша           - Строка - Base64 строка.
//
Функция ОписаниеХешируемойОбласти()
	
	Результат = Новый Структура;
	Результат.Вставить("ИдентификаторУзла", "");
	Результат.Вставить("АлгоритмыТрансформации", Новый Массив);
	Результат.Вставить("АлгоритмХеширования", "");
	Результат.Вставить("ЗначениеХеша", "");
	
	Возврат Результат;
	
КонецФункции

// Возвращаемое значение:
//  Структура:
//   * ИдентификаторУзла   - Строка
//   * ЗначениеСертификата - Строка - Base64 строка.
//
Функция ОписаниеСертификата()
	
	Результат = Новый Структура;
	Результат.Вставить("ИдентификаторУзла",   "");
	Результат.Вставить("ЗначениеСертификата", "");
	
	Возврат Результат;
	
КонецФункции

// Параметры:
//  ПроверкаПодписи - Булево
//
// Возвращаемое значение:
//  Структура:
//   * ИдентификаторУзла      - см. ДоступныеЗначения
//   * АлгоритмКанонизации    - см. ДоступныеЗначения
//   * АлгоритмыТрансформации - см. ДоступныеЗначения
//   * ЗначениеХеша           - см. ДоступныеЗначения
//   * ЗначениеПодписи        - см. ДоступныеЗначения
//   * ЗначениеСертификата    - см. ДоступныеЗначения
//   * АлгоритмПодписи        - см. ДоступныеЗначения
//   * АлгоритмХеширования    - см. ДоступныеЗначения
//
Функция ДоступныеСвойстваКонвертаXML(ПроверкаПодписи)
	
	Результат = Новый Структура;
	Результат.Вставить("ИдентификаторУзла", ДоступныеЗначения("", , Истина));
	
	Результат.Вставить("АлгоритмКанонизации", ДоступныеЗначения(""));
	// Canonical XML 1.0.
	Значения = Результат.АлгоритмКанонизации.Значения;
	Значения.Вставить("http://www.w3.org/TR/2001/REC-xml-c14n-20010315", АлгоритмКанонизации("c14n", 0, 0));
	Если ПроверкаПодписи Тогда
		Значения.Вставить("http://www.w3.org/TR/2001/REC-xml-c14n-20010315#", АлгоритмКанонизации("c14n", 0, 0));
	КонецЕсли;
	Значения.Вставить("http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments", АлгоритмКанонизации("c14n", 0, 1));
	// Canonical XML 1.1.
	Значения.Вставить("http://www.w3.org/2006/12/xml-c14n11", АлгоритмКанонизации("c14n", 2, 0));
	Если ПроверкаПодписи Тогда
		Значения.Вставить("http://www.w3.org/2006/12/xml-c14n11#", АлгоритмКанонизации("c14n", 2, 0));
	КонецЕсли;
	Значения.Вставить("http://www.w3.org/2006/12/xml-c14n11#WithComments", АлгоритмКанонизации("c14n", 2, 1));
	// Exclusive XML Canonicalization 1.0.
	Значения.Вставить("http://www.w3.org/2001/10/xml-exc-c14n#", АлгоритмКанонизации("c14n", 1, 0));
	Если ПроверкаПодписи Тогда
		Значения.Вставить("http://www.w3.org/2001/10/xml-exc-c14n", АлгоритмКанонизации("c14n", 1, 0));
	КонецЕсли;
	Значения.Вставить("http://www.w3.org/2001/10/xml-exc-c14n#WithComments", АлгоритмКанонизации("c14n", 1, 1));
	Если ПроверкаПодписи Тогда
		ПривестиКлючиКНижнемуРегистру(Результат.АлгоритмКанонизации.Значения);
	КонецЕсли;
	
	Результат.Вставить("АлгоритмыТрансформации", ДоступныеЗначения(""));
	Значения = Новый Соответствие(Новый ФиксированноеСоответствие(Значения));
	Результат.АлгоритмыТрансформации.Значения = Значения;
	Значения.Вставить("urn://smev-gov-ru/xmldsig/transform", АлгоритмКанонизации("smev", 0, 0));
	Значения.Вставить("http://www.w3.org/2000/09/xmldsig#enveloped-signature", АлгоритмКанонизации("envsig", 0, 0));
	Если ПроверкаПодписи Тогда
		ПривестиКлючиКНижнемуРегистру(Результат.АлгоритмыТрансформации.Значения);
	КонецЕсли;
	
	Результат.Вставить("ЗначениеХеша",        ДоступныеЗначения("%DigestValue%", Истина));
	Результат.Вставить("ЗначениеПодписи",     ДоступныеЗначения("%SignatureValue%", Истина));
	Результат.Вставить("ЗначениеСертификата", ДоступныеЗначения("%BinarySecurityToken%", Истина));
	
	Результат.Вставить("АлгоритмПодписи",     ДоступныеЗначения("%SignatureMethod%"));
	Результат.Вставить("АлгоритмХеширования", ДоступныеЗначения("%DigestMethod%"));
	
	Наборы = ЭлектроннаяПодписьСлужебныйКлиентСервер.НаборыАлгоритмовДляСозданияПодписи();
	Для Каждого Набор Из Наборы Цикл
		Результат.АлгоритмПодписи.Значения.Вставить(Набор.ИмяАлгоритмаПодписиXML,
			АлгоритмПодписиИХеширования(Набор.ИмяАлгоритмаПодписиXML, Набор.ИдентификаторАлгоритмаПодписи));
		Результат.АлгоритмХеширования.Значения.Вставить(Набор.ИмяАлгоритмаХешированияXML,
			АлгоритмПодписиИХеширования(Набор.ИмяАлгоритмаХешированияXML, Набор.ИдентификаторАлгоритмаХеширования));
	КонецЦикла;
	Если ПроверкаПодписи Тогда
		ПривестиКлючиКНижнемуРегистру(Результат.АлгоритмПодписи.Значения);
		ПривестиКлючиКНижнемуРегистру(Результат.АлгоритмХеширования.Значения);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Параметры:
//  Имя           - Строка
//  Идентификатор - Строка
//
// Возвращаемое значение:
//  Структура:
//   * Имя           - Строка
//   * Идентификатор - Строка
//
Функция АлгоритмПодписиИХеширования(Имя, Идентификатор)
	
	Результат = Новый Структура;
	Результат.Вставить("Имя", Имя);
	Результат.Вставить("Идентификатор", Идентификатор);
	
	Возврат Результат;
	
КонецФункции

// Параметры:
//  Вид            - Строка
//  Версия         - Число
//  СКомментариями - Число
//
// Возвращаемое значение:
//  Структура:
//   * Вид            - Строка
//   * Версия         - Число
//   * СКомментариями - Число
//
Функция АлгоритмКанонизации(Вид, Версия, СКомментариями) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Вид", Вид);
	Результат.Вставить("Версия", Версия);
	Результат.Вставить("СКомментариями", СКомментариями);
	
	Возврат Результат;
	
КонецФункции

// Параметры:
//  ИмяПараметра    - Строка
//  ЭтоСтрокаBase64 - Булево
//  ЭтоURI          - Булево
//
// Возвращаемое значение:
//  Структура:
//   * ИмяПараметра    - Строка
//   * ЭтоСтрокаBase64 - Булево
//   * ЭтоURI          - Булево
//   * Значения - Соответствие из КлючИЗначение:
//       ** Ключ     - Строка
//       ** Значение - Структура
//
Функция ДоступныеЗначения(ИмяПараметра, ЭтоСтрокаBase64 = Ложь, ЭтоURI = Ложь)
	
	Результат = Новый Структура;
	Результат.Вставить("ИмяПараметра", ИмяПараметра);
	Результат.Вставить("Значения", Новый Соответствие);
	Результат.Вставить("ЭтоСтрокаBase64", ЭтоСтрокаBase64);
	Результат.Вставить("ЭтоURI", ЭтоURI);
	
	Возврат Результат;
	
КонецФункции

Процедура ПривестиКлючиКНижнемуРегистру(Значения)
	
	НовыеЗначения = Новый Соответствие;
	
	Для Каждого КлючИЗначение Из Значения Цикл
		НовыеЗначения.Вставить(НРег(КлючИЗначение.Ключ), КлючИЗначение.Значение);
	КонецЦикла;
	
	Значения = НовыеЗначения;
	
КонецПроцедуры

#КонецОбласти

#Область КлассификаторОшибокКриптографии

Функция ОшибкаПоКлассификатору(ТекстДляПоискаВКлассификаторе) Экспорт
	
	КлассификаторОшибок = ЭлектроннаяПодписьСлужебныйПовтИсп.КлассификаторОшибокКриптографии();
	Если ТипЗнч(КлассификаторОшибок) <> Тип("ТаблицаЗначений")
		Или КлассификаторОшибок.Количество() = 0 Тогда
		
		Возврат Неопределено;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	КлассификаторОшибок.ТекстОшибки КАК ТекстОшибки,
	|	КлассификаторОшибок.Причина КАК Причина,
	|	КлассификаторОшибок.Решение КАК Решение,
	|	КлассификаторОшибок.СпособУстранения КАК СпособУстранения,
	|	КлассификаторОшибок.Ссылка КАК Ссылка
	|ПОМЕСТИТЬ КлассификаторОшибок
	|ИЗ
	|	&КлассификаторОшибок КАК КлассификаторОшибок
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	КлассификаторОшибок.Причина КАК Причина,
	|	КлассификаторОшибок.Решение КАК Решение,
	|	КлассификаторОшибок.СпособУстранения КАК СпособУстранения,
	|	КлассификаторОшибок.Ссылка КАК Ссылка
	|ИЗ
	|	КлассификаторОшибок КАК КлассификаторОшибок
	|ГДЕ
	|	&ТекстОшибки ПОДОБНО ""%"" + КлассификаторОшибок.ТекстОшибки + ""%""";
	Запрос.УстановитьПараметр("КлассификаторОшибок", КлассификаторОшибок);
	Запрос.УстановитьПараметр("ТекстОшибки", ТекстДляПоискаВКлассификаторе);
	РезультатПоиска = Запрос.Выполнить();
	
	Если РезультатПоиска.Пустой() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ОшибкиИзКлассификатора = РезультатПоиска.Выбрать();
	ОшибкиИзКлассификатора.Следующий();
	
	ПредставлениеОшибки = ПредставлениеОшибки();
	ЗаполнитьЗначенияСвойств(ПредставлениеОшибки, ОшибкиИзКлассификатора);
	
	Возврат ПредставлениеОшибки;
	
КонецФункции

Функция КлассификаторОшибокКриптографии() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Если Не ОбщегоНазначения.РазделениеВключено() Тогда
		Попытка
			ТекстОшибки = ОбновитьКлассификатор();
		Исключение
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		КонецПопытки;
		Если ЗначениеЗаполнено(ТекстОшибки) Тогда
			Комментарий = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Не удалось обновить классификатор ошибок криптографии по причине:
				           |%1'"), ТекстОшибки);
			ЗаписьЖурналаРегистрации(
				НСтр("ru = 'Электронная подпись.Обновление классификатора ошибок'",
				ОбщегоНазначения.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,,,
				Комментарий);
		КонецЕсли;
	КонецЕсли;
	
	ДанныеКлассификатора = Константы.КлассификаторОшибокКриптографии.Получить();
	Если Не ЗначениеЗаполнено(ДанныеКлассификатора) Тогда
		Возврат ПредставлениеКлассификатораДляХранения();
	КонецЕсли;
	
	Возврат ДанныеКлассификатора.Получить();
	
КонецФункции

Функция АдресКлассификатораОшибок()
	
	АдресКлассификатора = Новый Структура;
	АдресКлассификатора.Вставить("Протокол", "http://");
	АдресКлассификатора.Вставить("АдресСервера", "downloads.v8.1c.ru");
	АдресКлассификатора.Вставить("АдресРесурса",
		"content/LED/settings/ErrorClassifier/classifier.json");
	
	Возврат АдресКлассификатора;
	
КонецФункции

Функция ПредставлениеОшибки()
	
	ПредставлениеОшибки = Новый Структура;
	ПредставлениеОшибки.Вставить("Ссылка", "");
	ПредставлениеОшибки.Вставить("Причина", "");
	ПредставлениеОшибки.Вставить("Решение", "");
	ПредставлениеОшибки.Вставить("СпособУстранения", "");
	
	Возврат ПредставлениеОшибки;
	
КонецФункции

Функция ПредставлениеКлассификатораДляХранения()
	
	ПредставлениеКлассификатора = Новый ТаблицаЗначений;
	ПредставлениеКлассификатора.Колонки.Добавить("ТекстОшибки",
		Новый ОписаниеТипов("Строка", Новый КвалификаторыСтроки(500)));
	ПредставлениеКлассификатора.Колонки.Добавить("Причина",
		Новый ОписаниеТипов("Строка", Новый КвалификаторыСтроки(500)));
	ПредставлениеКлассификатора.Колонки.Добавить("Решение",
		Новый ОписаниеТипов("Строка", Новый КвалификаторыСтроки(500)));
	ПредставлениеКлассификатора.Колонки.Добавить("СпособУстранения",
		Новый ОписаниеТипов("Строка", Новый КвалификаторыСтроки(500)));
	ПредставлениеКлассификатора.Колонки.Добавить("Ссылка",
		Новый ОписаниеТипов("Строка", Новый КвалификаторыСтроки(500)));
	
	Возврат ПредставлениеКлассификатора;
	
КонецФункции

Функция ОбновитьКлассификатор()
	
	ДатаПоследнегоОбновления = Константы.ДатаПоследнегоОбновленияКлассификатораОшибок.Получить();
	Если ЗначениеЗаполнено(ДатаПоследнегоОбновления)
		И ТекущаяУниверсальнаяДата() - ДатаПоследнегоОбновления < 24*3600 Тогда
		
		Возврат "";
	КонецЕсли;
	
	АдресКлассификатора = АдресКлассификатораОшибок();
	ПолныйАдрес = АдресКлассификатора.Протокол + АдресКлассификатора.АдресСервера + "/" + АдресКлассификатора.АдресРесурса;
	ДанныеКлассификатора = Неопределено;
	ТекстОшибки = "";
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		
		МодульПолучениеФайловИзИнтернета = ОбщегоНазначения.ОбщийМодуль("ПолучениеФайловИзИнтернета");
		РезультатЗагрузки = МодульПолучениеФайловИзИнтернета.СкачатьФайлВоВременноеХранилище(ПолныйАдрес,, Ложь);
		
		Если РезультатЗагрузки.Статус Тогда
			ДанныеКлассификатора = ПолучитьИзВременногоХранилища(РезультатЗагрузки.Путь);
			УдалитьИзВременногоХранилища(РезультатЗагрузки.Путь);
		Иначе
			Возврат РезультатЗагрузки.СообщениеОбОшибке;
		КонецЕсли;
		
	Иначе
		
		Соединение = Новый HTTPСоединение(АдресКлассификатора.АдресСервера,,,,, 20);
		
		Заголовки = Новый Соответствие;
		Заголовки.Вставить("Accept-Charset", "UTF-8");
		
		Ответ = Соединение.Получить(
			Новый HTTPЗапрос(АдресКлассификатора.АдресРесурса, Заголовки));
		
		Если Ответ.КодСостояния = 200 Тогда
			ДанныеКлассификатора = Ответ.ПолучитьТелоКакСтроку();
		Иначе
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'HTTP ответ - %1'"), Строка(Ответ.КодСостояния));
		КонецЕсли;
		
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ТекстОшибки)
	   И Не ЗначениеЗаполнено(ДанныеКлассификатора) Тогда
		
		ТекстОшибки = НСтр("ru = 'Получены пустые данные.'");
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ТекстОшибки) Тогда
		Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'При скачивании данных по адресу:
			           |%1
			           |возникла ошибка:
			           |%2'"),
			ПолныйАдрес,
			ТекстОшибки);
	КонецЕсли;
	
	ЗаписатьДанныеКлассификатора(ДанныеКлассификатора);
	
	Возврат "";
	
КонецФункции

Процедура ЗаписатьДанныеКлассификатора(ДанныеКлассификатора)
	
	ЧтениеJSON = Новый ЧтениеJSON;
	Если ТипЗнч(ДанныеКлассификатора) = Тип("Строка") Тогда
		ЧтениеJSON.УстановитьСтроку(ДанныеКлассификатора);
	Иначе
		ЧтениеJSON.ОткрытьПоток(ДанныеКлассификатора.ОткрытьПотокДляЧтения());
	КонецЕсли;
	
	КлассификаторОшибок = ПрочитатьJSON(ЧтениеJSON,, "LastChangeDate");
	ЧтениеJSON.Закрыть();
	
	ПредставлениеКлассификатора = ПредставлениеКлассификатораДляХранения();
	Для Каждого ИзвестнаяОшибка Из КлассификаторОшибок.Classifier Цикл
		
		НоваяОшибка = ПредставлениеКлассификатора.Добавить();
		НоваяОшибка.Ссылка = ИзвестнаяОшибка.Anchor;
		НоваяОшибка.Причина = ИзвестнаяОшибка.Reason;
		НоваяОшибка.Решение = ИзвестнаяОшибка.Solution;
		НоваяОшибка.ТекстОшибки = ИзвестнаяОшибка.ErrorText;
		НоваяОшибка.СпособУстранения = ИзвестнаяОшибка.RepairMethods;
		
	КонецЦикла;
	
	Константы.КлассификаторОшибокКриптографии.Установить(
		Новый ХранилищеЗначения(ПредставлениеКлассификатора, Новый СжатиеДанных(9)));
	
	Константы.ДатаПоследнегоОбновленияКлассификатораОшибок.Установить(
		ТекущаяУниверсальнаяДата());
		
КонецПроцедуры

#КонецОбласти

#Область ДиагностикаЭлектроннойПодписи

Процедура ДополнитьТехническойИнформациейОСервере(ТехническаяИнформация,
			ПроверенныеПутиКМодулямПрограммНаКлиенте) Экспорт
	
	Если Не ЭлектроннаяПодпись.СоздаватьЭлектронныеПодписиНаСервере()
		И Не ЭлектроннаяПодпись.ПроверятьЭлектронныеПодписиНаСервере() Тогда
		
		ТехническаяИнформация = ТехническаяИнформация + Символы.ПС
			+ НСтр("ru = 'Электронная подпись на сервере не используется.'") + Символы.ПС;
	Иначе
		ТехническаяИнформация = ТехническаяИнформация
			+ Символы.ПС + ТехническаяИнформацияОКомпьютере()
			+ Символы.ПС + Символы.ПС + ТехническаяИнформацияОКомпоненте()
			+ Символы.ПС + ТехническаяИнформацияОПрограммах();
	КонецЕсли;
	
	ТехническаяИнформация = ТехническаяИнформация + Символы.ПС
		+ ТехническаяИнформацияОНастройкахПрограммВСправочнике(ПроверенныеПутиКМодулямПрограммНаКлиенте);
	
	Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		РежимРаботы = ?(ОбщегоНазначения.КлиентПодключенЧерезВебСервер(),
			НСтр("ru = 'Файловый через веб'"), НСтр("ru = 'Файловый'"));
	Иначе
		РежимРаботы = НСтр("ru = 'Клиент-серверный'");
	КонецЕсли;
	
	ТехническаяИнформация = ТехническаяИнформация
		+ Символы.ПС + НСтр("ru = 'Режим работы информационной базы'")+ " - " + РежимРаботы
		+ Символы.ПС + Символы.ПС + ТехническаяИнформацияОВерсияхПодсистем() + Символы.ПС
		+ НСтр("ru = 'Расширения'") + ":" + Символы.ПС + ТехническаяИнформацияОРасширениях();
	
КонецПроцедуры

Функция ТехническаяИнформацияОКомпьютере()
	
	ПараметрыЗапуска = ФайловаяСистема.ПараметрыЗапускаПрограммы();
	ПараметрыЗапуска.ДождатьсяЗавершения = Истина;
	ПараметрыЗапуска.ПолучитьПотокВывода = Истина;
	ПараметрыЗапуска.КодировкаПотоков = КодировкаТекста.UTF8;
	
	Если ОбщегоНазначения.ЭтоWindowsСервер() Тогда
		Команда = "echo %username%";
	Иначе
		Команда = "whoami";
	КонецЕсли;
	
	Результат = ФайловаяСистема.ЗапуститьПрограмму(Команда, ПараметрыЗапуска);
	Если Результат.КодВозврата = 0 Тогда
		ИмяПользователяОС = СокрЛП(Результат.ПотокВывода);
	Иначе
		ИмяПользователяОС = "";
	КонецЕсли;
	
	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Сервер (%1):'"), ИмяКомпьютера() + "\" + ИмяПользователяОС) + Символы.ПС
		+ ЭлектроннаяПодписьСлужебныйКлиентСервер.ДиагностическаяИнформацияОКомпьютере();
	
КонецФункции

Функция ТехническаяИнформацияОКомпоненте()
	
	ВерсияКомпоненты = "";
	Попытка 
		ВерсияКомпоненты = ОбъектВнешнейКомпонентыExtraCryptoAPI().ПолучитьВерсию();
	Исключение
		ВерсияКомпоненты = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Возврат НСтр("ru = 'Версия компоненты ExtraCryptoAPI на сервере'") + " - " + ВерсияКомпоненты;
	
КонецФункции

Функция ТехническаяИнформацияОПрограммах()
	
	ИспользуемыеПрограммы = ЭлектроннаяПодписьСлужебныйВызовСервера.ИспользуемыеПрограммы();
	Если ИспользуемыеПрограммы.Количество() = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	ДиагностическаяИнформация = Символы.ПС + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Программы на сервере ""%1"":'"), ИмяКомпьютера()) + Символы.ПС;
	
	Для Каждого Программа Из ИспользуемыеПрограммы Цикл
		
		ПараметрыСоздания = ПараметрыСозданияМенеджераКриптографии();
		ПараметрыСоздания.Программа = Программа.Ссылка;
		ПараметрыСоздания.ПоказатьОшибку = Ложь;
		ПараметрыСоздания.ОписаниеОшибки = Новый Структура;
		
		МенеджерКриптографии = МенеджерКриптографии("", ПараметрыСоздания);
		
		ДиагностическаяИнформация = ДиагностическаяИнформация
			+ ЭлектроннаяПодписьСлужебныйКлиентСервер.ДиагностическаяИнформацияПоПрограмме(Программа,
				МенеджерКриптографии, ПараметрыСоздания.ОписаниеОшибки);
	КонецЦикла;
	
	Возврат ДиагностическаяИнформация;
	
КонецФункции

Функция ТехническаяИнформацияОНастройкахПрограммВСправочнике(ПроверенныеПутиКМодулямПрограммНаКлиенте)
	
	ДиагностическаяИнформация = Символы.ПС
		+ НСтр("ru = 'Настройки программ в справочнике:'") + Символы.ПС;
	
	ИспользуемыеПрограммы = ЭлектроннаяПодписьСлужебныйВызовСервера.ИспользуемыеПрограммы();
	Если ИспользуемыеПрограммы.Количество() = 0 Тогда
		ДиагностическаяИнформация = ДиагностическаяИнформация
			+ НСтр("ru = 'В справочник не добавлено ни одной программы.'");
		Возврат ДиагностическаяИнформация;
	КонецЕсли;
	
	Для Каждого Программа Из ИспользуемыеПрограммы Цикл
		ДиагностическаяИнформация = ДиагностическаяИнформация + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1:
			           |	Имя программы: %2
			           |	Тип программы: %3
			           |	Алгоритм подписи: %4
			           |	Алгоритм хеширования: %5
			           |	Алгоритм шифрования: %6'"),
			Программа.Представление,
			Программа.ИмяПрограммы,
			Программа.ТипПрограммы,
			Программа.АлгоритмПодписи,
			Программа.АлгоритмХеширования,
			Программа.АлгоритмШифрования) + Символы.ПС;
		
		Если ТребуетсяПутьКПрограмме(Истина) Тогда
			ДобавитьИнформациюОПутиКПрограмме(ДиагностическаяИнформация,
				НСтр("ru = 'Пути к модулям программы на клиенте:'"),
				ПроверенныеПутиКМодулямПрограммНаКлиенте.Получить(Программа.Ссылка).ПутьКПрограмме);
		КонецЕсли;
		Если ТребуетсяПутьКПрограмме() Тогда
			ДобавитьИнформациюОПутиКПрограмме(ДиагностическаяИнформация,
				НСтр("ru = 'Пути к модулям программы на сервере:'"),
				ПутьКПрограмме(Программа.Ссылка).ПутьКПрограмме);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ДиагностическаяИнформация;
	
КонецФункции

Процедура ДобавитьИнформациюОПутиКПрограмме(ДиагностическаяИнформация, Заголовок, ПутьКПрограмме)
	
	ПутиКМодулям = СтрРазделить(ПутьКПрограмме, ":", Ложь);
	
	ДиагностическаяИнформация = ДиагностическаяИнформация
		+ Символы.Таб + Заголовок + Символы.ПС
		+ Символы.Таб + Символы.Таб + """" + СтрСоединить(ПутиКМодулям,
			"""" + Символы.ПС + Символы.Таб + Символы.Таб + """") + """"
		+ Символы.ПС;
	
КонецПроцедуры

Функция ТехническаяИнформацияОВерсияхПодсистем()
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ВерсииПодсистем.ИмяПодсистемы КАК ИмяПодсистемы,
	|	ВерсииПодсистем.Версия КАК Версия
	|ИЗ
	|	РегистрСведений.ВерсииПодсистем КАК ВерсииПодсистем";
	ВерсииПодсистем = Запрос.Выполнить().Выбрать();
	
	ДиагностическаяИнформация = НСтр("ru = 'Версии подсистем'") + ":" + Символы.ПС;
	Пока ВерсииПодсистем.Следующий() Цикл
		ДиагностическаяИнформация = ДиагностическаяИнформация
			+ ВерсииПодсистем.ИмяПодсистемы + " - "
			+ ВерсииПодсистем.Версия + Символы.ПС;
	КонецЦикла;
	
	Возврат ДиагностическаяИнформация;
	
КонецФункции

Функция ТехническаяИнформацияОРасширениях()
	
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	ПредставлениеРасширений = "";
	
	Расширения = РасширенияКонфигурации.Получить();
	Для Каждого Расширение Из Расширения Цикл
		
		ПредставлениеРасширений = ПредставлениеРасширений
			+ Расширение.Имя + " - " + Расширение.Синоним + " - "
			+ Формат(Расширение.Активно, НСтр("ru = 'БЛ=Отключено; БИ=Включено'")) + Символы.ПС;
		
	КонецЦикла;
	
	Возврат ПредставлениеРасширений;
	
КонецФункции

#КонецОбласти

#КонецОбласти