///////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2019, ООО 1С-Софт
// Все права защищены. Эта программа и сопроводительные материалы предоставляются 
// в соответствии с условиями лицензии Attribution 4.0 International (CC BY 4.0)
// Текст лицензии доступен по ссылке:
// https://creativecommons.org/licenses/by/4.0/legalcode
///////////////////////////////////////////////////////////////////////////////////////////////////////

#Область СлужебныйПрограммныйИнтерфейс

// Получить первое значение определенного вида контактной информации у объекта.
//
// Параметры:
//     Ссылка                  - ЛюбаяСсылка - ссылка на объект-владелец контактной информации (организация,
//                                             контрагент, партнер и т.д.).
//     ТипКонтактнойИнформации - Перечисление.ТипыКонтактнойИнформации - параметры обработки.
//     Дата                     - Дата - Дата, на которую будет получено значение контактной информации.
//
// Возвращаемое значение:
//     Строка - строковое представление значения.
//
Функция ПервоеЗначениеКонтактнойИнформацииОбъектаПоТипу(Ссылка, ТипКонтактнойИнформации, Дата) Экспорт

	Результат = "";
	ПолноеИмя = Ссылка.Метаданные().ПолноеИмя();

	Если СтрНачинаетсяС(ПолноеИмя , НСтр("ru = 'Справочник'")) Тогда
		ИмяГруппыКонтактнойИнформации = НСтр("ru = 'Справочник'") + Ссылка.Метаданные().Имя;
	ИначеЕсли СтрНачинаетсяС(ПолноеИмя , НСтр("ru = 'Документ'")) Тогда
		ИмяГруппыКонтактнойИнформации = НСтр("ru = 'Документ'") + Ссылка.Метаданные().Имя;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|ВЫБОР
		|	КОГДА ВидыКонтактнойИнформации.ИмяПредопределенногоВида <> """"
		|	ТОГДА ВидыКонтактнойИнформации.ИмяПредопределенногоВида
		|	ИНАЧЕ ВидыКонтактнойИнформации.ИмяПредопределенныхДанных
		|КОНЕЦ КАК Наименование
		|ИЗ
		|	Справочник.ВидыКонтактнойИнформации КАК ВидыКонтактнойИнформации
		|ГДЕ
		|	ВидыКонтактнойИнформации.ЭтоГруппа = ИСТИНА";
	
	РезультатЗапроса = Запрос.Выполнить().Выбрать();
	Пока РезультатЗапроса.Следующий() Цикл
		Если РезультатЗапроса.Наименование = ИмяГруппыКонтактнойИнформации Тогда
			Запрос = Новый Запрос;
			Запрос.Текст = 
				"ВЫБРАТЬ
				|	ВидыКонтактнойИнформацииПодчиненный.Ссылка КАК Ссылка
				|ИЗ
				|	Справочник.ВидыКонтактнойИнформации КАК ВидыКонтактнойИнформации
				|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ВидыКонтактнойИнформации КАК ВидыКонтактнойИнформацииПодчиненный
				|		ПО (ВидыКонтактнойИнформацииПодчиненный.Родитель = ВидыКонтактнойИнформации.Ссылка)
				|ГДЕ
				|	ВидыКонтактнойИнформации.ИмяПредопределенногоВида = &ИмяПредопределенногоВида
				|	И ВидыКонтактнойИнформации.ЭтоГруппа = ИСТИНА
				|	И ВидыКонтактнойИнформацииПодчиненный.Тип = &Тип";
			
			Запрос.УстановитьПараметр("ИмяПредопределенногоВида", ИмяГруппыКонтактнойИнформации);
			Запрос.УстановитьПараметр("Тип", ТипКонтактнойИнформации);
			
			РезультатЗапроса = Запрос.Выполнить().Выбрать();
			Если РезультатЗапроса.Следующий() Тогда
				КонтактнаяИнформацияОбъекта = УправлениеКонтактнойИнформацией.КонтактнаяИнформацияОбъекта(Ссылка,
					РезультатЗапроса.Ссылка, Дата, Ложь);
					Если КонтактнаяИнформацияОбъекта.Количество() > 0 Тогда
						Результат = КонтактнаяИнформацияОбъекта[0].Представление;
					КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;

КонецФункции

Функция ПроверитьАдрес(Адрес, ПараметрыПроверкиАдреса = Неопределено) Экспорт
	
	РезультатПроверки = Новый Структура("Результат, СписокОшибок");
	РезультатПроверки.СписокОшибок = Новый СписокЗначений;
	
	Если ТипЗнч(Адрес) <> Тип("Строка") Тогда
		РезультатПроверки.Результат = "СодержитОшибки";
		РезультатПроверки.СписокОшибок.Добавить("ФорматАдреса", НСтр("ru = 'Некорректный формат адреса'"));
		Возврат РезультатПроверки;
	КонецЕсли;
	
	Если Метаданные.Обработки.Найти("РасширенныйВводКонтактнойИнформации") <> Неопределено Тогда
		Обработки["РасширенныйВводКонтактнойИнформации"].ПроверитьАдрес(Адрес, РезультатПроверки, ПараметрыПроверкиАдреса);
	КонецЕсли;
	
	Возврат РезультатПроверки;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обработчики событий подсистем конфигурации.

// См. ВерсионированиеОбъектовПереопределяемый.ПриПодготовкеДанныхОбъекта.
Процедура ПриПодготовкеДанныхОбъекта(Объект, ДополнительныеРеквизиты) Экспорт 
	
	Если Объект.Метаданные().ТабличныеЧасти.Найти("КонтактнаяИнформация") <> Неопределено Тогда
		Для Каждого Контакт Из УправлениеКонтактнойИнформацией.КонтактнаяИнформацияОбъекта(Объект.Ссылка,, ТекущаяДатаСеанса(), Ложь) Цикл
			Если ЗначениеЗаполнено(Контакт.Вид) Тогда
				Реквизит = ДополнительныеРеквизиты.Добавить();
				Реквизит.Наименование = Контакт.Вид.Наименование;
				Реквизит.Значение = Контакт.Представление;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// См. ЗагрузкаДанныхИзФайлаПереопределяемый.ПриОпределенииСправочниковДляЗагрузкиДанных.
Процедура ПриОпределенииСправочниковДляЗагрузкиДанных(ЗагружаемыеСправочники) Экспорт
	
	// Загрузка в классификатор стран мира запрещена.
	СтрокаТаблицы = ЗагружаемыеСправочники.Найти(Метаданные.Справочники.СтраныМира.ПолноеИмя(), "ПолноеИмя");
	Если СтрокаТаблицы <> Неопределено Тогда 
		ЗагружаемыеСправочники.Удалить(СтрокаТаблицы);
	КонецЕсли;
	
КонецПроцедуры

// См. ЗапретРедактированияРеквизитовОбъектовПереопределяемый.ПриОпределенииОбъектовСЗаблокированнымиРеквизитами.
Процедура ПриОпределенииОбъектовСЗаблокированнымиРеквизитами(Объекты) Экспорт
	
	Объекты.Вставить(Метаданные.Справочники.ВидыКонтактнойИнформации.ПолноеИмя(), "");
	
КонецПроцедуры

// См. ГрупповоеИзменениеОбъектовПереопределяемый.ПриОпределенииОбъектовСРедактируемымиРеквизитами.
Процедура ПриОпределенииОбъектовСРедактируемымиРеквизитами(Объекты) Экспорт
	Объекты.Вставить(Метаданные.Справочники.ВидыКонтактнойИнформации.ПолноеИмя(), "РеквизитыНеРедактируемыеВГрупповойОбработке");
КонецПроцедуры

// См. ОбновлениеИнформационнойБазыБСП.ПриДобавленииОбработчиковОбновления.
Процедура ПриДобавленииОбработчиковОбновления(Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия    = "2.2.3.34";
	Обработчик.Процедура = "УправлениеКонтактнойИнформациейСлужебный.ОбновитьСуществующиеСтраныМира";
	Обработчик.РежимВыполнения = "Монопольно";
	Обработчик.ОбщиеДанные      = Ложь;
	Обработчик.НачальноеЗаполнение = Истина;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия    = "2.3.1.8";
	Обработчик.Процедура = "УправлениеКонтактнойИнформациейСлужебный.ОбновитьНастройкуДобавочногоНомераТелефона";
	Обработчик.РежимВыполнения = "Оперативно";
	Обработчик.ОбщиеДанные      = Ложь;
	Обработчик.НачальноеЗаполнение = Истина;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия    = "2.3.1.15";
	Обработчик.Процедура = "УправлениеКонтактнойИнформациейСлужебный.УстановитьЗначениеПризнакаИспользуется";
	Обработчик.РежимВыполнения = "Оперативно";
	Обработчик.ОбщиеДанные      = Ложь;
	Обработчик.НачальноеЗаполнение = Истина;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия          = "2.4.3.4";
	Обработчик.Идентификатор   = Новый УникальныйИдентификатор("dfc6a0fa-7c7b-4096-9d04-2c67d5eb17a4");
	Обработчик.Процедура       = "Справочники.СтраныМира.ОбновитьСтраныМираПоОКСМ";
	Обработчик.РежимВыполнения = "Отложенно";
	Обработчик.ПроцедураЗаполненияДанныхОбновления = "Справочники.СтраныМира.ЗаполнитьСписокСтранКОбработке";
	Обработчик.ОчередьОтложеннойОбработки = 1;
	Обработчик.ЧитаемыеОбъекты    = "Справочник.СтраныМира";
	Обработчик.ИзменяемыеОбъекты  = "Справочник.СтраныМира";
	Обработчик.БлокируемыеОбъекты = "Справочник.СтраныМира";
	Обработчик.ПроцедураПроверки  = "ОбновлениеИнформационнойБазы.ДанныеОбновленыНаНовуюВерсиюПрограммы";
	Обработчик.Комментарий = НСтр("ru = 'Обновление сведений о странах мирах в соответствии с общероссийским классификатором стран мира.
		|До завершения обработки наименование стран в документах в ряде случаев будет отображаться некорректно.'");
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Процедура = "УправлениеКонтактнойИнформациейСлужебный.ЗаполнитьНаименованияВидовКонтактнойИнформацииПользователя";
	Обработчик.РежимВыполнения = "Оперативно";
	Обработчик.НачальноеЗаполнение = Истина;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Возвращает пространство имен для оперирования с XDTO контактной информации.
//
// Возвращаемое значение:
//      Строка - пространство имен.
//
Функция ПространствоИмен() Экспорт
	Возврат "http://www.v8.1c.ru/ssl/contactinfo";
КонецФункции

// Заполняет список страна при автоподборе по введенному пользователем тексту.
//
Процедура ОбработкаПолученияДанныхВыбора(ДанныеВыбора, Параметры, СтандартнаяОбработка) Экспорт
	
	Если Не ЕстьПравоДобавления() Или Метаданные.ОбщиеМодули.Найти("РаботаСАдресами") = Неопределено Тогда
		// Нет прав на добавление страны мира, поведение по умолчанию.
		Возврат;
	КонецЕсли;
	
	МодульРаботаСАдресами = ОбщегоНазначения.ОбщийМодуль("РаботаСАдресами");
	ДанныеВыбора = МодульРаботаСАдресами.ЗаполнитьДанныеВыбораАвтоподбораПоСтранам(Параметры);
	СтандартнаяОбработка = Ложь;
	
КонецПроцедуры

Процедура АвтоподборАдреса(Знач Текст, ДанныеВыбора) Экспорт
	
	Если Метаданные.Обработки.Найти("РасширенныйВводКонтактнойИнформации") = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ДополнительныеПараметры = Новый Структура("ТолькоВебСервис", Истина);
	Результат = Обработки["РасширенныйВводКонтактнойИнформации"].СписокАвтоподбораНаселенногоПункта(Текст, ДополнительныеПараметры);
	Если Результат.Отказ Тогда
		Возврат;
	КонецЕсли;
	
	ДанныеВыбора = Результат.Данные;
	ФорматированиеРезультатовАвтоподбора(ДанныеВыбора, Текст);
	
КонецПроцедуры

Процедура ФорматированиеРезультатовАвтоподбора(ДанныеВыбора, Знач Текст) Экспорт
	
	МодульРаботаСАдресамиКлиентСервер = ОбщегоНазначения.ОбщийМодуль("РаботаСАдресамиКлиентСервер");
	
	// Оформление списка поиска
	ФрагментыТекстаПоиска = СтрРазделить(Текст, " ");
	Для каждого СтрокаДанных Из ДанныеВыбора Цикл
		
		Если ТипЗнч(СтрокаДанных.Значение) = Тип("Структура")
			И СтрокаДанных.Значение.Свойство("Адрес") Тогда
			
			Если ЗначениеЗаполнено(СтрокаДанных.Значение.Адрес) Тогда
				Адрес = JSONВКонтактнуюИнформациюПоПолям(СтрокаДанных.Значение.Адрес, Перечисления.ТипыКонтактнойИнформации.Адрес);
				СтрокаДанных.Значение.Представление = МодульРаботаСАдресамиКлиентСервер.ПредставлениеАдреса(Адрес, Ложь);
			КонецЕсли;
			
			УстаревшийАдрес = Не СтрокаДанных.Значение.Муниципальный;
		Иначе
			УстаревшийАдрес = Ложь;
		КонецЕсли;
		
		Представление = СтрокаДанных.Представление;
		
		Для каждого ФрагментТекстаПоиска Из ФрагментыТекстаПоиска Цикл
			Позиция = СтрНайти(ВРег(Представление), ВРег(ФрагментТекстаПоиска));
			Если Позиция > 0 Тогда
				Представление = Лев(Представление, Позиция - 1) + Символы.ПС + Символы.ВТаб + Сред(Представление, Позиция, СтрДлина(ФрагментТекстаПоиска)) 
				+ Символы.ПС + Сред(Представление, Позиция + СтрДлина(ФрагментТекстаПоиска));
			КонецЕсли;
		КонецЦикла;
		Набор = СтрРазделить(Представление, Символы.ПС);
		Для Счетчик = 0 По Набор.Количество() - 1 Цикл
			Если СтрНачинаетсяС(Набор[Счетчик], Символы.ВТаб) Тогда
				Набор[Счетчик] = Новый ФорматированнаяСтрока(СокрЛП(Набор[Счетчик]), Новый Шрифт(,, Истина), ЦветаСтиля.РезультатУспехЦвет);
			ИначеЕсли УстаревшийАдрес Тогда
				Набор[Счетчик] = Новый ФорматированнаяСтрока(Набор[Счетчик],, ЦветаСтиля.ТекстЗапрещеннойЯчейкиЦвет);
			КонецЕсли;
		КонецЦикла;
		СтрокаДанных.Представление = Новый ФорматированнаяСтрока(Набор);
		
	КонецЦикла;

КонецПроцедуры

Функция ЭтоТипАдрес(ЗначениеТипа)
	Возврат СтрСравнить(ЗначениеТипа, Строка(ПредопределенноеЗначение("Перечисление.ТипыКонтактнойИнформации.Адрес"))) = 0;
КонецФункции

#Область ОбновлениеИнформационнойБазы

// Обновляем только существующие элементы стран мира по классификатору.
Процедура ОбновитьСуществующиеСтраныМира() Экспорт
	
	Если Метаданные.ОбщиеМодули.Найти("РаботаСАдресами") = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ВсеОшибки = "";
	Добавлять = Ложь;
	
	Фильтр = Новый Структура("Код");
	МодульРаботаСАдресами = ОбщегоНазначения.ОбщийМодуль("РаботаСАдресами");
	
	// Сравнивать в запросе нельзя из-за возможной регистронезависимости базы данных.
	Для Каждого СтрокаКлассификатора Из МодульРаботаСАдресами.ТаблицаКлассификатора() Цикл
		Фильтр.Код = СтрокаКлассификатора.Код;
		Выборка = Справочники.СтраныМира.Выбрать(,, Фильтр);
		СтранаНайдена = Выборка.Следующий();
		Если Не СтранаНайдена И Добавлять Тогда
			// Добавление страны
			Страна = Справочники.СтраныМира.СоздатьЭлемент();
		ИначеЕсли СтранаНайдена И (
			Выборка.Наименование <> СтрокаКлассификатора.Наименование
			Или Выборка.КодАльфа2 <> СтрокаКлассификатора.КодАльфа2
			Или Выборка.КодАльфа3 <> СтрокаКлассификатора.КодАльфа3
			Или Выборка.НаименованиеПолное <> СтрокаКлассификатора.НаименованиеПолное) Тогда
			// Изменение страны
			Страна = Выборка.ПолучитьОбъект();
		Иначе
			Продолжить;
		КонецЕсли;
		
		НачатьТранзакцию();
		Попытка
			Если Не Страна.ЭтоНовый() Тогда
				ЗаблокироватьДанныеДляРедактирования(Страна.Ссылка);
			КонецЕсли;
			ЗаполнитьЗначенияСвойств(Страна, СтрокаКлассификатора, "Код, Наименование, КодАльфа2, КодАльфа3, НаименованиеПолное");
			Страна.ДополнительныеСвойства.Вставить("НеПроверятьУникальность");
			Страна.Записать();
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			Инфо = ИнформацияОбОшибке();
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Ошибка записи страны мира %1 (код %2) при обновлении классификатора, %3'"),
				Выборка.Код, Выборка.Наименование, КраткоеПредставлениеОшибки(Инфо));
			ЗаписьЖурналаРегистрации(ОбновлениеИнформационнойБазы.СобытиеЖурналаРегистрации(),
				УровеньЖурналаРегистрации.Ошибка,,,
				ТекстОшибки + Символы.ПС + ПодробноеПредставлениеОшибки(Инфо));
			ВсеОшибки = ВсеОшибки + Символы.ПС + ТекстОшибки;
		КонецПопытки;
		
	КонецЦикла;
	
	Если Не ПустаяСтрока(ВсеОшибки) Тогда
		ВызватьИсключение СокрЛП(ВсеОшибки);
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбновитьНастройкуДобавочногоНомераТелефона() Экспорт
	
	// Устанавливает флаг ТелефонCДобавочнымНомером для обратной совместимости.
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ВидыКонтактнойИнформации.Ссылка
		|ИЗ
		|	Справочник.ВидыКонтактнойИнформации КАК ВидыКонтактнойИнформации
		|ГДЕ
		|	ВидыКонтактнойИнформации.Тип =  Значение(Перечисление.ТипыКонтактнойИнформации.Телефон)";
	
	РезультатЗапроса = Запрос.Выполнить().Выбрать();
	
	Пока РезультатЗапроса.Следующий() Цикл
		ВидКонтактнойИнформации = РезультатЗапроса.Ссылка.ПолучитьОбъект();
		ВидКонтактнойИнформации.ТелефонCДобавочнымНомером = Истина;
		ОбновлениеИнформационнойБазы.ЗаписатьДанные(ВидКонтактнойИнформации);
	КонецЦикла;
	
КонецПроцедуры

// Инициализирует значение реквизита Используется справочника ВидыКонтактнойИнформации.
//
Процедура УстановитьЗначениеПризнакаИспользуется() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	ВидыКонтактнойИнформации.Ссылка КАК Ссылка,
	|	ВидыКонтактнойИнформации.ИмяПредопределенныхДанных КАК ИмяПредопределенныхДанных
	|ИЗ
	|	Справочник.ВидыКонтактнойИнформации КАК ВидыКонтактнойИнформации
	|ГДЕ
	|	НЕ ВидыКонтактнойИнформации.Используется";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Если СтрНачинаетсяС(ВРег(Выборка.ИмяПредопределенныхДанных), "УДАЛИТЬ") Тогда
			Продолжить;
		КонецЕсли;
		
		ВидКонтактнойИнформацииОбъект = Выборка.Ссылка.ПолучитьОбъект();
		ВидКонтактнойИнформацииОбъект.Используется = Истина;
		ОбновлениеИнформационнойБазы.ЗаписатьДанные(ВидКонтактнойИнформацииОбъект);
		
	КонецЦикла;
	
КонецПроцедуры

// Вызывается при начальном заполнении.
// Установка наименования элементов выполняется в общем модуле УправлениеКонтактнойИнформациейПереопределяемый
// в процедуре ПриПолученииНаименованийВидовКонтактнойИнформации.
//
Процедура ЗаполнитьНаименованияВидовКонтактнойИнформацииПользователя() Экспорт
	
	ПараметрыГруппы = Справочники.ВидыКонтактнойИнформации.СправочникПользователи.ПолучитьОбъект();
	ПараметрыГруппы.Наименование = НСтр("ru='Контактная информация справочника ""Пользователи""'");
	ОбновлениеИнформационнойБазы.ЗаписатьОбъект(ПараметрыГруппы);
	
	ПараметрыВида = Справочники.ВидыКонтактнойИнформации.EmailПользователя.ПолучитьОбъект();
	ПараметрыВида.Наименование = НСтр("ru='Электронная почта'");
	ОбновлениеИнформационнойБазы.ЗаписатьОбъект(ПараметрыВида);
	
	ПараметрыВида = Справочники.ВидыКонтактнойИнформации.ТелефонПользователя.ПолучитьОбъект();
	ПараметрыВида.Наименование = НСтр("ru='Телефон'");
	ОбновлениеИнформационнойБазы.ЗаписатьОбъект(ПараметрыВида);
	
КонецПроцедуры

#КонецОбласти

#Область ОбщиеСлужебныеПроцедурыИФункции

Функция СобытиеЖурналаРегистрации()
	
	Возврат НСтр("ru = 'Контактная информация'", ОбщегоНазначения.КодОсновногоЯзыка());
	
КонецФункции

// Преобразует контактную информацию XDTO в XML.
//
//  Параметры:
//      ОбъектXDTOИнформации - ОбъектXDTO - контактная информация.
//
// Возвращаемое значение:
//      Строка - результат преобразования в формате XML.
//
Функция КонтактнаяИнформацияXDTOВXML(ОбъектXDTOИнформации) Экспорт
	
	Запись = Новый ЗаписьXML;
	Запись.УстановитьСтроку(Новый ПараметрыЗаписиXML(, , Ложь, Ложь, ""));
	
	Если ОбъектXDTOИнформации <> Неопределено Тогда
		ФабрикаXDTO.ЗаписатьXML(Запись, ОбъектXDTOИнформации);
	КонецЕсли;
	
	Результат = СтрЗаменить(Запись.Закрыть(), Символы.ПС, "&#10;");
	Результат = СтрЗаменить(Результат, "<ВнутригРайон/>", "");// Совместимость с КЛАДР
	
	Если Метаданные.ОбщиеМодули.Найти("РаботаСАдресами") <> Неопределено Тогда
		МодульРаботаСАдресами = ОбщегоНазначения.ОбщийМодуль("РаботаСАдресами");
		Результат = МодульРаботаСАдресами.ПередЗаписьюXDTOКонтактнаяИнформация(Результат);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Разбирает представление КИ и возвращает XDTO.
//
//  Параметры:
//      Текст        - Строка  - XML
//      ОжидаемыйВид - СправочникСсылка.ВидыКонтактнойИнформации, ПеречислениеСсылка.ТипыКонтактнойИнформации, Структура.
//
// Возвращаемое значение:
//      Строк - контактная информация.
//
Функция КонтактнаяИнформацияПоПредставлению(Представление, ОжидаемыйВид, РазбиватьНаПоля = Ложь) Экспорт
	
	ОжидаемыйТип = УправлениеКонтактнойИнформациейСлужебныйПовтИсп.ТипВидаКонтактнойИнформации(ОжидаемыйВид);
	
	Если ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Адрес Тогда
		
		Возврат СформироватьАдресПоПредставлению(Представление, РазбиватьНаПоля);
		
	ИначеЕсли ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Телефон
		ИЛИ ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Факс Тогда
			Возврат ДесериализацияТелефонаФаксаВJSON("", Представление, ОжидаемыйТип);
		
	Иначе
		
		КонтактнойИнформации = УправлениеКонтактнойИнформациейКлиентСервер.ОписаниеНовойКонтактнойИнформации(ОжидаемыйТип);
		КонтактнойИнформации.Value = Представление;
		Возврат КонтактнойИнформации;
		
	КонецЕсли;
	
КонецФункции

Функция СформироватьАдресПоПредставлению(Представление, РазбиватьНаПоля = Ложь)
	
	ЕстьРаботаСАдресамиКлиентСервер = Метаданные.ОбщиеМодули.Найти("РаботаСАдресамиКлиентСервер") <> Неопределено;
	
	Если ЕстьРаботаСАдресамиКлиентСервер Тогда
		МодульРаботаСАдресамиКлиентСервер = ОбщегоНазначения.ОбщийМодуль("РаботаСАдресамиКлиентСервер");
		Адрес = МодульРаботаСАдресамиКлиентСервер.ОписаниеНовойКонтактнойИнформации(Перечисления.ТипыКонтактнойИнформации.Адрес);
		НаименованиеОсновнаяСтрана = СокрЛП(МодульРаботаСАдресамиКлиентСервер.ОсновнаяСтрана().Наименование);
	Иначе
		Адрес = УправлениеКонтактнойИнформациейКлиентСервер.ОписаниеНовойКонтактнойИнформации(Перечисления.ТипыКонтактнойИнформации.Адрес);
		НаименованиеОсновнаяСтрана = "";
	КонецЕсли;
	
	// Разбираем адрес из его представления по классификатору.
	Если Не ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.АдресныйКлассификатор") Тогда
		Адрес.Value = Представление;
		Возврат Адрес;
	КонецЕсли;
	
	ДанныеАнализа = ЧастиАдресаТаблицей(Представление);
	Если ДанныеАнализа.Количество() = 0 Тогда
		Возврат Адрес;
	КонецЕсли;
	
	ОпределитьСтрануИИндекс(ДанныеАнализа);
	СтрокаСтраны = ДанныеАнализа.Найти(-2, "Уровень");
	
	Если СтрокаСтраны = Неопределено Тогда
		Адрес.Country = НаименованиеОсновнаяСтрана;
	Иначе
		Адрес.Country = СокрЛП(ВРег(СтрокаСтраны.Значение));
	КонецЕсли;
	
	// Обработка частых сокращений в адресе
	Если Метаданные.ОбщиеМодули.Найти("РаботаСАдресами") <> Неопределено Тогда
		МодульРаботаСАдресами = ОбщегоНазначения.ОбщийМодуль("РаботаСАдресами");
		МодульРаботаСАдресами.ОбработкаЧастыхСокращенийВАдресах(ДанныеАнализа);
	КонецЕсли;
	
	Если Адрес.Country = НаименованиеОсновнаяСтрана Тогда
		
		Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.АдресныйКлассификатор") Тогда
			
			МодульАдресныйКлассификаторСлужебный = ОбщегоНазначения.ОбщийМодуль("АдресныйКлассификаторСлужебный");
			ВариантыАдреса = МодульАдресныйКлассификаторСлужебный.РаспознатьАдрес(ДанныеАнализа, Представление, РазбиватьНаПоля);
			
			Если ВариантыАдреса = Неопределено Тогда
				
				Если РазбиватьНаПоля Тогда
					
					МодульРаботаСАдресамиКлиентСервер = ОбщегоНазначения.ОбщийМодуль("РаботаСАдресамиКлиентСервер");
					Адрес.AddressType = МодульРаботаСАдресамиКлиентСервер.МуниципальныйАдрес();
					
					Адрес.Value = Представление;
					РаспределитьАдресПоПолямБезКлассификатора(Адрес, ДанныеАнализа);
					
				Иначе
					
					Адрес.Value = Представление;
					Адрес.AddressType = УправлениеКонтактнойИнформациейКлиентСервер.АдресВСвободнойФорме();
					
				КонецЕсли;
			Иначе
				
				ЗаполнитьЗначенияСвойств(Адрес, ВариантыАдреса);
				Если ЕстьРаботаСАдресамиКлиентСервер Тогда
					МодульРаботаСАдресамиКлиентСервер = ОбщегоНазначения.ОбщийМодуль("РаботаСАдресамиКлиентСервер");
					МодульРаботаСАдресамиКлиентСервер.ОбновитьПредставлениеАдреса(Адрес, Ложь);
				Иначе
					ОбновитьПредставлениеАдреса(Адрес, Ложь);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	Иначе
		
		Если ЕстьРаботаСАдресамиКлиентСервер Тогда
			МодульРаботаСАдресамиКлиентСервер = ОбщегоНазначения.ОбщийМодуль("РаботаСАдресамиКлиентСервер");
			ТипАдреса = ?(УправлениеКонтактнойИнформацией.ЭтоСтранаУчастникЕАЭС(Адрес.Country),
				УправлениеКонтактнойИнформациейКлиентСервер.АдресЕАЭС(),
				УправлениеКонтактнойИнформациейКлиентСервер.ИностранныйАдрес());
			Адрес.AddressType = ТипАдреса;
		Иначе
			Адрес.AddressType = УправлениеКонтактнойИнформациейКлиентСервер.АдресВСвободнойФорме();
		КонецЕсли;
		
		НовоеПредставление = Новый Массив;
		ДанныеАнализа.Сортировать("Позиция");
		Для каждого ЧастьАдрес Из ДанныеАнализа Цикл
			Если ЧастьАдрес.Уровень >=0 Тогда
				НовоеПредставление.Добавить(ЧастьАдрес.Значение);
			КонецЕсли;
		КонецЦикла;
		
		Адрес.Area = СтрСоединить(НовоеПредставление, ", ");
		
	КонецЕсли;
	
	Если ПустаяСтрока(Адрес.ZipCode) Тогда
		СтрокаИндекс = ДанныеАнализа.Найти(-1, "Уровень");
		Если СтрокаИндекс <> Неопределено Тогда
			Адрес.ZipCode = СокрЛП(СтрокаИндекс.Значение);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Адрес;
	
КонецФункции

Процедура ОбновитьПредставлениеАдреса(Адрес, ВключатьСтрануВПредставление)
	
	Если ТипЗнч(Адрес) <> Тип("Структура") Тогда
		ВызватьИсключение НСтр("ru='Для формирования представления адреса передан некорректный тип адреса'");
	КонецЕсли;
	
	СписокЗаполненныхУровней = Новый Массив;
	
	Если ВключатьСтрануВПредставление И Адрес.Свойство("Country") И НЕ ПустаяСтрока(Адрес.Country) Тогда
		СписокЗаполненныхУровней.Добавить(Адрес.Country);
	КонецЕсли;
	
	Если Адрес.Свойство("ZipCode") И НЕ ПустаяСтрока(Адрес.ZipCode) Тогда
		СписокЗаполненныхУровней.Добавить(Адрес.ZipCode);
	КонецЕсли;
	
	СписокЗаполненныхУровней.Добавить(Адрес["Area"] + " " + Адрес["AreaType"]);
	СписокЗаполненныхУровней.Добавить(Адрес["City"] + " " + Адрес["CityType"]);
	
	Адрес.Value = СтрСоединить(СписокЗаполненныхУровней, ", ");
	
КонецПроцедуры

Процедура РаспределитьАдресПоПолямБезКлассификатора(Адрес, ДанныеАнализа)
	
	ПредставлениеПоДаннымАнализа = Новый Массив;
	Для каждого ЧастьАдрес Из ДанныеАнализа Цикл
		Если ЧастьАдрес.Уровень >= 0 Тогда
			ПредставлениеПоДаннымАнализа.Добавить(СокрЛП(ЧастьАдрес.Наименование + " " + ЧастьАдрес.Сокращение));
		КонецЕсли;
	КонецЦикла;
	
	Адрес.Street = СтрСоединить(ПредставлениеПоДаннымАнализа, ", ");
	
КонецПроцедуры

Функция ЧастиАдресаТаблицей(Знач Текст)
	
	ТипСтрока = Новый ОписаниеТипов("Строка", Новый КвалификаторыСтроки(128));
	ТипЧисло  = Новый ОписаниеТипов("Число");
	
	Результат = Новый ТаблицаЗначений;
	Колонки = Результат.Колонки;
	Колонки.Добавить("Уровень", ТипЧисло);
	Колонки.Добавить("Позиция", ТипЧисло);
	Колонки.Добавить("Значение", ТипСтрока);
	Колонки.Добавить("Наименование", ТипСтрока);
	Колонки.Добавить("Сокращение", ТипСтрока);
	Колонки.Добавить("Начало", ТипЧисло);
	Колонки.Добавить("Длина", ТипЧисло);
	Колонки.Добавить("Идентификатор", ТипСтрока);
	
	Номер = 1;
	Для Каждого Часть Из СловаТекстаТаблицей(Текст, "," + Символы.ПС) Цикл
		Значение = СокрЛП(Часть.Значение);
		Если ПустаяСтрока(Значение) Тогда
			Продолжить;
		КонецЕсли;
		
		Строка = Результат.Добавить();
		
		Строка.Уровень = 0;
		Строка.Позиция  = Номер;
		Номер = Номер + 1;
		
		Строка.Начало = Часть.Начало;
		Строка.Длина  = Часть.Длина;
		
		Позиция = СтрДлина(Значение);
		Пока Позиция > 0 Цикл
			Символ = Сред(Значение, Позиция, 1);
			Если ПустаяСтрока(Символ) Тогда
				Строка.Наименование = СокрЛП(Лев(Значение, Позиция-1));
				Прервать;
			КонецЕсли;
			Строка.Сокращение = Символ + Строка.Сокращение;
			Позиция = Позиция - 1;
		КонецЦикла;
		
		Если ПустаяСтрока(Строка.Наименование) Тогда
			Строка.Наименование = СокрЛП(Строка.Сокращение);
			Строка.Сокращение   = "";
		КонецЕсли;
		Строка.Значение = СокрЛП(Строка.Наименование + " " + Строка.Сокращение);
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

Функция СловаТекстаТаблицей(Знач Текст, Знач Разделители = Неопределено)
	
	// Удаление из текста спец. символов "точек", "номеров".
	Текст = СтрЗаменить(Текст, "№", "");
	
	НачалоСлова = 0;
	Состояние   = 0;
	
	ТипСтрока = Новый ОписаниеТипов("Строка");
	ТипЧисло  = Новый ОписаниеТипов("Число");
	
	Результат = Новый ТаблицаЗначений;
	Колонки = Результат.Колонки;
	Колонки.Добавить("Значение", ТипСтрока);
	Колонки.Добавить("Начало",   ТипЧисло);
	Колонки.Добавить("Длина",    ТипЧисло);
	
	Для Позиция = 1 По СтрДлина(Текст) Цикл
		ТекущийСимвол = Сред(Текст, Позиция, 1);
		ЭтоРазделитель = ?(Разделители = Неопределено, ПустаяСтрока(ТекущийСимвол), СтрНайти(Разделители, ТекущийСимвол) > 0);
		
		Если Состояние = 0 И (Не ЭтоРазделитель) Тогда
			НачалоСлова = Позиция;
			Состояние   = 1;
		ИначеЕсли Состояние = 1 И ЭтоРазделитель Тогда
			Строка = Результат.Добавить();
			Строка.Начало = НачалоСлова;
			Строка.Длина  = Позиция-НачалоСлова;
			Строка.Значение = Сред(Текст, Строка.Начало, Строка.Длина);
			Состояние = 0;
		КонецЕсли;
	КонецЦикла;
	
	Если Состояние = 1 Тогда
		Строка = Результат.Добавить();
		Строка.Начало = НачалоСлова;
		Строка.Длина  = Позиция-НачалоСлова;
		Строка.Значение = Сред(Текст, Строка.Начало, Строка.Длина)
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

Процедура ОпределитьСтрануИИндекс(ДанныеАдреса)
	
	Если Метаданные.ОбщиеМодули.Найти("РаботаСАдресами") = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ОписаниеТипаЧисло = Новый ОписаниеТипов("Число");
	МодульРаботаСАдресами = ОбщегоНазначения.ОбщийМодуль("РаботаСАдресами");
	Классификатор = МодульРаботаСАдресами.ТаблицаКлассификатора();
	
	Для каждого ЭлементАдреса Из ДанныеАдреса Цикл
		Индекс = ОписаниеТипаЧисло.ПривестиЗначение(ЭлементАдреса.Наименование);
		Если Индекс >= 100000 И Индекс < 1000000 Тогда
			ЭлементАдреса.Уровень = -1;
		Иначе
			Если Классификатор.Найти(ВРег(ЭлементАдреса.Значение), "Наименование") <> Неопределено Тогда
				ЭлементАдреса.Уровень = -2;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Разбирает представление КИ и возвращает XDTO.
//
//  Параметры:
//      Текст        - Строка  - XML
//      ОжидаемыйВид - СправочникСсылка.ВидыКонтактнойИнформации, ПеречислениеСсылка.ТипыКонтактнойИнформации, Структура.
//
// Возвращаемое значение:
//      ОбъектXDTO - контактная информация.
//
Функция КонтактнаяИнформацияXDTOПоПредставлению(Текст, ОжидаемыйВид) Экспорт
	
	ОжидаемыйТип = УправлениеКонтактнойИнформациейСлужебныйПовтИсп.ТипВидаКонтактнойИнформации(ОжидаемыйВид);
	
	Если ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Адрес Тогда
		Возврат АдресXMLВXDTO("", Текст, ОжидаемыйТип);
		
	ИначеЕсли ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.АдресЭлектроннойПочты Тогда
		Возврат ДесериализацияПрочейКонтактнойИнформации("", Текст, ОжидаемыйТип);
		
	ИначеЕсли ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.ВебСтраница Тогда
		Возврат ДесериализацияПрочейКонтактнойИнформации("", Текст, ОжидаемыйТип);
		
	ИначеЕсли ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Телефон Тогда
		Возврат ДесериализацияТелефона("", Текст, ОжидаемыйТип);
		
	ИначеЕсли ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Факс Тогда
		Возврат ДесериализацияФакса("", Текст, ОжидаемыйТип);
		
	ИначеЕсли ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Skype Тогда
		Возврат ДесериализацияПрочейКонтактнойИнформации("", Текст, ОжидаемыйТип);
		
	ИначеЕсли ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Другое Тогда
		Возврат ДесериализацияПрочейКонтактнойИнформации("", Текст, ОжидаемыйТип);
		
	КонецЕсли;
	
	Возврат Неопределено;
КонецФункции

// Преобразует строку в XDTO контактную информацию адреса.
//
//  Параметры:
//      ЗначенияПолей - Строка - сериализованная информация, значения полей.
//      Представление - Строка - представление старший-младший, используется для попытки разбора, если ЗначенияПолей
//                               пусто.
//      ОжидаемыйТип  - ПеречислениеСсылка.ТипыКонтактнойИнформации - необязательный тип для контроля.
//
//  Возвращаемое значение:
//      ОбъектXDTO  - контактной информации.
//
Функция АдресXMLВXDTO(Знач ЗначенияПолей, Знач Представление = "", Знач ОжидаемыйТип = Неопределено) Экспорт
	
	Если Метаданные.Обработки.Найти("РасширенныйВводКонтактнойИнформации") <> Неопределено Тогда
		Возврат Обработки["РасширенныйВводКонтактнойИнформации"].АдресXMLВXDTO(ЗначенияПолей, Представление, ОжидаемыйТип);
	КонецЕсли;
	
	// Пустой объект с представлением.
	ПространствоИмен = ПространствоИмен();
	Результат = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "КонтактнаяИнформация"));
	Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "Адрес"));
	Результат.Состав.Состав = Представление;
	Результат.Представление = Представление;
	Возврат Результат;
	
КонецФункции

// Преобразует строку в XDTO контактную информацию телефона.
//
//      ЗначенияПолей - Строка - сериализованная информация, значения полей.
//      Представление - Строка - представление старший-младший, используется для попытки разбора, если ЗначенияПолей
//                               пусто.
//      ОжидаемыйТип  - ПеречислениеСсылка.ТипыКонтактнойИнформации - необязательный тип для контроля.
//
//  Возвращаемое значение:
//      ОбъектXDTO  - контактной информации.
//
Функция ДесериализацияТелефона(ЗначенияПолей, Представление = "", ОжидаемыйТип = Неопределено) Экспорт
	Возврат ДесериализацияТелефонаФакса(ЗначенияПолей, Представление, ОжидаемыйТип);
КонецФункции

// Преобразует строку в XDTO контактную информацию Факса.
//
//      ЗначенияПолей - Строка - сериализованная информация, значения полей.
//      Представление - Строка - представление старший-младший, используется для попытки разбора, если ЗначенияПолей
//                               пусто.
//      ОжидаемыйТип  - ПеречислениеСсылка.ТипыКонтактнойИнформации - необязательный тип для контроля.
//
//  Возвращаемое значение:
//      ОбъектXDTO  - контактной информации.
//
Функция ДесериализацияФакса(ЗначенияПолей, Представление = "", ОжидаемыйТип = Неопределено) Экспорт
	Возврат ДесериализацияТелефонаФакса(ЗначенияПолей, Представление, ОжидаемыйТип);
КонецФункции

// Преобразует строку в XDTO прочую контактную информацию.
//
// Параметры:
//   ЗначенияПолей - Строка - сериализованная информация, значения полей.
//   Представление - Строка - представление старший-младший, используется для попытки разбора, если ЗначенияПолей пусто.
//   ОжидаемыйТип  - ПеречислениеСсылка.ТипыКонтактнойИнформации - необязательный тип для контроля.
//
// Возвращаемое значение:
//   ОбъектXDTO  - контактной информации.
//
Функция ДесериализацияПрочейКонтактнойИнформации(ЗначенияПолей, Представление = "", ОжидаемыйТип = Неопределено)
	
	Если УправлениеКонтактнойИнформациейКлиентСервер.ЭтоКонтактнаяИнформацияВXML(ЗначенияПолей) Тогда
		// Общий формат контактной информации.
		Возврат КонтактнаяИнформацияИзXML(ЗначенияПолей, ОжидаемыйТип);
	КонецЕсли;
	
	ПространствоИмен = ПространствоИмен();
	Результат = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "КонтактнаяИнформация"));
	Результат.Представление = Представление;
	
	Если ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.АдресЭлектроннойПочты Тогда
		Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "ЭлектроннаяПочта"));
		
	ИначеЕсли ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.ВебСтраница Тогда
		Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "ВебСайт"));
		
	ИначеЕсли ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Skype Тогда
		Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "Skype"));
		
	ИначеЕсли ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Другое Тогда
		Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "Прочее"));
		
	ИначеЕсли ОжидаемыйТип <> Неопределено Тогда
		ВызватьИсключение НСтр("ru = 'Ошибка десериализации контактной информации, ожидается другой тип'");
		
	КонецЕсли;
	
	Результат.Состав.Значение = Представление;
	
	Возврат Результат;
	
КонецФункции

// Возвращает представление контактной информации.
//
// Параметры:
//   КонтактнаяИнформация    -  Строка - Адрес в формат JSON или XML .
//   ФорматКонтактнойИнформации  - Строка             - если указано "КЛАДР", то в представление адреса 
//                                        не включаются округ и внутригородской район.
//    ВидКонтактнойИнформации - Структура - дополнительные параметры формирования представления для адресов:
//      * Тип - Строка - Тип контактной информации;
//      * ВключатьСтрануВПредставление - Булево - в представление будет включена страна адреса;
//      * ФорматАдреса                 - Строка - если указано "КЛАДР", то в представление адреса 
//                                                не включаются округ и внутригородской район.
// Возвращаемое значение:
//      Строка - сформированное представление.
//
Функция ПредставлениеКонтактнойИнформации(Знач КонтактнаяИнформация, Знач ФорматКонтактнойИнформации) Экспорт
	
	Если ПустаяСтрока(КонтактнаяИнформация) Тогда
		Возврат "";
	КонецЕсли;
	
	Вид = Неопределено;
	Если УправлениеКонтактнойИнформациейКлиентСервер.ЭтоКонтактнаяИнформацияВJSON(КонтактнаяИнформация) Тогда
		
		КонтактнаяИнформация = СтрокуJSONВСтруктуру(КонтактнаяИнформация);
		
	ИначеЕсли ТипЗнч(КонтактнаяИнформация) = Тип("Структура") Тогда
		
		Если КонтактнаяИнформация.Свойство("НомерТелефона") Тогда
			ТипКонтактнойИнформации =Перечисления.ТипыКонтактнойИнформации.Телефон;
		Иначе
			ТипКонтактнойИнформации =Перечисления.ТипыКонтактнойИнформации.Адрес;
		КонецЕсли;
		
		КонтактнаяИнформация = КонтактнаяИнформацияВСтруктуруJSON(КонтактнаяИнформация, ТипКонтактнойИнформации);
		
	ИначеЕсли ТипЗнч(КонтактнаяИнформация) = Тип("Строка") Или ТипЗнч(КонтактнаяИнформация) = Тип("ОбъектXDTO") Тогда
		
		КонтактнаяИнформация = КонтактнаяИнформацияВСтруктуруJSON(КонтактнаяИнформация);
		
	КонецЕсли;
	
	Если ПустаяСтрока(КонтактнаяИнформация.Value) Тогда
		СформироватьПредставлениеКонтактнойИнформации(КонтактнаяИнформация, Вид);
	КонецЕсли;
	
	Возврат КонтактнаяИнформация.Value
	
КонецФункции

// Вычисляет, что адрес был введен в свободной форме.
//
//  Параметры:
//      КонтактнаяИнформация - Структура, Строка - Контактная информация.
//
//  Возвращаемое значение:
//      Булево - новое значение.
//
Функция АдресВведенВСвободнойФорме(Знач КонтактнаяИнформация) Экспорт
	
	Если УправлениеКонтактнойИнформациейКлиентСервер.ЭтоКонтактнаяИнформацияВXML(КонтактнаяИнформация) Тогда
		КонтактнаяИнформацияJSON = УправлениеКонтактнойИнформацией.КонтактнаяИнформацияВJSON(КонтактнаяИнформация);
		КонтактнаяИнформация = JSONВКонтактнуюИнформациюПоПолям(КонтактнаяИнформацияJSON, Перечисления.ТипыКонтактнойИнформации.Адрес);
	ИначеЕсли УправлениеКонтактнойИнформациейКлиентСервер.ЭтоКонтактнаяИнформацияВJSON(КонтактнаяИнформация) Тогда
		КонтактнаяИнформация = JSONВКонтактнуюИнформациюПоПолям(КонтактнаяИнформация, Перечисления.ТипыКонтактнойИнформации.Адрес);
	КонецЕсли;
	
	Если ТипЗнч(КонтактнаяИнформация) = Тип("Структура")
		И КонтактнаяИнформация.Свойство("AddressType") Тогда
			Возврат УправлениеКонтактнойИнформациейКлиентСервер.ЭтоАдресВСвободнойФорме(КонтактнаяИнформация.AddressType);
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Формирует и возвращает представление контактной информации.
//
// Параметры:
//   Информация    - Структура, Строка - Контактная информация строкой в формате JSON или структура с полями.
//   ВидИнформации - СправочникСсылка.ВидыКонтактнойИнформации, Структура - параметры для формирования представления.
//
// Возвращаемое значение:
//      Строка - сформированное представление.
//
Функция СформироватьПредставлениеКонтактнойИнформации(Знач Информация, Знач ВидИнформации)
	
	Если ТипЗнч(Информация) = Тип("Строка") И УправлениеКонтактнойИнформациейКлиентСервер.ЭтоКонтактнаяИнформацияВJSON(Информация) Тогда
		ТипКонтактнойИнформации = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ВидИнформации, "Тип");
		Информация = JSONВКонтактнуюИнформациюПоПолям(Информация, ТипКонтактнойИнформации);
	КонецЕсли;
	
	Если ТипЗнч(Информация) = Тип("Структура") Тогда
		
		Если ЭтоТипАдрес(Информация.Type) Тогда
			Возврат ПредставлениеАдреса(Информация, ВидИнформации);
			
		ИначеЕсли Информация.Type = Строка(Перечисления.ТипыКонтактнойИнформации.Телефон)
			ИЛИ Информация.Type = Строка(Перечисления.ТипыКонтактнойИнформации.Факс) Тогда
			ПредставлениеТелефона = ПредставлениеТелефона(Информация);
			Возврат ?(ПустаяСтрока(ПредставлениеТелефона), Информация.Value, ПредставлениеТелефона);
		КонецЕсли;
		
		Возврат Информация.Value;
	КонецЕсли;
	
	// Старый формат или новый десериализованный.
	Возврат СформироватьПредставлениеКонтактнойИнформации(КонтактнаяИнформацияВСтруктуруJSON(Информация), ВидИнформации);
	
КонецФункции

// Возвращает флаг того, что переданный адрес - российский.
//
//  Параметры:
//      Адрес - Структура, Строка - Контактная информация адреса в виде структуры или строки JSON.
//
//  Возвращаемое значение:
//      Булево - результат проверки.
//
Функция ЭтоНациональныйАдрес(Знач Адрес) Экспорт
	
	Если НЕ ЗначениеЗаполнено(Адрес) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Метаданные.ОбщиеМодули.Найти("РаботаСАдресамиКлиентСервер") <> Неопределено Тогда
		
		Если ТипЗнч(Адрес) = Тип("Строка") Тогда
			Адрес = JSONВКонтактнуюИнформациюПоПолям(Адрес, Перечисления.ТипыКонтактнойИнформации.Адрес);
		КонецЕсли;
		
		Если ТипЗнч(Адрес) = Тип("Структура") И Адрес.Свойство("Country")Тогда
			
			МодульРаботаСАдресамиКлиентСервер = ОбщегоНазначения.ОбщийМодуль("РаботаСАдресамиКлиентСервер");
			НаименованиеСтраны = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(МодульРаботаСАдресамиКлиентСервер.ОсновнаяСтрана(), "Наименование");
			Возврат СтрСравнить(НаименованиеСтраны, Адрес.Country) = 0;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Формирует представление для адреса по правилу:
//  1) Страна, если надо.
//  2) Индекс, субъект рф, округ, район, город, внутригородской район, населенный пункт, улица.
//  3) Здания, помещения.
//
// Параметры:
//  Адрес			 - Структура - Адрес с разбивкой по полям.
//  ВидИнформации	 - Структура - Описание вида контактной информации.
// 
// Возвращаемое значение:
//  Строка  - Представление адреса.
//
Функция ПредставлениеАдреса(Знач Адрес, Знач ВидИнформации)
	
	Если ТипЗнч(ВидИнформации) = Тип("Структура") И ВидИнформации.Свойство("ВключатьСтрануВПредставление") Тогда
		ВключатьСтрануВПредставление = ВидИнформации.ВключатьСтрануВПредставление;
	Иначе
		ВключатьСтрануВПредставление = Ложь;
	КонецЕсли;
	
	Если ТипЗнч(Адрес) = Тип("Структура") Тогда
		
		Если Метаданные.ОбщиеМодули.Найти("РаботаСАдресамиКлиентСервер") <> Неопределено Тогда
			МодульРаботаСАдресамиКлиентСервер = ОбщегоНазначения.ОбщийМодуль("РаботаСАдресамиКлиентСервер");
			МодульРаботаСАдресамиКлиентСервер.ОбновитьПредставлениеАдреса(Адрес, ВключатьСтрануВПредставление);
		Иначе
			ОбновитьПредставлениеАдреса(Адрес, ВключатьСтрануВПредставление);
		КонецЕсли;
		
		Возврат Адрес.Value;
	Иначе
		// Это иностранный адрес
		Представление = СокрЛП(Адрес);
		
		Если СтрЧислоВхождений(Представление, ",") = 9 Тогда
			// Удаляем пустые значения и страну.
			ПредставлениеМассивом = СтрРазделить(Представление, ",", Ложь);
			Если ПредставлениеМассивом.Количество() > 0 Тогда
				Для Индекс = 0 По ПредставлениеМассивом.ВГраница() Цикл
					ПредставлениеМассивом[Индекс] = СокрЛП(ПредставлениеМассивом[Индекс]);
				КонецЦикла;
				ПредставлениеМассивом.Удалить(0); // удаляем страну
				Представление = СтрСоединить(ПредставлениеМассивом, ", ");
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Представление;
	
КонецФункции

Функция ПредставлениеТелефона(ДанныеТелефон)
	
	Если ТипЗнч(ДанныеТелефон) = Тип("Структура") Тогда
		
		ПредставлениеТелефона = УправлениеКонтактнойИнформациейКлиентСервер.СформироватьПредставлениеТелефона(
			СократитьНеЦифры(ДанныеТелефон.countryCode),
			ДанныеТелефон.areaCode,
			ДанныеТелефон.number,
			ДанныеТелефон.extNumber,
			"");
			
	Иначе
		
		ПредставлениеТелефона = УправлениеКонтактнойИнформациейКлиентСервер.СформироватьПредставлениеТелефона(
			СократитьНеЦифры(ДанныеТелефон.КодСтраны), 
			ДанныеТелефон.КодГорода,
			ДанныеТелефон.Номер,
			ДанныеТелефон.Добавочный,
			"");
		
	КонецЕсли;
	
	Возврат ПредставлениеТелефона;
	
КонецФункции

// Конструктор структуры, совместимой по полям со справочником видов контактной информации.
//
// Параметры:
//     Источник - СправочникСсылка.ВидыКонтактнойИнформации - необязательный источник данных для заполнения.
//
// Возвращаемое значение:
//     Структура - совместимая по полям со справочникам видов контактной информации.
//
Функция СтруктураВидаКонтактнойИнформации(Знач Источник = Неопределено) Экспорт
	
	МетаданныеРеквизитов = Метаданные.Справочники.ВидыКонтактнойИнформации.Реквизиты;
	
	Если ТипЗнч(Источник) = Тип("СправочникСсылка.ВидыКонтактнойИнформации") Тогда
		Реквизиты = "Наименование";
		Для Каждого МетаданныеРеквизита Из МетаданныеРеквизитов Цикл
			Реквизиты = Реквизиты + "," + МетаданныеРеквизита.Имя;
		КонецЦикла;
		
		Результат = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Источник, Реквизиты);
	Иначе
		Результат = Новый Структура("Наименование", "");
		Для Каждого МетаданныеРеквизита Из МетаданныеРеквизитов Цикл
			Результат.Вставить(МетаданныеРеквизита.Имя, МетаданныеРеквизита.Тип.ПривестиЗначение());
		КонецЦикла;
		
		Если Источник <> Неопределено Тогда
			ЗаполнитьЗначенияСвойств(Результат, Источник);
			
			Если Источник.Свойство("НастройкиПроверки") И Источник.НастройкиПроверки <> Неопределено Тогда
				ЗаполнитьЗначенияСвойств(Результат, Источник.НастройкиПроверки);
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	Результат.Вставить("Ссылка", Источник);
	
	Возврат Результат;
	
КонецФункции

Функция ДанныеВидовКонтактнойИнформации(Знач ВидыКонтактнойИнформации) Экспорт
	
	МетаданныеРеквизитов = Метаданные.Справочники.ВидыКонтактнойИнформации.Реквизиты;
	Реквизиты = "Наименование, ИмяПредопределенныхДанных, ПометкаУдаления";
	Для Каждого МетаданныеРеквизита Из МетаданныеРеквизитов Цикл
		Реквизиты = Реквизиты + "," + МетаданныеРеквизита.Имя;
	КонецЦикла;
	
	Возврат ОбщегоНазначения.ЗначенияРеквизитовОбъектов(ВидыКонтактнойИнформации, Реквизиты);
	
КонецФункции

// Обновляет агрегатное поле ВидДляСписка контактной информацию у объекта.
//
// Параметры:
//  Объект - СправочникОбъект - Объект с табличной часть КонтактнаяИнформация.
//
Процедура ОбновитьКонтактнуюИнформациюДляСписковДляОбъекта(Объект) Экспорт
	
	КонтактнаяИнформация = Объект.КонтактнаяИнформация;
	
	Если КонтактнаяИнформация.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Индекс = КонтактнаяИнформация.Количество() - 1;
	Пока Индекс >= 0 Цикл
		Если НЕ ЗначениеЗаполнено(КонтактнаяИнформация[Индекс].Вид) Тогда
			КонтактнаяИнформация.Удалить(Индекс);
		КонецЕсли;
		Индекс = Индекс -1;
	КонецЦикла;
	
	КолонкаДействуетСОтсутствует = (Объект.Метаданные().ТабличныеЧасти.КонтактнаяИнформация.Реквизиты.Найти("ДействуетС") = Неопределено);
	
	Запрос = Новый Запрос("ВЫБРАТЬ
		|	КонтактнаяИнформация.Представление КАК Представление,
		|	КонтактнаяИнформация.Вид КАК Вид" + ?(КолонкаДействуетСОтсутствует, "", ", КонтактнаяИнформация.ДействуетС КАК ДействуетС") + "
		|ПОМЕСТИТЬ КонтактнаяИнформация
		|ИЗ
		|	&КонтактнаяИнформация КАК КонтактнаяИнформация
		|;");
	
	Если КолонкаДействуетСОтсутствует Тогда
		Запрос.Текст = Запрос.Текст + "ВЫБРАТЬ
		|	КонтактнаяИнформация.Представление КАК Представление,
		|	КонтактнаяИнформация.Вид КАК Вид,
		|	КОЛИЧЕСТВО(КонтактнаяИнформация.Вид) КАК Количество
		|ИЗ
		|	КонтактнаяИнформация КАК КонтактнаяИнформация
		|
		|СГРУППИРОВАТЬ ПО
		|	КонтактнаяИнформация.Вид,
		|	КонтактнаяИнформация.Представление ИТОГИ ПО Вид";
	Иначе
		Запрос.Текст = Запрос.Текст + "ВЫБРАТЬ
		|	КонтактнаяИнформация.Вид КАК Вид,
		|	МАКСИМУМ(КонтактнаяИнформация.ДействуетС) КАК ДействуетС
		|ПОМЕСТИТЬ АктуальнаяКонтактнаяИнформация
		|ИЗ
		|	КонтактнаяИнформация КАК КонтактнаяИнформация
		|
		|СГРУППИРОВАТЬ ПО
		|	КонтактнаяИнформация.Вид
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	КонтактнаяИнформация.Представление КАК Представление,
		|	КонтактнаяИнформация.Вид КАК Вид,
		|	КонтактнаяИнформация.ДействуетС КАК ДействуетС,
		|	КОЛИЧЕСТВО(КонтактнаяИнформация.Вид) КАК Количество
		|ИЗ
		|	АктуальнаяКонтактнаяИнформация КАК АктуальнаяКонтактнаяИнформация
		|		ЛЕВОЕ СОЕДИНЕНИЕ КонтактнаяИнформация КАК КонтактнаяИнформация
		|		ПО АктуальнаяКонтактнаяИнформация.ДействуетС = КонтактнаяИнформация.ДействуетС
		|			И АктуальнаяКонтактнаяИнформация.Вид = КонтактнаяИнформация.Вид
		|
		|СГРУППИРОВАТЬ ПО
		|	КонтактнаяИнформация.Вид,
		|	КонтактнаяИнформация.Представление,
		| КонтактнаяИнформация.ДействуетС
		|ИТОГИ ПО
		|	Вид, ДействуетС"; 
	КонецЕсли;
	
	Запрос.УстановитьПараметр("КонтактнаяИнформация", КонтактнаяИнформация);
	РезультатЗапроса = Запрос.Выполнить();
	ВыборкаВид       = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	
	Пока ВыборкаВид.Следующий() Цикл
		ВыборкаДетальныеЗаписи = ВыборкаВид.Выбрать();
		Если ВыборкаВид.Количество = 1 Тогда
			Если КолонкаДействуетСОтсутствует Тогда
				СтрокаТаблиц = КонтактнаяИнформация.Найти(ВыборкаВид.Вид, "Вид");
				СтрокаТаблиц.ВидДляСписка = ВыборкаВид.Вид;
			Иначе
				ДействуетС = Дата(1,1,1);
				Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
					Если ЗначениеЗаполнено(ВыборкаДетальныеЗаписи.ДействуетС) Тогда
						ДействуетС = ВыборкаДетальныеЗаписи.ДействуетС;
					КонецЕсли;
				КонецЦикла;
				НайденныеСтроки = КонтактнаяИнформация.НайтиСтроки(Новый Структура("Вид", ВыборкаВид.Вид));
				Для каждого СтрокаСКонтактнойИнформацией Из НайденныеСтроки Цикл
					СтрокаСКонтактнойИнформацией.ВидДляСписка = ?(СтрокаСКонтактнойИнформацией.ДействуетС = ДействуетС,
							ВыборкаВид.Вид, Справочники.ВидыКонтактнойИнформации.ПустаяСсылка());
				КонецЦикла;
			КонецЕсли;
		ИначеЕсли ВыборкаВид.Количество > 1 Тогда
			ЭлементыКонтактнойИнформации = Новый Массив;
			Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
				Если ЗначениеЗаполнено(ВыборкаДетальныеЗаписи.Представление) Тогда
					ЭлементыКонтактнойИнформации.Добавить(ВыборкаДетальныеЗаписи.Представление);
				КонецЕсли;
			КонецЦикла;
			СтрокаТаблиц               = КонтактнаяИнформация.Добавить();
			СтрокаТаблиц.ВидДляСписка  = ВыборкаВид.Вид;
			СтрокаТаблиц.Представление = СтрСоединить(ЭлементыКонтактнойИнформации, ", ");
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Обновляет агрегатное поле ВидДляСписка в табличных частях КонтактнаяИнформация у всех объекта.
//
Процедура ОбновитьКонтактнуюИнформациюДляСписков() Экспорт
	
	ОбъектыСКолонкойВидДляСписка = ОбъектыСодержащиеВидДляСписка();
	
	Для каждого ОбъектСсылка Из ОбъектыСКолонкойВидДляСписка Цикл
		Объект = ОбъектСсылка.ПолучитьОбъект();
		КонтактнаяИнформация = Объект.КонтактнаяИнформация;
		
		Отбор = Новый Структура("Тип", Перечисления.ТипыКонтактнойИнформации.ПустаяСсылка());
		СтрокиДляУдаления = КонтактнаяИнформация.НайтиСтроки(Отбор);
		Для каждого СтрокаДляУдаления Из СтрокиДляУдаления Цикл
			КонтактнаяИнформация.Удалить(СтрокаДляУдаления);
		КонецЦикла;
		
		Запрос = Новый Запрос;
		Запрос.Текст = 
			"ВЫБРАТЬ
			|	КонтактнаяИнформация.Представление КАК Представление,
			|	КонтактнаяИнформация.Вид КАК Вид
			|ПОМЕСТИТЬ КонтактнаяИнформация
			|ИЗ
			|	&КонтактнаяИнформация КАК КонтактнаяИнформация
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|ВЫБРАТЬ
			|	КонтактнаяИнформация.Представление КАК Представление,
			|	КонтактнаяИнформация.Вид КАК Вид,
			|	КОЛИЧЕСТВО(КонтактнаяИнформация.Вид) КАК Количество
			|ИЗ
			|	КонтактнаяИнформация КАК КонтактнаяИнформация
			|
			|СГРУППИРОВАТЬ ПО
			|	КонтактнаяИнформация.Вид,
			|	КонтактнаяИнформация.Представление ИТОГИ ПО Вид";
		
		Запрос.УстановитьПараметр("КонтактнаяИнформация", КонтактнаяИнформация);
		РезультатЗапроса = Запрос.Выполнить();
		ВыборкаВид = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
		
		Пока ВыборкаВид.Следующий() Цикл
			ВыборкаДетальныеЗаписи = ВыборкаВид.Выбрать();
			Если ВыборкаВид.Количество = 1 Тогда
				СтрокаТаблиц = КонтактнаяИнформация.Найти(ВыборкаВид.Вид, "Вид");
				СтрокаТаблиц.ВидДляСписка = ВыборкаВид.Вид;
			ИначеЕсли ВыборкаВид.Количество > 1 Тогда
				СтрокаТаблиц = КонтактнаяИнформация.Добавить();
				СтрокаТаблиц.ВидДляСписка = ВыборкаВид.Вид;
				Разделитель = "";
				Представление = "";
				Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
					Представление = Представление +Разделитель + ВыборкаДетальныеЗаписи.Представление;
					Разделитель = ", ";
				КонецЦикла;
				СтрокаТаблиц.Представление = Представление;
			КонецЕсли;
		КонецЦикла;
		ОбновлениеИнформационнойБазы.ЗаписатьДанные(Объект);
	КонецЦикла;

КонецПроцедуры

Функция ОбъектыСодержащиеВидДляСписка()
	
	ОбъектыМетаданных = Новый Массив;
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ВидыКонтактнойИнформации.Ссылка,
	|ВЫБОР
	|	КОГДА ВидыКонтактнойИнформации.ИмяПредопределенногоВида <> """"
	|	ТОГДА ВидыКонтактнойИнформации.ИмяПредопределенногоВида
	|	ИНАЧЕ ВидыКонтактнойИнформации.ИмяПредопределенныхДанных
	|КОНЕЦ КАК ИмяПредопределенногоВида
	|ИЗ
	|	Справочник.ВидыКонтактнойИнформации КАК ВидыКонтактнойИнформации
	|ГДЕ
	|	ВидыКонтактнойИнформации.ЭтоГруппа = ИСТИНА";
	
	РезультатЗапроса = Запрос.Выполнить();
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		Если СтрНачинаетсяС(ВыборкаДетальныеЗаписи.ИмяПредопределенногоВида, "Справочник") Тогда
			ИмяОбъекта = Сред(ВыборкаДетальныеЗаписи.ИмяПредопределенногоВида, СтрДлина("Справочник") + 1);
			Если Метаданные.Справочники.Найти(ИмяОбъекта) <> Неопределено Тогда 
				КонтактнаяИнформация = Метаданные.Справочники[ИмяОбъекта].ТабличныеЧасти.КонтактнаяИнформация;
				Если КонтактнаяИнформация.Реквизиты.Найти("ВидДляСписка") <> Неопределено Тогда
					ОбъектыМетаданных.Добавить(Справочники[ИмяОбъекта].ПустаяСсылка());
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли СтрНачинаетсяС(ВыборкаДетальныеЗаписи.ИмяПредопределенногоВида, "Документ") Тогда
			ИмяОбъекта = Сред(ВыборкаДетальныеЗаписи.ИмяПредопределенногоВида, СтрДлина("Документ") + 1);
			Если Метаданные.Документы.Найти(ИмяОбъекта) <> Неопределено Тогда
				КонтактнаяИнформация = Метаданные.Документы[ИмяОбъекта].ТабличныеЧасти.КонтактнаяИнформация;
				Если КонтактнаяИнформация.Реквизиты.Найти("ВидДляСписка") <> Неопределено Тогда
					ОбъектыМетаданных.Добавить(Документы[ИмяОбъекта].ПустаяСсылка());
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Разделитель = "";
	ТекстЗапроса = "";
	Для каждого Объект Из ОбъектыМетаданных Цикл
		ТекстЗапроса = ТекстЗапроса + Разделитель + " ВЫБРАТЬ
		|	КонтактнаяИнформация.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник." + Объект.Метаданные().Имя + ".КонтактнаяИнформация КАК КонтактнаяИнформация
		|ГДЕ
		|	КонтактнаяИнформация.Вид <> ЗНАЧЕНИЕ(Справочник.ВидыКонтактнойИнформации.ПустаяСсылка)
		|
		|СГРУППИРОВАТЬ ПО
		|	КонтактнаяИнформация.Ссылка
		|
		|ИМЕЮЩИЕ
		|	КОЛИЧЕСТВО(КонтактнаяИнформация.Вид) > 0 ";
		Разделитель = " ОБЪЕДИНИТЬ ВСЕ ";
	КонецЦикла;
	
	Запрос = Новый Запрос(ТекстЗапроса);
	РезультатЗапроса = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");

	Возврат РезультатЗапроса;

КонецФункции

// Проверяет корректность параметров вида контактной информации.
//
// Параметры:
//  ВидКонтактнойИнформации - СправочникСсылка.ВидыКонтактнойИнформации - Проверяемый вид контактной информации.
//
// Возвращаемое значение:
//  Структура - Результат проверки вида контактной информации.
//   * ЕстьОшибки    - Булево - признак наличия ошибок в виде контактной информации.
//   * ТекстОшибки   - Строка - информация об ошибке.
Функция ПроверитьПараметрыВидаКонтактнойИнформации(ВидКонтактнойИнформации) Экспорт
	
	Результат = Новый Структура("ЕстьОшибки, ТекстОшибки", Ложь, "");
	
	Если НЕ ЗначениеЗаполнено(ВидКонтактнойИнформации.Тип) Тогда
		Результат.ЕстьОшибки = Истина;
		Результат.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Не заполнено обязательное поле Тип у вида контактной информации ""%1"".'"),
			Строка(ВидКонтактнойИнформации.Наименование));
		Возврат Результат;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ВидКонтактнойИнформации.Наименование) Тогда
		Результат.ЕстьОшибки = Истина;
		Результат.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Не заполнено обязательное поле Наименование у вида контактной информации ""%1"".'"),
			Строка(ВидКонтактнойИнформации.ИмяПредопределенногоВида));
		Возврат Результат;
	КонецЕсли;
	
	Разделитель = "";
	Если ВидКонтактнойИнформации.Тип = Перечисления.ТипыКонтактнойИнформации.Адрес Тогда
		
		Если НЕ ВидКонтактнойИнформации.ТолькоНациональныйАдрес
			И (ВидКонтактнойИнформации.ПроверятьКорректность
			ИЛИ ВидКонтактнойИнформации.СкрыватьНеактуальныеАдреса) Тогда
				Результат.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Некорректно заполнены настройки проверки адреса у вида контактной информации %1.
					| Проверка корректности адреса доступна только для российских адресов'"), Строка(ВидКонтактнойИнформации.Наименование));
					Разделитель = Символы.ПС;
			КонецЕсли;
			
		Если ВидКонтактнойИнформации.РазрешитьВводНесколькихЗначений
			И ВидКонтактнойИнформации.ХранитьИсториюИзменений Тогда
				Результат.ТекстОшибки = Результат.ТекстОшибки + Разделитель + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Некорректно заполнены настройки адреса у вида контактной информации %1.
					| Не допускается возможность ввода нескольких значений контактной информации при включенной истории хранения изменений.'"),
						Строка(ВидКонтактнойИнформации.Наименование));
		КонецЕсли;
	КонецЕсли;
	
	Результат.ЕстьОшибки = ЗначениеЗаполнено(Результат.ТекстОшибки);
	Возврат Результат;
	
КонецФункции

Функция НомерТелефонаВСтарыйСписокПолей(XDTOТелефон) Экспорт
	Результат = Новый СписокЗначений;
	
	Результат.Добавить(XDTOТелефон.КодСтраны,  "КодСтраны");
	Результат.Добавить(XDTOТелефон.КодГорода,  "КодГорода");
	Результат.Добавить(XDTOТелефон.Номер,      "НомерТелефона");
	Результат.Добавить(XDTOТелефон.Добавочный, "Добавочный");
	
	Возврат Результат;
КонецФункции

// Возвращает флаг возможности добавления и изменения элементов.
//
Функция ЕстьПравоДобавления() Экспорт
	Возврат ПравоДоступа("Добавление", Метаданные.Справочники.СтраныМира);
КонецФункции

#КонецОбласти

// Для обратной совместимости.

#Область СлужебныеПроцедурыИФункцииДляСовместимости

// Преобразует XML в объект XDTO контактной информации.
//
//  Параметры:
//      Текст            - Строка - строка XML контактной информации.
//      ОжидаемыйВид     - СправочникСсылка.ВидыКонтактнойИнформации, ПеречислениеСсылка.ТипыКонтактнойИнформации, Структура
//      РезультатПреобразования - Структура - если задана, то в свойства записываются сведения:
//        * ТекстОшибки - Строка - описание ошибок чтения. При этом возвращаемое значение функции будет 
//                                 корректного типа, но не заполнен.
//
// Возвращаемое значение:
//      ОбъектXDTO - контактная информация, соответствующая XDTO-пакету КонтактнаяИнформация.
//   
Функция КонтактнаяИнформацияИзXML(Знач Текст, Знач ОжидаемыйВид = Неопределено, РезультатПреобразования = Неопределено, Знач Представление = "") Экспорт
	
	ОжидаемыйТип = УправлениеКонтактнойИнформациейСлужебныйПовтИсп.ТипВидаКонтактнойИнформации(ОжидаемыйВид);
	
	Если РезультатПреобразования = Неопределено Или ТипЗнч(РезультатПреобразования) <> Тип("Структура") Тогда
		РезультатПреобразования = Новый Структура;
	КонецЕсли;
	РезультатПреобразования.Вставить("СведенияИсправлены", Ложь);
	
	ПеречислениеАдрес                 = Перечисления.ТипыКонтактнойИнформации.Адрес;
	ПеречислениеАдресЭлектроннойПочты = Перечисления.ТипыКонтактнойИнформации.АдресЭлектроннойПочты;
	ПеречислениеSkype                 = Перечисления.ТипыКонтактнойИнформации.Skype;
	ПеречислениеВебСтраница           = Перечисления.ТипыКонтактнойИнформации.ВебСтраница;
	ПеречислениеТелефон               = Перечисления.ТипыКонтактнойИнформации.Телефон;
	ПеречислениеФакс                  = Перечисления.ТипыКонтактнойИнформации.Факс;
	ПеречислениеДругое                = Перечисления.ТипыКонтактнойИнформации.Другое;
	
	ПространствоИмен = ПространствоИмен();
	
	Если УправлениеКонтактнойИнформациейКлиентСервер.ЭтоКонтактнаяИнформацияВXML(Текст) Тогда
		ЧтениеXML = Новый ЧтениеXML;
		
		Если Метаданные.ОбщиеМодули.Найти("РаботаСАдресами") <> Неопределено Тогда
			МодульРаботаСАдресами = ОбщегоНазначения.ОбщийМодуль("РаботаСАдресами");
			Текст = МодульРаботаСАдресами.ПередЧтениемXDTOКонтактнаяИнформация(Текст);
		КонецЕсли;
		
		ЧтениеXML.УстановитьСтроку(Текст);
		
		ТекстОшибки = Неопределено;
		
		НеобходимоВосстановитьКонтактнуюИнформацию = Ложь;
		
		Попытка
			
			Результат = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML, ФабрикаXDTO.Тип(ПространствоИмен, "КонтактнаяИнформация"));
			
			Если ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Адрес И КонтактнаяИнформацияXDTOПустая(Результат) Тогда
				НеобходимоВосстановитьКонтактнуюИнформацию = Истина;
			ИначеЕсли ПустаяСтрока(Результат.Представление) Тогда
				Результат.Представление = УправлениеКонтактнойИнформацией.ПредставлениеКонтактнойИнформации(Результат, ОжидаемыйВид);
			КонецЕсли;
			
		Исключение
			
			НеобходимоВосстановитьКонтактнуюИнформацию = Истина;
			
		КонецПопытки;
		
		Если НеобходимоВосстановитьКонтактнуюИнформацию Тогда
			ОписаниеПричиныОшибки = НСтр("ru='Сведения контактной информации были восстановлены после сбоя.'");
			Если ЗначениеЗаполнено(Представление) Тогда
				Результат = КонтактнаяИнформацияXDTOПоПредставлению(Представление, ОжидаемыйВид);
				Если СтрСравнить(Результат.Представление, Представление) <> 0  Тогда
					ТекстОшибки = ОписаниеПричиныОшибки;
					РезультатПреобразования.Вставить("ТекстОшибки", ТекстОшибки);
				КонецЕсли;
				
			КонецЕсли;
			
			// Некорректный формат XML
			ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрации(),
				УровеньЖурналаРегистрации.Предупреждение, , Текст, ОписаниеПричиныОшибки + Символы.ПС
					+ ИнформацияОбОшибке().Описание);
				
			РезультатПреобразования.Вставить("СведенияИсправлены", Истина);
		КонецЕсли;
		
		Если ТекстОшибки = Неопределено И ОжидаемыйТип <> Неопределено Тогда
			
			Если Результат = Неопределено Тогда
				ТекстОшибки = СтрЗаменить(НСтр("ru='Сведения контактной информации %ОжидаемыйВид% были повреждены или некорректно заполнены.'"),
					"%ОжидаемыйВид%", Строка(ОжидаемыйВид));
			Иначе
				// Контролируем соответствие типов.
				НайденТип = ?(Результат.Состав = Неопределено, Неопределено, Результат.Состав.Тип());
				
				ШаблонСообщения = СтрЗаменить(НСтр("ru='Сведения %1 контактной информации %ОжидаемыйВид% были повреждены или некорректно заполнены.'"),
					"%ОжидаемыйВид%", Строка(ОжидаемыйВид));
				Если ОжидаемыйТип = ПеречислениеАдрес И НайденТип <> ФабрикаXDTO.Тип(ПространствоИмен, "Адрес") Тогда
					ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, НСтр("ru='об адресе'"));
				ИначеЕсли ОжидаемыйТип = ПеречислениеАдресЭлектроннойПочты И НайденТип <> ФабрикаXDTO.Тип(ПространствоИмен, "ЭлектроннаяПочта") Тогда
					ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, НСтр("ru='электронной почты'"));
				ИначеЕсли ОжидаемыйТип = ПеречислениеВебСтраница И НайденТип <> ФабрикаXDTO.Тип(ПространствоИмен, "ВебСайт") Тогда
					ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, НСтр("ru='веб-страницы'"));
				ИначеЕсли ОжидаемыйТип = ПеречислениеТелефон И НайденТип <> ФабрикаXDTO.Тип(ПространствоИмен, "НомерТелефона") Тогда
					ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, НСтр("ru='о номере телефона'"));
				ИначеЕсли ОжидаемыйТип = ПеречислениеФакс И НайденТип <> ФабрикаXDTO.Тип(ПространствоИмен, "НомерФакса") Тогда
					ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, НСтр("ru='о номере факса'"));
				ИначеЕсли ОжидаемыйТип = ПеречислениеSkype И НайденТип <> ФабрикаXDTO.Тип(ПространствоИмен, "Skype") Тогда
					ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, НСтр("ru='о логине Skype'"));
				ИначеЕсли ОжидаемыйТип = ПеречислениеДругое И НайденТип <> ФабрикаXDTO.Тип(ПространствоИмен, "Прочее") Тогда
					ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, НСтр("ru='о дополнительной'"));
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		Если ТекстОшибки = Неопределено Тогда
			// Успешно прочитано
			Возврат Результат;
		КонецЕсли;
		
		РезультатПреобразования.Вставить("ТекстОшибки", ТекстОшибки);
		
		// Будет возвращен пустой объект.
		Текст = "";
	КонецЕсли;
	
	Если ТипЗнч(Текст) = Тип("СписокЗначений") Тогда
		Представление = "";
		ЭтоНовый = Текст.Количество() = 0;
	ИначеЕсли ПустаяСтрока(Представление) Тогда
		Представление = Строка(Текст);
		ЭтоНовый = ПустаяСтрока(Текст);
	Иначе
		ЭтоНовый = Ложь;
	КонецЕсли;
	
	Результат = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "КонтактнаяИнформация"));
	
	// Разбор
	Если ОжидаемыйТип = ПеречислениеАдрес Тогда
		Если ЭтоНовый Тогда
			Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "Адрес"));
		Иначе
			Результат = АдресXMLВXDTO(Текст, Представление, ОжидаемыйТип);
		КонецЕсли;
		
	ИначеЕсли ОжидаемыйТип = ПеречислениеТелефон Тогда
		Если ЭтоНовый Тогда
			Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "НомерТелефона"));
		Иначе
			Результат = ДесериализацияТелефона(Текст, Представление, ОжидаемыйТип)
		КонецЕсли;
		
	ИначеЕсли ОжидаемыйТип = ПеречислениеФакс Тогда
		Если ЭтоНовый Тогда
			Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "НомерФакса"));
		Иначе
			Результат = ДесериализацияФакса(Текст, Представление, ОжидаемыйТип)
		КонецЕсли;
		
	ИначеЕсли ОжидаемыйТип = ПеречислениеАдресЭлектроннойПочты Тогда
		Если ЭтоНовый Тогда
			Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "ЭлектроннаяПочта"));
		Иначе
			Результат = ДесериализацияПрочейКонтактнойИнформации(Текст, Представление, ОжидаемыйТип)
		КонецЕсли;
	ИначеЕсли ОжидаемыйТип = ПеречислениеSkype Тогда
		Если ЭтоНовый Тогда
			Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "Skype"));
		Иначе
			Результат = ДесериализацияПрочейКонтактнойИнформации(Текст, Представление, ОжидаемыйТип)
		КонецЕсли;
	ИначеЕсли ОжидаемыйТип = ПеречислениеВебСтраница Тогда
		Если ЭтоНовый Тогда
			Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "ВебСайт"));
		Иначе
			Результат = ДесериализацияПрочейКонтактнойИнформации(Текст, Представление, ОжидаемыйТип)
		КонецЕсли;
		
	ИначеЕсли ОжидаемыйТип = ПеречислениеДругое Тогда
		Если ЭтоНовый Тогда
			Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "Прочее"));
		Иначе
			Результат = ДесериализацияПрочейКонтактнойИнформации(Текст, Представление, ОжидаемыйТип)
		КонецЕсли;
		
	Иначе
		ТекстОшибки = НСтр("ru = 'Сведения о виде контактной информации %1 были повреждены или некорректно заполнены,
								|т.к. обязательное поле тип не заполнено.'");
		ТекстОшибки =  СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстОшибки, ?(ЗначениеЗаполнено(ОжидаемыйВид), """" + ОжидаемыйВид.Наименование + """", ""));
		РезультатПреобразования.Вставить("ТекстОшибки", ТекстОшибки);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция КонтактнаяИнформацияXDTOПустая(Знач Результат)
	
	Состав = Результат.Свойства().Получить("Состав");
	Если Состав <> Неопределено Тогда
		Сведения = Результат.Состав.Свойства().Получить("Состав");
		Если Сведения <> Неопределено Тогда
			Если ТипЗнч(Результат.Состав.Состав) = Тип("Строка") Тогда
				Возврат ПустаяСтрока(Результат.Состав.Состав);
			ИначеЕсли ТипЗнч(Результат.Состав.Состав) = Тип("ОбъектXDTO") Тогда
				Для каждого ПолеXDTO Из Результат.Состав.Состав.Свойства() Цикл
					Если ПолеXDTO.Имя = "ДопАдрЭл" Или ПолеXDTO.Имя = "СвРайМО" Тогда
						Продолжить;
					ИначеЕсли ЗначениеЗаполнено(Результат.Состав.Состав.Получить(ПолеXDTO.Имя)) Тогда
						Возврат Ложь;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		Иначе
			ПолеЗначение = Результат.Состав.Свойства().Получить("Значение");
			Если ПолеЗначение <> Неопределено Тогда
				Возврат ПустаяСтрока(Результат.Состав.Получить("Значение"));
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Возвращает флаг того, что переданных объект КИ содержит данные.
//
// Параметры:
//      КонтактнаяИнформация - Структура - проверяемые данные контактной информации.
//
// Возвращаемое значение:
//     Булево - флаг наличия данных.
//
Функция КонтактнаяИнформацияЗаполнена(Знач  КонтактнаяИнформация) Экспорт
	
	Возврат ЕстьЗаполненныеСвойстваКонтактнойИнформации(КонтактнаяИнформация);
	
КонецФункции

Функция ЕстьЗаполненныеСвойстваКонтактнойИнформации(Знач Владелец)
	
	Если Владелец = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Не Владелец.Свойство("Value") Или Не Владелец.Свойство("Type") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ПустаяСтрока(Владелец.value) Или ПустаяСтрока(Владелец.type) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ЭтоТипАдрес(Владелец.Type) Тогда
		СписокПолейДляПроверки = Новый Массив();
		СписокПолейДляПроверки.Добавить("Country");
	
		Если Метаданные.ОбщиеМодули.Найти("РаботаСАдресамиКлиентСервер") <> Неопределено Тогда
			
			МодульРаботаСАдресамиКлиентСервер = ОбщегоНазначения.ОбщийМодуль("РаботаСАдресамиКлиентСервер");
			ОбщегоНазначенияКлиентСервер.ДополнитьМассив(СписокПолейДляПроверки, МодульРаботаСАдресамиКлиентСервер.ИменаУровнейАдреса(Владелец, Истина));
			
		КонецЕсли;
		
		Для каждого ИмяПоля Из СписокПолейДляПроверки Цикл
			Если Владелец.Свойство(ИмяПоля) И ЗначениеЗаполнено(Владелец[ИмяПоля]) Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Процедура ЗаменитьВСтруктуреНеопределеноНаПустуюСтроку(СтруктураДляОбхода) Экспорт
	
	Для каждого КлючЗначение Из СтруктураДляОбхода Цикл
		Если ТипЗнч(КлючЗначение.Значение) = Тип("Структура")Тогда
			ЗаменитьВСтруктуреНеопределеноНаПустуюСтроку(СтруктураДляОбхода[КлючЗначение.Ключ]);
		ИначеЕсли КлючЗначение.Значение = Неопределено Тогда
			СтруктураДляОбхода[КлючЗначение.Ключ] = "";
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

Функция ДесериализацияТелефонаФакса(ЗначенияПолей, Представление = "", ОжидаемыйТип = Неопределено)
	
	Если УправлениеКонтактнойИнформациейКлиентСервер.ЭтоКонтактнаяИнформацияВXML(ЗначенияПолей) Тогда
		// Общий формат контактной информации.
		Возврат КонтактнаяИнформацияИзXML(ЗначенияПолей, ОжидаемыйТип);
	КонецЕсли;
	
	ПространствоИмен = ПространствоИмен();
	
	Если ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Телефон Тогда
		Данные = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "НомерТелефона"));
		
	ИначеЕсли ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Факс Тогда
		Данные = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "НомерФакса"));
		
	ИначеЕсли ОжидаемыйТип = Неопределено Тогда
		// Считаем телефоном
		Данные = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "НомерТелефона"));
		
	Иначе
		ВызватьИсключение НСтр("ru='Ошибка десериализации контактной информации, ожидается телефон или факс'");
	КонецЕсли;
	
	Результат = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "КонтактнаяИнформация"));
	Результат.Состав        = Данные;
	
	// Из пар ключ-значение
	СписокЗначенийПолей = Неопределено;
	Если ТипЗнч(ЗначенияПолей)=Тип("СписокЗначений") Тогда
		СписокЗначенийПолей = ЗначенияПолей;
	ИначеЕсли Не ПустаяСтрока(ЗначенияПолей) Тогда
		СписокЗначенийПолей = ПреобразоватьСтрокуВСписокПолей(ЗначенияПолей);
	КонецЕсли;
	
	ПолеПредставления = "";
	Если СписокЗначенийПолей <> Неопределено Тогда
		Для Каждого ЗначениеПоля Из СписокЗначенийПолей Цикл
			Поле = ВРег(ЗначениеПоля.Представление);
			
			Если Поле = "КОДСТРАНЫ" Тогда
				Данные.КодСтраны = ЗначениеПоля.Значение;
				
			ИначеЕсли Поле = "КОДГОРОДА" Тогда
				Данные.КодГорода = ЗначениеПоля.Значение;
				
			ИначеЕсли Поле = "НОМЕРТЕЛЕФОНА" Тогда
				Данные.Номер = ЗначениеПоля.Значение;
				
			ИначеЕсли Поле = "ДОБАВОЧНЫЙ" Тогда
				Данные.Добавочный = ЗначениеПоля.Значение;
				
			ИначеЕсли Поле = "ПРЕДСТАВЛЕНИЕ" Тогда
				ПолеПредставления = СокрЛП(ЗначениеПоля.Значение);
				
			КонецЕсли;
			
		КонецЦикла;
		
		// Представление с приоритетами.
		Если Не ПустаяСтрока(Представление) Тогда
			Результат.Представление = Представление;
		ИначеЕсли ЗначениеЗаполнено(ПолеПредставления) Тогда
			Результат.Представление = ПолеПредставления;
		Иначе
			Результат.Представление = ПредставлениеТелефона(Данные);
		КонецЕсли;
		
		Возврат Результат;
	КонецЕсли;
	
	// Разбираем из представления.
	
	// Группы цифр, разделенные символами - не цифрами: страна, город, номер, добавочный. 
	// Добавочный включает в себя непробельные символы слева и справа.
	Позиция = 1;
	Данные.КодСтраны  = НайтиПодстрокуЦифр(Представление, Позиция);
	НачалоГорода = Позиция;
	
	Данные.КодГорода  = НайтиПодстрокуЦифр(Представление, Позиция);
	Данные.Номер      = НайтиПодстрокуЦифр(Представление, Позиция, " -");
	
	Добавочный = СокрЛП(Сред(Представление, Позиция));
	Если СтрНачинаетсяС(Добавочный, ",") Тогда
		Добавочный = СокрЛ(Сред(Добавочный, 2));
	КонецЕсли;
	Если ВРег(Лев(Добавочный, СтрДлина("ДОБ")))= "ДОБ" Тогда
		Добавочный = СокрЛ(Сред(Добавочный, СтрДлина("ДОБ") + 1));
	КонецЕсли;
	Если ВРег(Лев(Добавочный, 1 ))= "." Тогда
		Добавочный = СокрЛ(Сред(Добавочный, 2));
	КонецЕсли;
	Данные.Добавочный = СокрЛП(Добавочный);
	
	// Корректируем возможные ошибки.
	Если ПустаяСтрока(Данные.Номер) Тогда
		Если СтрНачинаетсяС(СокрЛ(Представление), "+") Тогда
			// Была попытка явно указать код страны, оставляем страну в покое.
			Данные.КодГорода  = "";
			Данные.Номер      = СократитьНеЦифры(Сред(Представление, НачалоГорода));
			Данные.Добавочный = "";
		Иначе
			Данные.КодСтраны  = "";
			Данные.КодГорода  = "";
			Данные.Номер      = Представление;
			Данные.Добавочный = "";
		КонецЕсли;
	КонецЕсли;
	
	Результат.Представление = Представление;
	Возврат Результат;
КонецФункции

// Возвращает список значений. Преобразует строку полей в список значений.
//
// Параметры:
//    СтрокаПолей - Строка - строка полей.
//
// Возвращаемое значение:
//    СписокЗначений - список значений полей.
//
Функция ПреобразоватьСтрокуВСписокПолей(СтрокаПолей) Экспорт
	
	// XML сериализацию преобразовывать не надо.
	Если УправлениеКонтактнойИнформациейКлиентСервер.ЭтоКонтактнаяИнформацияВXML(СтрокаПолей) Тогда
		Возврат СтрокаПолей;
	КонецЕсли;
	
	Результат = Новый СписокЗначений;
	
	СтруктураЗначенийПолей = СтруктураЗначенийПолей(СтрокаПолей);
	Для каждого ЗначениеПоля Из СтруктураЗначенийПолей Цикл
		Результат.Добавить(ЗначениеПоля.Значение, ЗначениеПоля.Ключ);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

//  Преобразует строку полей вида ключ = значение в структуру.
//
//  Параметры:
//      СтрокаПолей             - Строка - строка полей с данными в виде ключ = значение.
//      ВидКонтактнойИнформации - СправочникСсылка.ВидыКонтактнойИнформации - для определения состава незаполненных
//                                                                            полей.
//
//  Возвращаемое значение:
//      Структура - значения полей.
//
Функция СтруктураЗначенийПолей(СтрокаПолей, ВидКонтактнойИнформации = Неопределено) Экспорт
	
	Если ВидКонтактнойИнформации = ПредопределенноеЗначение("Перечисление.ТипыКонтактнойИнформации.Адрес") Тогда
		Результат = УправлениеКонтактнойИнформациейКлиентСервер.СтруктураПолейАдреса();
	ИначеЕсли ВидКонтактнойИнформации = ПредопределенноеЗначение("Перечисление.ТипыКонтактнойИнформации.Телефон") Тогда
		Результат = УправлениеКонтактнойИнформациейКлиентСервер.СтруктураПолейТелефона();
	Иначе
		Результат = Новый Структура;
	КонецЕсли;
	
	ПоследнийЭлемент = Неопределено;
	
	Для Итерация = 1 По СтрЧислоСтрок(СтрокаПолей) Цикл
		ПолученнаяСтрока = СтрПолучитьСтроку(СтрокаПолей, Итерация);
		Если СтрНачинаетсяС(ПолученнаяСтрока, Символы.Таб) Тогда
			Если Результат.Количество() > 0 Тогда
				Результат.Вставить(ПоследнийЭлемент, Результат[ПоследнийЭлемент] + Символы.ПС + Сред(ПолученнаяСтрока, 2));
			КонецЕсли;
		Иначе
			ПозицияСимвола = СтрНайти(ПолученнаяСтрока, "=");
			Если ПозицияСимвола <> 0 Тогда
				НазваниеПоля = Лев(ПолученнаяСтрока, ПозицияСимвола - 1);
				ЗначениеПоля = Сред(ПолученнаяСтрока, ПозицияСимвола + 1);
				Если НазваниеПоля = "Регион" Или НазваниеПоля = "Район" Или НазваниеПоля = "Город" 
					Или НазваниеПоля = "НаселенныйПункт" Или НазваниеПоля = "Улица" Тогда
					Если СтрНайти(СтрокаПолей, НазваниеПоля + "Сокращение") = 0 Тогда
						Результат.Вставить(НазваниеПоля + "Сокращение", АдресноеСокращение(ЗначениеПоля));
					КонецЕсли;
				КонецЕсли;
				Результат.Вставить(НазваниеПоля, ЗначениеПоля);
				ПоследнийЭлемент = НазваниеПоля;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Получает сокращение географического названия объекта.
//
// Параметры:
//    ГеографическоеНазвание - Строка - географическое название объекта.
//
// Возвращаемое значение:
//     Строка - пустая строка или последнее слово в географическом названии.
//
Функция АдресноеСокращение(Знач ГеографическоеНазвание)
	
	Сокращение = "";
	МассивСлов = СтрРазделить(ГеографическоеНазвание, " ", Ложь);
	Если МассивСлов.Количество() > 1 Тогда
		Сокращение = МассивСлов[МассивСлов.Количество() - 1];
	КонецЕсли;
	
	Возврат Сокращение;
	
КонецФункции

Функция ДесериализацияТелефонаФаксаВJSON(ЗначенияПолей, Представление = "", ОжидаемыйТип = Неопределено)
	
	Если УправлениеКонтактнойИнформациейКлиентСервер.ЭтоКонтактнаяИнформацияВXML(ЗначенияПолей) Тогда
		// Общий формат контактной информации.
		Возврат КонтактнаяИнформацияИзXML(ЗначенияПолей, ОжидаемыйТип);
	КонецЕсли;
	
	Данные = УправлениеКонтактнойИнформациейКлиентСервер.ОписаниеНовойКонтактнойИнформации(ОжидаемыйТип);
	
	// Из пар ключ-значение
	СписокЗначенийПолей = Неопределено;
	Если ТипЗнч(ЗначенияПолей)=Тип("СписокЗначений") Тогда
		СписокЗначенийПолей = ЗначенияПолей;
	ИначеЕсли Не ПустаяСтрока(ЗначенияПолей) Тогда
		СписокЗначенийПолей = ПреобразоватьСтрокуВСписокПолей(ЗначенияПолей);
	КонецЕсли;
	
	ПолеПредставления = "";
	Если СписокЗначенийПолей <> Неопределено Тогда
		Для Каждого ЗначениеПоля Из СписокЗначенийПолей Цикл
			Поле = ВРег(ЗначениеПоля.Представление);
			
			Если Поле = "КОДСТРАНЫ" Тогда
				Данные.CountryCode = ЗначениеПоля.Значение;
				
			ИначеЕсли Поле = "КОДГОРОДА" Тогда
				Данные.AreaCode = ЗначениеПоля.Значение;
				
			ИначеЕсли Поле = "НОМЕРТЕЛЕФОНА" Тогда
				Данные.Number = ЗначениеПоля.Значение;
				
			ИначеЕсли Поле = "ДОБАВОЧНЫЙ" Тогда
				Данные.ExtNumber = ЗначениеПоля.Значение;
				
			ИначеЕсли Поле = "ПРЕДСТАВЛЕНИЕ" Тогда
				ПолеПредставления = СокрЛП(ЗначениеПоля.Значение);
				
			КонецЕсли;
			
		КонецЦикла;
		
		// Представление с приоритетами.
		Если Не ПустаяСтрока(Представление) Тогда
			Данные.Value = Представление;
		ИначеЕсли ЗначениеЗаполнено(ПолеПредставления) Тогда
			Данные.Value = ПолеПредставления;
		Иначе
			Данные.Value = ПредставлениеТелефона(Данные);
		КонецЕсли;
		
		Возврат Данные;
	КонецЕсли;
	
	// Разбираем из представления.
	
	// Группы цифр, разделенные символами - не цифрами: страна, город, номер, добавочный. 
	// Добавочный включает в себя непробельные символы слева и справа.
	Позиция = 1;
	Данные.CountryCode  = НайтиПодстрокуЦифр(Представление, Позиция);
	НачалоГорода = Позиция;
	
	Данные.AreaCode  = НайтиПодстрокуЦифр(Представление, Позиция);
	Данные.Number    = НайтиПодстрокуЦифр(Представление, Позиция, " -");
	
	Добавочный = СокрЛП(Сред(Представление, Позиция));
	Если СтрНачинаетсяС(Добавочный, ",") Тогда
		Добавочный = СокрЛ(Сред(Добавочный, 2));
	КонецЕсли;
	Если ВРег(Лев(Добавочный, 3 ))= "ДОБ" Тогда
		Добавочный = СокрЛ(Сред(Добавочный, 4));
	КонецЕсли;
	Если ВРег(Лев(Добавочный, 1 ))= "." Тогда
		Добавочный = СокрЛ(Сред(Добавочный, 2));
	КонецЕсли;
	Данные.ExtNumber = СокрЛП(Добавочный);
	
	// Корректируем возможные ошибки.
	Если ПустаяСтрока(Данные.Number) Тогда
		Если СтрНачинаетсяС(СокрЛ(Представление), "+") Тогда
			// Была попытка явно указать код страны, оставляем страну в покое.
			Данные.AreaCode  = "";
			Данные.Number      = СократитьНеЦифры(Сред(Представление, НачалоГорода));
			Данные.ExtNumber = "";
		Иначе
			Данные.CountryCode  = "";
			Данные.AreaCode  = "";
			Данные.Number      = Представление;
			Данные.ExtNumber = "";
		КонецЕсли;
	КонецЕсли;
	
	Данные.Value = Представление;
	Возврат Данные;
КонецФункции

// Возвращает первую подстроку из цифр в строке. Параметр ПозицияНачала изменяется на первую не цифру.
//
Функция НайтиПодстрокуЦифр(Текст, ПозицияНачала = Неопределено, ДопустимоКромеЦифр = "")
	
	Если ПозицияНачала = Неопределено Тогда
		ПозицияНачала = 1;
	КонецЕсли;
	
	Результат = "";
	ПозицияКонца = СтрДлина(Текст);
	ПоискНачала  = Истина;
	
	Пока ПозицияНачала <= ПозицияКонца Цикл
		Символ = Сред(Текст, ПозицияНачала, 1);
		ЭтоЦифра = Символ >= "0" И Символ <= "9";
		
		Если ПоискНачала Тогда
			Если ЭтоЦифра Тогда
				Результат = Результат + Символ;
				ПоискНачала = Ложь;
			КонецЕсли;
		Иначе
			Если ЭтоЦифра Или СтрНайти(ДопустимоКромеЦифр, Символ) > 0 Тогда
				Результат = Результат + Символ;    
			Иначе
				Прервать;
			КонецЕсли;
		КонецЕсли;
		
		ПозицияНачала = ПозицияНачала + 1;
	КонецЦикла;
	
	// Убираем возможные висящие разделители справа.
	Возврат СократитьНеЦифры(Результат, ДопустимоКромеЦифр, Ложь);
	
КонецФункции

Функция СократитьНеЦифры(Текст, ДопустимоКромеЦифр = "", Направление = Истина)
	
	Длина = СтрДлина(Текст);
	Если Направление Тогда
		// Сокращение слева
		Индекс = 1;
		Конец  = 1 + Длина;
		Шаг    = 1;
	Иначе
		// Сокращение справа    
		Индекс = Длина;
		Конец  = 0;
		Шаг    = -1;
	КонецЕсли;
	
	Пока Индекс <> Конец Цикл
		Символ = Сред(Текст, Индекс, 1);
		ЭтоЦифра = (Символ >= "0" И Символ <= "9") Или СтрНайти(ДопустимоКромеЦифр, Символ) = 0;
		Если ЭтоЦифра Тогда
			Прервать;
		КонецЕсли;
		Индекс = Индекс + Шаг;
	КонецЦикла;
	
	Если Направление Тогда
		// Сокращение слева
		Возврат Прав(Текст, Длина - Индекс + 1);
	КонецЕсли;
	
	// Сокращение справа
	Возврат Лев(Текст, Индекс);
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункцииПоРаботеСXML

// Возвращает соответствующее значение перечисления "ТипыКонтактнойИнформации" по строке XML.
//
// Параметры:
//    XMLСтрока - Строка, описывающая контактную информацию.
//
// Возвращаемое значение:
//     ПеречислениеСсылка.ТипыКонтактнойИнформации - результат.
//
Функция ТипКонтактнойИнформации(Знач XMLСтрока) Экспорт
	Возврат ЗначениеИзСтрокиXML(XSLT_ТипКонтактнойИнформацииПоСтрокеXML(XMLСтрока));
КонецФункции

// Читает строку состава из значения контактной информации.
// Если значение состава сложного типа, то возвращает неопределено.
//
// Параметры:
//    Текст  Строка - XML строка контактной информации. Может быть модифицирован.
//
// Возвращаемое значение:
//    Строка       - XML значение состава.
//    Неопределено - Свойство "Состав" не найдено.
//
Функция СтрокаСоставаКонтактнойИнформации(Знач Текст, Знач НовоеЗначение = Неопределено) Экспорт
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(Текст);
	ОбъектXDTO= ФабрикаXDTO.ПрочитатьXML(Чтение, 
		ФабрикаXDTO.Тип(ПространствоИмен(), "КонтактнаяИнформация"));
	
	Состав = ОбъектXDTO.Состав;
	Если Состав <> Неопределено 
		И Состав.Свойства().Получить("Значение") <> Неопределено
		И ТипЗнч(Состав.Значение) = Тип("Строка") Тогда
		Возврат Состав.Значение;
	КонецЕсли;
	
	Возврат Неопределено;
КонецФункции

// Сравнивает два экземпляра контактной информации.
//
// Параметры:
//    Данные1 - ОбъектXTDO - объект с контактной информацией.
//            - Строка     - контактная информация в формате XML.
//            - Структура  - описание контактной информацию. Ожидаются поля:
//                 * ЗначенияПолей - Строка, Структура, СписокЗначений, Соответствие - поля контактной информации.
//                 * Представление - Строка - Представление. Используется в случае, если не удалось вычислить 
//                                            представление из ЗначенияПолей (отсутствие в них поля Представление).
//                 * Комментарий - Строка - комментарий. Используется в случае, если не удалось вычислить комментарий
//                                          из ЗначенияПолей.
//                 * ВидКонтактнойИнформации - СправочникСсылка.ВидыКонтактнойИнформации,
//                                             ПеречислениеСсылка.ТипыКонтактнойИнформации, Структура -
//                                             Используется в случае, если не удалось вычислить тип из ЗначенияПолей.
//    Данные2 - ОбъектXTDO, Строка, Структура - аналогично Данные1.
//
// Возвращаемое значение:
//     ТаблицаЗначений: - таблица отличающихся полей со следующими колонками:
//        * Путь      - Строка - XPath, идентифицирующий различающееся значение. Значение "ТипКонтактнойИнформации"
//                               означает, что переданные экземпляры контактной информации различаются типом.
//        * Описание  - Строка - описание отличающегося реквизита в терминах предметной области.
//        * Значение1 - Строка - значение, соответствующая объекту, переданному в параметре Данные1.
//        * Значение2 - Строка - значение, соответствующая объекту, переданному в параметре Данные2.
//
Функция РазличияКонтактнойИнформации(Знач Данные1, Знач Данные2) Экспорт
	ДанныеКИ1 = ПривестиКонтактнуюИнформациюXML(Данные1);
	ДанныеКИ2 = ПривестиКонтактнуюИнформациюXML(Данные2);
	
	ТипКонтактнойИнформации = ДанныеКИ1.ТипКонтактнойИнформации;
	Если ТипКонтактнойИнформации <> ДанныеКИ2.ТипКонтактнойИнформации Тогда
		// Различные типы, дальше не сравниваем.
		Результат = Новый ТаблицаЗначений;
		Колонки   = Результат.Колонки;
		СтрокаРезультата = Результат.Добавить();
		СтрокаРезультата[Колонки.Добавить("Путь").Имя]      = "ТипКонтактнойИнформации";
		СтрокаРезультата[Колонки.Добавить("Значение1").Имя] = ДанныеКИ1.ТипКонтактнойИнформации;
		СтрокаРезультата[Колонки.Добавить("Значение2").Имя] = ДанныеКИ2.ТипКонтактнойИнформации;
		СтрокаРезультата[Колонки.Добавить("Описание").Имя]  = НСтр("ru = 'Различные типы контактной информации'");
		Возврат Результат;
	КонецЕсли;
	
	ТекстРазличияXML = XSLT_ТаблицаЗначенийРазличияXML(ДанныеКИ1.ДанныеXML, ДанныеКИ2.ДанныеXML);
	
	// Отдаем интерпретацию в зависимости от типа.
	Возврат ЗначениеИзСтрокиXML( XSLT_ИнтерпретацияРазличияXMLКонтактнойИнформации(
			ТекстРазличияXML, ТипКонтактнойИнформации));
	
КонецФункции

// Преобразует контактную информацию в вид XML.
//
// Параметры:
//    Данные - Строка     - описание контактной информации XML или JSON.
//           - ОбъектXTDO - описание контактной информации.
//           - Структура  - описание контактной информации. Ожидаются поля:
//                 * ЗначенияПолей - Строка, Структура, СписокЗначений, Соответствие - поля контактной информации.
//                 * Представление - Строка - Представление. Используется в случае, если не удалось вычислить 
//                                            представление из ЗначенияПолей (отсутствие в них поля Представление).
//                 * Комментарий - Строка - комментарий. Используется в случае, если не удалось вычислить комментарий
//                                          из ЗначенияПолей.
//                 * ВидКонтактнойИнформации - СправочникСсылка.ВидыКонтактнойИнформации,
//                                             ПеречислениеСсылка.ТипыКонтактнойИнформации, Структура
//                                             Используется в случае, если не удалось вычислить тип из ЗначенияПолей.
//
// Возвращаемое значение:
//     Структура - содержит поля:
//        * ТипКонтактнойИнформации - Перечисление.ТипыКонтактнойИнформации
//        * ДанныеXML               - Строка - текст XML.
//
Функция ПривестиКонтактнуюИнформациюXML(Знач Данные) Экспорт
	
	XMLСтрока               = "";
	ЗначенияПолей           = "";
	Комментарий             = Неопределено;
	ТипКонтактнойИнформации = Неопределено;
	
	Если ТипЗнч(Данные) = Тип("ОбъектXDTO") Тогда
		XMLСтрока = КонтактнаяИнформацияXDTOВXML(Данные);
		ТипКонтактнойИнформации = ЗначениеИзСтрокиXML(XSLT_ТипКонтактнойИнформацииПоСтрокеXML(XMLСтрока));
	Иначе
		
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
			ЗначенияПолей = ?(Данные.Свойство("ЗначенияПолей"), Данные.ЗначенияПолей, "");;
			Комментарий = ?(Данные.Свойство("Комментарий"), Данные.Комментарий, "");
			
			Если Данные.Свойство("ВидКонтактнойИнформации") И Данные.ВидКонтактнойИнформации <> Неопределено Тогда
				ТипКонтактнойИнформации = УправлениеКонтактнойИнформациейСлужебныйПовтИсп.ТипВидаКонтактнойИнформации(Данные.ВидКонтактнойИнформации);
			КонецЕсли;
			
		ИначеЕсли ТипЗнч(Данные) = Тип("Строка") Тогда
			ЗначенияПолей = Данные;
		КонецЕсли;
		
		Если УправлениеКонтактнойИнформациейКлиентСервер.ЭтоКонтактнаяИнформацияВJSON(ЗначенияПолей) Тогда
			XMLСтрока = КонтактнаяИнформацияИзJSONВXML(ЗначенияПолей, ТипКонтактнойИнформации);
			ТипКонтактнойИнформации = ЗначениеИзСтрокиXML(XSLT_ТипКонтактнойИнформацииПоСтрокеXML(XMLСтрока));
		ИначеЕсли ЭтоСтрокаXML(ЗначенияПолей) Тогда
			XMLСтрока = ЗначенияПолей;
			ТипКонтактнойИнформации = ЗначениеИзСтрокиXML(XSLT_ТипКонтактнойИнформацииПоСтрокеXML(XMLСтрока));
		ИначеЕсли ТипЗнч(ЗначенияПолей) = Тип("Строка") И ТипКонтактнойИнформации = Неопределено Тогда
			
			// старый формат ключ-значение
			Если СтрНайти(ВРег(ЗначенияПолей), "РЕГИОН=") > 0 Тогда
				ТипКонтактнойИнформации = Перечисления.ТипыКонтактнойИнформации.Адрес;
			ИначеЕсли СтрНайти(ВРег(ЗначенияПолей), "НОМЕРТЕЛЕФОНА=") > 0 Тогда
				ТипКонтактнойИнформации = Перечисления.ТипыКонтактнойИнформации.Телефон;
			ИначеЕсли СтрНайти(ВРег(ЗначенияПолей), "НОМЕРФАКСА=") > 0 Тогда
				ТипКонтактнойИнформации = Перечисления.ТипыКонтактнойИнформации.Факс;
			Иначе
				ТипКонтактнойИнформации = Перечисления.ТипыКонтактнойИнформации.Другое;
			КонецЕсли;
			
		КонецЕсли;
	
	КонецЕсли;
	
	Если ЗначениеЗаполнено(XMLСтрока) Тогда
		
		Если Не ПустаяСтрока(Комментарий) Тогда
			УправлениеКонтактнойИнформацией.УстановитьКомментарийКонтактнойИнформации(ЗначенияПолей, Комментарий);
		КонецЕсли;

		Возврат Новый Структура("ДанныеXML, ТипКонтактнойИнформации", XMLСтрока, ТипКонтактнойИнформации);
	КонецЕсли;
	
	// Разбираем по ЗначенияПолей, ВидКонтактнойИнформации, Представление.
	ТипЗначенийПолей = ТипЗнч(ЗначенияПолей);
	Если ТипЗначенийПолей = Тип("Строка") Тогда
		// Текст из пар ключ-значение
		СтрокаXMLСтруктуры = XSLT_СтрокаКлючЗначениеВСтруктуру(ЗначенияПолей)
		
	ИначеЕсли ТипЗначенийПолей = Тип("СписокЗначений") Тогда
		// Список значений
		СтрокаXMLСтруктуры = XSLT_СписокЗначенийВСтруктуру( ЗначениеВСтрокуXML(ЗначенияПолей) );
		
	ИначеЕсли ТипЗначенийПолей = Тип("Соответствие") Тогда
		// Соответствие
		СтрокаXMLСтруктуры = XSLT_СоответствиеВСтруктуру( ЗначениеВСтрокуXML(ЗначенияПолей) );
		
	ИначеЕсли ТипЗначенийПолей = Тип("ОбъектXDTO") Тогда
		// Ожидаем структуру
		Если ЗначенияПолей.Состав.Страна = Неопределено Тогда
			ЗначенияПолей.Состав.Страна = "";
		КонецЕсли;
		Если ЗначенияПолей.Состав.Состав = Неопределено Тогда
			ЗначенияПолей.Состав.Состав = "";
		КонецЕсли;
		
		СтрокаXMLСтруктуры = ЗначениеВСтрокуXML(ЗначенияПолей);
	Иначе
		// Ожидаем структуру
		СтрокаXMLСтруктуры = ЗначениеВСтрокуXML(ЗначенияПолей);
		
	КонецЕсли;
	
	Результат = Новый Структура("ТипКонтактнойИнформации, ДанныеXML", ТипКонтактнойИнформации);
	
	ВсеТипы = Перечисления.ТипыКонтактнойИнформации;
	Если ТипКонтактнойИнформации = ВсеТипы.Адрес Тогда
		Результат.ДанныеXML = XSLT_СтруктураВАдрес(СтрокаXMLСтруктуры, Данные.Представление, Комментарий);
		
	ИначеЕсли ТипКонтактнойИнформации = ВсеТипы.АдресЭлектроннойПочты Тогда
		Результат.ДанныеXML = XSLT_СтруктураВАдресЭлектроннойПочты(СтрокаXMLСтруктуры, Данные.Представление, Комментарий);
		
	ИначеЕсли ТипКонтактнойИнформации = ВсеТипы.ВебСтраница Тогда
		Результат.ДанныеXML = XSLT_СтруктураВВебСтраницу(СтрокаXMLСтруктуры, Данные.Представление, Комментарий);
		
	ИначеЕсли ТипКонтактнойИнформации = ВсеТипы.Телефон Тогда
		Результат.ДанныеXML = XSLT_СтруктураВТелефон(СтрокаXMLСтруктуры, Данные.Представление, Комментарий);
		
	ИначеЕсли ТипКонтактнойИнформации = ВсеТипы.Факс Тогда
		Результат.ДанныеXML = XSLT_СтруктураВФакс(СтрокаXMLСтруктуры, Данные.Представление, Комментарий);
		
	ИначеЕсли ТипКонтактнойИнформации = ВсеТипы.Другое Тогда
		Результат.ДанныеXML = XSLT_СтруктураВДругое(СтрокаXMLСтруктуры, Данные.Представление, Комментарий);
		
	ИначеЕсли ТипКонтактнойИнформации = ВсеТипы.Skype Тогда
		Результат.ДанныеXML = XSLT_СтруктураВДругое(СтрокаXMLСтруктуры, Данные.Представление, Комментарий);
		
	Иначе
		ВызватьИсключение НСтр("ru = 'Ошибка параметров преобразования, не определен тип контактной информации'");
		
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

// Преобразует формат из XML в JSON
//
Функция КонтактнаяИнформацияВСтруктуруJSON(КонтактнаяИнформация, Знач Тип = Неопределено, Представление = "", ОбновлятьИдентификаторы = Истина) Экспорт
	
	Если Тип <> Неопределено И ТипЗнч(Тип) <> Тип("ПеречислениеСсылка.ТипыКонтактнойИнформации") Тогда
		Тип = УправлениеКонтактнойИнформациейСлужебныйПовтИсп.ТипВидаКонтактнойИнформации(Тип);
	КонецЕсли;
	
	Если Тип = Неопределено Тогда
		Если ТипЗнч(КонтактнаяИнформация) = Тип("Строка") Тогда
			
			Если ЭтоСтрокаXML(КонтактнаяИнформация) Тогда
				Тип = ТипКонтактнойИнформации(КонтактнаяИнформация);
			КонецЕсли;
			
		ИначеЕсли ТипЗнч(КонтактнаяИнформация) = Тип("ОбъектXDTO") Тогда
			
			НайденТип = ?(КонтактнаяИнформация.Состав = Неопределено, Неопределено, КонтактнаяИнформация.Состав.Тип());
			Тип = СоответствиеXDTOТиповКонтактнойИнформации(НайденТип);
			
		КонецЕсли;
	КонецЕсли;
	
	Если Метаданные.ОбщиеМодули.Найти("РаботаСАдресами") <> Неопределено И Тип = Перечисления.ТипыКонтактнойИнформации.Адрес Тогда
		
		МодульРаботаСАдресами = ОбщегоНазначения.ОбщийМодуль("РаботаСАдресами");
		Возврат МодульРаботаСАдресами.КонтактнаяИнформацияВСтруктуруJSON(КонтактнаяИнформация, Тип, Представление, ОбновлятьИдентификаторы);
		
	КонецЕсли;
	
	Результат = УправлениеКонтактнойИнформациейКлиентСервер.ОписаниеНовойКонтактнойИнформации(Тип);
	
	Формат9Запятых = Ложь;
	
	Если ТипЗнч(КонтактнаяИнформация) = Тип("Строка") Тогда
		Если УправлениеКонтактнойИнформациейКлиентСервер.ЭтоКонтактнаяИнформацияВJSON(КонтактнаяИнформация) Тогда
			Возврат JSONВКонтактнуюИнформациюПоПолям(КонтактнаяИнформация, Тип);
		ИначеЕсли УправлениеКонтактнойИнформациейКлиентСервер.ЭтоКонтактнаяИнформацияВXML(КонтактнаяИнформация) Тогда
			РезультатПреобразования = Новый Структура;
			XDTOКонтактнаяИнформация = КонтактнаяИнформацияИзXML(КонтактнаяИнформация, Тип, РезультатПреобразования, Представление);
		Иначе
			Если СтрЧислоВхождений(КонтактнаяИнформация, ",") = 9 Тогда
				Формат9Запятых  = Истина;
				Результат.Value = КонтактнаяИнформация
			Иначе
				XDTOКонтактнаяИнформация      = КонтактнаяИнформацияИзXML(КонтактнаяИнформация, Тип,, Представление);
			КонецЕсли;
		КонецЕсли;
		
	ИначеЕсли ТипЗнч(КонтактнаяИнформация) = Тип("Структура") Тогда
		
		СоответствиеПолей = Новый Соответствие();
		СоответствиеПолей.Вставить("Представление", "value");
		СоответствиеПолей.Вставить("Комментарий",   "comment");
		
		Если Тип = Перечисления.ТипыКонтактнойИнформации.Телефон Тогда
			
			СоответствиеПолей.Вставить("КодСтраны",     "countryCode");
			СоответствиеПолей.Вставить("КодГорода",     "areaCode");
			СоответствиеПолей.Вставить("НомерТелефона", "number");
			СоответствиеПолей.Вставить("Добавочный",    "extNumber");
			
		КонецЕсли;
		
		Для каждого ПолеКонтактнойИнформации Из КонтактнаяИнформация Цикл
			ИмяПоля = СоответствиеПолей.Получить(ПолеКонтактнойИнформации.Ключ);
			Если ИмяПоля <> Неопределено Тогда
				Результат[ИмяПоля] = ПолеКонтактнойИнформации.Значение;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Результат;
		
	Иначе
		XDTOКонтактнаяИнформация = КонтактнаяИнформация;
		Тип = Перечисления.ТипыКонтактнойИнформации.Адрес;
	КонецЕсли;
	
	Результат.Value   = Строка(XDTOКонтактнаяИнформация.Представление);
	Результат.Comment = Строка(XDTOКонтактнаяИнформация.Комментарий);
	
	Если Тип <> Перечисления.ТипыКонтактнойИнформации.Адрес И Тип <> Перечисления.ТипыКонтактнойИнформации.Телефон Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если Не Формат9Запятых Тогда
		
		ПространствоИмен = ПространствоИмен();
		Состав = XDTOКонтактнаяИнформация.Состав;
		
		Если Состав = Неопределено Тогда
			Возврат Результат;
		КонецЕсли;
		
		XDTOТип = Состав.Тип();
		
		Если XDTOТип = ФабрикаXDTO.Тип(ПространствоИмен, "Адрес") Тогда
			
			Результат.Вставить("Country", Строка(Состав.Страна));
			Страна = Справочники.СтраныМира.НайтиПоНаименованию(Состав.Страна, Истина);
			Результат.Вставить("CountryCode", СокрЛП(Страна.Код));
			
		ИначеЕсли XDTOТип = ФабрикаXDTO.Тип(ПространствоИмен(), "НомерТелефона")
			Или XDTOТип = ФабрикаXDTO.Тип(ПространствоИмен(), "НомерФакса") Тогда
			
			Результат.CountryCode = Состав.КодСтраны;
			Результат.AreaCode    = Состав.КодГорода;
			Результат.Number      = Состав.Номер;
			Результат.ExtNumber   = Состав.Добавочный;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция СоответствиеXDTOТиповКонтактнойИнформации(НайденТип) Экспорт
	
	ПространствоИмен = ПространствоИмен();
	
	СоответствиеТипов = Новый Соответствие;
	СоответствиеТипов.Вставить(ФабрикаXDTO.Тип(ПространствоИмен, "Адрес"), Перечисления.ТипыКонтактнойИнформации.Адрес);
	СоответствиеТипов.Вставить(ФабрикаXDTO.Тип(ПространствоИмен, "ЭлектроннаяПочта"), Перечисления.ТипыКонтактнойИнформации.АдресЭлектроннойПочты);
	СоответствиеТипов.Вставить(ФабрикаXDTO.Тип(ПространствоИмен, "ВебСайт"), Перечисления.ТипыКонтактнойИнформации.ВебСтраница);
	СоответствиеТипов.Вставить(ФабрикаXDTO.Тип(ПространствоИмен, "НомерТелефона"), Перечисления.ТипыКонтактнойИнформации.Телефон);
	СоответствиеТипов.Вставить(ФабрикаXDTO.Тип(ПространствоИмен, "НомерФакса"), Перечисления.ТипыКонтактнойИнформации.Факс);
	СоответствиеТипов.Вставить(ФабрикаXDTO.Тип(ПространствоИмен, "Skype"), Перечисления.ТипыКонтактнойИнформации.Skype);
	СоответствиеТипов.Вставить(ФабрикаXDTO.Тип(ПространствоИмен, "Прочее"), Перечисления.ТипыКонтактнойИнформации.Другое);
	
	Возврат СоответствиеТипов[НайденТип];

КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункцииПоРаботеСXSLT

// Производит сравнение двух строк XML.
// Проверяются только строки и атрибуты, без пробельных, CDATA и т.п. Порядок важен.
//
// Параметры:
//    Текст1 - Строка - Строка XML.
//    Текст2 - Строка - Строка XML.
//
// Возвращаемое значение:
//    Строка - сериализованый ValueTable (http://v8.1c.ru/8.1/data/core), в котором три колонки:
//       * Путь      - Строка - путь к месту различия.
//       * Значение1 - Строка - значение в XML из параметра Текст1.
//       * Значение2 - Строка - значение в XML из параметра Текст2.
//
Функция XSLT_ТаблицаЗначенийРазличияXML(Текст1, Текст2)
	
	Преобразователь = ПреобразованиеXSLT_ТаблицаЗначенийРазличияXML();
	
	Построитель = Новый ТекстовыйДокумент;
	Построитель.ДобавитьСтроку("<dn><f>");
	Построитель.ДобавитьСтроку( XSLT_УдалитьОписаниеXML(Текст1) );
	Построитель.ДобавитьСтроку("</f><s>");
	Построитель.ДобавитьСтроку( XSLT_УдалитьОписаниеXML(Текст2) );
	Построитель.ДобавитьСтроку("</s></dn>");
	
	Возврат Преобразователь.ПреобразоватьИзСтроки(Построитель.ПолучитьТекст());
	
КонецФункции

// Преобразует текст с парами Ключ = Значение, разделенных переносами строк (см формат адреса) в XML.
// В случае повторных ключей все включаются в результат, но при десериализации будет использован 
// последний (особенность работы сериализатора платформы).
//
// Параметры:
//    Текст - Строка - пары Ключ = Значение.
//
// Возвращаемое значение:
//     Строка  - XML сериализованной структуры.
//
Функция XSLT_СтрокаКлючЗначениеВСтруктуру(Знач Текст) 
	
	Преобразователь = ПреобразованиеXSLT_СтрокаКлючЗначениеВСтруктуру();
	Возврат Преобразователь.ПреобразоватьИзСтроки(XSLT_УзелСтрокиПараметра(Текст));
	
КонецФункции

// Преобразует список значений в структуру. Представление преобразуется в ключ.
//
// Параметры:
//    Текст - Строка - сериализованная список значений.
//
// Возвращаемое значение:
//    Строка - результат преобразования.
//
Функция XSLT_СписокЗначенийВСтруктуру(Текст)
	
	Преобразователь = ПреобразованиеXSLT_СписокЗначенийВСтруктуру();
	Возврат Преобразователь.ПреобразоватьИзСтроки(Текст);
	
КонецФункции

// Преобразует соответствие в структуру. Ключ преобразуется в ключ, значение - в значение.
//
// Параметры:
//    Текст - Строка - сериализованное соответствие.
//
// Возвращаемое значение:
//    Строка - результат преобразования.
//
Функция XSLT_СоответствиеВСтруктуру(Текст)
	
	Преобразователь = ПреобразованиеXSLT_СоответствиеВСтруктуру();
	Возврат Преобразователь.ПреобразоватьИзСтроки(Текст);
	
КонецФункции

// Анализирует таблицу Путь-Значение1-Значение2 для указанного вида контактной информации.
//
// Параметры:
//    Текст                   - Строка - строка XML с ValueTable из результата сравнения XML.
//    ТипКонтактнойИнформации - ПеречислениеСсылка.ТипыКонтактнойИнформации  - значение перечисления типа.
//
// Возвращаемое значение:
//    Строка - сериализованную таблицу значений отличающихся полей.
//
Функция XSLT_ИнтерпретацияРазличияXMLКонтактнойИнформации(Знач Текст, Знач ТипКонтактнойИнформации) 
	
	Преобразователь = ПреобразованиеXSLT_ИнтерпретацияРазличияXMLКонтактнойИнформации(
		ТипКонтактнойИнформации);
	Возврат Преобразователь.ПреобразоватьИзСтроки(Текст);
	
КонецФункции

// Преобразует структуру в XML контактной информации.
//
// Параметры:
//    Текст         - Строка - сериализованная структура.
//    Представление - Строка - необязательное представление. Используется, только если в структуре нет поля
//                             представления.
//    Комментарий   - Строка - необязательный комментарий. Используется, только если в структуре нет поля комментария.
//
// Возвращаемое значение:
//    Строка - XML контактной информации.
//
Функция XSLT_СтруктураВАдрес(Знач Текст, Знач Представление = Неопределено, Знач Комментарий = Неопределено)
	
	Преобразователь = ПреобразованиеXSLT_ПреобразованиеXSL();
	Возврат XSLT_КонтрольПредставленияИКомментария(
		Преобразователь.ПреобразоватьИзСтроки(Текст),
		Представление, Комментарий);
		
КонецФункции

// Преобразует структуру в XML контактной информации.
//
// Параметры:
//    Текст         - Строка - сериализованная структура.
//    Представление - Строка - необязательное представление. Используется, только если в структуре нет поля
//                             представления.
//    Комментарий   - Строка - необязательный комментарий. Используется, только если в структуре нет поля комментария.
//
// Возвращаемое значение:
//    Строка - XML контактной информации.
//
Функция XSLT_СтруктураВАдресЭлектроннойПочты(Знач Текст, Знач Представление = Неопределено, Знач Комментарий = Неопределено)
	
	Преобразователь = ПреобразованиеXSLT_СтруктураВАдресЭлектроннойПочты();
	Возврат XSLT_КонтрольПредставленияИКомментария(
		XSLT_КонтрольСтроковогоЗначенияПростогоТипа(Преобразователь.ПреобразоватьИзСтроки(Текст), Представление), 
		Представление, Комментарий);
		
КонецФункции

// Преобразует структуру в XML контактной информации.
//
// Параметры:
//    Текст         - Строка - сериализованная структура.
//    Представление - Строка - необязательное представление. Используется, только если в структуре нет поля
//                             представления.
//    Комментарий   - Строка - необязательный комментарий. Используется, только если в структуре нет поля комментария.
//
// Возвращаемое значение:
//    Строка - XML контактной информации.
//
Функция XSLT_СтруктураВВебСтраницу(Знач Текст, Знач Представление = Неопределено, Знач Комментарий = Неопределено)
	Преобразователь = ПреобразованиеXSLT_СтруктураВВебСтраницу();
	
	Возврат XSLT_КонтрольПредставленияИКомментария(
		XSLT_КонтрольСтроковогоЗначенияПростогоТипа( Преобразователь.ПреобразоватьИзСтроки(Текст), Представление),
		Представление, Комментарий);
		
КонецФункции

// Преобразует структуру в XML контактной информации.
//
// Параметры:
//    Текст         - Строка - сериализованная структура.
//    Представление - Строка - необязательное представление. Используется, только если в структуре нет поля
//                             представления.
//    Комментарий   - Строка - необязательный комментарий. Используется, только если в структуре нет поля комментария.
//
// Возвращаемое значение:
//    Строка - XML контактной информации.
//
Функция XSLT_СтруктураВТелефон(Знач Текст, Знач Представление = Неопределено, Знач Комментарий = Неопределено)
	Преобразователь = ПреобразованиеXSLT_СтруктураВТелефон();
	Возврат XSLT_КонтрольПредставленияИКомментария(
		Преобразователь.ПреобразоватьИзСтроки(Текст),
		Представление, Комментарий);
КонецФункции

// Преобразует структуру в XML контактной информации.
//
// Параметры:
//    Текст         - Строка - сериализованная структура.
//    Представление - Строка - необязательное представление. Используется, только если в структуре нет поля
//                             представления.
//    Комментарий   - Строка - необязательный комментарий. Используется, только если в структуре нет поля комментария.
//
// Возвращаемое значение:
//    Строка - XML контактной информации.
//
Функция XSLT_СтруктураВФакс(Знач Текст, Знач Представление = Неопределено, Знач Комментарий = Неопределено)
	
	Преобразователь = ПреобразованиеXSLT_СтруктураВФакс();
	Возврат XSLT_КонтрольПредставленияИКомментария(
		Преобразователь.ПреобразоватьИзСтроки(Текст),
		Представление, Комментарий);
		
КонецФункции

// Преобразует структуру в XML контактной информации.
//
// Параметры:
//    Текст         - Строка - сериализованная структура.
//    Представление - Строка - необязательное представление. Используется, только если в структуре нет поля
//                             представления.
//    Комментарий   - Строка - необязательный комментарий. Используется, только если в структуре нет поля комментария.
//
// Возвращаемое значение:
//    Строка - XML контактной информации.
//
Функция XSLT_СтруктураВДругое(Знач Текст, Знач Представление = Неопределено, Знач Комментарий = Неопределено)
	
	Преобразователь = ПреобразованиеXSLT_СтруктураВДругое();
	Возврат XSLT_КонтрольПредставленияИКомментария(
		XSLT_КонтрольСтроковогоЗначенияПростогоТипа( Преобразователь.ПреобразоватьИзСтроки(Текст), Представление),
		Представление, Комментарий);
		
КонецФункции

// Устанавливает в контактной информации представление и комментарий, если они не заполнены.
//
// Параметры:
//    Текст         - Строка - сериализованная структура.
//    Представление - Строка - необязательное представление. Используется, только если в структуре нет поля
//                             представления.
//    Комментарий   - Строка - необязательный комментарий. Используется, только если в структуре нет поля комментария.
//
// Возвращаемое значение:
//    Строка - XML контактной информации.
//
Функция XSLT_КонтрольПредставленияИКомментария(Знач Текст, Знач Представление = Неопределено, Знач Комментарий = Неопределено)
	
	Если Представление = Неопределено И Комментарий = Неопределено Тогда
		Возврат Текст;
	КонецЕсли;
	
	XSLT_Текст = Новый ТекстовыйДокумент;
	XSLT_Текст.ДобавитьСтроку("
		|<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform""
		|  xmlns:tns=""http://www.v8.1c.ru/ssl/contactinfo""
		|  xmlns=""http://www.v8.1c.ru/ssl/contactinfo"" 
		|>
		|  <xsl:output method=""xml"" omit-xml-declaration=""yes"" indent=""yes"" encoding=""utf-8""/>
		|
		|  <xsl:template match=""node() | @*"">
		|    <xsl:copy>
		|      <xsl:apply-templates select=""node() | @*"" />
		|    </xsl:copy>
		|  </xsl:template>
		|");
		
	Если Представление <> Неопределено Тогда
		XSLT_Текст.ДобавитьСтроку("
		|  <xsl:template match=""tns:КонтактнаяИнформация/@Представление"">
		|    <xsl:attribute name=""Представление"">
		|      <xsl:choose>
		|        <xsl:when test="".=''"">" + НормализованнаяСтрокаXML(Представление) + "</xsl:when>
		|        <xsl:otherwise>
		|          <xsl:value-of select="".""/>
		|        </xsl:otherwise>
		|      </xsl:choose>
		|    </xsl:attribute>
		|  </xsl:template>
		|");
	КонецЕсли;
	
	Если Комментарий <> Неопределено Тогда
		XSLT_Текст.ДобавитьСтроку("
		|  <xsl:template match=""tns:КонтактнаяИнформация/tns:Комментарий"">
		|    <xsl:element name=""Комментарий"">
		|      <xsl:choose>
		|        <xsl:when test="".=''"">" + НормализованнаяСтрокаXML(Комментарий) + "</xsl:when>
		|        <xsl:otherwise>
		|          <xsl:value-of select="".""/>
		|        </xsl:otherwise>
		|      </xsl:choose>
		|    </xsl:element>
		|  </xsl:template>
		|");
	КонецЕсли;
		XSLT_Текст.ДобавитьСтроку("
		|</xsl:stylesheet>
		|");
		
	Преобразователь = Новый ПреобразованиеXSL;
	Преобразователь.ЗагрузитьТаблицуСтилейXSLИзСтроки(XSLT_Текст.ПолучитьТекст());
	
	Возврат Преобразователь.ПреобразоватьИзСтроки(Текст);
КонецФункции

// Устанавливает в контактной информации Состав.Значение на переданное представление.
// Если Представление равно неопределено, то никаких действий не производит. Иначе проверяет на пустоту.
// Состав. Если там ничего нет и атрибут "Состав.Значение" пуст, то ставим в состав значение представления.
//
// Параметры:
//    Текст         - Строка - XML контактной информации.
//    Представление - Строка - устанавливаемое представление.
//
// Возвращаемое значение:
//    Строка - XML контактной информации.
//
Функция XSLT_КонтрольСтроковогоЗначенияПростогоТипа(Знач Текст, Знач Представление)
	
	Если Представление = Неопределено Тогда
		Возврат Текст;
	КонецЕсли;
	
	Преобразователь = Новый ПреобразованиеXSL;
	Преобразователь.ЗагрузитьТаблицуСтилейXSLИзСтроки("
		|<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform""
		|  xmlns:tns=""http://www.v8.1c.ru/ssl/contactinfo""
		|>
		|  <xsl:output method=""xml"" omit-xml-declaration=""yes"" indent=""yes"" encoding=""utf-8""/>
		|  
		|  <xsl:template match=""node() | @*"">
		|    <xsl:copy>
		|      <xsl:apply-templates select=""node() | @*"" />
		|    </xsl:copy>
		|  </xsl:template>
		|  
		|  <xsl:template match=""tns:КонтактнаяИнформация/tns:Состав/@Значение"">
		|    <xsl:attribute name=""Значение"">
		|      <xsl:choose>
		|        <xsl:when test="".=''"">" + НормализованнаяСтрокаXML(Представление) + "</xsl:when>
		|        <xsl:otherwise>
		|          <xsl:value-of select="".""/>
		|        </xsl:otherwise>
		|      </xsl:choose>
		|    </xsl:attribute>
		|  </xsl:template>
		|
		|</xsl:stylesheet>
		|");
	
	Возврат Преобразователь.ПреобразоватьИзСтроки(Текст);
КонецФункции

// Возвращает фрагмент XML для подстановки строки в виде <Узел>Строка<Узел>.
//
// Параметры:
//    Текст       - Строка - вставка в XML.
//    ИмяЭлемента - Строка - необязательное имя для внешнего узла.
//
// Возвращаемое значение:
//    Строка - результирующий XML.
//
Функция XSLT_УзелСтрокиПараметра(Знач Текст, Знач ИмяЭлемента = "ExternalParamNode")
	
	// Через запись xml для маскировки спецсимволов.
	Запись = Новый ЗаписьXML;
	Запись.УстановитьСтроку();
	Запись.ЗаписатьНачалоЭлемента(ИмяЭлемента);
	Запись.ЗаписатьТекст(Текст);
	Запись.ЗаписатьКонецЭлемента();
	Возврат Запись.Закрыть();
	
КонецФункции

// Возвращает XML без описания <?xml...> для включения внутрь другого XML.
//
// Параметры:
//    Текст - Строка - исходный XML.
//
// Возвращаемое значение:
//    Строка - результирующий XML.
//
Функция XSLT_УдалитьОписаниеXML(Знач Текст)
	
	Преобразователь = ПреобразованиеXSLT_УдалитьОписаниеXML();
	Возврат Преобразователь.ПреобразоватьИзСтроки(СокрЛ(Текст));
	
КонецФункции

// Преобразует текст XML контактной информации в перечисление типа.
//
// Параметры:
//    Текст - Строка - исходный XML.
//
// Возвращаемое значение:
//    Строка - сериализованное значение перечисления ТипыКонтактнойИнформации.
//
Функция XSLT_ТипКонтактнойИнформацииПоСтрокеXML(Знач Текст)
	
	Преобразователь = ПреобразованиеXSLT_ТипКонтактнойИнформацииПоСтрокеXML();
	Возврат Преобразователь.ПреобразоватьИзСтроки(СокрЛ(Текст));
	
КонецФункции

//  Возвращает признак того, является ли текст XML.
//
//  Параметры:
//      Текст - Строка - проверяемый текст.
//
// Возвращаемое значение:
//      Булево - результат проверки.
//
Функция ЭтоСтрокаXML(Текст)
	
	Возврат ТипЗнч(Текст) = Тип("Строка") И Лев(СокрЛ(Текст),1) = "<";
	
КонецФункции

// Десериализатор известных платформе типов.
Функция ЗначениеИзСтрокиXML(Знач Текст)
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(Текст);
	Возврат СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
	
КонецФункции

// Сериализатор известных платформе типов.
Функция ЗначениеВСтрокуXML(Знач Значение)
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку(Новый ПараметрыЗаписиXML(, , Ложь, Ложь, ""));
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, Значение, НазначениеТипаXML.Явное);
	// Платформенный сериализатор позволяет записать в значение атрибутов перенос строки.
	Возврат СтрЗаменить(ЗаписьXML.Закрыть(), Символы.ПС, "&#10;");
	
КонецФункции

// Для работы с атрибутами содержащими переносы строк.
//
// Параметры:
//     Текст - Строка - Корректируемая строка XML.
//
// Возвращаемое значение:
//     Строка - Нормализованная строка.
//
Функция МногострочнаяСтрокаXML(Знач Текст)
	
	Возврат СтрЗаменить(Текст, Символы.ПС, "&#10;");
	
КонецФункции

// Подготавливает строку для включения в текст XML, убирая спецсимволы.
//
// Параметры:
//     Текст - Строка - Корректируемая строка XML.
//
// Возвращаемое значение:
//     Строка - Нормализованная строка.
//
Функция НормализованнаяСтрокаXML(Знач Текст)
	
	Результат = СтрЗаменить(Текст,     """", "&quot;");
	Результат = СтрЗаменить(Результат, "&",  "&amp;");
	Результат = СтрЗаменить(Результат, "'",  "&apos;");
	Результат = СтрЗаменить(Результат, "<",  "&lt;");
	Результат = СтрЗаменить(Результат, ">",  "&gt;");
	Возврат МногострочнаяСтрокаXML(Результат);
	
КонецФункции

// Инициализация преобразователей

// Преобразование для сравнения двух строк XML.
//
// Возвращаемое значение:
//     ПреобразованиеXSL  - подготовленный объект.
//
Функция ПреобразованиеXSLT_ТаблицаЗначенийРазличияXML()
	Преобразователь = Новый ПреобразованиеXSL;
	
	// Пространство имен должно быть пустым!
	Преобразователь.ЗагрузитьТаблицуСтилейXSLИзСтроки("
		|<xsl:stylesheet version=""1.0""
		|  xmlns:xsl=""http://www.w3.org/1999/XSL/Transform""
		|  xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
		|  xmlns:xs=""http://www.w3.org/2001/XMLSchema""
		|
		|  xmlns:str=""http://exslt.org/strings""
		|  xmlns:exsl=""http://exslt.org/common""
		|
		|  extension-element-prefixes=""str exsl""
		|>
		|<xsl:output method=""xml"" omit-xml-declaration=""yes"" indent=""yes"" encoding=""utf-8""/>
		|" + XSLT_ШаблоныСтроковыхФункций() + "
		|" + XSLT_ШаблоныФункцийXPath() + "
		|
		|  <!-- parce tree elements to xpath-value -->
		|  <xsl:template match=""node()"" mode=""action"">
		|    
		|    <xsl:variable name=""text"">
		|      <xsl:call-template name=""str-trim-all"">
		|        <xsl:with-param name=""str"" select=""text()"" />
		|      </xsl:call-template>
		|    </xsl:variable>
		|
		|    <xsl:if test=""$text!=''"">
		|      <xsl:element name=""item"">
		|        <xsl:attribute name=""path"">
		|          <xsl:variable name=""tmp-path"">
		|            <xsl:call-template name=""build-path"" />
		|          </xsl:variable>
		|          <xsl:value-of select=""substring($tmp-path, 6)"" /> <!-- pass '/dn/f' or '/dn/s' -->
		|        </xsl:attribute>
		|        <xsl:attribute name=""value"">
		|          <xsl:value-of select=""text()"" />
		|        </xsl:attribute>
		|      </xsl:element>
		|    </xsl:if>
		|
		|    <xsl:apply-templates select=""@* | node()"" mode=""action""/>
		|  </xsl:template>
		|
		|  <!-- parce tree attributes to xpath-value -->
		|  <xsl:template match=""@*"" mode=""action"">
		|    <xsl:element name=""item"">
		|      <xsl:attribute name=""path"">
		|          <xsl:variable name=""tmp-path"">
		|            <xsl:call-template name=""build-path"" />
		|          </xsl:variable>
		|          <xsl:value-of select=""substring($tmp-path, 6)"" /> <!-- pass '/dn/f' or '/dn/s' -->
		|      </xsl:attribute>
		|      <xsl:attribute name=""value"">
		|        <xsl:value-of select=""."" />
		|      </xsl:attribute>
		|    </xsl:element>
		|  </xsl:template>
		|
		|  <!-- main -->
		|  <xsl:variable name=""dummy"">
		|    <xsl:element name=""first"">
		|      <xsl:apply-templates select=""/dn/f"" mode=""action"" />
		|    </xsl:element> 
		|    <xsl:element name=""second"">
		|      <xsl:apply-templates select=""/dn/s"" mode=""action"" />
		|    </xsl:element>
		|  </xsl:variable>
		|  <xsl:variable name=""dummy-nodeset"" select=""exsl:node-set($dummy)"" />
		|  <xsl:variable name=""first-items"" select=""$dummy-nodeset/first/item"" />
		|  <xsl:variable name=""second-items"" select=""$dummy-nodeset/second/item"" />
		|
		|  <xsl:template match=""/"">
		|    
		|    <!-- first vs second -->
		|    <xsl:variable name=""first-second"">
		|      <xsl:for-each select=""$first-items"">
		|        <xsl:call-template name=""compare"">
		|          <xsl:with-param name=""check"" select=""$second-items"" />
		|        </xsl:call-template>
		|      </xsl:for-each>
		|    </xsl:variable>
		|    <xsl:variable name=""first-second-nodeset"" select=""exsl:node-set($first-second)"" />
		|
		|    <!-- second vs first without doubles -->
		|    <xsl:variable name=""doubles"" select=""$first-second-nodeset/item"" />
		|    <xsl:variable name=""second-first"">
		|      <xsl:for-each select=""$second-items"">
		|        <xsl:call-template name=""compare"">
		|          <xsl:with-param name=""check"" select=""$first-items"" />
		|          <xsl:with-param name=""doubles"" select=""$doubles"" />
		|        </xsl:call-template>
		|      </xsl:for-each>
		|    </xsl:variable>
		|      
		|    <!-- result -->
		|    <ValueTable xmlns=""http://v8.1c.ru/8.1/data/core"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" xsi:type=""ValueTable"">
		|      <column>
		|        <Name xsi:type=""xs:string"">Путь</Name>
		|        <ValueType>
		|           <Type>xs:string</Type>
		|           <StringQualifiers><Length>0</Length><AllowedLength>Variable</AllowedLength></StringQualifiers>
		|        </ValueType>
		|      </column>
		|      <column>
		|        <Name xsi:type=""xs:string"">Значение1</Name>
		|        <ValueType>
		|           <Type>xs:string</Type>
		|           <StringQualifiers><Length>0</Length><AllowedLength>Variable</AllowedLength></StringQualifiers>
		|        </ValueType>
		|      </column>
		|      <column>
		|        <Name xsi:type=""xs:string"">Значение2</Name>
		|        <ValueType>
		|           <Type>xs:string</Type>
		|           <StringQualifiers><Length>0</Length><AllowedLength>Variable</AllowedLength></StringQualifiers>
		|        </ValueType>
		|      </column>
		|
		|      <xsl:for-each select=""$first-second-nodeset/item | exsl:node-set($second-first)/item"">
		|        <xsl:element name=""row"">
		|           <xsl:element name=""Value"">
		|             <xsl:value-of select=""@path""/>
		|           </xsl:element>
		|           <xsl:element name=""Value"">
		|             <xsl:value-of select=""@value1""/>
		|           </xsl:element>
		|           <xsl:element name=""Value"">
		|             <xsl:value-of select=""@value2""/>
		|           </xsl:element>
		|        </xsl:element>
		|      </xsl:for-each>
		|
		|    </ValueTable>
		|
		|  </xsl:template>
		|  <!-- /main -->
		|
		|  <!-- compare sub -->
		|  <xsl:template name=""compare"">
		|    <xsl:param name=""check"" />
		|    <xsl:param name=""doubles"" select=""/.."" />
		|    
		|    <xsl:variable name=""path""  select=""@path""/>
		|    <xsl:variable name=""value"" select=""@value""/>
		|    <xsl:variable name=""diff""  select=""$check[@path=$path]""/>
		|    <xsl:choose>
		|      <xsl:when test=""count($diff)=0"">
		|        <xsl:if test=""count($doubles[@path=$path and @value1='' and @value2=$value])=0"">
		|          <xsl:element name=""item"">
		|            <xsl:attribute name=""path"">   <xsl:value-of select=""$path""/> </xsl:attribute>
		|            <xsl:attribute name=""value1""> <xsl:value-of select=""$value""/> </xsl:attribute>
		|            <xsl:attribute name=""value2"" />
		|          </xsl:element>
		|        </xsl:if>
		|      </xsl:when>
		|      <xsl:otherwise>
		|
		|        <xsl:for-each select=""$diff[@value!=$value]"">
		|            <xsl:variable name=""diff-value"" select=""@value""/>
		|            <xsl:if test=""count($doubles[@path=$path and @value1=$diff-value and @value2=$value])=0"">
		|              <xsl:element name=""item"">
		|                <xsl:attribute name=""path"">   <xsl:value-of select=""$path""/>  </xsl:attribute>
		|                <xsl:attribute name=""value1""> <xsl:value-of select=""$value""/> </xsl:attribute>
		|                <xsl:attribute name=""value2""> <xsl:value-of select=""@value""/> </xsl:attribute>
		|              </xsl:element>
		|            </xsl:if>
		|        </xsl:for-each>
		|      </xsl:otherwise>
		|    </xsl:choose>
		|  </xsl:template>
		|  
		|</xsl:stylesheet>
		|");
		
	Возврат Преобразователь;
КонецФункции

// Преобразование для текста с парами Ключ=Значение, разделенных переносами строк (см формат адреса) в XML.
// В случае повторных ключей все включаются в результат, но при десериализации будет использован 
// последний (особенность работы сериализатора платформы).
//
// Возвращаемое значение:
//     ПреобразованиеXSL  - подготовленный объект.
//
Функция ПреобразованиеXSLT_СтрокаКлючЗначениеВСтруктуру()
	Преобразователь = Новый ПреобразованиеXSL;
	Преобразователь.ЗагрузитьТаблицуСтилейXSLИзСтроки("
		|<xsl:stylesheet version=""1.0""
		|  xmlns:xsl=""http://www.w3.org/1999/XSL/Transform""
		|  xmlns:str=""http://exslt.org/strings""
		|  extension-element-prefixes=""str""
		|>
		|<xsl:output method=""xml"" omit-xml-declaration=""yes"" indent=""yes"" encoding=""utf-8""/>
		|" + XSLT_ШаблоныСтроковыхФункций() + "
		|
		|  <xsl:template match=""ExternalParamNode"">
		|
		|    <xsl:variable name=""source"">
		|      <xsl:call-template name=""str-replace-all"">
		|        <xsl:with-param name=""str"" select=""."" />
		|        <xsl:with-param name=""search-for"" select=""'&#10;&#09;'"" />
		|        <xsl:with-param name=""replace-by"" select=""'&#13;'"" />
		|      </xsl:call-template>
		|    </xsl:variable>
		|
		|    <Structure xmlns=""http://v8.1c.ru/8.1/data/core"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:type=""Structure"">
		|
		|     <xsl:for-each select=""str:tokenize($source, '&#10;')"" >
		|       <xsl:if test=""contains(., '=')"">
		|
		|         <xsl:element name=""Property"">
		|           <xsl:attribute name=""name"" >
		|             <xsl:call-template name=""str-trim-all"">
		|               <xsl:with-param name=""str"" select=""substring-before(., '=')"" />
		|             </xsl:call-template>
		|           </xsl:attribute>
		|
		|           <Value xsi:type=""xs:string"">
		|             <xsl:call-template name=""str-replace-all"">
		|               <xsl:with-param name=""str"" select=""substring-after(., '=')"" />
		|               <xsl:with-param name=""search-for"" select=""'&#13;'"" />
		|               <xsl:with-param name=""replace-by"" select=""'&#10;'"" />
		|             </xsl:call-template>
		|           </Value>
		|
		|         </xsl:element>
		|
		|       </xsl:if>
		|     </xsl:for-each>
		|
		|    </Structure>
		|
		|  </xsl:template>
		|
		|</xsl:stylesheet>
		|");

	Возврат Преобразователь;
КонецФункции

// Преобразование для списка значений в структуру. Представление преобразуется в ключ.
//
// Возвращаемое значение:
//     ПреобразованиеXSL  - подготовленный объект.
//
Функция ПреобразованиеXSLT_СписокЗначенийВСтруктуру()
	Преобразователь = Новый ПреобразованиеXSL;
	Преобразователь.ЗагрузитьТаблицуСтилейXSLИзСтроки("
		|<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform""
		|  xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
		|  xmlns:tns=""http://v8.1c.ru/8.1/data/core""
		|  xmlns=""http://v8.1c.ru/8.1/data/core""
		|>
		|<xsl:output method=""xml"" omit-xml-declaration=""yes"" indent=""yes"" encoding=""utf-8""/>
		|" + XSLT_ШаблоныСтроковыхФункций() + "
		|
		|  <xsl:template match=""/"">
		|    <Structure xmlns=""http://v8.1c.ru/8.1/data/core"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:type=""Structure"">
		|      <xsl:apply-templates select=""//tns:ValueListType/tns:item"" />
		|    </Structure >
		|  </xsl:template>
		|
		|  <xsl:template match=""//tns:ValueListType/tns:item"">
		|    <xsl:element name=""Property"">
		|      <xsl:attribute name=""name"">
		|        <xsl:call-template name=""str-trim-all"">
		|          <xsl:with-param name=""str"" select=""tns:presentation"" />
		|        </xsl:call-template>
		|      </xsl:attribute>
		|
		|      <xsl:element name=""Value"">
		|        <xsl:attribute name=""xsi:type"">
		|          <xsl:value-of select=""tns:value/@xsi:type""/>  
		|        </xsl:attribute>
		|        <xsl:value-of select=""tns:value""/>  
		|      </xsl:element>
		|
		|    </xsl:element>
		|</xsl:template>
		|
		|</xsl:stylesheet>
		|");
	Возврат Преобразователь;
КонецФункции

// Преобразование для соответствия в структуру. Ключ преобразуется в ключ, значение - в значение.
//
// Возвращаемое значение:
//     ПреобразованиеXSL  - подготовленный объект.
//
Функция ПреобразованиеXSLT_СоответствиеВСтруктуру()
	Преобразователь = Новый ПреобразованиеXSL;
	Преобразователь.ЗагрузитьТаблицуСтилейXSLИзСтроки("
		|<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform""
		|  xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
		|  xmlns:tns=""http://v8.1c.ru/8.1/data/core""
		|  xmlns=""http://v8.1c.ru/8.1/data/core""
		|>
		|<xsl:output method=""xml"" omit-xml-declaration=""yes"" indent=""yes"" encoding=""utf-8""/>
		|" + XSLT_ШаблоныСтроковыхФункций() + "
		|
		|  <xsl:template match=""/"">
		|    <Structure xmlns=""http://v8.1c.ru/8.1/data/core"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:type=""Structure"">
		|      <xsl:apply-templates select=""//tns:Map/tns:pair"" />
		|    </Structure >
		|  </xsl:template>
		|  
		|  <xsl:template match=""//tns:Map/tns:pair"">
		|  <xsl:element name=""Property"">
		|    <xsl:attribute name=""name"">
		|      <xsl:call-template name=""str-trim-all"">
		|        <xsl:with-param name=""str"" select=""tns:Key"" />
		|      </xsl:call-template>
		|    </xsl:attribute>
		|  
		|    <xsl:element name=""Value"">
		|      <xsl:attribute name=""xsi:type"">
		|        <xsl:value-of select=""tns:Value/@xsi:type""/>  
		|      </xsl:attribute>
		|        <xsl:value-of select=""tns:Value""/>  
		|      </xsl:element>
		|  
		|    </xsl:element>
		|  </xsl:template>
		|
		|</xsl:stylesheet>
		|");
	Возврат Преобразователь;
КонецФункции

// Убирает описание <?xml...> для включения внутрь другого XML.
//
// Возвращаемое значение:
//     ПреобразованиеXSL  - подготовленный объект.
//
Функция ПреобразованиеXSLT_УдалитьОписаниеXML()
	Преобразователь = Новый ПреобразованиеXSL;
	Преобразователь.ЗагрузитьТаблицуСтилейXSLИзСтроки("
		|<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform"">
		|<xsl:output method=""xml"" omit-xml-declaration=""yes"" indent=""yes"" encoding=""utf-8""/>
		|  <xsl:template match=""node() | @*"">
		|    <xsl:copy>
		|      <xsl:apply-templates select=""node() | @*"" />
		|    </xsl:copy>
		|  </xsl:template>
		|</xsl:stylesheet>
		|");
	Возврат Преобразователь;
КонецФункции

// Преобразование для контактной информации в виде XML (см пакет XDTO КонтактнаяИнформация) в перечисление
// ТипКонтактнойИнформации.
//
// Возвращаемое значение:
//     ПреобразованиеXSL  - подготовленный объект.
//
Функция ПреобразованиеXSLT_ТипКонтактнойИнформацииПоСтрокеXML()
	Преобразователь = Новый ПреобразованиеXSL;
	Преобразователь.ЗагрузитьТаблицуСтилейXSLИзСтроки("
		|<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform""
		|  xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
		|  xmlns:ci=""http://www.v8.1c.ru/ssl/contactinfo""
		|>
		|  <xsl:output method=""xml"" omit-xml-declaration=""yes"" indent=""yes"" encoding=""utf-8""/>
		|
		|  <xsl:template match=""/"">
		|    <EnumRef.ТипыКонтактнойИнформации xmlns=""http://v8.1c.ru/8.1/data/enterprise/current-config"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:type=""EnumRef.ТипыКонтактнойИнформации"">
		|      <xsl:call-template name=""enum-by-type"" >
		|        <xsl:with-param name=""type"" select=""ci:КонтактнаяИнформация/ci:Состав/@xsi:type"" />
		|      </xsl:call-template>
		|    </EnumRef.ТипыКонтактнойИнформации>
		|  </xsl:template>
		|
		|  <xsl:template name=""enum-by-type"">
		|    <xsl:param name=""type"" />
		|    <xsl:choose>
		|      <xsl:when test=""$type='Адрес'"">
		|        <xsl:text>Адрес</xsl:text>
		|      </xsl:when>
		|      <xsl:when test=""$type='НомерТелефона'"">
		|        <xsl:text>Телефон</xsl:text>
		|      </xsl:when>
		|      <xsl:when test=""$type='НомерФакса'"">
		|        <xsl:text>Факс</xsl:text>
		|      </xsl:when>
		|      <xsl:when test=""$type='ЭлектроннаяПочта'"">
		|        <xsl:text>АдресЭлектроннойПочты</xsl:text>
		|      </xsl:when>
		|      <xsl:when test=""$type='ВебСайт'"">
		|        <xsl:text>ВебСтраница</xsl:text>
		|      </xsl:when>
		|      <xsl:when test=""$type='Прочее'"">
		|        <xsl:text>Другое</xsl:text>
		|      </xsl:when>
		|    </xsl:choose>
		|  </xsl:template>
		|
		|</xsl:stylesheet>
		|");
	Возврат Преобразователь;
КонецФункции

// Преобразование для таблицы различий XML в зависимости от типа контактной информации.
//
// Параметры:
//    ТипКонтактнойИнформации - Строка, ПеречислениеСсылка.ТипыКонтактнойИнформации - имя или значение перечисления.
//
// Возвращаемое значение:
//     ПреобразованиеXSL  - подготовленный объект.
//
Функция ПреобразованиеXSLT_ИнтерпретацияРазличияXMLКонтактнойИнформации(Знач ТипКонтактнойИнформации)
	
	Если ТипЗнч(ТипКонтактнойИнформации) <> Тип("Строка") Тогда
		ТипКонтактнойИнформации = ТипКонтактнойИнформации.Метаданные().Имя;
	КонецЕсли;
	
	Преобразователь = Новый ПреобразованиеXSL;
	Преобразователь.ЗагрузитьТаблицуСтилейXSLИзСтроки("
		|<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform""
		|  xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
		|  xmlns:ci=""http://www.v8.1c.ru/ssl/contactinfo""
		|>
		|<xsl:output method=""xml"" omit-xml-declaration=""yes"" indent=""yes"" encoding=""utf-8""/>
		|  <xsl:param name=""target-type"" select=""'" + ТипКонтактнойИнформации + "'""/>
		|
		|  <xsl:template match=""/"">
		|    <xsl:choose>
		|      <xsl:when test=""$target-type='Адрес'"">
		|         <xsl:apply-templates select=""."" mode=""action-address""/>
		|      </xsl:when>
		|      <xsl:otherwise>
		|         <xsl:apply-templates select=""."" mode=""action-copy""/>
		|      </xsl:otherwise>
		|    </xsl:choose>
		|  </xsl:template>
		|
		|  <xsl:template match=""node() | @*"" mode=""action-copy"">
		|    <xsl:copy>
		|      <xsl:apply-templates select=""node() | @*"" mode=""action-copy""/>
		|    </xsl:copy>
		|  </xsl:template>
		|
		|  <xsl:template match=""node() | @*"" mode=""action-address"">
		|    <xsl:copy>
		|      <xsl:apply-templates select=""node() | @*"" mode=""action-address""/>
		|    </xsl:copy>
		|  </xsl:template>
		|
		|</xsl:stylesheet>
		|");
	Возврат Преобразователь;
КонецФункции

// Возвращает преобразователь XSL для конвертации структуры в контактную информацию в виде XML.
//
// Возвращаемое значение:
//     ПреобразованиеXSL  - подготовленный объект.
//
Функция ПреобразованиеXSLT_ПреобразованиеXSL()
	
	Если Метаданные.ОбщиеМодули.Найти("РаботаСАдресами") <> Неопределено Тогда
		МодульРаботаСАдресами = ОбщегоНазначения.ОбщийМодуль("РаботаСАдресами");
		ДополнительныеПравилаПреобразования = МодульРаботаСАдресами.ДополнительныеПравилаПреобразования();
	КонецЕсли;
	
	ОсновнаяСтрана = "";
	Если Метаданные.ОбщиеМодули.Найти("РаботаСАдресамиКлиентСервер") <> Неопределено Тогда
		МодульРаботаСАдресамиКлиентСервер = ОбщегоНазначения.ОбщийМодуль("РаботаСАдресамиКлиентСервер");
		ОсновнаяСтрана = МодульРаботаСАдресамиКлиентСервер.ОсновнаяСтрана();
	КонецЕсли;
	
	Преобразователь = Новый ПреобразованиеXSL;
	Преобразователь.ЗагрузитьТаблицуСтилейXSLИзСтроки("
		|<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform""
		|  xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
		|  xmlns:xs=""http://www.w3.org/2001/XMLSchema""
		|  xmlns:tns=""http://v8.1c.ru/8.1/data/core""
		|  xmlns=""http://www.v8.1c.ru/ssl/contactinfo"" 
		|
		|  xmlns:data=""http://www.v8.1c.ru/ssl/contactinfo""
		|
		|  xmlns:exsl=""http://exslt.org/common""
		|  extension-element-prefixes=""exsl""
		|  exclude-result-prefixes=""data tns""
		|>
		|<xsl:output method=""xml"" omit-xml-declaration=""yes"" indent=""yes"" encoding=""utf-8""/>
		|  " + XSLT_ШаблоныСтроковыхФункций() + "
		|  
		|  <xsl:variable name=""local-country"">" + ОсновнаяСтрана + "</xsl:variable>
		|
		|  <xsl:variable name=""presentation"" select=""tns:Structure/tns:Property[@name='Представление']/tns:Value/text()"" />
		|  
		|  <xsl:template match=""/"">
		|    <КонтактнаяИнформация>
		|
		|      <xsl:attribute name=""Представление"">
		|        <xsl:value-of select=""$presentation""/>
		|      </xsl:attribute> 
		|      <xsl:element name=""Комментарий"">
		|       <xsl:value-of select=""tns:Structure/tns:Property[@name='Комментарий']/tns:Value/text()""/>
		|      </xsl:element>
		|
		|      <xsl:element name=""Состав"">
		|        <xsl:attribute name=""xsi:type"">Адрес</xsl:attribute>
		|        <xsl:variable name=""country"" select=""tns:Structure/tns:Property[@name='Страна']/tns:Value/text()""></xsl:variable>
		|        <xsl:variable name=""country-upper"">
		|          <xsl:call-template name=""str-upper"">
		|            <xsl:with-param name=""str"" select=""$country"" />
		|          </xsl:call-template>
		|        </xsl:variable>
		|
		|        <xsl:attribute name=""Страна"">
		|          <xsl:choose>
		|            <xsl:when test=""0=count($country)"">
		|              <xsl:value-of select=""$local-country"" />
		|            </xsl:when>
		|            <xsl:otherwise>
		|              <xsl:value-of select=""$country"" />
		|            </xsl:otherwise> 
		|          </xsl:choose>
		|        </xsl:attribute>
		|
		|        <xsl:choose>
		|          <xsl:when test=""0=count($country)"">
		|            <xsl:apply-templates select=""/"" mode=""domestic"" />
		|          </xsl:when>
		|          <xsl:when test=""$country-upper=$local-country"">
		|            <xsl:apply-templates select=""/"" mode=""domestic"" />
		|          </xsl:when>
		|          <xsl:otherwise>
		|            <xsl:apply-templates select=""/"" mode=""foreign"" />
		|          </xsl:otherwise> 
		|        </xsl:choose>
		|
		|      </xsl:element>
		|    </КонтактнаяИнформация>
		|  </xsl:template>
		|  
		|  <xsl:template match=""/"" mode=""foreign"">
		|    <xsl:element name=""Состав"">
		|      <xsl:attribute name=""xsi:type"">xs:string</xsl:attribute>
		|
		|      <xsl:variable name=""value"" select=""tns:Structure/tns:Property[@name='Значение']/tns:Value/text()"" />        
		|      <xsl:choose>
		|        <xsl:when test=""0=count($value)"">
		|          <xsl:value-of select=""$presentation"" />
		|        </xsl:when>
		|        <xsl:otherwise>
		|          <xsl:value-of select=""$value"" />
		|        </xsl:otherwise> 
		|      </xsl:choose>
		|    
		|    </xsl:element>
		|  </xsl:template>
		|" + ДополнительныеПравилаПреобразования);
		
		Возврат Преобразователь;
КонецФункции

// Преобразует сериализованную структуру в контактную информацию в виде XML.
//
// Возвращаемое значение:
//     ПреобразованиеXSL  - подготовленный объект.
//
Функция ПреобразованиеXSLT_СтруктураВАдресЭлектроннойПочты()
	Возврат ПреобразованиеXSLT_СтруктураВСтроковыйСостав("ЭлектроннаяПочта");
КонецФункции

// Преобразует сериализованную структуру в контактную информацию в виде XML.
//
// Возвращаемое значение:
//     ПреобразованиеXSL  - подготовленный объект.
//
Функция ПреобразованиеXSLT_СтруктураВВебСтраницу()
	Возврат ПреобразованиеXSLT_СтруктураВСтроковыйСостав("ВебСайт");
КонецФункции

// Преобразует сериализованную структуру в контактную информацию в виде XML.
//
Функция ПреобразованиеXSLT_СтруктураВТелефон()
	Возврат ПреобразованиеXSLT_СтруктураВТелефонФакс("НомерТелефона");
КонецФункции

// Преобразует сериализованную структуру в контактную информацию в виде XML.
//
// Возвращаемое значение:
//     ПреобразованиеXSL  - подготовленный объект.
//
Функция ПреобразованиеXSLT_СтруктураВФакс()
	Возврат ПреобразованиеXSLT_СтруктураВТелефонФакс("НомерФакса");
КонецФункции

// Преобразует сериализованную структуру в контактную информацию в виде XML.
//
// Возвращаемое значение:
//     ПреобразованиеXSL  - подготовленный объект.
//
Функция ПреобразованиеXSLT_СтруктураВДругое()
	Возврат ПреобразованиеXSLT_СтруктураВСтроковыйСостав("Прочее");
КонецФункции

// Общее преобразование сериализованной структуры в контактную информацию в виде XML простого типа.
//
// Возвращаемое значение:
//     ПреобразованиеXSL  - подготовленный объект.
//
Функция ПреобразованиеXSLT_СтруктураВСтроковыйСостав(Знач ИмяXDTOТипа)
	Преобразователь = Новый ПреобразованиеXSL;
	Преобразователь.ЗагрузитьТаблицуСтилейXSLИзСтроки("
		|<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform""
		|  xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
		|  xmlns:tns=""http://v8.1c.ru/8.1/data/core""
		|  xmlns=""http://www.v8.1c.ru/ssl/contactinfo"" 
		|>
		|<xsl:output method=""xml"" omit-xml-declaration=""yes"" indent=""yes"" encoding=""utf-8""/>
		|
		|<xsl:template match=""/"">
		|  
		|  <xsl:element name=""КонтактнаяИнформация"">
		|  
		|  <xsl:attribute name=""Представление"">
		|    <xsl:value-of select=""tns:Structure/tns:Property[@name='Представление']/tns:Value/text()""/>
		|  </xsl:attribute> 
		|  <xsl:element name=""Комментарий"">
		|    <xsl:value-of select=""tns:Structure/tns:Property[@name='Комментарий']/tns:Value/text()""/>
		|  </xsl:element>
		|  
		|  <xsl:element name=""Состав"">
		|    <xsl:attribute name=""xsi:type"">" + ИмяXDTOТипа + "</xsl:attribute>
		|    <xsl:attribute name=""Значение"">
		|    <xsl:choose>
		|      <xsl:when test=""0=count(tns:Structure/tns:Property[@name='Значение'])"">
		|      <xsl:value-of select=""tns:Structure/tns:Property[@name='Представление']/tns:Value/text()""/>
		|      </xsl:when>
		|      <xsl:otherwise>
		|      <xsl:value-of select=""tns:Structure/tns:Property[@name='Значение']/tns:Value/text()""/>
		|      </xsl:otherwise>
		|    </xsl:choose>
		|    </xsl:attribute>
		|    
		|  </xsl:element>
		|  </xsl:element>
		|  
		|</xsl:template>
		|</xsl:stylesheet>
		|");
	Возврат Преобразователь;
КонецФункции

// Общее преобразование для телефона и факса.
//
// Возвращаемое значение:
//     ПреобразованиеXSL  - подготовленный объект.
//
Функция ПреобразованиеXSLT_СтруктураВТелефонФакс(Знач ИмяXDTOТипа)
	Преобразователь = Новый ПреобразованиеXSL;
	Преобразователь.ЗагрузитьТаблицуСтилейXSLИзСтроки("
		|<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform""
		|  xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
		|  xmlns:tns=""http://v8.1c.ru/8.1/data/core""
		|  xmlns=""http://www.v8.1c.ru/ssl/contactinfo"" 
		|>
		|<xsl:output method=""xml"" omit-xml-declaration=""yes"" indent=""yes"" encoding=""utf-8""/>
		|  <xsl:template match=""/"">
		|
		|    <xsl:element name=""КонтактнаяИнформация"">
		|
		|      <xsl:attribute name=""Представление"">
		|        <xsl:value-of select=""tns:Structure/tns:Property[@name='Представление']/tns:Value/text()""/>
		|      </xsl:attribute> 
		|      <xsl:element name=""Комментарий"">
		|        <xsl:value-of select=""tns:Structure/tns:Property[@name='Комментарий']/tns:Value/text()""/>
		|      </xsl:element>
		|      <xsl:element name=""Состав"">
		|        <xsl:attribute name=""xsi:type"">" + ИмяXDTOТипа + "</xsl:attribute>
		|
		|        <xsl:attribute name=""КодСтраны"">
		|          <xsl:value-of select=""tns:Structure/tns:Property[@name='КодСтраны']/tns:Value/text()""/>
		|        </xsl:attribute> 
		|        <xsl:attribute name=""КодГорода"">
		|          <xsl:value-of select=""tns:Structure/tns:Property[@name='КодГорода']/tns:Value/text()""/>
		|        </xsl:attribute> 
		|        <xsl:attribute name=""Номер"">
		|          <xsl:value-of select=""tns:Structure/tns:Property[@name='НомерТелефона']/tns:Value/text()""/>
		|        </xsl:attribute> 
		|        <xsl:attribute name=""Добавочный"">
		|          <xsl:value-of select=""tns:Structure/tns:Property[@name='Добавочный']/tns:Value/text()""/>
		|        </xsl:attribute> 
		|
		|      </xsl:element>
		|    </xsl:element>
		|
		|  </xsl:template>
		|</xsl:stylesheet>
		|");
	Возврат Преобразователь;
КонецФункции

// Фрагмент XSL с процедурами для обработки строк.
//
// Возвращаемое значение:
//     Строка - фрагмент XML для использования в преобразовании.
//
Функция XSLT_ШаблоныСтроковыхФункций()
	
	НаборБуквНижнийРегистр  = "abcdefghijklmnopqrstuvwxyz";
	НаборБуквВерхнийРегистр = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	
	Если Метаданные.ОбщиеМодули.Найти("РаботаСАдресами") <> Неопределено Тогда
		МодульРаботаСАдресами = ОбщегоНазначения.ОбщийМодуль("РаботаСАдресами");
		НаборБуквНижнийРегистр  = МодульРаботаСАдресами.НаборБуквВНижнемРегистре();
		НаборБуквВерхнийРегистр = МодульРаботаСАдресами.НаборБуквВВерхнемРегистре();
	КонецЕсли;
	
	Возврат "
		|<!-- string functions -->
		|
		|  <xsl:template name=""str-trim-left"">
		|    <xsl:param name=""str"" />
		|    <xsl:variable name=""head"" select=""substring($str, 1, 1)""/>
		|    <xsl:variable name=""tail"" select=""substring($str, 2)""/>
		|    <xsl:choose>
		|      <xsl:when test=""(string-length($str) > 0) and (string-length(normalize-space($head)) = 0)"">
		|        <xsl:call-template name=""str-trim-left"">
		|          <xsl:with-param name=""str"" select=""$tail""/>
		|        </xsl:call-template>
		|      </xsl:when>
		|      <xsl:otherwise>
		|        <xsl:value-of select=""$str""/>
		|      </xsl:otherwise>
		|    </xsl:choose>
		|  </xsl:template>
		|
		|  <xsl:template name=""str-trim-right"">
		|    <xsl:param name=""str"" />
		|    <xsl:variable name=""head"" select=""substring($str, 1, string-length($str) - 1)""/>
		|    <xsl:variable name=""tail"" select=""substring($str, string-length($str))""/>
		|    <xsl:choose>
		|      <xsl:when test=""(string-length($str) > 0) and (string-length(normalize-space($tail)) = 0)"">
		|        <xsl:call-template name=""str-trim-right"">
		|          <xsl:with-param name=""str"" select=""$head""/>
		|        </xsl:call-template>
		|      </xsl:when>
		|      <xsl:otherwise>
		|        <xsl:value-of select=""$str""/>
		|      </xsl:otherwise>
		|    </xsl:choose>
		|  </xsl:template>
		|
		|  <xsl:template name=""str-trim-all"">
		|    <xsl:param name=""str"" />
		|      <xsl:call-template name=""str-trim-right"">
		|        <xsl:with-param name=""str"">
		|          <xsl:call-template name=""str-trim-left"">
		|            <xsl:with-param name=""str"" select=""$str""/>
		|          </xsl:call-template>
		|      </xsl:with-param>
		|    </xsl:call-template>
		|  </xsl:template>
		|
		|  <xsl:template name=""str-replace-all"">
		|    <xsl:param name=""str"" />
		|    <xsl:param name=""search-for"" />
		|    <xsl:param name=""replace-by"" />
		|    <xsl:choose>
		|      <xsl:when test=""contains($str, $search-for)"">
		|        <xsl:value-of select=""substring-before($str, $search-for)"" />
		|        <xsl:value-of select=""$replace-by"" />
		|        <xsl:call-template name=""str-replace-all"">
		|          <xsl:with-param name=""str"" select=""substring-after($str, $search-for)"" />
		|          <xsl:with-param name=""search-for"" select=""$search-for"" />
		|          <xsl:with-param name=""replace-by"" select=""$replace-by"" />
		|        </xsl:call-template>
		|      </xsl:when>
		|      <xsl:otherwise>
		|        <xsl:value-of select=""$str"" />
		|      </xsl:otherwise>
		|    </xsl:choose>
		|  </xsl:template>
		|
		|  <xsl:param name=""alpha-low"" select=""'" + НаборБуквНижнийРегистр + "'"" />
		|  <xsl:param name=""alpha-up""  select=""'" + НаборБуквВерхнийРегистр + "'"" />
		|
		|  <xsl:template name=""str-upper"">
		|    <xsl:param name=""str"" />
		|    <xsl:value-of select=""translate($str, $alpha-low, $alpha-up)""/>
		|  </xsl:template>
		|
		|  <xsl:template name=""str-lower"">
		|    <xsl:param name=""str"" />
		|    <xsl:value-of select=""translate($str, alpha-up, $alpha-low)"" />
		|  </xsl:template>
		|
		|<!-- /string functions -->
		|";
КонецФункции

// Фрагмент XSL с процедурами для работы с xpath.
//
// Возвращаемое значение:
//     Строка - фрагмент XML для использования в преобразовании.
//
Функция XSLT_ШаблоныФункцийXPath()
	Возврат "
		|<!-- path functions -->
		|
		|  <xsl:template name=""build-path"">
		|  <xsl:variable name=""node"" select="".""/>
		|
		|    <xsl:for-each select=""$node | $node/ancestor-or-self::node()[..]"">
		|      <xsl:choose>
		|        <!-- element -->
		|        <xsl:when test=""self::*"">
		|            <xsl:value-of select=""'/'""/>
		|            <xsl:value-of select=""name()""/>
		|            <xsl:variable name=""thisPosition"" select=""count(preceding-sibling::*[name(current()) = name()])""/>
		|            <xsl:variable name=""numFollowing"" select=""count(following-sibling::*[name(current()) = name()])""/>
		|            <xsl:if test=""$thisPosition + $numFollowing > 0"">
		|              <xsl:value-of select=""concat('[', $thisPosition +1, ']')""/>
		|            </xsl:if>
		|        </xsl:when>
		|        <xsl:otherwise>
		|          <!-- not element -->
		|          <xsl:choose>
		|            <!-- attribute -->
		|            <xsl:when test=""count(. | ../@*) = count(../@*)"">
		|                <xsl:value-of select=""'/'""/>
		|                <xsl:value-of select=""concat('@',name())""/>
		|            </xsl:when>
		|            <!-- text- -->
		|            <xsl:when test=""self::text()"">
		|                <xsl:value-of select=""'/'""/>
		|                <xsl:value-of select=""'text()'""/>
		|                <xsl:variable name=""thisPosition"" select=""count(preceding-sibling::text())""/>
		|                <xsl:variable name=""numFollowing"" select=""count(following-sibling::text())""/>
		|                <xsl:if test=""$thisPosition + $numFollowing > 0""> 
		|                  <xsl:value-of select=""concat('[', $thisPosition +1, ']')""/>
		|                </xsl:if>
		|            </xsl:when>
		|            <!-- processing instruction -->
		|            <xsl:when test=""self::processing-instruction()"">
		|                <xsl:value-of select=""'/'""/>
		|                <xsl:value-of select=""'processing-instruction()'""/>
		|                <xsl:variable name=""thisPosition"" select=""count(preceding-sibling::processing-instruction())""/>
		|                <xsl:variable name=""numFollowing"" select=""count(following-sibling::processing-instruction())""/>
		|                <xsl:if test=""$thisPosition + $numFollowing > 0"">
		|                  <xsl:value-of select=""concat('[', $thisPosition +1, ']')""/>
		|                </xsl:if>
		|            </xsl:when>
		|            <!-- comment -->
		|            <xsl:when test=""self::comment()"">
		|                <xsl:value-of select=""'/'""/>
		|                <xsl:value-of select=""'comment()'""/>
		|                <xsl:variable name=""thisPosition"" select=""count(preceding-sibling::comment())""/>
		|                <xsl:variable name=""numFollowing"" select=""count(following-sibling::comment())""/>
		|                <xsl:if test=""$thisPosition + $numFollowing > 0"">
		|                  <xsl:value-of select=""concat('[', $thisPosition +1, ']')""/>
		|                </xsl:if>
		|            </xsl:when>
		|            <!-- namespace -->
		|            <xsl:when test=""count(. | ../namespace::*) = count(../namespace::*)"">
		|              <xsl:variable name=""ap"">'</xsl:variable>
		|              <xsl:value-of select=""'/'""/>
		|                <xsl:value-of select=""concat('namespace::*','[local-name() = ', $ap, local-name(), $ap, ']')""/>
		|            </xsl:when>
		|          </xsl:choose>
		|        </xsl:otherwise>
		|      </xsl:choose>
		|    </xsl:for-each>
		|
		|  </xsl:template>
		|
		|<!-- /path functions -->
		|";
КонецФункции

#КонецОбласти

// Область Конвертация JSON и другие типы: структура, XML и т.п.

// Конвертация

Функция СтруктураВСтрокуJSON(Значение) Экспорт
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	
	Для каждого ЭлементСтруктуры Из Значение Цикл
		Если ПустаяСтрока(ЭлементСтруктуры.Значение) И ЭлементСтруктуры.Значение <> "" Тогда
			// Преобразуем неопределено, NULL и незначащие символы в пустую строку.
			Значение[ЭлементСтруктуры.Ключ] = "";
		ИначеЕсли ТипЗнч(ЭлементСтруктуры.Значение) = Тип("Массив") Тогда
			
			Индекс = ЭлементСтруктуры.Значение.Количество() - 1;
			Пока Индекс >=0 Цикл
				Если ПустаяСтрока(ЭлементСтруктуры.Значение[Индекс].number) Тогда
					ЭлементСтруктуры.Значение.Удалить(Индекс);
				КонецЕсли;
				Индекс = Индекс - 1;
			КонецЦикла;
			
		КонецЕсли;
	КонецЦикла;
	
	ЗаписатьJSON(ЗаписьJSON, Значение,, "АдаптацияПолейКонтактнойИнформации", УправлениеКонтактнойИнформациейСлужебный);
	
	Возврат ЗаписьJSON.Закрыть();
	
КонецФункции

Функция АдаптацияПолейКонтактнойИнформации(Свойство, Значение, ДополнительныеПараметрыФункцииПреобразования, Отказ) Экспорт
	
	Если ТипЗнч(Значение) = Тип("УникальныйИдентификатор") Тогда
		Возврат Строка(Значение);
	КонецЕсли;
	
КонецФункции

Функция JSONВКонтактнуюИнформациюПоПолям(Значение, ТипКонтактнойИнформации) Экспорт
	
	Результат = Новый Структура();
	
	Если Метаданные.ОбщиеМодули.Найти("РаботаСАдресамиКлиентСервер") <> Неопределено Тогда
		МодульРаботаСАдресамиКлиентСервер = ОбщегоНазначения.ОбщийМодуль("РаботаСАдресамиКлиентСервер");
		Результат = МодульРаботаСАдресамиКлиентСервер.ОписаниеНовойКонтактнойИнформации(ТипКонтактнойИнформации);
	Иначе
		Результат = УправлениеКонтактнойИнформациейКлиентСервер.ОписаниеНовойКонтактнойИнформации(ТипКонтактнойИнформации);
	КонецЕсли;
	
	КонтактнаяИнформация = СтрокуJSONВСтруктуру(Значение);
	ЗаполнитьЗначенияСвойств(Результат, КонтактнаяИнформация);
	
	Возврат Результат;
	
КонецФункции

Функция СтрокуJSONВСтруктуру(Значение) Экспорт
	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(Значение);
	
	Результат = ПрочитатьJSON(ЧтениеJSON,,,, "ВосстановлениеПолейКонтактнойИнформации", УправлениеКонтактнойИнформациейСлужебный);
	
	ЧтениеJSON.Закрыть();
	
	Возврат Результат;
	
КонецФункции

Функция ВосстановлениеПолейКонтактнойИнформации(Свойство, Значение, ДополнительныеПараметрыФункцииПреобразования) Экспорт
	
	Если СтрЗаканчиваетсяНа(ВРег(Свойство), "ID") И СтрДлина(Значение) = 36 Тогда
		Возврат Новый УникальныйИдентификатор(Значение);
	КонецЕсли;
	
КонецФункции

Функция КонтактнаяИнформацияИзJSONВXML(Знач КонтактнаяИнформация, ОжидаемыйТип = Неопределено) Экспорт
	
	Если УправлениеКонтактнойИнформациейКлиентСервер.ЭтоКонтактнаяИнформацияВJSON(КонтактнаяИнформация) Тогда
		КонтактнаяИнформация = JSONВКонтактнуюИнформациюПоПолям(КонтактнаяИнформация, ОжидаемыйТип);
	КонецЕсли;
	
	Если ОжидаемыйТип = Неопределено Тогда
		
		Если ТипЗнч(КонтактнаяИнформация) = Тип("Структура") И КонтактнаяИнформация.Свойство("Type") Тогда
			
			ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации[КонтактнаяИнформация.Type];
			
		ИначеЕсли УправлениеКонтактнойИнформациейКлиентСервер.ЭтоКонтактнаяИнформацияВXML(КонтактнаяИнформация) Тогда
			КонтактнаяИнформацияXML = ПривестиКонтактнуюИнформациюXML(КонтактнаяИнформация);
			ОжидаемыйТип = КонтактнаяИнформацияXML.ТипКонтактнойИнформации;
		Иначе
			ТекстОшибки = НСтр("ru='Ошибка конвертации контактной информации из формата JSON в XML.'");
			ЗаписьЖурналаРегистрации(ОбновлениеИнформационнойБазы.СобытиеЖурналаРегистрации(), 
				УровеньЖурналаРегистрации.Ошибка,,,
				ТекстОшибки + Символы.ПС + Строка(КонтактнаяИнформация));
			ВызватьИсключение НСтр("ru='Не удалось определить тип контактной информации. Подробнее см. в журнале регистрации.'");
		КонецЕсли;
		
	КонецЕсли;
	
	ПространствоИмен = ПространствоИмен();

	ЭтоНовый = ПустаяСтрока(КонтактнаяИнформация);
	Представление = "";
	
	Результат = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "КонтактнаяИнформация"));
	
	// Разбор
	Если ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Адрес Тогда
		Если ЭтоНовый Тогда
			Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "Адрес"));
		Иначе
			Результат = КонвертироватьАдресИзJSONВXML(КонтактнаяИнформация, Представление, ОжидаемыйТип);
		КонецЕсли;
		
	ИначеЕсли ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Телефон Тогда
		Если ЭтоНовый Тогда
			Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "НомерТелефона"));
		Иначе
			Результат = КонвертироватьТелефонФаксИзJSONВXML(КонтактнаяИнформация, Представление, ОжидаемыйТип)
		КонецЕсли;
		
	ИначеЕсли ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Факс Тогда
		Если ЭтоНовый Тогда
			Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "НомерФакса"));
		Иначе
			Результат = КонвертироватьТелефонФаксИзJSONВXML(КонтактнаяИнформация, Представление, ОжидаемыйТип)
		КонецЕсли;
		
	ИначеЕсли ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.АдресЭлектроннойПочты Тогда
		Если ЭтоНовый Тогда
			Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "ЭлектроннаяПочта"));
		Иначе
			Результат = КонвертироватьПрочуюКонтактнуюИнформациюИзJSONВXML(КонтактнаяИнформация, Представление, ОжидаемыйТип)
		КонецЕсли;
	ИначеЕсли ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Skype Тогда
		Если ЭтоНовый Тогда
			Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "Skype"));
		Иначе
			Результат = КонвертироватьПрочуюКонтактнуюИнформациюИзJSONВXML(КонтактнаяИнформация, Представление, ОжидаемыйТип)
		КонецЕсли;
	ИначеЕсли ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.ВебСтраница Тогда
		Если ЭтоНовый Тогда
			Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "ВебСайт"));
		Иначе
			Результат = КонвертироватьПрочуюКонтактнуюИнформациюИзJSONВXML(КонтактнаяИнформация, Представление, ОжидаемыйТип)
		КонецЕсли;
		
	ИначеЕсли ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Другое Тогда
		Если ЭтоНовый Тогда
			Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "Прочее"));
		Иначе
			Результат = КонвертироватьПрочуюКонтактнуюИнформациюИзJSONВXML(КонтактнаяИнформация, Представление, ОжидаемыйТип)
		КонецЕсли;
		
	Иначе
		ТекстОшибки = НСтр("ru = 'Сведения о виде контактной информации %1 были повреждены или некорректно заполнены,
								|т.к. обязательное поле тип не заполнено.'");
		ТекстОшибки =  СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстОшибки, ?(ЗначениеЗаполнено(ОжидаемыйТип), """" + СокрЛП(ОжидаемыйТип) + """", ""));
	КонецЕсли;
	
	Возврат КонтактнаяИнформацияXDTOВXML(Результат);
	
КонецФункции

// Внутреннее для сериализации.
Функция КонвертироватьАдресИзJSONВXML(Знач ЗначенияПолей, Знач Представление, Знач ОжидаемыйТип = Неопределено)
	
	Если Метаданные.ОбщиеМодули.Найти("РаботаСАдресами") <> Неопределено Тогда
		МодульРаботаСАдресами = ОбщегоНазначения.ОбщийМодуль("РаботаСАдресами");
		Возврат МодульРаботаСАдресами.КонвертироватьАдресИзJSONВXML(ЗначенияПолей, Представление, ОжидаемыйТип);
	КонецЕсли;
	
	// Старый формат через разделитель строк и равенство.
	ПространствоИмен = ПространствоИмен();
	
	Результат = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "КонтактнаяИнформация"));
	Результат.Состав      = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "Адрес"));
	
	// Общий состав
	Адрес = Результат.Состав;
	
	ПолеПредставления      = "";
	
	Для Каждого ЭлементСписка Из ЗначенияПолей Цикл
		
		Если ПустаяСтрока(ЭлементСписка.Значение) Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяПоля = ВРег(ЭлементСписка.Ключ);
		
		Если ИмяПоля = "COMMENT" Тогда
			Комментарий = СокрЛП(ЭлементСписка.Значение);
			Если ЗначениеЗаполнено(Комментарий) Тогда
				Результат.Комментарий = Комментарий;
			КонецЕсли;
			
		ИначеЕсли ИмяПоля = "COUNTRY" Тогда
			Адрес.Страна = Строка(ЭлементСписка.Значение);
			
		ИначеЕсли ИмяПоля = "VALUE" Тогда
			ПолеПредставления = СокрЛП(ЭлементСписка.Значение);
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Представление с приоритетами.
	Если Не ПустаяСтрока(Представление) Тогда
		Результат.Представление = Представление;
	Иначе
		Результат.Представление = ПолеПредставления;
	КонецЕсли;
	
	Адрес.Состав = Результат.Представление;
	
	Возврат Результат;
КонецФункции

Функция КонвертироватьТелефонФаксИзJSONВXML(ЗначенияПолей, Представление = "", ОжидаемыйТип = Неопределено)
	
	Если УправлениеКонтактнойИнформациейКлиентСервер.ЭтоКонтактнаяИнформацияВXML(ЗначенияПолей) Тогда
		// Общий формат контактной информации.
		Возврат КонтактнаяИнформацияИзXML(ЗначенияПолей, ОжидаемыйТип);
	КонецЕсли;
	
	ПространствоИмен = ПространствоИмен();
	
	Если ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Телефон Тогда
		Данные = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "НомерТелефона"));
		
	ИначеЕсли ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Факс Тогда
		Данные = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "НомерФакса"));
		
	ИначеЕсли ОжидаемыйТип = Неопределено Тогда
		// Считаем телефоном
		Данные = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "НомерТелефона"));
		
	Иначе
		ВызватьИсключение НСтр("ru='Ошибка преобразования контактной информации, ожидается телефон или факс'");
	КонецЕсли;
	
	Результат = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "КонтактнаяИнформация"));
	Результат.Состав        = Данные;
	
	ПолеПредставления = "";
	Для Каждого ЗначениеПоля Из ЗначенияПолей Цикл
		Поле = ВРег(ЗначениеПоля.Ключ);
		
		Если Поле = "COUNTRYCODE" Тогда
			Данные.КодСтраны = ЗначениеПоля.Значение;
			
		ИначеЕсли Поле = "AREACODE" Тогда
			Данные.КодГорода = ЗначениеПоля.Значение;
			
		ИначеЕсли Поле = "NUMBER" Тогда
			Данные.Номер = ЗначениеПоля.Значение;
			
		ИначеЕсли Поле = "EXTNUMBER" Тогда
			Данные.Добавочный = ЗначениеПоля.Значение;
			
		ИначеЕсли Поле = "VALUE" Тогда
			ПолеПредставления = СокрЛП(ЗначениеПоля.Значение);
			
		ИначеЕсли Поле = "COMMENT" Тогда
			Комментарий = СокрЛП(ЗначениеПоля.Значение);
			Если ЗначениеЗаполнено(Комментарий) Тогда
				Результат.Комментарий = Комментарий;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Представление с приоритетами.
	Если Не ПустаяСтрока(Представление) Тогда
		Результат.Представление = Представление;
	ИначеЕсли ЗначениеЗаполнено(ПолеПредставления) Тогда
		Результат.Представление = ПолеПредставления;
	Иначе
		Результат.Представление = ПредставлениеТелефона(Данные);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Преобразует строку в XDTO прочую контактную информацию.
//
// Параметры:
//   ЗначенияПолей - Строка - сериализованная информация, значения полей.
//   Представление - Строка - представление старший-младший, используется для попытки разбора, если ЗначенияПолей пусто.
//   ОжидаемыйТип  - ПеречислениеСсылка.ТипыКонтактнойИнформации - необязательный тип для контроля.
//
// Возвращаемое значение:
//   ОбъектXDTO  - контактной информации.
//
Функция КонвертироватьПрочуюКонтактнуюИнформациюИзJSONВXML(ЗначенияПолей, Знач Представление = "", ОжидаемыйТип = Неопределено)
	
	Если УправлениеКонтактнойИнформациейКлиентСервер.ЭтоКонтактнаяИнформацияВXML(ЗначенияПолей) Тогда
		// Общий формат контактной информации.
		Возврат КонтактнаяИнформацияИзXML(ЗначенияПолей, ОжидаемыйТип);
	КонецЕсли;
	
	ПространствоИмен = ПространствоИмен();
	Результат = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "КонтактнаяИнформация"));
	
	Если ПустаяСтрока(Представление) И ЗначенияПолей.Свойство("Value") И ЗначениеЗаполнено(ЗначенияПолей.Value) Тогда
		Представление = ЗначенияПолей.Value;
	КонецЕсли;
	
	Результат.Представление = Представление;
	
	Если ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.АдресЭлектроннойПочты Тогда
		Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "ЭлектроннаяПочта"));
		
	ИначеЕсли ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.ВебСтраница Тогда
		Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "ВебСайт"));
		
	ИначеЕсли ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Skype Тогда
		Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "Skype"));
		
	ИначеЕсли ОжидаемыйТип = Перечисления.ТипыКонтактнойИнформации.Другое Тогда
		Результат.Состав = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(ПространствоИмен, "Прочее"));
		
	ИначеЕсли ОжидаемыйТип <> Неопределено Тогда
		ВызватьИсключение НСтр("ru = 'Ошибка десериализации контактной информации, ожидается другой тип'");
		
	КонецЕсли;
	
	Результат.Состав.Значение = Представление;
	
	Комментарий = "";
	Если ЗначенияПолей.Свойство("Comment") И ЗначениеЗаполнено(ЗначенияПолей.Comment) Тогда
		Комментарий = СокрЛП(ЗначенияПолей.Comment);
		Если ЗначениеЗаполнено(Комментарий) Тогда
			Результат.Комментарий = Комментарий;
		КонецЕсли;
	КонецЕсли;
	
	
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти


