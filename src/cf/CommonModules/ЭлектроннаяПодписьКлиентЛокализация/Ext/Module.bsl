///////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2024, ООО 1С-Софт
// Все права защищены. Эта программа и сопроводительные материалы предоставляются 
// в соответствии с условиями лицензии Attribution 4.0 International (CC BY 4.0)
// Текст лицензии доступен по ссылке:
// https://creativecommons.org/licenses/by/4.0/legalcode
///////////////////////////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Код линии технической поддержки.
// 
// Параметры:
//  Получатель - Строка
//
Процедура ПриОпределенииПолучателяОбращенияВТехническуюПоддержку(Получатель) Экспорт
	
	// Локализация
	Получатель = "edo";
	// Конец Локализация
	
КонецПроцедуры

// Фильтр для выбора подписей.
// 
// Параметры:
//  Фильтр - Строка
//
Процедура ПриПолученииФильтраДляВыбораПодписей(Фильтр) Экспорт
	
	// Локализация
	Если ОбщегоНазначенияКлиент.ПодсистемаСуществует("СтандартныеПодсистемы.МашиночитаемыеДоверенности") Тогда
		Фильтр = НСтр("ru = 'Файлы подписи (*.p7s, *.sig%1), МЧД (*.xml, *.zip)|*.p7s;*.sig%2;*.xml;*.zip'");
	КонецЕсли;
	// Конец Локализация
	
КонецПроцедуры

// При получении списка выбора машиночитаемых доверенностей в форме добавления подписей из файла.
// 
// Параметры:
//  Форма - см. ОбщаяФорма.ДобавлениеЭлектроннойПодписиИзФайла
//  ТекущиеДанные - ДанныеФормыЭлементКоллекции - строка подписи в форме ОбщаяФорма.ДобавлениеЭлектроннойПодписиИзФайла
//  СписокВыбора - СписокЗначений
//
Процедура ПриПолученииСпискаВыбораМашиночитаемыхДоверенностей(Форма, ТекущиеДанные, СписокВыбора) Экспорт
	
	// Локализация
	
	Доверенности = Форма.Доверенности;
	Если ЗначениеЗаполнено(ТекущиеДанные.ПоляОтбора) Тогда
		ПоляОтбора = СтрРазделить(ТекущиеДанные.ПоляОтбора, ";");
		
		Для Каждого Доверенность Из Доверенности Цикл
			Для Каждого Элемент Из ПоляОтбора Цикл
				Если СтрНайти(Доверенность.ПоляОтбора, Элемент) <> 0 Тогда
					СписокВыбора.Добавить(Доверенность.НомерДоверенности, Доверенность.МашиночитаемаяДоверенность);
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	
	// Конец Локализация
	
КонецПроцедуры

// При выборе машиночитаемой доверенности в форме добавления подписей из файла.
// 
// Параметры:
//  ОбработчикЗавершения - ОписаниеОповещения
//  ТекущиеДанные - ДанныеФормыЭлементКоллекции - строка подписи в форме ОбщаяФорма.ДобавлениеЭлектроннойПодписиИзФайла 
//
Процедура ПриВыбореМашиночитаемойДоверенности(ОбработчикЗавершения, ТекущиеДанные) Экспорт
	
	// Локализация
	
	Если Не ОбщегоНазначенияКлиент.ПодсистемаСуществует("СтандартныеПодсистемы.МашиночитаемыеДоверенности") Тогда
		Возврат;
	КонецЕсли;
	
	СвойстваПодписи = ПолучитьИзВременногоХранилища(ТекущиеДанные.АдресСвойствПодписи);
	
	ПараметрыФормы = Новый Структура;
	ПараметрыФормы.Вставить("СертификатПредставителя", СвойстваПодписи.Сертификат);
	ПараметрыФормы.Вставить("НаДату", СвойстваПодписи.ДатаПодписи);
	ПараметрыФормы.Вставить("ТолькоДействующие", Истина);
	ПараметрыФормы.Вставить("РежимВыбора", Истина);

	МодульМашиночитаемыеДоверенностиФНСКлиент = ОбщегоНазначенияКлиент.ОбщийМодуль("МашиночитаемыеДоверенностиФНСКлиент");
	МодульМашиночитаемыеДоверенностиФНСКлиент.ОткрытьСписокМЧД(ПараметрыФормы, ОбработчикЗавершения);
	
	// Конец Локализация
	
КонецПроцедуры

// Добавляет в список сохраняемых файлы машиночитаемых доверенностей при сохранении подписей.
// 
// Параметры:
//  ФайлыМашиночитаемыхДоверенностей - Соответствие
//  КоллекцияПодписей - ДанныеФормыКоллекция
//
Процедура ПриОпределенииФайловМашиночитаемыхДоверенностей(ФайлыМашиночитаемыхДоверенностей,
		КоллекцияПодписей) Экспорт
		
	// Локализация
	
	Если Не ОбщегоНазначенияКлиент.ПодсистемаСуществует("СтандартныеПодсистемы.МашиночитаемыеДоверенности") Тогда
		Возврат;
	КонецЕсли;
	
	МашиночитаемыеДоверенности = Новый Массив;
		
	Для Каждого Подпись Из КоллекцияПодписей Цикл
		Для Каждого МашиночитаемаяДоверенность Из Подпись.МашиночитаемаяДоверенность Цикл
			Если МашиночитаемыеДоверенности.Найти(МашиночитаемаяДоверенность.Значение) = Неопределено Тогда
				МашиночитаемыеДоверенности.Добавить(МашиночитаемаяДоверенность.Значение);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;

	Если МашиночитаемыеДоверенности.Количество() > 0 Тогда
		МодульМашиночитаемыеДоверенностиФНССлужебныйВызовСервера = ОбщегоНазначенияКлиент.ОбщийМодуль(
			"МашиночитаемыеДоверенностиФНССлужебныйВызовСервера");
		ФайлыМашиночитаемыхДоверенностей = МодульМашиночитаемыеДоверенностиФНССлужебныйВызовСервера.ФайлыДоверенностей(
			МашиночитаемыеДоверенности, Ложь);
	КонецЕсли;
	
	// Конец Локализация
	
КонецПроцедуры

// При проверке конфликта программ криптографии.
// 
// Параметры:
//  Форма - ФормаКлиентскогоПриложения
//  РезультатПроверки - Структура
//
Процедура ПриПроверкеКонфликтаПрограммКриптографии(Форма, РезультатПроверки) Экспорт
	
	// Локализация
	Элементы = Форма.Элементы;
	МассивПрограмм = Новый Массив;
	Для Каждого Программа Из РезультатПроверки.Программы Цикл
		Если ЗначениеЗаполнено(Программа.Программа) И МассивПрограмм.Найти(Программа.Программа) = Неопределено Тогда
			МассивПрограмм.Добавить(Программа.Программа);
		КонецЕсли;
	КонецЦикла;

	Элементы.ГруппаПодсказкаКриптопровайдеры.Видимость = Истина;
	Элементы.ДекорацияПроверкаУстановкиКриптопровайдера.Заголовок = СтроковыеФункцииКлиент.ФорматированнаяСтрока(
			НСтр("ru = 'На вашем компьютере установлено несколько приложений с алгоритмами ГОСТ: %1.
				 |Возможна некорректная работа из-за конфликта между ними. В этом случае следует удалить приложения и после перезагрузки установить только одно из них.'"),
		СтрСоединить(МассивПрограмм, ", "));
	Элементы.ДекорацияИнформацияКриптопровайдеры.Картинка = БиблиотекаКартинок.Предупреждение;
	// Конец Локализация
	
КонецПроцедуры

// При проверке установленных программ криптографии.
// 
// Параметры:
//  Форма - ФормаКлиентскогоПриложения
//  РезультатПроверки - Структура
//  ЕстьПроверяемыеПрограммы - Булево
//
Процедура ПриПроверкеУстановленныхПрограммКриптографии(Форма, РезультатПроверки, ЕстьПроверяемыеПрограммы) Экспорт
	
	// Локализация
	
	Элементы = Форма.Элементы;
	Если Не ЕстьПроверяемыеПрограммы Тогда
		Элементы.ГруппаПодсказкаКриптопровайдеры.Видимость = Истина;
		Если РезультатПроверки.Токены.Количество() > 0 Тогда
			Элементы.ДекорацияПроверкаУстановкиКриптопровайдера.Заголовок = СтроковыеФункцииКлиент.ФорматированнаяСтрока(
				НСтр("ru = 'Для работы с усиленной квалифицированной электронной подписью на компьютере должно быть установлено сертифицированное приложение (средство криптографической защиты информации). <a href = ""%1"">Установить</a>.
					|<a href = ""%2"">Подробнее о работе с токенами без установки приложения</a>.'"),
						"ПроверитьУстановкуПрограммКриптографии",
						ЭлектроннаяПодписьСлужебныйКлиентСервер.ДействиеУстановитьБиблиотекиДляТокенов());
		Иначе
			Элементы.ДекорацияПроверкаУстановкиКриптопровайдера.Заголовок = СтроковыеФункцииКлиент.ФорматированнаяСтрока(
				НСтр("ru = 'Для работы с усиленной квалифицированной электронной подписью на компьютере должно быть установлено сертифицированное приложение (средство криптографической защиты информации).
					|<a href = ""%1"">Установить.</a>'"), "ПроверитьУстановкуПрограммКриптографии");
		КонецЕсли;
	КонецЕсли;

	// Конец Локализация
	
КонецПроцедуры

// Определяет подключенные токены к устройству.
// 
// Параметры:
//  ОбъектКомпоненты - Неопределено, ОбъектВнешнейКомпоненты.
//  ПредложитьУстановить - Булево - Предложить установить компоненту, если не установлена.
// 
// Возвращаемое значение:
//  Обещание - Структура
//
Асинх Функция УстановленныеТокены(ОбъектКомпоненты = Неопределено, ПредложитьУстановить = Ложь) Экспорт

	Результат = Новый Структура;
	Результат.Вставить("ПроверкаВыполнена", Ложь);
	Результат.Вставить("Токены", Новый Массив);
	Результат.Вставить("Ошибка", "");
	
	// Локализация
	
	Если ОбъектКомпоненты = Неопределено Тогда
		ТекстПояснения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Для получения данных о токенах требуется установка внешней компоненты %1.'"),
			"ExtraCryptoAPI");
		Попытка
			ОбъектКомпоненты = Ждать ЭлектроннаяПодписьСлужебныйКлиент.ОбъектВнешнейКомпонентыExtraCryptoAPI(ПредложитьУстановить, ТекстПояснения);
		Исключение
			Результат.Ошибка = ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
			Возврат Результат;
		КонецПопытки;
	КонецЕсли;
	
	Ждать ОчиститьОшибкиКомпоненты(ОбъектКомпоненты);
	
	Попытка
		ТипыУстройств = Ждать ОбъектКомпоненты.PKCS11ПолучитьПоддерживаемыеБэкендыАсинх();
		Ждать ОшибкаКомпоненты(ОбъектКомпоненты);
		ТипыУстройств = СтрРазделить(ТипыУстройств.Значение, "; ");
	Исключение
		Результат.Ошибка = ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		Возврат Результат;
	КонецПопытки;

	СтрокиУстройств = Новый Соответствие;
	СтрокиТокенов = Новый Соответствие;
	Библиотеки = Новый Соответствие;
	
	Для Каждого ТипУстройства Из ТипыУстройств Цикл
		
		СвойстваТокена = ЭлектроннаяПодписьСлужебныйКлиент.НовыеСвойстваТокена();
		СвойстваТокена.Токен = ТипУстройства;
		СвойстваТокена.Представление = МодельТокена(ТипУстройства);
		СвойстваТокена.СерийныйНомер = ТипУстройства;
		
		ТекстОшибки = "";
		Если ТипУстройства = Рутокен() Тогда
			СистемнаяИнформация = Новый СистемнаяИнформация();
			Если СтрНайти(СистемнаяИнформация.ВерсияОС, "Microsoft Windows 7") Тогда
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Версия операционной системы Microsoft Windows 7 не подходит для работы с токеном %1.
					|Требуется более новая версия Windows или токен JaCarta.'"), 
					СвойстваТокена.Представление);
			КонецЕсли;
		КонецЕсли;
		
		Если ТекстОшибки = "" Тогда
			ОшибкаИнициализацииТокена = "";
			БиблиотекиТокена = "";
			Попытка
				НастройкиТокена = Ждать ОбъектКомпоненты.PKCS11ПолучитьНастройкиБэкендаПоУмолчаниюАсинх(ТипУстройства);
				Ждать ОшибкаКомпоненты(ОбъектКомпоненты);
				БиблиотекиТокена = НастройкиТокена.Значение;
				Если ЗначениеЗаполнено(БиблиотекиТокена) Тогда
					СвойстваТокена.Библиотеки =  ПрочитатьЗначениеJSON(БиблиотекиТокена);
					Библиотеки.Вставить(ТипУстройства, СвойстваТокена.Библиотеки);
				КонецЕсли;
				
				Если Не ЗначениеЗаполнено(СвойстваТокена.Библиотеки.pkcs11_library_path) Тогда
					Если ТипУстройства = Рутокен() Тогда
						ОшибкаИнициализацииТокена = ЭлектроннаяПодписьКлиентСерверЛокализация.НеУстановленаПанельРутокен();
					Иначе
						ОшибкаИнициализацииТокена = ЭлектроннаяПодписьКлиентСерверЛокализация.НеУстановленЕдиныйКлиентДжакарта();
					КонецЕсли;
				Иначе
					Ждать ОбъектКомпоненты.PKCS11ИнициализацияАсинх(БиблиотекиТокена);
					Ждать ОшибкаКомпоненты(ОбъектКомпоненты);
				КонецЕсли;
				
			Исключение
				ОшибкаИнициализацииТокена = ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
			КонецПопытки;

			Если ЗначениеЗаполнено(ОшибкаИнициализацииТокена) Тогда

				Если ЭтоОшибкаЗагрузкиБиблиотеки(ОшибкаИнициализацииТокена) Тогда
					Если ТипУстройства = Рутокен() Тогда
						СвойстваТокена.Ошибка = ЭлектроннаяПодписьКлиентСерверЛокализация.НеУстановленаПанельРутокен();
					Иначе
						СвойстваТокена.Ошибка = ЭлектроннаяПодписьКлиентСерверЛокализация.НеУстановленЕдиныйКлиентДжакарта();
					КонецЕсли;
				ИначеЕсли Не ЗначениеЗаполнено(БиблиотекиТокена) Тогда
					СвойстваТокена.Ошибка = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = '%1: Не удалось получить настройки для работы с токеном: %2'"),
						СвойстваТокена.Представление, ОшибкаИнициализацииТокена);
				Иначе
					СвойстваТокена.Ошибка = ОшибкаИнициализацииТокена;
				КонецЕсли;
			Иначе
				СвойстваТокена.Ошибка = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = '%1: %2.'"), СвойстваТокена.Представление,
					ЭлектроннаяПодписьСлужебныйКлиент.ОшибкаНеНайденТокен());
			КонецЕсли;
		Иначе
			СвойстваТокена.Ошибка = ТекстОшибки;
		КонецЕсли;
		
		СтрокиУстройств.Вставить(ТипУстройства, СвойстваТокена);
		
	КонецЦикла;
	
	ОшибкаПолученияСлотов = "";
		
	Попытка
		СписокСлотов = Ждать ОбъектКомпоненты.PKCS11ПолучитьСписокСлотовАсинх(Истина);
		Ждать ОшибкаКомпоненты(ОбъектКомпоненты);
	Исключение
		ОшибкаПолученияСлотов = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось получить список токенов. %1'"),
			ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	ТокенНеВставлен = Не ЗначениеЗаполнено(ОшибкаПолученияСлотов) И (СписокСлотов.Значение = Неопределено Или СписокСлотов.Значение = "null");
	
	Если Не ЗначениеЗаполнено(ОшибкаПолученияСлотов) И Не ТокенНеВставлен Тогда

		СписокСлотов = ЭлектроннаяПодписьСлужебныйКлиентСервер.ПрочитатьОтветКомпоненты(СписокСлотов.Значение);

		Для Каждого Слот Из СписокСлотов Цикл
			Если Слот.Ключ <> "available slot number" Тогда
				Продолжить;
			КонецЕсли;
			ЗначенияСлотов = Слот.Значение;
			Для Каждого ЗначениеСлота Из ЗначенияСлотов Цикл

				ТипУстройства = ТипУстройства(ЗначениеСлота);

				СвойстваТокена = ЭлектроннаяПодписьСлужебныйКлиент.НовыеСвойстваТокена();
				СвойстваТокена.Слот = ЗначениеСлота;
				СвойстваТокена.Токен = ТипУстройства;
				СвойстваТокена.Представление = СтрШаблон("%1 %2", МодельТокена(ТипУстройства), СвойстваТокена.Слот);
				СвойстваТокена.Библиотеки = Библиотеки.Получить(ТипУстройства);

				Если СтрокиУстройств.Получить(ТипУстройства) <> Неопределено Тогда
					СтрокиУстройств.Удалить(ТипУстройства);
				КонецЕсли;
			
				Попытка
					ИнформацияОТокене = Ждать ОбъектКомпоненты.PKCS11ПолучитьИнформациюОТокенеАсинх(ЗначениеСлота);
					Ждать ОшибкаКомпоненты(ОбъектКомпоненты);
				Исключение
					СвойстваТокена.Ошибка = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Не удалось получить информацию о токене в слоте %1. %2'"),
						ЗначениеСлота, ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
					СтрокиТокенов.Вставить(ТипУстройства, СвойстваТокена);
					Продолжить;
				КонецПопытки;

				Информация = ЭлектроннаяПодписьСлужебныйКлиентСервер.ПрочитатьОтветКомпоненты(ИнформацияОТокене.Значение);
				СвойстваТокена.СерийныйНомер = Информация.Получить("serial_number");
				Модель = Информация.Получить("model");
				СвойстваТокена.Модель = МодельТокена(Модель, ТипУстройства);
				СвойстваТокена.Представление = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			 		НСтр("ru = '%1 (серийный номер %2)'"), СвойстваТокена.Модель,
			 		ПредставлениеСерийногоНомера(ТипУстройства, СвойстваТокена.СерийныйНомер));

				Попытка
					СписокМеханизмов = Ждать ОбъектКомпоненты.PKCS11ПолучитьСписокПоддерживаемыхМеханизмовАсинх(ЗначениеСлота);
					Ждать ОшибкаКомпоненты(ОбъектКомпоненты);
				Исключение
					ОшибкаПолученияМеханизмовТокена = ОбработкаОшибок.КраткоеПредставлениеОшибки(
						ИнформацияОбОшибке());
					Если ЭтоОшибкаПолученияМеханизмовТокена(ОшибкаПолученияМеханизмовТокена) Тогда
						СвойстваТокена.Ошибка = НСтр("ru = 'Использование токена возможно вместе с приложением для работы с электронной подписью.'");
					Иначе
						СвойстваТокена.Ошибка = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
							НСтр("ru = 'Не удалось получить информацию о механизмах токена: %1'"),
							ОшибкаПолученияМеханизмовТокена);
					КонецЕсли;
					СтрокиТокенов.Вставить(ТипУстройства, СвойстваТокена);
					Продолжить;
				КонецПопытки;

				СвойстваТокена.Механизмы = СписокМеханизмов.Значение;
				СтрокиТокенов.Вставить(ТипУстройства, СвойстваТокена);
				
			КонецЦикла;
		КонецЦикла;
	ИначеЕсли Не ТокенНеВставлен И Не ЭтоОшибкаЗагрузкиБиблиотеки(ОшибкаПолученияСлотов) Тогда
		Для Каждого КлючИЗначение Из СтрокиУстройств Цикл
			КлючИЗначение.Значение.Ошибка = ОшибкаПолученияСлотов + Символы.ПС + КлючИЗначение.Значение.Ошибка;
		КонецЦикла;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из СтрокиТокенов Цикл
		Результат.Токены.Добавить(КлючИЗначение.Значение);
	КонецЦикла;
	Для Каждого КлючИЗначение Из СтрокиУстройств Цикл
		Результат.Токены.Добавить(КлючИЗначение.Значение);
	КонецЦикла;
	
	// Конец Локализация
	
	Возврат Результат;
	
КонецФункции

// Получить свойства сертификатов на токенах.
// 
// Параметры:
//  Контекст - Структура:
//    * МассивСертификатов - Массив
//  ПредложитьУстановить - Булево - Предложить установить компоненту, если не установлена.
// 
// Возвращаемое значение:
//    Обещание - Контекст
//
Асинх Функция ПолучитьСвойстваСертификатовНаТокенах(Контекст, ПредложитьУстановить) Экспорт
	
	// Локализация
	Токены = Ждать СертификатыНаТокенах(ПредложитьУстановить);
	
	Для Каждого Токен Из Токены Цикл
		Если Токен.Сертификаты = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Для Каждого СвойстваСертификата Из Токен.Сертификаты Цикл
			СертификатКриптографии = Новый СертификатКриптографии;
			Ждать СертификатКриптографии.ИнициализироватьАсинх(СвойстваСертификата.Значение);
			Контекст.МассивСертификатов.Добавить(СертификатКриптографии);
		КонецЦикла;
	КонецЦикла;
	// Конец Локализация 
	
	Возврат Контекст;
	
КонецФункции

// Возвращает отпечатки сертификатов на токенах.
// 
// Параметры:
//  ПредложитьУстановить - Булево - Предложить установить компоненту, если не установлена.
//  ВключаяПросроченные - Булево - если Ложь, возвращаются только отпечатки действующих сертификатов.
// 
// Возвращаемое значение:
//    Обещание - Массив
//
Асинх Функция ПолучитьОтпечаткиСертификатовНаТокенах(ПредложитьУстановить, ВключаяПросроченные = Ложь) Экспорт
	
	МассивОтпечатков = Новый Массив;
	
	// Локализация
	Токены = Ждать СертификатыНаТокенах(ПредложитьУстановить);
	
	Для Каждого Токен Из Токены Цикл
		Если Токен.Сертификаты = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Для Каждого СвойстваСертификата Из Токен.Сертификаты Цикл
			Если ВключаяПросроченные Тогда
				МассивОтпечатков.Добавить(СвойстваСертификата.Ключ);
			Иначе
				СертификатКриптографии = Новый СертификатКриптографии;
				Ждать СертификатКриптографии.ИнициализироватьАсинх(СвойстваСертификата.Значение);
				ДатыСертификата = ЭлектроннаяПодписьСлужебныйКлиентСервер.ДатыСертификата(СертификатКриптографии,
					ЭлектроннаяПодписьСлужебныйКлиент.РазницаСУниверсальнымВременем());
				Если ДатыСертификата.ДействителенДо >= ОбщегоНазначенияКлиент.ДатаСеанса() Тогда
					МассивОтпечатков.Добавить(СвойстваСертификата.Ключ);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	// Конец Локализация 
	
	Возврат МассивОтпечатков;
	
КонецФункции

// Сертификаты на токенах.
// 
// Параметры:
//  ПредложитьУстановить - Булево - Предложить установить.
//  Обновить - Булево - Обновить список сертификатов на токене в кэше.
// 
// Возвращаемое значение:
//  Обещание - Массив Из Структура - Токены
//  
Асинх Функция СертификатыНаТокенах(ПредложитьУстановить, Обновить = Ложь) Экспорт
	
	УстановленныеКриптопровайдеры = Ждать ЭлектроннаяПодписьСлужебныйКлиент.УстановленныеКриптопровайдерыИзКэша(ПредложитьУстановить);
	Токены = УстановленныеКриптопровайдеры.Токены;
	ЗаписатьТокеныВКэш = Ложь;
	
	// Локализация

	Для Каждого Токен Из Токены Цикл
		
		Если Не ЗначениеЗаполнено(Токен.Слот) Тогда
			Продолжить;
		КонецЕсли;
		
		Если Токен.Сертификаты <> Неопределено И Не Обновить Тогда
			Продолжить;
		КонецЕсли;
		
		Сертификаты = Новый Соответствие;
		Результат = Ждать СертификатыНаТокене(Токен, Неопределено, ПредложитьУстановить);
		Если Результат.ПроверкаВыполнена Тогда
		
			Ошибки = Новый Массив;
			Для Каждого Сертификат Из Результат.Сертификаты Цикл
				СертификатКриптографии = Ждать ЭлектроннаяПодписьСлужебныйКлиент.СертификатИзСтроки(Сертификат);
				Если ТипЗнч(СертификатКриптографии) = Тип("Строка") Тогда
					Ошибки.Добавить(СертификатКриптографии);
					Продолжить;
				КонецЕсли;
				Сертификаты.Вставить(Base64Строка(СертификатКриптографии.Отпечаток), Ждать СертификатКриптографии.ВыгрузитьАсинх());
			КонецЦикла;
			
			Если Ошибки.Количество() > 0 Тогда
				Токен.Ошибка = СтрСоединить(Ошибки, Символы.ПС);
			КонецЕсли;
		Иначе
			Токен.Ошибка = Результат.Ошибка;
		КонецЕсли;
		
		ЗаписатьТокеныВКэш = Истина;
		Токен.Сертификаты = Сертификаты;
		
	КонецЦикла;
	
	// Конец Локализация
	
	Если ЗаписатьТокеныВКэш Тогда
		УстановленныеКриптопровайдеры.Токены = Токены;
		ЭлектроннаяПодписьСлужебныйКлиент.ЗаписатьВКэшУстановленныеКриптопровайдеры(УстановленныеКриптопровайдеры)
	КонецЕсли;
	
	Возврат Токены;
	
КонецФункции

// Сертификаты на токене.
// 
// Параметры:
//  Токен - Структура
//  ОбъектКомпоненты - Неопределено, ОбъектВнешнейКомпоненты
//  ПредложитьУстановить - Булево - Предложить установить
// 
// Возвращаемое значение:
//  Обещание - Структура
//
Асинх Функция СертификатыНаТокене(Токен, ОбъектКомпоненты = Неопределено, ПредложитьУстановить = Ложь) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ПроверкаВыполнена", Ложь);
	Результат.Вставить("Сертификаты", Новый Массив);
	Результат.Вставить("Ошибка", "");
	
	// Локализация
	
	Если ОбъектКомпоненты = Неопределено Тогда
		Попытка
			ОбъектКомпоненты = Ждать ЭлектроннаяПодписьСлужебныйКлиент.ОбъектВнешнейКомпонентыExtraCryptoAPI(ПредложитьУстановить);
		Исключение
			Результат.Ошибка = ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
			Возврат Результат;
		КонецПопытки;
	КонецЕсли;
	
	Ждать ОчиститьОшибкиКомпоненты(ОбъектКомпоненты);
	
	Попытка
		СертификатыНаТокене = Ждать ОбъектКомпоненты.PKCS11ПолучитьСписокСертификатовАсинх(Токен.Слот);
		Ждать ОшибкаКомпоненты(ОбъектКомпоненты);
		Результат.ПроверкаВыполнена = Истина;
		Результат.Сертификаты = ЭлектроннаяПодписьСлужебныйКлиентСервер.ПрочитатьОтветКомпоненты(СертификатыНаТокене.Значение);
	Исключение
		ТекстОшибки = ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		Если ЭтоОшибкаИнициализацииСлота(ТекстОшибки) Тогда
			Возврат ОшибкаИнициализацииСлота(Токен);
		Иначе
			Результат.Ошибка = ТекстОшибки;
		КонецЕсли;
		Возврат Результат;
	КонецПопытки;
	
	// Конец Локализация
	
	Возврат Результат;
	
КонецФункции

// Токен для шифрования.
// 
// Параметры:
//  Сертификат - СертификатКриптографии
//  АлгоритмШифрования - Строка - OID или см. ЭлектроннаяПодписьКлиент.Зашифровать.ОписаниеДанных.АлгоритмШифрования 
//  СвойстваСертификата - Структура
//  	* АлгоритмОткрытогоКлюча - Строка - OID
// 
// Возвращаемое значение:
//  Обещание - Структура
//
Асинх Функция ТокенДляШифрования(Сертификат, АлгоритмШифрования = Неопределено, СвойстваСертификата = Неопределено) Экспорт
	Результат = Неопределено;
	
	// Локализация
	УстановленныеКриптопровайдеры = Ждать ЭлектроннаяПодписьСлужебныйКлиент.УстановленныеКриптопровайдерыИзКэша(Истина);
	Токены = УстановленныеКриптопровайдеры.Токены;
	
	Если Токены.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если СвойстваСертификата = Неопределено Или Не ЗначениеЗаполнено(СвойстваСертификата.АлгоритмОткрытогоКлюча) Тогда
		Попытка
			ОбъектКомпоненты = Ждать ЭлектроннаяПодписьСлужебныйКлиент.ОбъектВнешнейКомпонентыExtraCryptoAPI(Истина);
		Исключение
			Возврат Неопределено;
		КонецПопытки;
		СвойстваСертификата = Ждать ЭлектроннаяПодписьСлужебныйКлиент.ПолучитьСвойстваСертификатаАсинх(Сертификат, ОбъектКомпоненты);
		Если ЗначениеЗаполнено(СвойстваСертификата.Ошибка) Тогда
			Возврат Неопределено;
		КонецЕсли;
		АлгоритмОткрытогоКлюча = СвойстваСертификата.СвойстваСертификата.АлгоритмОткрытогоКлюча;
	Иначе
		АлгоритмОткрытогоКлюча = СвойстваСертификата.АлгоритмОткрытогоКлюча;
	КонецЕсли;
	
	Если АлгоритмОткрытогоКлюча <> "1.2.643.7.1.1.1.1" И АлгоритмОткрытогоКлюча <> "1.2.643.7.1.1.1.2" Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(АлгоритмШифрования) Тогда
		АлгоритмШифрования = ЭлектроннаяПодписьКлиентСерверЛокализация.ПреобразованныйАлгоритмШифрования(АлгоритмШифрования);
	Иначе
		АлгоритмШифрования = "1.2.643.2.2.21";
	КонецЕсли;
	
	Для Каждого Токен Из Токены Цикл
		Если ПоддержкаШифрования(Токен, АлгоритмШифрования) Тогда
			Возврат Токен;
		КонецЕсли;
	КонецЦикла;
	
	// Конец Локализация
	Возврат Результат;
КонецФункции

// Текст ошибки содержит информацию, что введен неправильный пин-код токена.
// 
// Параметры:
//  ТекстОшибки - Строка - текст ошибки
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоОшибкаНеправильныйПинКод(ТекстОшибки) Экспорт
	// Локализация
	Если СтрНачинаетсяС(ТекстОшибки, "[pkcs11:160]") Тогда
		Возврат Истина;
	КонецЕсли;
	// Конец Локализация
	Возврат Ложь;
КонецФункции

// Подпись на токене.
// 
// Параметры:
//  ПараметрыПодписи - Структура:
//    * Токен - Структура
//    * Сертификат - СертификатКриптографии
//    * Пароль - Строка
//    * ТипПодписи - ПеречислениеСсылка.ТипыПодписиКриптографии
//    * Открепленная - Булево
//    * ТипПодписи - ПеречислениеСсылка.ТипыПодписиКриптографии
//    * ОбъектКомпоненты - ОбъектВнешнейКомпоненты
//    * ВключатьСертификатВПодпись - Булево
//  Данные - ДвоичныеДанные
// 
// Возвращаемое значение:
//  Обещание - ДвоичныеДанные, Строка
//
Асинх Функция ПодписьНаТокене(ПараметрыПодписи, Данные) Экспорт
	
	НедоступноСозданиеПодписиТекст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru= 'Недоступно создание подписи с типом %1 на токене.'"), ПараметрыПодписи.ТипПодписи);
	
	// Локализация
	
	Если Не ЗначениеЗаполнено(ПараметрыПодписи.Токен.Пароль) Тогда
		Возврат НСтр("ru = 'Укажите пин-код токена.'")
	КонецЕсли;

	Если ЗначениеЗаполнено(ПараметрыПодписи.ТипПодписи) 
		И ПараметрыПодписи.ТипПодписи <> ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.БазоваяCAdESBES") Тогда
		Возврат НедоступноСозданиеПодписиТекст;
	КонецЕсли;
	
	ОбъектКомпоненты = ПараметрыПодписи.ОбъектКомпоненты;
	Если ОбъектКомпоненты = Неопределено Тогда
		Попытка
			ОбъектКомпоненты = Ждать ЭлектроннаяПодписьСлужебныйКлиент.ОбъектВнешнейКомпонентыExtraCryptoAPI(Истина);
		Исключение
			Возврат ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		КонецПопытки;
	КонецЕсли;
	
	Ждать ОчиститьОшибкиКомпоненты(ОбъектКомпоненты);
	
	Попытка
		ДанныеСертификата = Ждать ПараметрыПодписи.Сертификат.ВыгрузитьАсинх();
		СертификатСтрокой = ЭлектроннаяПодписьСлужебныйКлиентСервер.СертификатКриптографииBase64(ДанныеСертификата);
		
		Результат = Ждать ОбъектКомпоненты.PKCS11CMSSignАсинх(ПараметрыПодписи.Токен.Слот, ПараметрыПодписи.Токен.Пароль,
			СертификатСтрокой, Данные, 0, ПараметрыПодписи.Открепленная, 0);
		Ждать ОшибкаКомпоненты(ОбъектКомпоненты);
		ПодписьCMS = Результат.Значение;
		Если Не ЗначениеЗаполнено(ПодписьCMS) Тогда
			ВызватьИсключение НСтр("ru = 'Не удалось создать подпись.'");
		КонецЕсли;
		ДвоичныеДанныеПодписи = СтрЗаменить(ПодписьCMS, "-----BEGIN CMS-----", "");
		ДвоичныеДанныеПодписи = СтрЗаменить(ДвоичныеДанныеПодписи, "-----END CMS-----", "");
		ДвоичныеДанныеПодписи = СтрЗаменить(ДвоичныеДанныеПодписи, Символы.ВК, "");
		ДвоичныеДанныеПодписи = СтрЗаменить(ДвоичныеДанныеПодписи, Символы.ПС, "");
		ДвоичныеДанныеПодписи = Base64Значение(ДвоичныеДанныеПодписи);
		Возврат ДвоичныеДанныеПодписи;
	Исключение
		НедоступноСозданиеПодписиТекст = ТекстОшибки(ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке()),
			ПараметрыПодписи.Токен);
		Если ЭтоОшибкаПомещенияПодписиВБуфер(НедоступноСозданиеПодписиТекст) Тогда
			Возврат НСтр("ru= 'Не удалось создать подпись при взаимодействии библиотеки rtengine.dll с OpenSSL.'");
		КонецЕсли;
	
	КонецПопытки;

	// Конец Локализация
	
	Возврат НедоступноСозданиеПодписиТекст;

КонецФункции

// Проверяет подпись с помощью токена.
// 
// Параметры:
//  Данные - ДвоичныеДанные, Неопределено - если Неопределено, подпись будет проверяться как присоединенная.
//  Подпись - ДвоичныеДанные
//  ПараметрыПроверки - Структура:
//   * АлгоритмПодписи - Строка
//   * ОбъектКомпоненты - ОбъектВнешнейКомпоненты
//   * ВернутьСертификатыДляПроверки - Булево
// 
// Возвращаемое значение:
//  Обещание - Проверить подпись
//
Асинх Функция ПроверитьПодпись(Данные, Подпись, ПараметрыПроверки) Экспорт
	
	Результат = Неопределено;
	
	// Локализация
	
	УстановленныеКриптопровайдеры = Ждать ЭлектроннаяПодписьСлужебныйКлиент.УстановленныеКриптопровайдерыИзКэша(Ложь);
	Токены = УстановленныеКриптопровайдеры.Токены;
	
	Если Токены.Количество() = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	ОбъектКомпоненты = ПараметрыПроверки.ОбъектКомпоненты;
	Если ОбъектКомпоненты = Неопределено Тогда
		Попытка
			ОбъектКомпоненты = Ждать ЭлектроннаяПодписьСлужебныйКлиент.ОбъектВнешнейКомпонентыExtraCryptoAPI(Ложь);
		Исключение
			Возврат ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		КонецПопытки;
	КонецЕсли;
	
	Если ПараметрыПроверки.АлгоритмПодписи = Неопределено Тогда
		АлгоритмПодписи = ЭлектроннаяПодписьСлужебныйКлиентСервер.АлгоритмСформированнойПодписи(Подпись);
	Иначе
		АлгоритмПодписи = ПараметрыПроверки.АлгоритмПодписи;
	КонецЕсли;
	
	АлгоритмПодписи = СтрРазделить(АлгоритмПодписи, ",", Ложь);
	АлгоритмПодписи = АлгоритмПодписи[0];
	
	МеханизмПроверки = МеханизмПроверкиПодписи(АлгоритмПодписи);
	IDТокена = Неопределено;
	ЕстьАктивныеТокены = Ложь;
	Если ЗначениеЗаполнено(МеханизмПроверки) Тогда
		Для Каждого Токен Из Токены Цикл
			Если Не ЗначениеЗаполнено(Токен.Механизмы) Тогда
				Продолжить;
			КонецЕсли;
			ЕстьАктивныеТокены = Истина;
			ПоддерживаетсяМеханизмПроверки = ПоддерживаетсяМеханизм(Токен, МеханизмПроверки);
			Если ПоддерживаетсяМеханизмПроверки Тогда
				IDТокена = Токены[0].Слот;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если IDТокена = Неопределено Тогда
		Если ЕстьАктивныеТокены Тогда
			Результат = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Не найдено токенов, поддерживающих проверку подписи с алгоритмом %1'"), АлгоритмПодписи);
		Иначе
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;

	Ждать ОчиститьОшибкиКомпоненты(ОбъектКомпоненты);
	
	Попытка
		ПодписьСтрока = "-----BEGIN CMS-----" + Символы.ПС + ЭлектроннаяПодписьСлужебныйКлиентСервер.СертификатКриптографииBase64(Подпись)
			+ Символы.ПС + "-----END CMS-----";
		
		Если ПараметрыПроверки.ВернутьСертификатыДляПроверки Тогда
			
			РезультатПроверки = Ждать ОбъектКомпоненты.PKCS11CMSVerifySignАсинх(IDТокена, ПодписьСтрока, Данные, "");
			Ждать ОшибкаКомпоненты(ОбъектКомпоненты);
			
			Сертификаты = Новый Массив;
			СертификатыПодписи = ПрочитатьЗначениеJSON(РезультатПроверки.Параметры[3]);
			Для Каждого Сертификат Из СертификатыПодписи Цикл
				СертификатИзСтроки = Ждать ЭлектроннаяПодписьСлужебныйКлиент.СертификатИзСтроки(Сертификат);
				Сертификаты.Добавить(СертификатИзСтроки);
			КонецЦикла;
			
			Возврат Сертификаты;

		Иначе
			РезультатПроверки = Ждать ОбъектКомпоненты.PKCS11CMSVerifySignАсинх(IDТокена, ПодписьСтрока, Данные);
			Ждать ОшибкаКомпоненты(ОбъектКомпоненты);
		КонецЕсли;
		
		Результат = РезультатПроверки.Значение;
	Исключение
		
		ТекстОшибки = ТекстОшибки(ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке()), Токены[0]);
			
		Если СтрНайти(ТекстОшибки, "error:1700009E") <> 0 Тогда
			Возврат Нстр("ru = 'Хеш-значение неправильное'");
		КонецЕсли;
		
		Результат = СтрЗаменить(ТекстОшибки, Символы.ПС, "");
		
	КонецПопытки;
	
	// Конец Локализация
	
	Возврат Результат;

КонецФункции

// Шифрование на токене.
// 
// Параметры:
//  ПараметрыШифрования - Структура
//  Данные - ДвоичныеДанные
// 
// Возвращаемое значение:
//  Обещание - ДвоичныеДанные, Строка
//
Асинх Функция ШифрованиеНаТокене(ПараметрыШифрования, Данные) Экспорт
	
	Результат = НСтр("ru= 'Недоступно шифрование на токене.'");
	
	// Локализация
	
	Если ПараметрыШифрования.Токен.Токен = Джакарта() Тогда
		Возврат НСтр("ru = 'Шифрование средствами токена JaCarta недоступно, используйте Рутокен или приложения для работы с электронной подписью и шифрованием.'");
	КонецЕсли;
	
	Если ПараметрыШифрования.ОбъектКомпоненты = Неопределено Тогда
		Попытка
			ОбъектКомпоненты = Ждать ЭлектроннаяПодписьСлужебныйКлиент.ОбъектВнешнейКомпонентыExtraCryptoAPI(Истина);
		Исключение
			Возврат ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		КонецПопытки;
	КонецЕсли;
	
	Ждать ОчиститьОшибкиКомпоненты(ОбъектКомпоненты);
	
	Если ТипЗнч(ПараметрыШифрования.Сертификат) = Тип("Массив") Тогда
		СертификатыДляШифрования = ПараметрыШифрования.Сертификат;
	Иначе
		СертификатыДляШифрования = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПараметрыШифрования.Сертификат);
	КонецЕсли;
	
	СертификатыДляШифрованияСтрокой = Новый Массив;
	Попытка
		Для Каждого Сертификат Из СертификатыДляШифрования Цикл
			ДанныеСертификата = Ждать Сертификат.ВыгрузитьАсинх();
			СертификатыДляШифрованияСтрокой.Добавить(ЭлектроннаяПодписьСлужебныйКлиентСервер.СертификатКриптографииBase64(ДанныеСертификата));
		КонецЦикла;
		СертификатыДляШифрованияСтрокой = ЗаписатьЗначениеJSON(СертификатыДляШифрованияСтрокой);
	Исключение
		Возврат ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Попытка
		Результат = Ждать ОбъектКомпоненты.PKCS11CMSEncryptАсинх(
			ПараметрыШифрования.Токен.Слот, Данные, СертификатыДляШифрованияСтрокой,
			АлгоритмШифрованияЧисло(ПараметрыШифрования.АлгоритмШифрования));
		Ждать ОшибкаКомпоненты(ОбъектКомпоненты);
		Если Не ЗначениеЗаполнено(Результат.Значение) Тогда
			ВызватьИсключение НСтр("ru = 'Не удалось зашифровать данные.'");
		КонецЕсли;
		ЗашифрованныеДанныеСтрокой = СтрЗаменить(Результат.Значение, "-----BEGIN CMS-----", "");
		ЗашифрованныеДанныеСтрокой = СтрЗаменить(ЗашифрованныеДанныеСтрокой, "-----END CMS-----", "");
		ЗашифрованныеДанныеСтрокой = СтрЗаменить(ЗашифрованныеДанныеСтрокой, Символы.ВК, "");
		ЗашифрованныеДанныеСтрокой = СтрЗаменить(ЗашифрованныеДанныеСтрокой, Символы.ПС, "");
		Результат = Base64Значение(ЗашифрованныеДанныеСтрокой);
		
	Исключение
		Результат = ТекстОшибки(ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке()), ПараметрыШифрования.Токен);
	КонецПопытки;
	
	// Конец Локализация
	
	Возврат Результат;
КонецФункции

// Шифрование на токене.
// 
// Параметры:
//  ПараметрыРасшифровки - Структура
//  Данные - ДвоичныеДанные
// 
// Возвращаемое значение:
//  Обещание - ДвоичныеДанные, Строка
//
Асинх Функция РасшифровкаНаТокене(ПараметрыРасшифровки, Данные) Экспорт
	
	Результат = НСтр("ru= 'Недоступна расшифровка на токене.'");
	
	// Локализация
	
	Если ПараметрыРасшифровки.Токен.Токен = Джакарта() Тогда
		Возврат НСтр("ru = 'Расшифровка средствами токена JaCarta недоступна, используйте Рутокен или приложения для работы с электронной подписью и шифрованием.'");
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ПараметрыРасшифровки.Токен.Пароль) Тогда
		Возврат НСтр("ru = 'Укажите пин-код токена.'")
	КонецЕсли;
	
	Если ПараметрыРасшифровки.ОбъектКомпоненты = Неопределено Тогда
		Попытка
			ОбъектКомпоненты = Ждать ЭлектроннаяПодписьСлужебныйКлиент.ОбъектВнешнейКомпонентыExtraCryptoAPI(Истина);
		Исключение
			Возврат ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		КонецПопытки;
	КонецЕсли;
	
	Ждать ОчиститьОшибкиКомпоненты(ОбъектКомпоненты);
	
	Попытка
		ДанныеСертификата = Ждать ПараметрыРасшифровки.Сертификат.ВыгрузитьАсинх();
		СертификатСтрокой = ЭлектроннаяПодписьСлужебныйКлиентСервер.СертификатКриптографииBase64(ДанныеСертификата);
		ДанныеСтрока = "-----BEGIN CMS-----" + Символы.ПС + ЭлектроннаяПодписьСлужебныйКлиентСервер.СертификатКриптографииBase64(Данные)
			+ Символы.ПС + "-----END CMS-----";
	
		Результат = Ждать ОбъектКомпоненты.PKCS11CMSDecryptАсинх(ПараметрыРасшифровки.Токен.Слот, ПараметрыРасшифровки.Токен.Пароль, ДанныеСтрока, СертификатСтрокой);
		Ждать ОшибкаКомпоненты(ОбъектКомпоненты);
		Если Не ЗначениеЗаполнено(Результат.Значение) Тогда
			ВызватьИсключение НСтр("ru = 'Не удалось расшифровать данные.'");
		КонецЕсли;
		Возврат Результат.Значение;
	Исключение
		Результат = ТекстОшибки(ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке()), ПараметрыРасшифровки.Токен);
	КонецПопытки;
	
	// Конец Локализация
	
	Возврат Результат;
КонецФункции

// Открывает форму установки программ криптопровайдеров.
// 
// Параметры:
//  Параметры - Структура
//  Владелец - ФормаКлиентскогоПриложения
//  Оповещение - ОписаниеОповещения
//  СтандартнаяОбработка - Булево
//
Процедура ПриОткрытииФормыУстановкиПрограммКриптопровайдеров(Параметры, Владелец, Оповещение, СтандартнаяОбработка) Экспорт
	
	// Локализация	
	СтандартнаяОбработка = Ложь;
	ОткрытьФорму("Обработка.ПрограммыЭлектроннойПодписиИШифрования.Форма.УстановкаПриложенийДляРаботыСЭлектроннойПодписью",
		Параметры, Владелец,,,, Оповещение, РежимОткрытияОкнаФормы.БлокироватьОкноВладельца);
	
	Возврат;
	// Конец Локализация
	
КонецПроцедуры

// При заполнении результата проверки удостоверяющего центра.
// 
// Параметры:
//  Результат - см. ЭлектроннаяПодписьСлужебныйКлиентСервер.РезультатПроверкиУдостоверяющегоЦентраПоУмолчанию
//  СертификатКриптографии - СертификатКриптографии
//  НаДату - Дата
//  ПараметрыПроверки - Структура
//  СвойстваСертификата - см. ЭлектроннаяПодпись.СвойстваСертификата
// 
// Возвращаемое значение:
//  Обещание - см. ЭлектроннаяПодписьСлужебныйКлиентСервер.РезультатПроверкиУдостоверяющегоЦентраПоУмолчанию
//
Асинх Функция ПриЗаполненииРезультатаПроверкиУдостоверяющегоЦентра(
	Результат, СертификатКриптографии, НаДату, ПараметрыПроверки, СвойстваСертификата) Экспорт
	
	// Локализация
	
	Если Не ЭлектроннаяПодписьКлиент.ОбщиеНастройки().ДоступнаПроверкаПоСпискуУЦ Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если ПараметрыПроверки = Неопределено Или ПараметрыПроверки = Ложь Или ПараметрыПроверки = Истина Тогда
		НовыеПараметрыПроверки = Новый Структура;
		НовыеПараметрыПроверки.Вставить("ЭтоПроверкаПодписи", ?(ПараметрыПроверки = Неопределено, Ложь, ПараметрыПроверки));
		НовыеПараметрыПроверки.Вставить("ПроверятьСертификат", ЭлектроннаяПодписьСлужебныйКлиентСервер.ПроверятьКвалифицированные());
		ПараметрыПроверки = НовыеПараметрыПроверки;
	КонецЕсли;
	
	Если ПараметрыПроверки.ПроверятьСертификат = ЭлектроннаяПодписьСлужебныйКлиентСервер.НеПроверятьСертификат() Тогда
		Возврат Результат;
	КонецЕсли;
	
	ДанныеДляПроверкиУдостоверяющегоЦентра = ЭлектроннаяПодписьКлиентСерверЛокализация.ДанныеДляПроверкиУдостоверяющегоЦентра(
			СертификатКриптографии);

	Если ДанныеДляПроверкиУдостоверяющегоЦентра.ЗначенияПоиска = Неопределено Тогда
		ЭлектроннаяПодписьСлужебныйКлиентСервер.ЗаполнитьРезультатПроверкиСертификатНеквалифицированный(ПараметрыПроверки, Результат);
		Возврат Результат;
	КонецЕсли;

	ДанныеУдостоверяющегоЦентра = ЭлектроннаяПодписьСлужебныйКлиентПовтИсп.ДанныеУдостоверяющегоЦентра(
			ДанныеДляПроверкиУдостоверяющегоЦентра.ЗначенияПоиска);

	Если ДанныеУдостоверяющегоЦентра = Неопределено Тогда
		ЭлектроннаяПодписьСлужебныйКлиентСервер.ЗаполнитьРезультатПроверкиСертификатНеквалифицированный(ПараметрыПроверки, Результат);
		Возврат Результат;
	КонецЕсли;

	КонтекстПроверки = ЭлектроннаяПодписьКлиентСерверЛокализация.КонтекстПроверкиУдостоверяющегоЦентраСертификата();
	КонтекстПроверки.ДанныеУдостоверяющегоЦентра = ДанныеУдостоверяющегоЦентра;
	КонтекстПроверки.НаименованиеУдостоверяющегоЦентра = ДанныеДляПроверкиУдостоверяющегоЦентра.НаименованиеУдостоверяющегоЦентра;
	КонтекстПроверки.ЗначенияПоиска = ДанныеДляПроверкиУдостоверяющегоЦентра.ЗначенияПоиска;
	КонтекстПроверки.НаДату = ?(НаДату = Неопределено, ОбщегоНазначенияКлиент.ДатаСеанса(), НаДату);
	КонтекстПроверки.РазницаСУниверсальнымВременем = ЭлектроннаяПодписьСлужебныйКлиент.РазницаСУниверсальнымВременем();
	КонтекстПроверки.ЭтоПроверкаПодписи  = ПараметрыПроверки.ЭтоПроверкаПодписи;
	КонтекстПроверки.ПроверятьСертификат  = ПараметрыПроверки.ПроверятьСертификат;
	
	Если СвойстваСертификата = Неопределено Тогда
		КонтекстПроверки.СвойстваСертификата = Ждать ЭлектроннаяПодписьСлужебныйКлиент.СвойстваСертификата(СертификатКриптографии);
	Иначе
		КонтекстПроверки.СвойстваСертификата = СвойстваСертификата;
	КонецЕсли;

	Результат = ЭлектроннаяПодписьКлиентСерверЛокализация.РезультатПроверкиУдостоверяющегоЦентраСертификата(
		СертификатКриптографии, КонтекстПроверки);

	Если ЗначениеЗаполнено(Результат.Предупреждение.Причина) Тогда
		Результат.Предупреждение.Причина = СтроковыеФункцииКлиент.ФорматированнаяСтрока(
			Результат.Предупреждение.Причина);
	КонецЕсли;

	Если ЗначениеЗаполнено(Результат.Предупреждение.Решение) Тогда
		Результат.Предупреждение.Решение = СтроковыеФункцииКлиент.ФорматированнаяСтрока(
			Результат.Предупреждение.Решение);
	КонецЕсли;
	
	// Конец Локализация
	
	Возврат Результат;
	
КонецФункции

// Только для внутреннего использования.
// Проверяет установку программ криптографии в рамках проверки установки компонент для работы с электронной подписью.
//
// Параметры:
//  Результат	 - Булево - если Истина, то требуется установка дополнительных компонент.
//  Компоненты	 - см. ЭлектроннаяПодписьСлужебныйКлиент.НовыйКомпонентыРаботыСКриптографией.
//
Процедура ПриПроверкеУстановкиПрограммКриптографии(Результат, Компоненты) Экспорт
	
	// Локализация
	// Проверка установки криптопровайдера
	Если Компоненты.КриптопровайдерУстановлен
		И Не ЭлектроннаяПодписьКлиент.ПроверятьЭлектронныеПодписиНаСервере()
		И Не ЭлектроннаяПодписьКлиент.СоздаватьЭлектронныеПодписиНаСервере()
		И Не ЭлектроннаяПодписьСлужебныйКлиент.ИспользоватьСервисОблачнойПодписи()
		И Не ЭлектроннаяПодписьСлужебныйКлиент.ИспользоватьЭлектроннуюПодписьВМоделиСервиса() Тогда
		
		// В веб-клиенте выполнить проверку установки криптопровайдера можно только с установленной компонентой и расширением.
		Если Компоненты.РасширениеРаботыСКриптографиейУстановлено И Компоненты.КомпонентаExtraCryptoAPIУстановлена Тогда
			
			ПараметрыПроверки = Новый Структура;
			ПараметрыПроверки.Вставить("ПредлагатьУстановитьПрограмму", Ложь);
			
			ЭлектроннаяПодписьСлужебныйКлиент.ПроверитьУстановкуПрограммКриптографии(Неопределено, ПараметрыПроверки,
				Новый ОписаниеОповещения("ПослеПроверкиУстановкиПрограммКриптографии", ЭлектроннаяПодписьСлужебныйКлиент, Компоненты));
				
		КонецЕсли;
		
		Результат = Результат Или Не Компоненты.КриптопровайдерУстановлен;
		
	КонецЕсли;
	// Конец Локализация
	
КонецПроцедуры

// При продолжении проверки установленных программ криптографии.
// 
// Параметры:
//  Контекст - Структура - 
//  РезультатПроверки - Структура - 
//  ЕстьПроверяемыеПрограммы - Булево - 
// 
// Возвращаемое значение:
//  Обещание - Булево
//
Асинх Функция ПриПродолженииПроверкиУстановленныхПрограммКриптографии(
		Контекст, РезультатПроверки, ЕстьПроверяемыеПрограммы) Экспорт
	
	// Локализация
	
	Если Контекст.ПредлагатьУстановитьПрограмму 
		И РезультатПроверки.ПроверкаВыполнена 
		И Не ЕстьПроверяемыеПрограммы
		И Не Контекст.ЭтоПовторнаяПроверка Тогда
		
		Оповещение = Новый ОписаниеОповещения("ПослеУстановкиКриптопровайдера", ЭтотОбъект, Контекст);
		
#Если ВебКлиент Тогда
		Компоненты = ЭлектроннаяПодписьСлужебныйКлиент.НовыйКомпонентыРаботыСКриптографией();
		Компоненты.КриптопровайдерУстановлен = Ложь;
		
		ТребуетсяУстановкаДополнительныхКомпонент = Ждать ЭлектроннаяПодписьСлужебныйКлиент.ТребуетсяУстановкаДополнительныхКомпонент(Компоненты);
		
		Если ТребуетсяУстановкаДополнительныхКомпонент Тогда
			ПараметрыФормы = Новый Структура;
			ПараметрыФормы.Вставить("Компоненты", Компоненты);
			ПараметрыФормы.Вставить("ИмяТребуемойКомпоненты", "ПрограммаКриптографии");
			ОткрытьФорму("ОбщаяФорма.НачалоРаботыСЭлектроннойПодписью", ПараметрыФормы,
				Контекст.Форма, , , , Оповещение, РежимОткрытияОкнаФормы.БлокироватьОкноВладельца);
			Возврат Ложь;
		КонецЕсли;
#КонецЕсли
		
		ОткрытьФорму("Обработка.ПрограммыЭлектроннойПодписиИШифрования.Форма.УстановкаПриложенийДляРаботыСЭлектроннойПодписью",,
			Контекст.Форма,,,,Оповещение, РежимОткрытияОкнаФормы.БлокироватьОкноВладельца);
			
		Возврат Ложь;
	КонецЕсли;
	
	// Конец Локализация
	
	Возврат Истина;
	
КонецФункции

// При обработке навигационной ссылки классификатора.
// 
// Параметры:
//  Элемент - ДекорацияФормы
//  НавигационнаяСсылкаФорматированнойСтроки - Строка
//  Параметры - Структура
// 
// Возвращаемое значение:
//  Обещание - Булево
//
Асинх Функция ПриОбработкеНавигационнойСсылкиКлассификатора(Элемент, НавигационнаяСсылкаФорматированнойСтроки, Параметры) Экспорт
	
	// Локализация
	Если НавигационнаяСсылкаФорматированнойСтроки = "ДобавитьУдостоверяющийЦентрВСписокРазрешенныхНеаккредитованных" Тогда

		Если ЗначениеЗаполнено(Параметры.Сертификат)
			И ЭлектроннаяПодписьКлиент.ОбщиеНастройки().ДоступнаПроверкаПоСпискуУЦ Тогда
			ПараметрыСоздания = Новый Структура;
			ПараметрыСоздания.Вставить("Сертификат", Параметры.Сертификат);
			ОткрытьФорму("ОбщаяФорма.РазрешенныеНеаккредитованныеУЦ", ПараметрыСоздания, Элемент);
		КонецЕсли;

		Возврат Ложь;
	КонецЕсли;
	// Конец Локализация
	Возврат Истина;
	
КонецФункции


#КонецОбласти

// Локализация
#Область СлужебныеПроцедурыИФункции

Функция ТекстОшибки(ТекстОшибки, Токен)

	Если Токен.Токен = Рутокен() Тогда
		Если ЭтоОшибкаЗагрузкиБиблиотекиOpenSSL(ТекстОшибки) Тогда
			Возврат ЭлектроннаяПодписьКлиентСерверЛокализация.НеУстановленаOpenSSL();
		КонецЕсли;

		Если ЭтоОшибкаЗагрузкиБиблиотекиИнтеграции(ТекстОшибки) Тогда
			Возврат ЭлектроннаяПодписьКлиентСерверЛокализация.НеУстановленБиблиотекаИнтеграцииСOpenSSL();
		КонецЕсли;
		
	КонецЕсли;

	Если ЭтоОшибкаНеправильныйПинКод(ТекстОшибки) Тогда
		Возврат НСтр("ru= 'Указан неправильный пин-код токена.'");
	КонецЕсли;
	
	Если ЭтоОшибкаНеНайденКлючИлиСертификат(ТекстОшибки) Тогда
		Возврат НСтр("ru= 'Не найден сертификат на токене.'");
	КонецЕсли;
	
	Если ЭтоОшибкаИнициализацииСлота(ТекстОшибки) Тогда
		Возврат ОшибкаИнициализацииСлота(Токен);
	КонецЕсли;
	
	Возврат ТекстОшибки;

КонецФункции

Функция ПоддержкаШифрования(Токен, АлгоритмШифрования)
	
	МеханизмШифрования = МеханизмШифрования(АлгоритмШифрования);
	Если Не ЗначениеЗаполнено(МеханизмШифрования) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат ПоддерживаетсяМеханизм(Токен, МеханизмШифрования);
	
КонецФункции

Функция ЭтоОшибкаЗагрузкиБиблиотеки(ТекстОшибки)

	Если СтрНайти(ТекстОшибки, "[token:10102]") <> 0 Тогда
		Возврат Истина;
	КонецЕсли;

	Возврат Ложь;
КонецФункции

Функция ЭтоОшибкаЗагрузкиБиблиотекиOpenSSL(ТекстОшибки)

	Если СтрНайти(ТекстОшибки, "[token:10105]") <> 0 Тогда
		Возврат Истина;
	КонецЕсли;

	Возврат Ложь;
КонецФункции

Функция ЭтоОшибкаЗагрузкиБиблиотекиИнтеграции(ТекстОшибки)

	Если СтрНайти(ТекстОшибки, "[token:10104]") <> 0 Тогда
		Возврат Истина;
	КонецЕсли;

	Возврат Ложь;
КонецФункции

Функция ЭтоОшибкаИнициализацииСлота(ТекстОшибки)

	Если СтрНайти(ТекстОшибки, "[token:10203]") <> 0 Тогда
		Возврат Истина;
	КонецЕсли;

	Возврат Ложь;
КонецФункции

Функция ОшибкаИнициализацииСлота(Токен)

	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Не удалось инициализировать слот %1 на токене %2'"), Токен.Слот, Токен.Представление);
	
КонецФункции

Функция ЭтоОшибкаПолученияМеханизмовТокена(ТекстОшибки)

	Если СтрНайти(ТекстОшибки, "[token:10301]") <> 0 Тогда
		Возврат Истина;
	КонецЕсли;

	Возврат Ложь;
КонецФункции

Функция ЭтоОшибкаНеНайденКлючИлиСертификат(ТекстОшибки)

	Если СтрНайти(ТекстОшибки, "[token:10401]") <> 0 Тогда
		Возврат Истина;
	КонецЕсли;

	Возврат Ложь;
	
КонецФункции

Функция ЭтоОшибкаПомещенияПодписиВБуфер(ТекстОшибки)

	Если СтрНайти(ТекстОшибки, "[token:10601]") <> 0 Тогда
		Возврат Истина;
	КонецЕсли;

	Возврат Ложь;
	
КонецФункции

Асинх Функция ОшибкаКомпоненты(ОбъектКомпоненты, ВызыватьИсключение = Истина) Экспорт
	Ошибка = Ждать ОбъектКомпоненты.ПолучитьСписокОшибокАсинх();
	
	Если Не ЗначениеЗаполнено(Ошибка) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ВызыватьИсключение Тогда
		ВызватьИсключение Ошибка;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

Асинх Функция ОчиститьОшибкиКомпоненты(ОбъектКомпоненты) Экспорт
	Возврат Ждать ОшибкаКомпоненты(ОбъектКомпоненты, Ложь);
КонецФункции

Функция МодельТокена(Модель, ТипУстройства = Неопределено)
	
	Если СтрНачинаетсяС(НРег(Модель), "rutokenecp") Тогда
		Возврат НСтр("ru = 'Рутокен ЭЦП'");
	ИначеЕсли СтрНачинаетсяС(НРег(Модель), "rutokenlite") Тогда
		Возврат НСтр("ru = 'Рутокен Lite'");
	ИначеЕсли СтрНачинаетсяС(НРег(Модель), "rutokens") Тогда
		Возврат НСтр("ru = 'Рутокен S'");
	ИначеЕсли СтрНачинаетсяС(НРег(Модель), "rutoken") Тогда
		Возврат НСтр("ru = 'Рутокен'");
	ИначеЕсли СтрНачинаетсяС(НРег(Модель), "jacarta") Тогда
		Возврат "JaCarta";
	КонецЕсли;
	
	Если ТипУстройства <> Неопределено Тогда
		Возврат СтрШаблон("%1 %2", МодельТокена(ТипУстройства), Модель);
	КонецЕсли;
	
	Возврат Модель;
	
КонецФункции

Функция ТипУстройства(Слот)
	
	Если СтрНачинаетсяС(НРег(Слот), Рутокен()) Тогда
		Возврат Рутокен();
	ИначеЕсли СтрНачинаетсяС(НРег(Слот), "jacarta") Тогда
		Возврат "jacarta";
	КонецЕсли;
	
	Массив = СтрРазделить(Слот, ": ");
	Если Массив.Количество() > 0 Тогда
		Возврат Массив[0];
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

Функция Рутокен() Экспорт
	Возврат "rutoken"
КонецФункции

Функция Джакарта() Экспорт
	Возврат "jacarta"
КонецФункции

Функция ПредставлениеСерийногоНомера(ТипУстройства, СерийныйНомер)
	
	Если ТипУстройства = Рутокен() Тогда
		Возврат Формат(ЧислоИзШестнадцатеричнойСтроки("0x" + СерийныйНомер), "ЧГ=0;");
	КонецЕсли;
	Возврат СерийныйНомер;
	
КонецФункции

Функция МеханизмПроверкиПодписи(АлгоритмПодписи)
	Если АлгоритмПодписи = "ГОСТ 34.10-2012 256" Тогда
		Возврат "CKM_GOSTR3410_WITH_GOSTR3411_12_256"
	ИначеЕсли АлгоритмПодписи = "ГОСТ 34.10-2012 512" Тогда
		Возврат "CKM_GOSTR3410_WITH_GOSTR3411_12_512"
	ИначеЕсли АлгоритмПодписи = "ГОСТ 34.10-2001" Тогда
		Возврат "CKM_GOSTR3410"
	ИначеЕсли АлгоритмПодписи = "RSA_SIGN" Тогда
		Возврат "CKM_RSA_PKCS";
	КонецЕсли;
	Возврат "";
КонецФункции

Функция МеханизмШифрования(АлгоритмШифрования)
	Если АлгоритмШифрования = "1.2.643.2.2.21" Тогда
		Возврат "CKM_GOST28147_ECB"
	ИначеЕсли АлгоритмШифрования = "1.2.643.7.1.1.5.2.1" Тогда
		Возврат "CKM_KUZNECHIK_ECB"
	ИначеЕсли АлгоритмШифрования = "1.2.643.7.1.1.5.1.1" Тогда
		Возврат "CKM_MAGMA_ECB"
	КонецЕсли;
	Возврат "";
КонецФункции

Функция АлгоритмШифрованияЧисло(АлгоритмШифрования)
	АлгоритмШифрования = ЭлектроннаяПодписьКлиентСерверЛокализация.ПреобразованныйАлгоритмШифрования(АлгоритмШифрования);
	Если АлгоритмШифрования = "1.2.643.7.1.1.5.2.1" Тогда
		Возврат 1177; // id-tc26-cipher-gostr3412-2015-kuznyechik-ctracpkm
	ИначеЕсли АлгоритмШифрования = "1.2.643.7.1.1.5.1.1" Тогда
		Возврат 1174; // id-tc26-cipher-gostr3412-2015-magma
	КонецЕсли;
	Возврат 813; // id-tc26-gost-28147-param-Z
КонецФункции

Функция ПоддерживаетсяМеханизм(Токен, Механизм)
	
	Если Не ЗначениеЗаполнено(Токен.Механизмы) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Попытка
		СписокМеханизмов = ПрочитатьЗначениеJSON(Токен.Механизмы);
	Исключение
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось прочитать список механизмов токена %1 (%2):
			|%3'"),
			Токен.Представление,
			ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке()),
			Токен.Механизмы);
		
		ЖурналРегистрацииКлиент.ДобавитьСообщениеДляЖурналаРегистрации(НСтр("ru = 'Электронная подпись.Работа с токенами'", 
				ОбщегоНазначенияКлиент.КодОсновногоЯзыка()),
			"Ошибка", ТекстОшибки,, Истина);
		Возврат Ложь;
	КонецПопытки;
	
	Если Не ТипЗнч(СписокМеханизмов) = Тип("Структура")
		Или Не СписокМеханизмов.Свойство("support_mechanisms") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СписокМеханизмов = СписокМеханизмов["support_mechanisms"];
	
	Для Каждого Элемент Из СписокМеханизмов Цикл
		Если СокрЛП(Элемент.name) = Механизм Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

#Область УстановкаКриптопровайдеровЛокализация

#Область УстановитьCryptoPRO

Процедура УстановитьКриптоПро(Форма, ОповещениеОЗавершении, ВходящийКонтекст) Экспорт
	
	Если ЗначениеЗаполнено(ВходящийКонтекст) Тогда
		ПослеСохраненияФайловДистрибутива(Истина, ВходящийКонтекст);
		Возврат;
	КонецЕсли;
	
	Если ОбщегоНазначенияКлиент.ЭтоWindowsКлиент() Тогда
		Контекст = Новый Структура;
		Контекст.Вставить("ОповещениеОЗавершении", ОповещениеОЗавершении);
		Контекст.Вставить("ВладелецФормы", Форма.ВладелецФормы);
		Контекст.Вставить("Форма", Форма);
		Контекст.Вставить("ИмяПрограммы", ЭлектроннаяПодписьКлиентСерверЛокализация.ИмяПрограммыКриптоПро());
		Оповещение = Новый ОписаниеОповещения("УстановитьCryptoProCSPПослеВводаРегистрационныхДанных",
			ЭтотОбъект, Контекст);
		
		ОткрытьФорму("Обработка.ПрограммыЭлектроннойПодписиИШифрования.Форма.УстановкаCryptoProCSPРегистрационныеДанные",,
			Форма,,,, Оповещение);
	Иначе
		
		ОписаниеОшибки = СтроковыеФункцииКлиент.ФорматированнаяСтрока(
			НСтр("ru = 'Автоматическая установка приложения %1 возможна только на операционных системах Microsoft Windows.
				|Для самостоятельной установки перейдите на <a href = %2>официальный сайт КриптоПро</a>, выберите и скачайте дистрибутив нужной операционной системы.
				|Распакуйте скачанный архив и выполните запуск исполняемого файла.'"),
			ЭлектроннаяПодписьКлиентСерверЛокализация.ИмяПрограммыКриптоПро(),
			"https://cryptopro.ru/products/csp/downloads");
		
		ОбработатьОшибкуУстановкиПрограммыКриптографии(ОписаниеОшибки, ОповещениеОЗавершении);
		
	КонецЕсли;
		
КонецПроцедуры

Процедура УстановитьCryptoProCSPПослеВводаРегистрационныхДанных(РегистрационныеДанные, ВходящийКонтекст) Экспорт
	
	ОповещениеПослеСозданияКаталога = Новый ОписаниеОповещения(
			"УстановитьКриптопровайдерПослеСозданияВременногоКаталога", ЭтотОбъект, ВходящийКонтекст);
	
	ВходящийКонтекст.Вставить("ПослеСозданияВременногоКаталога", ОповещениеПослеСозданияКаталога);
		
	Если ЗначениеЗаполнено(РегистрационныеДанные) И ТипЗнч(РегистрационныеДанные) = Тип("Структура") Тогда
		
		ВходящийКонтекст.Вставить("РегистрационныеДанные", РегистрационныеДанные);
		Оповещение = Новый ОписаниеОповещения(
			"УстановитьКриптопровайдерПослеПолученияДистрибутива", ЭтотОбъект, ВходящийКонтекст);
		
		ПараметрыОжидания = ДлительныеОперацииКлиент.ПараметрыОжидания(ВходящийКонтекст.Форма);
		ПараметрыОжидания.ВыводитьОкноОжидания = Истина;
		
		ДлительнаяОперация = ЭлектроннаяПодписьСлужебныйВызовСервера.ПолучитьДистрибутив(
			ВходящийКонтекст.РегистрационныеДанные, "CryptoProCSP");
		ДлительныеОперацииКлиент.ОжидатьЗавершение(ДлительнаяОперация, Оповещение, ПараметрыОжидания);
	Иначе
		ОбработатьОшибкуУстановкиПрограммыКриптографии(НСтр("ru = 'Пользователь прервал операцию'"), ВходящийКонтекст);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область УстановитьVipNet

Процедура УстановитьVipNet(Форма, ОповещениеОЗавершении, ВходящийКонтекст) Экспорт
	
	Если ЗначениеЗаполнено(ВходящийКонтекст) Тогда
		ПослеСохраненияФайловДистрибутива(Истина, ВходящийКонтекст);
		Возврат;
	КонецЕсли;
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Если СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86
		ИЛИ СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64 Тогда
		
		Контекст = Новый Структура;
		Контекст.Вставить("ОповещениеОЗавершении", ОповещениеОЗавершении);
		Контекст.Вставить("ВладелецФормы", Форма.ВладелецФормы);
		Контекст.Вставить("Форма", Форма);
		Контекст.Вставить("ИмяПрограммы", ЭлектроннаяПодписьКлиентСерверЛокализация.ИмяПрограммыVipNet());
		
		Оповещение = Новый ОписаниеОповещения("УстановитьViPNetCSPПослеВводаРегистрационныхДанных",
			ЭтотОбъект, Контекст);
		
		ОткрытьФорму(
			"Обработка.ПрограммыЭлектроннойПодписиИШифрования.Форма.УстановкаViPNetCSPРегистрационныеДанные",,
			Форма,,,, Оповещение);
	Иначе
		ОписаниеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Установка %1 возможна только на операционных системах Microsoft Windows.'"),
			ЭлектроннаяПодписьКлиентСерверЛокализация.ИмяПрограммыVipNet());
		ОбработатьОшибкуУстановкиПрограммыКриптографии(ОписаниеОшибки, ОповещениеОЗавершении);
	КонецЕсли;
	
КонецПроцедуры

Процедура УстановитьViPNetCSPПослеВводаРегистрационныхДанных(РегистрационныеДанные, ВходящийКонтекст) Экспорт
	
	Если РегистрационныеДанные = КодВозвратаДиалога.Отмена
		 Или РегистрационныеДанные = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	
	Если СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86 Тогда
		РегистрационныеДанные.Вставить("Разрядность", 32);
	ИначеЕсли СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64 Тогда
		РегистрационныеДанные.Вставить("Разрядность", 64);
	Иначе
		Возврат;
	КонецЕсли;
	
	ОповещениеПослеСозданияКаталога = Новый ОписаниеОповещения(
			"УстановитьКриптопровайдерПослеСозданияВременногоКаталога", ЭтотОбъект, ВходящийКонтекст);
	
	ВходящийКонтекст.Вставить("ПослеСозданияВременногоКаталога", ОповещениеПослеСозданияКаталога);
	
	Если ЗначениеЗаполнено(РегистрационныеДанные) И ТипЗнч(РегистрационныеДанные) = Тип("Структура") Тогда
		ВходящийКонтекст.Вставить("РегистрационныеДанные", РегистрационныеДанные);
		Оповещение = Новый ОписаниеОповещения(
			"УстановитьКриптопровайдерПослеПолученияДистрибутива", ЭтотОбъект, ВходящийКонтекст);
		
		ПараметрыОжидания = ДлительныеОперацииКлиент.ПараметрыОжидания(ВходящийКонтекст.Форма);
		ПараметрыОжидания.ВыводитьОкноОжидания = Истина;
		
		ДлительнаяОперация = ЭлектроннаяПодписьСлужебныйВызовСервера.ПолучитьДистрибутив(ВходящийКонтекст.РегистрационныеДанные, "ViPNetCSP");
		ДлительныеОперацииКлиент.ОжидатьЗавершение(ДлительнаяОперация, Оповещение, ПараметрыОжидания);
	Иначе
		ОбработатьОшибкуУстановкиПрограммыКриптографии(НСтр("ru = 'Пользователь прервал операцию'"), ВходящийКонтекст);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

Процедура УстановитьSignalCOM() Экспорт
	
	ФайловаяСистемаКлиент.ОткрытьНавигационнуюСсылку("https://www.signal-com.ru/products/crypt/signal-com-csp/");
	
КонецПроцедуры

// Параметры:
//  ДлительнаяОперация - см. ДлительныеОперацииКлиент.НовыйРезультатДлительнойОперации
//  ВходящийКонтекст - Структура
//
Процедура УстановитьКриптопровайдерПослеПолученияДистрибутива(ДлительнаяОперация, ВходящийКонтекст) Экспорт
	
	Если ДлительнаяОперация = Неопределено Тогда
		ОписаниеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Вызов API сервиса выдачи дистрибутивов %1 не был завершен штатно.'"), ВходящийКонтекст.ИмяПрограммы);
		ОбработатьОшибкуУстановкиПрограммыКриптографии(ОписаниеОшибки, ВходящийКонтекст);
		Возврат;
	КонецЕсли;
	
	Если ДлительнаяОперация.Статус = "Ошибка" Тогда
		СтандартныеПодсистемыКлиент.ВывестиИнформациюОбОшибке(ДлительнаяОперация.ИнформацияОбОшибке);
		Возврат;
	КонецЕсли;
		
	РезультатПолученияДистрибутива = ЭлектроннаяПодписьСлужебныйВызовСервера.РезультатПолученияДистрибутиваКриптопровайдера(
		ДлительнаяОперация, ВходящийКонтекст.Форма.УникальныйИдентификатор);
	Если ЗначениеЗаполнено(РезультатПолученияДистрибутива.Ошибка) Тогда
		ОбработатьОшибкуУстановкиПрограммыКриптографии(РезультатПолученияДистрибутива.Ошибка, ВходящийКонтекст);
		Возврат;
	КонецЕсли;
	ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(ВходящийКонтекст, РезультатПолученияДистрибутива.ДанныеДистрибутива);
	ФайловаяСистемаКлиент.СоздатьВременныйКаталог(ВходящийКонтекст.ПослеСозданияВременногоКаталога);
	
КонецПроцедуры

Процедура УстановитьКриптопровайдерПослеСозданияВременногоКаталога(ИмяКаталогаВременныхФайлов, ВходящийКонтекст) Экспорт
	
	ИмяКаталогаВременныхФайлов = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(ИмяКаталогаВременныхФайлов);
	ВходящийКонтекст.Вставить("ВременныйКаталог", ИмяКаталогаВременныхФайлов);
	
	Оповещение = Новый ОписаниеОповещения("ПослеСохраненияФайловДистрибутива", ЭтотОбъект, ВходящийКонтекст);
	ПараметрыСохранения = ФайловаяСистемаКлиент.ПараметрыСохраненияФайла();
	ПараметрыСохранения.Интерактивно = Ложь;
	ПараметрыСохранения.Диалог.Каталог = ИмяКаталогаВременныхФайлов;
	ФайловаяСистемаКлиент.СохранитьФайлы(Оповещение, ВходящийКонтекст.Дистрибутив, ПараметрыСохранения);
	
КонецПроцедуры

Процедура ПослеСохраненияФайловДистрибутива(ПолученныеФайлы, ВходящийКонтекст) Экспорт
	
	Если ПолученныеФайлы = Неопределено Тогда
		ОбработатьОшибкуУстановкиПрограммыКриптографии(НСтр("ru = 'Не удалось сохранить на компьютер файлы дистрибутива'"),
			ВходящийКонтекст);
		Возврат;
	КонецЕсли;
	
	ВходящийКонтекст.Вставить("ФайлыДистрибутиваПолучены", Истина);
	
	Если ВходящийКонтекст.РегистрационныеДанные.ВыполнятьКонтрольЦелостности Тогда
		ПараметрыФормы = Новый Структура;

		ПараметрыФормы.Вставить("Дистрибутив", ВходящийКонтекст.ВременныйКаталог + ВходящийКонтекст.ИмяФайлаДистрибутива);
		ПараметрыФормы.Вставить("Версия", ВходящийКонтекст.Версия);
		ПараметрыФормы.Вставить("ИмяПрограммы", ВходящийКонтекст.ИмяПрограммы);
		ПараметрыФормы.Вставить("КонтрольнаяСумма", ВходящийКонтекст.КонтрольнаяСумма);
		ПараметрыФормы.Вставить("КомандаЗапуска", ВходящийКонтекст.КомандаЗапуска);

		ОткрытьФорму(
			"Обработка.ПрограммыЭлектроннойПодписиИШифрования.Форма.УстановкаКриптопровайдераИнформацияОДистрибутиве",
			ПараметрыФормы, , , , ,
			Новый ОписаниеОповещения("УстановитьКриптопровайдерПослеПолученияПодтвержденияНаУстановку", ЭтотОбъект,
			ВходящийКонтекст));
	Иначе
		УстановитьКриптопровайдерПослеПолученияПодтвержденияНаУстановку(Истина, ВходящийКонтекст);
	КонецЕсли;
	
КонецПроцедуры

Процедура УстановитьКриптопровайдерПослеПолученияПодтвержденияНаУстановку(Результат, ВходящийКонтекст) Экспорт
	
	Если Результат = Истина Тогда

		ЗапуститьПриложениеНаКлиенте(ВходящийКонтекст.КомандаЗапуска, ВходящийКонтекст.ВременныйКаталог,
			Истина, Ложь, ВходящийКонтекст);
	Иначе
		
		ОбработатьОшибкуУстановкиПрограммыКриптографии(НСтр("ru = 'Пользователь прервал операцию'"), ВходящийКонтекст);
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбработатьОшибкуУстановкиПрограммыКриптографии(Ошибка, ВходящийКонтекст)
	
	Если ТипЗнч(Ошибка) = Тип("ИнформацияОбОшибке") Тогда
		СтандартныеПодсистемыКлиент.ВывестиИнформациюОбОшибке(Ошибка);
		Возврат; 
	КонецЕсли;
	
	РезультатВыполнения = Новый Структура("Выполнено", Ложь);
	РезультатВыполнения.Вставить("ОписаниеОшибки", Ошибка);
		
	Если ТипЗнч(ВходящийКонтекст) = Тип("Структура") 
		И ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(ВходящийКонтекст,"ФайлыДистрибутиваПолучены", Ложь) Тогда
		РезультатВыполнения.Вставить("ВходящийКонтекст", ВходящийКонтекст);
	КонецЕсли;
	
	Если ТипЗнч(ВходящийКонтекст) = Тип("Структура") И ВходящийКонтекст.ОповещениеОЗавершении <> Неопределено Тогда
			
		ВыполнитьОбработкуОповещения(ВходящийКонтекст.ОповещениеОЗавершении, РезультатВыполнения);
		
	ИначеЕсли ТипЗнч(ВходящийКонтекст) = Тип("ОписаниеОповещения") Тогда
		
		РезультатВыполнения = Новый Структура("Выполнено", Ложь);
		РезультатВыполнения.Вставить("ОписаниеОшибки", Ошибка);
		ВыполнитьОбработкуОповещения(ВходящийКонтекст, РезультатВыполнения);
	
	Иначе
		
		ПоказатьПредупреждение(Неопределено, Ошибка,, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Установка %1'"), ВходящийКонтекст.ИмяПрограммы));
		
	КонецЕсли;
	
КонецПроцедуры

#Область ЗапуститьПриложениеНаКлиенте

Процедура ЗапуститьПриложениеНаКлиенте(СтрокаКоманды, ТекущийКаталог, ДождатьсяЗавершения, ВыводитьСообщения, ВходящийКонтекст)
	
	Оповещение = Новый ОписаниеОповещения(
			"ЗапуститьПриложениеНаКлиентеПослеЗапускаПриложения", ЭтотОбъект, ВходящийКонтекст,
			"ЗапуститьПриложениеНаКлиентеПриОшибкеЗапускаПриложения", ЭтотОбъект);
	
	ПараметрыЗапуска = ФайловаяСистемаКлиент.ПараметрыЗапускаПрограммы();
	ПараметрыЗапуска.Оповещение = Оповещение;
	ПараметрыЗапуска.ТекущийКаталог = ТекущийКаталог;
	ПараметрыЗапуска.ДождатьсяЗавершения = ДождатьсяЗавершения;
	
#Если ВебКлиент Или МобильныйКлиент Тогда
	ВходящийКонтекст.КомандаЗапуска = ВходящийКонтекст.ВременныйКаталог + ВходящийКонтекст.ИмяФайлаДистрибутива;
#Иначе
	ПараметрыЗапуска.ВыполнитьСНаивысшимиПравами = Истина;
#КонецЕсли

	ФайловаяСистемаКлиент.ЗапуститьПрограмму(СтрокаКоманды, ПараметрыЗапуска);
	
КонецПроцедуры

Процедура ЗапуститьПриложениеНаКлиентеПослеЗапускаПриложения(КодВозврата, ВходящийКонтекст) Экспорт
	
	Если ТипЗнч(ВходящийКонтекст.ОповещениеОЗавершении) = Тип("ОписаниеОповещения") Тогда
		РезультатВыполнения = Новый Структура;
		РезультатВыполнения.Вставить("Выполнено", Истина);
		РезультатВыполнения.Вставить("ОписаниеОшибки", "");
		
		ВыполнитьОбработкуОповещения(
			ВходящийКонтекст.ОповещениеОЗавершении,
			РезультатВыполнения);
	КонецЕсли;

КонецПроцедуры

Процедура ЗапуститьПриложениеНаКлиентеПриОшибкеЗапускаПриложения(ИнформацияОбОшибке, СтандартнаяОбработка, ВходящийКонтекст) Экспорт
	
	СтандартнаяОбработка = Ложь;
	
	ОписаниеОшибки = НСтр("ru = 'Не удалось открыть файл %1.
                           |Возможно файл уже открыт.'");
	ОписаниеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ОписаниеОшибки, ВходящийКонтекст.СтрокаКоманды);
	ОбщегоНазначенияКлиент.СообщитьПользователю(ОписаниеОшибки);
	
	РезультатВыполнения = Новый Структура;
	РезультатВыполнения.Вставить("Выполнено", Ложь);
	РезультатВыполнения.Вставить("ОписаниеОшибки", ОписаниеОшибки);
	РезультатВыполнения.Вставить("ВходящийКонтекст", ВходящийКонтекст);
	
	ВыполнитьОбработкуОповещения(
			ВходящийКонтекст.ОповещениеОЗавершении,
			РезультатВыполнения);

КонецПроцедуры

#КонецОбласти

Процедура ПослеУстановкиКриптопровайдера(Результат, Контекст) Экспорт
	
	Контекст.Вставить("ЭтоПовторнаяПроверка", Истина);
	ЭлектроннаяПодписьСлужебныйКлиент.ПроверитьУстановкуПрограммКриптографии(Контекст.Форма, Контекст, Контекст.Оповещение);
	
КонецПроцедуры

#КонецОбласти


#КонецОбласти

// Конец Локализация
