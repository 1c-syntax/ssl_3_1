///////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2022, ООО 1С-Софт
// Все права защищены. Эта программа и сопроводительные материалы предоставляются 
// в соответствии с условиями лицензии Attribution 4.0 International (CC BY 4.0)
// Текст лицензии доступен по ссылке:
// https://creativecommons.org/licenses/by/4.0/legalcode
///////////////////////////////////////////////////////////////////////////////////////////////////////

#Область СлужебныйПрограммныйИнтерфейс

// Формирует имя файла подписи по шаблону.
//
Функция ИмяФайлаПодписи(ИмяБезРасширения, КомуВыданСертификат, РасширениеДляФайловПодписи, ТребуетсяРазделитель = Истина) Экспорт
	
	Разделитель = ?(ТребуетсяРазделитель, " - ", " ");
	
	ИмяФайлаПодписиБезРасширения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку("%1%2%3",
		ИмяБезРасширения, Разделитель, КомуВыданСертификат);
	
	Если СтрДлина(ИмяФайлаПодписиБезРасширения) > 200 Тогда
		ИмяФайлаПодписиБезРасширения = ЭлектроннаяПодписьСлужебныйВызовСервера.СокращенноеИмяФайла(
			ОбщегоНазначенияКлиентСервер.ЗаменитьНедопустимыеСимволыВИмениФайла(ИмяФайлаПодписиБезРасширения), 200);
	КонецЕсли;
	
	ИмяФайлаПодписи = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку("%1.%2",
		ИмяФайлаПодписиБезРасширения, РасширениеДляФайловПодписи);
	
	Возврат ОбщегоНазначенияКлиентСервер.ЗаменитьНедопустимыеСимволыВИмениФайла(ИмяФайлаПодписи);

КонецФункции

// Формирует имя файла сертификата по шаблону.
//
Функция ИмяФайлаСертификата(ИмяБезРасширения, КомуВыданСертификат, РасширениеДляФайловСертификата, ТребуетсяРазделитель = Истина) Экспорт
	
	Разделитель = ?(ТребуетсяРазделитель, " - ", " ");
	
	ИмяФайлаСертификатаБезРасширения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку("%1%2%3",
		ИмяБезРасширения, Разделитель, КомуВыданСертификат);
	
	Если СтрДлина(ИмяФайлаСертификатаБезРасширения) > 200 Тогда
		ИмяФайлаСертификатаБезРасширения = ЭлектроннаяПодписьСлужебныйВызовСервера.СокращенноеИмяФайла(
			ОбщегоНазначенияКлиентСервер.ЗаменитьНедопустимыеСимволыВИмениФайла(ИмяФайлаСертификатаБезРасширения), 200);
	КонецЕсли;
	
	ИмяФайлаСертификата = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку("%1.%2",
		ИмяФайлаСертификатаБезРасширения, РасширениеДляФайловСертификата);
	
	Возврат ОбщегоНазначенияКлиентСервер.ЗаменитьНедопустимыеСимволыВИмениФайла(ИмяФайлаСертификата);
	
КонецФункции

// Конструктор результата проверки по списку удостоверяющих центров.
// 
// Возвращаемое значение:
//  Структура - результат проверки удостоверяющего центра по умолчанию:
//   * Действует - Булево - аккредитованный УЦ действует на дату проверки или проверка не выполнялась (сертификат 
//                 неквалифицированный или УЦ не найден в списке аккредитованных)
//   * НайденВСпискеУдостоверяющихЦентров - Булево - сертификат, выданный УЦ является квалифицированным
//   * Государственный - Булево - относится к определенному списку УЦ, выдающих сертификаты, по которым не нужно
//                                выполнять некоторые проверки.
//   например, в России: УЦ ФНС России, Казначейства России, и Банка России.
//   * ЭтоКвалифицированныйСертификат - Булево - сертификат выдан в период аккредитации УЦ.
//   * Предупреждение - см. ПредупреждениеПриПроверкеУдостоверяющегоЦентраСертификата
//
Функция РезультатПроверкиУдостоверяющегоЦентраПоУмолчанию() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Действует", Истина);
	Результат.Вставить("НайденВСпискеУдостоверяющихЦентров", Ложь);
	Результат.Вставить("Государственный", Ложь);
	Результат.Вставить("ЭтоКвалифицированныйСертификат", Ложь);
	Результат.Вставить("Предупреждение", ПредупреждениеПриПроверкеУдостоверяющегоЦентраСертификата());
	
	Возврат Результат;
	
КонецФункции

// Возвращаемое значение:
//   Структура - сообщение об ошибке/предупреждение для проверяемого сертификата:
//   * ТекстОшибки - Строка
//   * ВозможенПеревыпуск - Булево - можно подать заявление на новый сертификат из программы.
//   * Причина - Строка - причина ошибки для отображения в расширенной форме ошибки.
//   * Решение - Строка - рекомендация для отображения в расширенной форме ошибки.
//
Функция ПредупреждениеПриПроверкеУдостоверяющегоЦентраСертификата() Экспорт
	
	Предупреждение = Новый Структура;
	Предупреждение.Вставить("ТекстОшибки", "");
	Предупреждение.Вставить("ВозможенПеревыпуск", Ложь);
	Предупреждение.Вставить("Причина", "");
	Предупреждение.Вставить("Решение", "");
	Предупреждение.Вставить("ДополнительныеСведения", "");
	
	Возврат Предупреждение;
	
КонецФункции


#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ПользователиСертификатаСтрокой(Пользователь1, Пользователь2, КоличествоПользователей) Экспорт
	
	СтрокаПользователей = СтрШаблон("%1, %2", Пользователь1, Пользователь2);
	Если КоличествоПользователей > 2 Тогда
		СтрокаПользователей = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1 и другие (всего %2)'"), СтрокаПользователей, Формат(КоличествоПользователей, "ЧГ=0"));
	КонецЕсли;

	Возврат СтрокаПользователей;
	
КонецФункции

Функция ОписаниеПрограммыПоИмениКриптопровайдера(ИмяКриптопровайдера, ОписанияПрограмм) Экспорт
	
	ПрограммаНайдена = Ложь;
	Для Каждого ОписаниеПрограммы Из ОписанияПрограмм Цикл
		Если ОписаниеПрограммы.ИмяПрограммы = ИмяКриптопровайдера Тогда
			ПрограммаНайдена = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если ПрограммаНайдена Тогда
		Возврат ОписаниеПрограммы;
	КонецЕсли;
	
	ОписаниеПрограммы = Неопределено;
	
	Если ИмяКриптопровайдера = "Crypto-Pro GOST R 34.10-2001 KC1 CSP"
	 Или ИмяКриптопровайдера = "Crypto-Pro GOST R 34.10-2001 KC2 CSP" Тогда
		
		ОписаниеПрограммы = ОписаниеПрограммыПоИмениКриптопровайдера(
			"Crypto-Pro GOST R 34.10-2001 Cryptographic Service Provider", ОписанияПрограмм);
		
	ИначеЕсли ИмяКриптопровайдера = "Crypto-Pro GOST R 34.10-2012 KC1 CSP"
	      Или ИмяКриптопровайдера = "Crypto-Pro GOST R 34.10-2012 KC2 CSP" Тогда
		
		ОписаниеПрограммы = ОписаниеПрограммыПоИмениКриптопровайдера(
			"Crypto-Pro GOST R 34.10-2012 Cryptographic Service Provider", ОписанияПрограмм);
		
	ИначеЕсли ИмяКриптопровайдера = "Crypto-Pro GOST R 34.10-2012 KC1 Strong CSP"
	      Или ИмяКриптопровайдера = "Crypto-Pro GOST R 34.10-2012 KC2 Strong CSP" Тогда
		
		ОписаниеПрограммы = ОписаниеПрограммыПоИмениКриптопровайдера(
			"Crypto-Pro GOST R 34.10-2012 Strong Cryptographic Service Provider", ОписанияПрограмм);
	КонецЕсли;
	
	Возврат ОписаниеПрограммы;
	
КонецФункции

//  Возвращаемое значение:
//   Структура - содержит ошибки выполнения операций программами:
//     * ОписаниеОшибки  - Строка - полное описание ошибки, когда оно возвращается строкой.
//     * ЗаголовокОшибки - Строка - заголовок ошибки, который соответствует операции
//                                  когда операция одна (не заполнен, когда операций несколько).
//     * Общая           - Булево - если Истина, то одна ошибка общая для всех программ.
//     * ИмяКомпьютера   - Строка - имя компьютера при выполнении операции на стороне сервера.
//     * Ошибки          - Массив из см. НовыеСвойстваОшибки
//
Функция НовоеОписаниеОшибок(ИмяКомпьютера = "") Экспорт
	
	Описание = Новый Структура;
	Описание.Вставить("ОписаниеОшибки",  "");
	Описание.Вставить("ЗаголовокОшибки", "");
	Описание.Вставить("Общая",           Ложь);
	Описание.Вставить("ИмяКомпьютера",   ИмяКомпьютера);
	Описание.Вставить("Ошибки",          Новый Массив);
	
	Возврат Описание;
	
КонецФункции

// Возвращает свойства ошибки выполнения одной операции одной программой.
//
// Возвращаемое значение:
//  Структура:
//   * ЗаголовокОшибки   - Строка - заголовок ошибки, который соответствует операции
//                           когда операций несколько (не заполнен, когда операция одна).
//   * Описание          - Строка - краткое представление ошибки.
//   * ИзИсключения      - Булево - описание ошибки содержит краткое представление информации об ошибке.
//   * НетРасширения     - Булево - не подключилось расширение для работы с ЭП (требуется установить).
//   * КАдминистратору   - Булево - для исправления ошибки требуются права администратора.
//   * Инструкция        - Булево - для исправления требуется инструкция по работе с программами ЭП.
//   * НастройкаПрограмм - Булево - для исправления ошибки требуется настройка программ.
//   * Программа         - СправочникСсылка.ПрограммыЭлектроннойПодписиИШифрования - если не
//                           заполнено, значит ошибка, общая для всех программ.
//   * НетАлгоритма      - Булево - менеджер криптографии не поддерживает алгоритм, указанный
//                                  для его создании в дополнение к указанной программе.
//   * НеУказанПуть      - Булево - для программы не указан путь, необходимый для ОС Linux.
//
Функция НовыеСвойстваОшибки() Экспорт
	
	ПустаяПрограмма = ПредопределенноеЗначение("Справочник.ПрограммыЭлектроннойПодписиИШифрования.ПустаяСсылка");
	
	СвойстваОшибки = Новый Структура;
	СвойстваОшибки.Вставить("ЗаголовокОшибки",   "");
	СвойстваОшибки.Вставить("Описание",          "");
	СвойстваОшибки.Вставить("ИзИсключения",      Ложь);
	СвойстваОшибки.Вставить("НеПоддерживается",  Ложь);
	СвойстваОшибки.Вставить("НетРасширения",     Ложь);
	СвойстваОшибки.Вставить("КАдминистратору",   Ложь);
	СвойстваОшибки.Вставить("Инструкция",        Ложь);
	СвойстваОшибки.Вставить("НастройкаПрограмм", Ложь);
	СвойстваОшибки.Вставить("Программа",         ПустаяПрограмма);
	СвойстваОшибки.Вставить("НетАлгоритма",      Ложь);
	СвойстваОшибки.Вставить("НеУказанПуть",      Ложь);
	
	Возврат СвойстваОшибки;
	
КонецФункции

// Текст ошибки вызова метода компоненты ExtraCryptoAPI.
// 
// Параметры:
//  ИмяМетода - Строка
//  ИнформацияОбОшибке - Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция ОшибкаВызоваМетодаКомпоненты(ИмяМетода, ИнформацияОбОшибке) Экспорт
	
	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Ошибка вызова метода %1 компоненты %2.'"), ИмяМетода, "ExtraCryptoAPI")
		+ Символы.ПС + ИнформацияОбОшибке;
	
КонецФункции

// Только для внутреннего использования.
// 
// Параметры:
//  Программа - Строка
//  Ошибки - Массив
//  ОписанияПрограмм - Массив из см. ЭлектроннаяПодписьСлужебныйПовтИсп.ОписаниеПрограммы
//
// Возвращаемое значение:
//  Массив из см. ЭлектроннаяПодписьСлужебныйПовтИсп.ОписаниеПрограммы
//
Функция МенеджерКриптографииОписанияПрограмм(Программа, Ошибки, Знач ОписанияПрограмм) Экспорт
	
	Если ТипЗнч(Программа) = Тип("Структура") Тогда
		
		ОписанияПрограмм = Новый Массив;
		ОписанияПрограмм.Добавить(Программа);
		Возврат ОписанияПрограмм;
		
	ИначеЕсли Программа <> Неопределено Тогда
		
		ПрограммаНайдена = Ложь;
		Для Каждого ОписаниеПрограммы Из ОписанияПрограмм Цикл
			
			Если ОписаниеПрограммы.Ссылка = Программа Тогда
				ПрограммаНайдена = Истина;
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
		Если Не ПрограммаНайдена Тогда
			МенеджерКриптографииДобавитьОшибку(Ошибки, Программа,
				НСтр("ru = 'Программа не предусмотрена для использования.'"), Истина);
			Возврат Неопределено;
		КонецЕсли;
		
		ОписанияПрограмм = Новый Массив;
		ОписанияПрограмм.Добавить(ОписаниеПрограммы);
		
	КонецЕсли;
	
	Возврат ОписанияПрограмм;
	
КонецФункции

// Только для внутреннего использования.
// 
// Параметры:
//  ОписаниеПрограммы - см. ЭлектроннаяПодписьСлужебныйПовтИсп.ОписаниеПрограммы
//  ЭтоLinux - Булево
//  Ошибки - Массив
//  ЭтоСервер - Булево
//  ПутиКПрограммамНаСерверахLinux - Строка
// 
// Возвращаемое значение:
//  Структура:
//   * ПутьКПрограмме - Строка
//  Неопределено
//
Функция МенеджерКриптографииСвойстваПрограммы(ОписаниеПрограммы, ЭтоLinux, Ошибки, ЭтоСервер,
			ОписаниеПути) Экспорт
	
	Если Не ЗначениеЗаполнено(ОписаниеПрограммы.ИмяПрограммы) Тогда
		МенеджерКриптографииДобавитьОшибку(Ошибки, ОписаниеПрограммы.Ссылка,
			НСтр("ru = 'Не указано имя программы.'"), Истина);
		Возврат Неопределено;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ОписаниеПрограммы.ТипПрограммы) Тогда
		МенеджерКриптографииДобавитьОшибку(Ошибки, ОписаниеПрограммы.Ссылка,
			НСтр("ru = 'Не указан тип программы.'"), Истина);
		Возврат Неопределено;
	КонецЕсли;
	
	СвойстваПрограммы = Новый Структура("ИмяПрограммы, ПутьКПрограмме, ТипПрограммы");
	
	ПутьКПрограмме = "";
	Если ЭтоLinux Тогда
		НеУказанПуть = Ложь;
		Если Не ЗначениеЗаполнено(ОписаниеПути.ПутьКПрограмме) Тогда
			ТекстОшибки = НСтр("ru = 'Не указан путь к программе.'");
			НеУказанПуть = Истина;
		ИначеЕсли Не ОписаниеПути.Существует Тогда
			Если ОписаниеПути.Свойство("ТекстОшибки")
			   И ЗначениеЗаполнено(ОписаниеПути.ТекстОшибки) Тогда
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Не удалось определить путь к программе по причине:
					           |%1'"), ОписаниеПути.ТекстОшибки);
			Иначе
				ПутиКМодулям = СтрРазделить(ОписаниеПути.ПутьКПрограмме, ":", Ложь);
				Если ПутиКМодулям.Количество() = 1 Тогда
					ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Файл не существует: ""%1"".'"), ПутиКМодулям[0]);
				Иначе
					ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Ни один из файлов не существует: ""%1"".'"),
						СтрСоединить(ПутиКМодулям, """, """));
				КонецЕсли;
			КонецЕсли;
		Иначе
			ТекстОшибки = "";
			ПутьКПрограмме = ОписаниеПути.ПутьКПрограмме;
		КонецЕсли;
		Если ЗначениеЗаполнено(ТекстОшибки) Тогда
			МенеджерКриптографииДобавитьОшибку(Ошибки,
				ОписаниеПрограммы.Ссылка, ТекстОшибки, ЭтоСервер, , , НеУказанПуть);
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	СвойстваПрограммы = Новый Структура;
	СвойстваПрограммы.Вставить("ИмяПрограммы",   ОписаниеПрограммы.ИмяПрограммы);
	СвойстваПрограммы.Вставить("ПутьКПрограмме", ПутьКПрограмме);
	СвойстваПрограммы.Вставить("ТипПрограммы",   ОписаниеПрограммы.ТипПрограммы);
	
	Возврат СвойстваПрограммы;
	
КонецФункции

// Только для внутреннего использования.
// Параметры:
//  ОписаниеПрограммы - Структура:
//    * Ссылка - СправочникСсылка.ПрограммыЭлектроннойПодписиИШифрования
//  АлгоритмыПодписи - Массив из Строка
//  АлгоритмПодписи - Строка
//  Ошибки - Массив из см. НовыеСвойстваОшибки
//  ЭтоСервер - Булево
//  ДобавлятьОшибку - Булево
// 
// Возвращаемое значение:
//  Булево
//
Функция МенеджерКриптографииАлгоритмПодписиПоддерживается(ОписаниеПрограммы, Операция,
			АлгоритмПодписи, Ошибки, ЭтоСервер, ДобавлятьОшибку) Экспорт
	
	ВозможныеАлгоритмы = СтрРазделить(АлгоритмПодписи, ",", Ложь);
	
	Для Каждого ВозможныйАлгоритм Из ВозможныеАлгоритмы Цикл
		ВозможныйАлгоритм = СокрЛП(ВозможныйАлгоритм);
		
		Если ВРег(ОписаниеПрограммы.АлгоритмПодписи) = ВРег(ВозможныйАлгоритм)
		 Или (Операция = "ПроверкаПодписи" Или Операция = "ПроверкаСертификата" Или Операция = "ПродлениеСрокаДействияПодписи" Или Операция = "Шифрование")
		   И ОписаниеПрограммы.АлгоритмыПроверкиПодписи.Найти(ВозможныйАлгоритм) <> Неопределено Тогда
			
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Если Не ДобавлятьОшибку Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Программа не поддерживает алгоритм подписи %1.'"),
		СокрЛП(СтрРазделить(ВозможныеАлгоритмы, ",")[0]));
	
	МенеджерКриптографииДобавитьОшибку(Ошибки, ОписаниеПрограммы.Ссылка, ТекстОшибки, ЭтоСервер, Истина);
	Ошибки[Ошибки.ВГраница()].НетАлгоритма = Истина;
	
	Возврат Ложь;
	
КонецФункции

// Только для внутреннего использования.
// 
// Параметры:
//  ОписаниеПрограммы - см. ЭлектроннаяПодписьСлужебныйПовтИсп.ОписаниеПрограммы
//  Менеджер - МенеджерКриптографии
//  Ошибки - Массив
//
// Возвращаемое значение:
//  Булево
//
Функция МенеджерКриптографииАлгоритмыУстановлены(ОписаниеПрограммы, Менеджер, Ошибки) Экспорт
	
	Если ОписаниеПрограммы.ИмяПрограммы = "Default" Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ВыполненОбходНарушенияОбратнойСовместимостиВViPNetCSP_4_4(ОписаниеПрограммы, Менеджер) Тогда
		Возврат Истина;
	КонецЕсли;
	
	АлгоритмПодписи = Строка(ОписаниеПрограммы.АлгоритмПодписи);
	Попытка
		Менеджер.АлгоритмПодписи = АлгоритмПодписи;
	Исключение
		Менеджер = Неопределено;
		// Платформа использует обобщенное сообщение "Неизвестный алгоритм криптографии". Требуется более конкретное.
		МенеджерКриптографииДобавитьОшибку(Ошибки, ОписаниеПрограммы.Ссылка, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Выбран неизвестный алгоритм подписи ""%1"".'"), АлгоритмПодписи), Истина);
		Возврат Ложь;
	КонецПопытки;
	
	АлгоритмХеширования = Строка(ОписаниеПрограммы.АлгоритмХеширования);
	Попытка
		Менеджер.АлгоритмХеширования = АлгоритмХеширования;
	Исключение
		Менеджер = Неопределено;
		// Платформа использует обобщенное сообщение "Неизвестный алгоритм криптографии". Требуется более конкретное.
		МенеджерКриптографииДобавитьОшибку(Ошибки, ОписаниеПрограммы.Ссылка, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Выбран неизвестный алгоритм хеширования ""%1"".'"), АлгоритмХеширования), Истина);
		Возврат Ложь;
	КонецПопытки;
	
	АлгоритмШифрования = Строка(ОписаниеПрограммы.АлгоритмШифрования);
	Попытка
		Менеджер.АлгоритмШифрования = АлгоритмШифрования;
	Исключение
		Менеджер = Неопределено;
		// Платформа использует обобщенное сообщение "Неизвестный алгоритм криптографии". Требуется более конкретное.
		МенеджерКриптографииДобавитьОшибку(Ошибки, ОписаниеПрограммы.Ссылка, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Выбран неизвестный алгоритм шифрования ""%1"".'"), АлгоритмШифрования), Истина);
		Возврат Ложь;
	КонецПопытки;
	
	Возврат Истина;
	
КонецФункции

// Для функции МенеджерКриптографииАлгоритмыУстановлены.
Функция ВыполненОбходНарушенияОбратнойСовместимостиВViPNetCSP_4_4(ОписаниеПрограммы, Менеджер)
	
	Если Не (  ОписаниеПрограммы.ИмяПрограммы = "Infotecs GOST 2012/512 Cryptographic Service Provider"
	         И ОписаниеПрограммы.ТипПрограммы = 77)
	   И Не (  ОписаниеПрограммы.ИмяПрограммы = "Infotecs GOST 2012/1024 Cryptographic Service Provider"
	         И ОписаниеПрограммы.ТипПрограммы = 78) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	АлгоритмПодписи     = Строка(ОписаниеПрограммы.АлгоритмПодписи);
	АлгоритмХеширования = Строка(ОписаниеПрограммы.АлгоритмХеширования);
	АлгоритмШифрования  = Строка(ОписаниеПрограммы.АлгоритмШифрования);
	
	АлгоритмыУстановлены = Истина;
	Попытка
		Менеджер.АлгоритмПодписи     = АлгоритмПодписи;
		Менеджер.АлгоритмХеширования = АлгоритмХеширования;
		Менеджер.АлгоритмШифрования  = АлгоритмШифрования;
	Исключение
		АлгоритмыУстановлены = Ложь;
	КонецПопытки;
	
	Если АлгоритмыУстановлены Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если АлгоритмПодписи     = "GOST 34.10-2012 256"
	   И АлгоритмХеширования = "GOST 34.11-2012 256"
	   И АлгоритмШифрования  = "GOST 28147-89" Тогда
		
		АлгоритмПодписи     = "GR 34.10-2012 256";
		АлгоритмХеширования = "GR 34.11-2012 256";
		АлгоритмШифрования  = "GOST 28147-89";
		
	ИначеЕсли АлгоритмПодписи     = "GR 34.10-2012 256"
	        И АлгоритмХеширования = "GR 34.11-2012 256"
	        И АлгоритмШифрования  = "GOST 28147-89" Тогда
	
		АлгоритмПодписи     = "GOST 34.10-2012 256";
		АлгоритмХеширования = "GOST 34.11-2012 256";
		АлгоритмШифрования  = "GOST 28147-89";
		
	ИначеЕсли АлгоритмПодписи     = "GOST 34.10-2012 512"
	        И АлгоритмХеширования = "GOST 34.11-2012 512"
	        И АлгоритмШифрования  = "GOST 28147-89" Тогда
		
		АлгоритмПодписи     = "GR 34.10-2012 512";
		АлгоритмХеширования = "GR 34.11-2012 512";
		АлгоритмШифрования  = "GOST 28147-89";
		
	ИначеЕсли АлгоритмПодписи     = "GR 34.10-2012 512"
	        И АлгоритмХеширования = "GR 34.11-2012 512"
	        И АлгоритмШифрования  = "GOST 28147-89" Тогда
	
		АлгоритмПодписи     = "GOST 34.10-2012 512";
		АлгоритмХеширования = "GOST 34.11-2012 512";
		АлгоритмШифрования  = "GOST 28147-89";
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
	АлгоритмыУстановлены = Истина;
	Попытка
		Менеджер.АлгоритмПодписи     = АлгоритмПодписи;
		Менеджер.АлгоритмХеширования = АлгоритмХеширования;
		Менеджер.АлгоритмШифрования  = АлгоритмШифрования;
	Исключение
		АлгоритмыУстановлены = Ложь;
	КонецПопытки;
	
	Возврат АлгоритмыУстановлены;
	
КонецФункции

// Только для внутреннего использования.
// 
// Параметры:
//  ОписаниеПрограммы - см. ЭлектроннаяПодписьСлужебныйПовтИсп.ОписаниеПрограммы
//  Ошибки - Массив
//  ЭтоСервер - Булево
//
Процедура МенеджерКриптографииПрограммаНеНайдена(ОписаниеПрограммы, Ошибки, ЭтоСервер) Экспорт
	
	МенеджерКриптографииДобавитьОшибку(Ошибки, ОписаниеПрограммы.Ссылка,
		НСтр("ru = 'Программа не установлена на компьютере.'"), ЭтоСервер, Истина);
	
КонецПроцедуры

// Только для внутреннего использования.
// 
// Параметры:
//  ОписаниеПрограммы - см. ЭлектроннаяПодписьСлужебныйПовтИсп.ОписаниеПрограммы
//  ИмяПрограммыПолученное - Строка
//  Ошибки - Массив
//  ЭтоСервер - Булево
//
// Возвращаемое значение:
//  Булево
//
Функция МенеджерКриптографииИмяПрограммыСовпадает(ОписаниеПрограммы, ИмяПрограммыПолученное, Ошибки, ЭтоСервер) Экспорт
	
	Если ИмяПрограммыПолученное <> ОписаниеПрограммы.ИмяПрограммы Тогда
		МенеджерКриптографииДобавитьОшибку(Ошибки, ОписаниеПрограммы.Ссылка, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Получена другая программа с именем ""%1"".'"), ИмяПрограммыПолученное), ЭтоСервер, Истина);
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Только для внутреннего использования.
//
// Параметры:
//  Ошибки    - Массив из см. НовыеСвойстваОшибки
//  Программа - СправочникСсылка.ПрограммыЭлектроннойПодписиИШифрования
//  Описание  - Строка
//  КАдминистратору - Булево
//  Инструкция   - Булево
//  ИзИсключения - Булево
//  НеУказанПуть - Булево
//
Процедура МенеджерКриптографииДобавитьОшибку(Ошибки, Программа, Описание,
			КАдминистратору, Инструкция = Ложь, ИзИсключения = Ложь, НеУказанПуть = Ложь) Экспорт
	
	СвойстваОшибки = НовыеСвойстваОшибки();
	Если ЗначениеЗаполнено(Программа) Тогда
		СвойстваОшибки.Программа = Программа;
	КонецЕсли;
	СвойстваОшибки.Описание          = Описание;
	СвойстваОшибки.КАдминистратору   = КАдминистратору;
	СвойстваОшибки.Инструкция        = Инструкция;
	СвойстваОшибки.ИзИсключения      = ИзИсключения;
	СвойстваОшибки.НеУказанПуть      = НеУказанПуть;
	СвойстваОшибки.НастройкаПрограмм = Истина;
	
	Ошибки.Добавить(СвойстваОшибки);
	
КонецПроцедуры

// Только для внутреннего использования.
//
// Параметры:
//  ОписаниеОшибок - см. НовоеОписаниеОшибок
//  Программа - СправочникСсылка.ПрограммыЭлектроннойПодписиИШифрования
//  АлгоритмПодписи - Строка
//  ЭтоПолноправныйПользователь - Булево
//  ЭтоСервер - Булево
//
Процедура МенеджерКриптографииЗаполнитьПредставлениеОшибок(ОписаниеОшибок,
			Программа, АлгоритмПодписи, ЭтоПолноправныйПользователь, ЭтоСервер) Экспорт
		
	Если ОписаниеОшибок.Ошибки.Количество() = 0 Тогда
		Если Не ЗначениеЗаполнено(АлгоритмПодписи) Тогда
			ТекстОшибки = НСтр("ru = 'Не предусмотрено использование ни одной программы.'");
		Иначе
			ШаблонОшибки = НСтр("ru = 'Не предусмотрено использование ни одной программы
			                          |с алгоритмом подписи %1.'");
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонОшибки,
				СокрЛП(СтрРазделить(АлгоритмПодписи, ",")[0]));
		КонецЕсли;
		ОписаниеОшибок.Общая = Истина;
		МенеджерКриптографииДобавитьОшибку(ОписаниеОшибок.Ошибки,
			Неопределено, ТекстОшибки, Истина, Истина);
	КонецЕсли;
	
	ЗаполнитьОбщееПредставлениеОшибок(ОписаниеОшибок, ЭтоПолноправныйПользователь);
	
КонецПроцедуры

// Только для внутреннего использования.
//
// Параметры:
//  ОписаниеОшибок - см. НовоеОписаниеОшибок
//  ЭтоПолноправныйПользователь - Булево
//
Процедура ЗаполнитьОбщееПредставлениеОшибок(ОписаниеОшибок, ЭтоПолноправныйПользователь)
	
	ЧастиОписания = Новый Массив;
	Если ЗначениеЗаполнено(ОписаниеОшибок.ЗаголовокОшибки) Тогда
		ЧастиОписания.Добавить(ОписаниеОшибок.ЗаголовокОшибки);
	КонецЕсли;
	
	КАдминистратору = Ложь;
	Для Каждого СвойстваОшибки Из ОписаниеОшибок.Ошибки Цикл
		Описание = "";
		Если ЗначениеЗаполнено(СвойстваОшибки.ЗаголовокОшибки) Тогда
			Описание = Описание + СвойстваОшибки.ЗаголовокОшибки + Символы.ПС;
		КонецЕсли;
		Если ЗначениеЗаполнено(СвойстваОшибки.Программа) Тогда
			Описание = Описание + Строка(СвойстваОшибки.Программа) + ":" + Символы.ПС;
		КонецЕсли;
		ЧастиОписания.Добавить(Описание + СвойстваОшибки.Описание);
		КАдминистратору = КАдминистратору Или СвойстваОшибки.КАдминистратору;
	КонецЦикла;
	ОписаниеОшибки = СтрСоединить(ЧастиОписания, Символы.ПС);
	
	Если КАдминистратору И Не ЭтоПолноправныйПользователь Тогда
		ОписаниеОшибки = ОписаниеОшибки + Символы.ПС + Символы.ПС
			+ НСтр("ru = 'Обратитесь к администратору.'");
	КонецЕсли;
	
	ОписаниеОшибок.ОписаниеОшибки = ОписаниеОшибки;
	
КонецПроцедуры

// Параметры:
//  ЗаголовокОшибки - Строка
//  ОписаниеОшибок - см. НовоеОписаниеОшибок
//
Функция ТекстОшибкиПоискаПрограммы(Знач ЗаголовокОшибки, ОписаниеОшибок) Экспорт
	
	Для Каждого Ошибка Из ОписаниеОшибок.Ошибки Цикл
		Прервать;
	КонецЦикла;
	
	ЗаголовокОшибки = СтрЗаменить(ЗаголовокОшибки, "%1", ОписаниеОшибок.ИмяКомпьютера);
	Возврат ЗаголовокОшибки + " " + Ошибка.Описание;
	
КонецФункции

// Только для внутреннего использования.
//
// Параметры:
//  Контекст - Структура:
//   * ОписаниеПрограммы - Структура:
//      * Ссылка - СправочникСсылка.ПрограммыЭлектроннойПодписиИШифрования
//  Ошибка - см. НовоеОписаниеОшибок
//
// Возвращаемое значение:
//  СправочникСсылка.СертификатыКлючейЭлектроннойПодписиИШифрования
//
Функция ЗаписатьСертификатВСправочник(Контекст, Ошибка) Экспорт
	
	Контекст.ДополнительныеПараметры.Программа = Контекст.ОписаниеПрограммы.Ссылка;
	Попытка
		Сертификат = ЭлектроннаяПодписьСлужебныйВызовСервера.ЗаписатьСертификатВСправочник(
			Контекст.ДанныеСертификата, Контекст.ДополнительныеПараметры);
	Исключение
		Сертификат = Неопределено;
		Контекст.ЗаголовокФормы = НСтр("ru = 'Ошибка добавления сертификата'");
		
		Ошибка.Общая = Истина;
		Ошибка.ЗаголовокОшибки = НСтр("ru = 'Не удалось записать сертификат по причине:'");
		
		СвойстваОшибки = НовыеСвойстваОшибки();
		СвойстваОшибки.Описание = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Ошибка.Ошибки.Добавить(СвойстваОшибки);
	КонецПопытки;
	
	Возврат Сертификат;
	
КонецФункции

// Только для внутреннего использования.
Функция ЗаголовокОшибкиДобавленияСертификата(Операция, ИмяКомпьютера = "") Экспорт
	
	Если ЗначениеЗаполнено(ИмяКомпьютера) Тогда // Признак ЭтоСервер.
		Если Операция = "Подписание" Тогда
			ШаблонЗаголовка = НСтр("ru = 'Не удалось пройти проверку подписания на сервере %1 по причине:'");
		ИначеЕсли Операция = "Шифрование" Тогда
			ШаблонЗаголовка = НСтр("ru = 'Не удалось пройти проверку шифрования на сервере %1 по причине:'");
		ИначеЕсли Операция = "Расшифровка" Тогда
			ШаблонЗаголовка = НСтр("ru = 'Не удалось пройти проверку расшифровки на сервере %1 по причине:'");
		КонецЕсли;
		ЗаголовокОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			ШаблонЗаголовка, ИмяКомпьютера);
	Иначе
		Если Операция = "Подписание" Тогда
			ЗаголовокОшибки = НСтр("ru = 'Не удалось пройти проверку подписания на компьютере по причине:'");
		ИначеЕсли Операция = "Шифрование" Тогда
			ЗаголовокОшибки = НСтр("ru = 'Не удалось пройти проверку шифрования на компьютере по причине:'");
		ИначеЕсли Операция = "Расшифровка" Тогда
			ЗаголовокОшибки = НСтр("ru = 'Не удалось пройти проверку расшифровки на компьютере по причине:'");
		КонецЕсли;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ЗаголовокОшибки) Тогда
		ТекущийТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Некорректное значение параметра Операция ""%1"" в процедуре %2'"),
			Операция,
			"ЗаполнитьОшибкуДобавленияСертификата");
		ВызватьИсключение ТекущийТекстОшибки;
	КонецЕсли;
	
	Возврат ЗаголовокОшибки;
	
КонецФункции

// Только для внутреннего использования.
//
// Параметры:
//  ОписаниеОшибок - см. НовоеОписаниеОшибок
//  ОписаниеПрограммы - Структура:
//   * Ссылка - СправочникСсылка.ПрограммыЭлектроннойПодписиИШифрования
//  Операция - Строка
//  ТекстОшибки - Строка
//  ЭтоПолноправныйПользователь - Булево
//  ПустыеДанные - Булево
//  ИмяКомпьютера - Строка
//
Процедура ЗаполнитьОшибкуДобавленияСертификата(ОписаниеОшибок, ОписаниеПрограммы, Операция,
			ТекстОшибки, ЭтоПолноправныйПользователь, ПустыеДанные = Ложь, ИмяКомпьютера = "") Экспорт
	
	ЗаголовокОшибки = ЗаголовокОшибкиДобавленияСертификата(Операция, ИмяКомпьютера);
	
	СвойстваОшибки = НовыеСвойстваОшибки();
	СвойстваОшибки.Описание = ТекстОшибки;
	СвойстваОшибки.Программа = ОписаниеПрограммы.Ссылка;
	
	Если Не ПустыеДанные Тогда
		СвойстваОшибки.ИзИсключения = Истина;
		СвойстваОшибки.Инструкция = Истина;
		СвойстваОшибки.НастройкаПрограмм = Истина;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ОписаниеОшибок.Ошибки) Тогда
		ОписаниеОшибок.ЗаголовокОшибки = ЗаголовокОшибки;
		
	ИначеЕсли Не ЗначениеЗаполнено(ОписаниеОшибок.ЗаголовокОшибки) Тогда
		СвойстваОшибки.ЗаголовокОшибки = ЗаголовокОшибки;
		
	ИначеЕсли ОписаниеОшибок.ЗаголовокОшибки <> ЗаголовокОшибки Тогда
		Для Каждого ТекущиеСвойства Из ОписаниеОшибок.Ошибки Цикл
			ТекущиеСвойства.ЗаголовокОшибки = ОписаниеОшибок.ЗаголовокОшибки;
		КонецЦикла;
		ОписаниеОшибок.ЗаголовокОшибки = "";
		СвойстваОшибки.ЗаголовокОшибки = ЗаголовокОшибки;
	КонецЕсли;
	
	ОписаниеОшибок.Ошибки.Добавить(СвойстваОшибки);
	
	ЗаполнитьОбщееПредставлениеОшибок(ОписаниеОшибок, ЭтоПолноправныйПользователь);
	
КонецПроцедуры

// Только для внутреннего использования.
Функция РежимыПроверкиСертификата(ИгнорироватьВремяДействия = Ложь) Экспорт
	
	МассивРежимовПроверки = Новый Массив;
	МассивРежимовПроверки.Добавить(РежимПроверкиСертификатаКриптографии.РазрешитьТестовыеСертификаты);
	
	Если ИгнорироватьВремяДействия Тогда
		МассивРежимовПроверки.Добавить(РежимПроверкиСертификатаКриптографии.ИгнорироватьВремяДействия);
	КонецЕсли;
	
	Возврат МассивРежимовПроверки;
	
КонецФункции

// Только для внутреннего использования.
Функция ПараметрыПроверкиСертификатаВСервисе(ОбщиеНастройки, РежимыПроверкиСертификата) Экспорт
	
	Если Не ОбщиеНастройки.ДоступнаПроверкаСертификатаВОблачномСервисеСПараметрами Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Режимы = Новый Массив;
	Для Каждого Режим Из РежимыПроверкиСертификата Цикл
		Если Режим = РежимПроверкиСертификатаКриптографии.ИгнорироватьВремяДействия Тогда
			Режимы.Добавить("ИгнорироватьВремяДействия");
		ИначеЕсли Режим = РежимПроверкиСертификатаКриптографии.ИгнорироватьДействительностьПодписи Тогда
			Режимы.Добавить("ИгнорироватьДействительностьПодписи");
		ИначеЕсли Режим = РежимПроверкиСертификатаКриптографии.ИгнорироватьПроверкуВСпискеОтозванныхСертификатов Тогда
			Режимы.Добавить("ИгнорироватьПроверкуВСпискеОтозванныхСертификатов");
		ИначеЕсли Режим = РежимПроверкиСертификатаКриптографии.РазрешитьТестовыеСертификаты Тогда
			Режимы.Добавить("РазрешитьТестовыеСертификаты");
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура("РежимПроверкиСертификата", СтрСоединить(Режимы, ","));
	
КонецФункции

// Только для внутреннего использования.
Функция СертификатПросрочен(Сертификат, НаДату, ДобавкаВремени) Экспорт
	
	Если Не ЗначениеЗаполнено(НаДату) Тогда
		Возврат "";
	КонецЕсли;
	
	ДатыСертификата = ДатыСертификата(Сертификат, ДобавкаВремени);
	
	Если ДатыСертификата.ДатаОкончания > НачалоДня(НаДату) Тогда
		Возврат "";
	КонецЕсли;
	
	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'На %1 просрочен сертификат.'"), Формат(НачалоДня(НаДату), "ДЛФ=D"));
	
КонецФункции

// Только для внутреннего использования.
Функция ТекстОшибкиСервисаСертификатНедействителен() Экспорт
	
	Возврат НСтр("ru = 'Сервис сообщил, что сертификат недействителен.'");
	
КонецФункции

// Только для внутреннего использования.
//
// Возвращаемое значение:
//  Строка
//
Функция ТекстОшибкиСервисаПодписьНедействительна() Экспорт
	
	Возврат НСтр("ru = 'Сервис сообщил, что подпись недействительна.'");
	
КонецФункции

// Только для внутреннего использования.
Функция ТипХранилищаДляПоискаСертификата(ТолькоВЛичномХранилище) Экспорт
	
	Если ТипЗнч(ТолькоВЛичномХранилище) = Тип("ТипХранилищаСертификатовКриптографии") Тогда
		ТипХранилища = ТолькоВЛичномХранилище;
	ИначеЕсли ТолькоВЛичномХранилище Тогда
		ТипХранилища = ТипХранилищаСертификатовКриптографии.ПерсональныеСертификаты;
	Иначе
		ТипХранилища = Неопределено; // Хранилище, содержащее сертификаты всех доступных типов.
	КонецЕсли;
	
	Возврат ТипХранилища;
	
КонецФункции

// Только для внутреннего использования.
Процедура ДобавитьСвойстваСертификатов(Таблица, МассивСертификатов, БезОтбора,
	ДобавкаВремени, ТекущаяДатаСеанса, Параметры = Неопределено) Экспорт
	
	ТолькоОтпечатки = Ложь;
	ВОблачномСервисе = Ложь;
	ОблачнаяПодпись = Ложь;
	
	Если Параметры <> Неопределено Тогда
		Если Параметры.Свойство("ТолькоОтпечатки") Тогда
			ТолькоОтпечатки = Параметры.ТолькоОтпечатки;
		КонецЕсли;
		Если Параметры.Свойство("ВОблачномСервисе") Тогда
			ВОблачномСервисе = Параметры.ВОблачномСервисе;
		КонецЕсли;
		Если Параметры.Свойство("ОблачнаяПодпись") Тогда
			ОблачнаяПодпись = Параметры.ОблачнаяПодпись;
		КонецЕсли;
	КонецЕсли;
	
	Если ТолькоОтпечатки Тогда
		ОтпечаткиУжеДобавленныхСертификатов = Таблица;
		НаСервере = Ложь;
	Иначе
		ОтпечаткиУжеДобавленныхСертификатов = Новый Соответствие; // Для пропуска дублей.
		НаСервере = ТипЗнч(Таблица) <> Тип("Массив");
	КонецЕсли;
	
	Для Каждого ТекущийСертификат Из МассивСертификатов Цикл
		Отпечаток = Base64Строка(ТекущийСертификат.Отпечаток);
		ДатыСертификата = ДатыСертификата(ТекущийСертификат, ДобавкаВремени);
		
		Если ДатыСертификата.ДатаОкончания <= ТекущаяДатаСеанса Тогда
			Если Не БезОтбора Тогда
				Продолжить; // Пропуск просроченных сертификатов.
			КонецЕсли;
		КонецЕсли;
		
		Если ОтпечаткиУжеДобавленныхСертификатов.Получить(Отпечаток) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ОтпечаткиУжеДобавленныхСертификатов.Вставить(Отпечаток, Истина);
		
		Если ТолькоОтпечатки Тогда
			Продолжить;
		КонецЕсли;
		
		ТипРазмещения = 1;
		Если НаСервере Тогда
			Если ОблачнаяПодпись Тогда
				ТипРазмещения = 3;
			ИначеЕсли ВОблачномСервисе Тогда
				ТипРазмещения = 4;
			Иначе
				ТипРазмещения = 2;
			КонецЕсли;
			Строка = Таблица.Найти(Отпечаток, "Отпечаток");
			Если Строка <> Неопределено Тогда
				Если ВОблачномСервисе Тогда
					Строка.ВОблачномСервисе = Истина;
				КонецЕсли;
				Продолжить; // Пропуск уже добавленных на клиенте.
			КонецЕсли;
		КонецЕсли;
		
		СостояниеСертификата = 2;
		Если ДатыСертификата.ДатаОкончания <= ТекущаяДатаСеанса Тогда
			СостояниеСертификата = 4;
		ИначеЕсли ДатыСертификата.ДатаОкончания <= ТекущаяДатаСеанса + 30*24*60*60 Тогда
			СостояниеСертификата = 3;
		КонецЕсли;
		
		СвойстваСертификата = Новый Структура;
		СвойстваСертификата.Вставить("Отпечаток", Отпечаток);
		СвойстваСертификата.Вставить("Представление",
			ПредставлениеСертификата(ТекущийСертификат, ДобавкаВремени));
		СвойстваСертификата.Вставить("КемВыдан", ПредставлениеИздателя(ТекущийСертификат));
		СвойстваСертификата.Вставить("ТипРазмещения", ТипРазмещения);
		СвойстваСертификата.Вставить("СостояниеСертификата", СостояниеСертификата);
		
		
		Если ТипЗнч(Таблица) = Тип("Массив") Тогда
			Таблица.Добавить(СвойстваСертификата);
		Иначе
			Если ОблачнаяПодпись Тогда
				СвойстваСертификата.Вставить("НаСервере", Ложь);
			ИначеЕсли ВОблачномСервисе Тогда
				СвойстваСертификата.Вставить("ВОблачномСервисе", Истина);
			ИначеЕсли НаСервере Тогда
				СвойстваСертификата.Вставить("НаСервере", Истина);
			КонецЕсли;
			ЗаполнитьЗначенияСвойств(Таблица.Добавить(), СвойстваСертификата);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Только для внутреннего использования.
//
// Параметры:
//   Массив - Массив
//
Процедура ДобавитьОтпечаткиСертификатов(Массив, МассивСертификатов, ДобавкаВремени, ТекущаяДатаСеанса) Экспорт
	
	Для Каждого ТекущийСертификат Из МассивСертификатов Цикл
		Отпечаток = Base64Строка(ТекущийСертификат.Отпечаток);
		Если ТипЗнч(ТекущаяДатаСеанса) = Тип("Дата") Тогда
			ДатыСертификата = ДатыСертификата(ТекущийСертификат, ДобавкаВремени);
			
			Если ДатыСертификата.ДатаОкончания <= ТекущаяДатаСеанса Тогда
				Продолжить; // Пропуск просроченных сертификатов.
			КонецЕсли;
		КонецЕсли;
		Если Массив.Найти(Отпечаток) = Неопределено Тогда
			Массив.Добавить(Отпечаток);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Только для внутреннего использования.
// 
// Параметры:
//  ДвоичныеДанныеПодписи - ДвоичныеДанные
//  СвойстваСертификата - см. ЭлектроннаяПодписьКлиент.СвойстваСертификата
//  Комментарий - Строка
//  АвторизованныйПользователь - СправочникСсылка.Пользователи
//  ИмяФайлаПодписи - Строка - имя файла подписи
//  ПараметрыПодписи - см. ПараметрыПодписиКриптографии
//  
// Возвращаемое значение:
//  Структура:
//   * Подпись - ДвоичныеДанные
//   * УстановившийПодпись - СправочникСсылка.Пользователи
//   * Комментарий - Строка
//   * ИмяФайлаПодписи - Строка 
//   * ДатаПодписи - Дата - дата подписи неподтвержденная
//   * ДатаПроверкиПодписи - Дата
//   * ПодписьВерна - Булево
//   * Сертификат - ДвоичныеДанные
//   * Отпечаток - Строка
//   * КомуВыданСертификат - Строка
//   * ТипПодписи - ПеречислениеСсылка.ТипыПодписиКриптографии
//   * СрокДействияПоследнейМеткиВремени - Дата
//   * ДатаПодписиИзМетки - Дата 
//   * НеподтвержденнаяДатаПодписи - Дата
//
Функция СвойстваПодписи(ДвоичныеДанныеПодписи, СвойстваСертификата, Комментарий,
			АвторизованныйПользователь, ИмяФайлаПодписи = "", ПараметрыПодписи = Неопределено) Экспорт
	
	СвойстваПодписи = Новый Структура;
	СвойстваПодписи.Вставить("Подпись",             ДвоичныеДанныеПодписи);
	СвойстваПодписи.Вставить("УстановившийПодпись", АвторизованныйПользователь);
	СвойстваПодписи.Вставить("Комментарий",         Комментарий);
	СвойстваПодписи.Вставить("ИмяФайлаПодписи",     ИмяФайлаПодписи);
	СвойстваПодписи.Вставить("ДатаПодписи",         Дата('00010101')); // Устанавливается перед записью.
	СвойстваПодписи.Вставить("ДатаПроверкиПодписи", Дата('00010101')); // Дата последней проверки подписи.
	СвойстваПодписи.Вставить("ПодписьВерна",        Ложь);             // Результат последней проверки подписи.
	// Производные свойства:
	СвойстваПодписи.Вставить("Сертификат",          СвойстваСертификата.ДвоичныеДанные);
	СвойстваПодписи.Вставить("Отпечаток",           СвойстваСертификата.Отпечаток);
	СвойстваПодписи.Вставить("КомуВыданСертификат", СвойстваСертификата.КомуВыдан);
	
	СвойстваПодписи.Вставить("ТипПодписи");
	СвойстваПодписи.Вставить("СрокДействияПоследнейМеткиВремени");
	СвойстваПодписи.Вставить("ДатаПодписиИзМетки");
	СвойстваПодписи.Вставить("НеподтвержденнаяДатаПодписи");
	
	Если ПараметрыПодписи <> Неопределено Тогда
		СвойстваПодписи.Вставить("ТипПодписи", ПараметрыПодписи.ТипПодписи);
		СвойстваПодписи.Вставить("СрокДействияПоследнейМеткиВремени", ПараметрыПодписи.СрокДействияПоследнейМеткиВремени);
		СвойстваПодписи.Вставить("ДатаПодписиИзМетки", ПараметрыПодписи.ДатаПодписиИзМетки);
		СвойстваПодписи.Вставить("НеподтвержденнаяДатаПодписи", ПараметрыПодписи.НеподтвержденнаяДатаПодписи);
	КонецЕсли;
	
	Возврат СвойстваПодписи;
	
КонецФункции

// Только для внутреннего использования.
// 
// Возвращаемое значение:
//  Структура - параметры подписи криптографии:
//   * ТипПодписи - ПеречислениеСсылка.ТипыПодписиКриптографии
//   * СрокДействияПоследнейМеткиВремени - Дата
//   * СертификатПоследнейМеткиВремени - СертификатКриптографии
//   * ДатаПодписиИзМетки - Дата
//   * ОписаниеСертификата - см. ЭлектроннаяПодписьКлиент.СвойстваСертификата
//   * НеподтвержденнаяДатаПодписи - Дата
//   * ДатаПоследнейМеткиВремени - Дата
//
Функция НовыеПараметрыПодписиКриптографии() Экспорт
	
	ПараметрыПодписи = Новый Структура;
	ПараметрыПодписи.Вставить("ТипПодписи");
	ПараметрыПодписи.Вставить("СрокДействияПоследнейМеткиВремени");
	ПараметрыПодписи.Вставить("СертификатПоследнейМеткиВремени");
	ПараметрыПодписи.Вставить("ДатаПодписиИзМетки");
	ПараметрыПодписи.Вставить("ОписаниеСертификата");
	ПараметрыПодписи.Вставить("НеподтвержденнаяДатаПодписи");
	ПараметрыПодписи.Вставить("ДатаПоследнейМеткиВремени");
	
	Возврат ПараметрыПодписи;
	
КонецФункции

// Только для внутреннего использования.
// Возвращаемое значение:
//  Дата, Неопределено
//
Функция ДатаПодписиИзПараметровПодписи(ПараметрыПодписи) Экспорт
	
	Если ЗначениеЗаполнено(ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(
		ПараметрыПодписи, "ДатаПодписиИзМетки", Неопределено)) Тогда
		Возврат ПараметрыПодписи.ДатаПодписиИзМетки;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(
		ПараметрыПодписи, "НеподтвержденнаяДатаПодписи", Неопределено)) Тогда
		Возврат ПараметрыПодписи.НеподтвержденнаяДатаПодписи;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Только для внутреннего использования.
// 
// Возвращаемое значение:
//   см. НовыеПараметрыПодписиКриптографии
//
Функция ПараметрыПодписиКриптографии(КонтейнерПодписи, ДобавкаВремени, ДатаСеанса) Экспорт

	ПараметрыПодписи = НовыеПараметрыПодписиКриптографии();
		
	Подпись = КонтейнерПодписи.Подписи[0];
	ПараметрыПодписи.ОписаниеСертификата = СвойстваСертификата(Подпись.СертификатПодписи, ДобавкаВремени);
		
	ДатаПодписиИзМетки = Дата(3999, 12, 31);
	Если ЗначениеЗаполнено(Подпись.НеподтвержденноеВремяПодписи) Тогда
		ПараметрыПодписи.НеподтвержденнаяДатаПодписи = Подпись.НеподтвержденноеВремяПодписи + ДобавкаВремени;
	КонецЕсли;
	
	ПараметрыПодписи.ТипПодписи = ТипПодписиКриптографии(Подпись.ТипПодписи);
	СрокДействияПоследнейМеткиВремени = Неопределено;
	Если Подпись.МеткаВремениПодписи <> Неопределено Тогда
		СертификатПоследнейМеткиВремени = Подпись.МеткаВремениПодписи.Подписи[0].СертификатПодписи; // СертификатКриптографии
		СрокДействияПоследнейМеткиВремени = СертификатПоследнейМеткиВремени.ДатаОкончания;
		ДатаПодписиИзМетки = Мин(ДатаПодписиИзМетки, Подпись.МеткаВремениПодписи.Дата + ДобавкаВремени);
		ПараметрыПодписи.ДатаПоследнейМеткиВремени = Подпись.МеткаВремениПодписи.Дата + ДобавкаВремени;
	КонецЕсли;
	
	Если Подпись.МеткаВремениДанныхПроверкиПодписи <> Неопределено Тогда
		СертификатПоследнейМеткиВремени = Подпись.МеткаВремениДанныхПроверкиПодписи.Подписи[0].СертификатПодписи;  // СертификатКриптографии
		СрокДействияПоследнейМеткиВремени = СертификатПоследнейМеткиВремени.ДатаОкончания;
		ДатаПодписиИзМетки = Мин(ДатаПодписиИзМетки, Подпись.МеткаВремениДанныхПроверкиПодписи.Дата + ДобавкаВремени);
		ПараметрыПодписи.ДатаПоследнейМеткиВремени = Подпись.МеткаВремениДанныхПроверкиПодписи.Дата + ДобавкаВремени;
	КонецЕсли;
	
	Если Подпись.АрхивныеМеткиВремени.Количество() > 0 Тогда
		ИндексПоследнейМетки = Подпись.АрхивныеМеткиВремени.ВГраница();
		СертификатПоследнейМеткиВремени = Подпись.АрхивныеМеткиВремени[ИндексПоследнейМетки].Подписи[0].СертификатПодписи; // СертификатКриптографии
		СрокДействияПоследнейМеткиВремени = СертификатПоследнейМеткиВремени.ДатаОкончания;
		ДатаПодписиИзМетки = Мин(ДатаПодписиИзМетки, Подпись.АрхивныеМеткиВремени[0].Дата + ДобавкаВремени);
		ПараметрыПодписи.ДатаПоследнейМеткиВремени = Подпись.АрхивныеМеткиВремени[ИндексПоследнейМетки].Дата;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СрокДействияПоследнейМеткиВремени) Тогда
		ПараметрыПодписи.СрокДействияПоследнейМеткиВремени = СрокДействияПоследнейМеткиВремени + ДобавкаВремени; 
		ПараметрыПодписи.СертификатПоследнейМеткиВремени = СертификатПоследнейМеткиВремени;
	ИначеЕсли ПараметрыПодписи.ОписаниеСертификата.ДействителенДо < ДатаСеанса Тогда
		ПараметрыПодписи.СрокДействияПоследнейМеткиВремени = ПараметрыПодписи.ОписаниеСертификата.ДействителенДо;
		ПараметрыПодписи.СертификатПоследнейМеткиВремени = Подпись.СертификатПодписи;
	Иначе
		ПараметрыПодписи.СертификатПоследнейМеткиВремени = Подпись.СертификатПодписи;
	КонецЕсли;

	Если ДатаПодписиИзМетки <> Дата(3999, 12, 31) Тогда
		ПараметрыПодписи.ДатаПодписиИзМетки = ДатаПодписиИзМетки;
	КонецЕсли;
		
	Возврат ПараметрыПодписи;
	
КонецФункции

// Только для внутреннего использования.
Функция ТипПодписиКриптографии(ТипПодписиЗначение) Экспорт
	
	Если Ложь Тогда // Для совместимости с версиями платформы, не поддерживающими усовершенствованную подпись.
		ТипПодписиКриптографии = Неопределено;
	КонецЕсли;
	
	ИмяТипа = "ТипПодписиКриптографии";
	
	Если ТипЗнч(ТипПодписиЗначение) = Тип(ИмяТипа) Тогда
		Если ТипПодписиЗначение = ТипПодписиКриптографии.CAdESBES Тогда
			Возврат ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.БазоваяCAdESBES");
		ИначеЕсли ТипПодписиЗначение = ТипПодписиКриптографии.CAdEST Тогда
			Возврат ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.СМеткойДоверенногоВремениCAdEST");
		ИначеЕсли ТипПодписиЗначение = ТипПодписиКриптографии.CAdESAv3 Тогда
			Возврат ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.АрхивнаяCAdESAv3");
		ИначеЕсли ТипПодписиЗначение = ТипПодписиКриптографии.CAdESC Тогда
			Возврат ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.СПолнымНаборомПроверочныхДанныхCAdESC");
		ИначеЕсли ТипПодписиЗначение = ТипПодписиКриптографии.CAdESXLongType2 Тогда
			Возврат ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.РасширеннаяДолгосрочнаяCAdESXLongType2");
		ИначеЕсли ТипПодписиЗначение = ТипПодписиКриптографии.CAdESAv2 Тогда
			Возврат ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.CAdESAv2");
		ИначеЕсли ТипПодписиЗначение = ТипПодписиКриптографии.CMS Тогда
			Возврат ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.ОбычнаяCMS");
		ИначеЕсли ТипПодписиЗначение = ТипПодписиКриптографии.CAdESXLong Тогда
			Возврат ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.CAdESXLong");
		ИначеЕсли ТипПодписиЗначение = ТипПодписиКриптографии.CAdESXLongType1 Тогда
			Возврат ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.CAdESXLongType1");
		ИначеЕсли ТипПодписиЗначение = ТипПодписиКриптографии.CAdESXType1  Тогда
			Возврат ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.CAdESXType1");
		ИначеЕсли ТипПодписиЗначение = ТипПодписиКриптографии.CAdESXType2 Тогда
			Возврат ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.CAdESXType2");
		КонецЕсли;
	Иначе
		Если ТипПодписиЗначение = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.БазоваяCAdESBES") Тогда
			Возврат ТипПодписиКриптографии.CAdESBES;
		ИначеЕсли ТипПодписиЗначение = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.СМеткойДоверенногоВремениCAdEST") Тогда
			Возврат ТипПодписиКриптографии.CAdEST;
		ИначеЕсли ТипПодписиЗначение = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.АрхивнаяCAdESAv3") Тогда
			Возврат ТипПодписиКриптографии.CAdESAv3;
		ИначеЕсли ТипПодписиЗначение = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.СПолнымНаборомПроверочныхДанныхCAdESC") Тогда
			Возврат ТипПодписиКриптографии.CAdESC;
		ИначеЕсли ТипПодписиЗначение = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.РасширеннаяДолгосрочнаяCAdESXLongType2") Тогда
			Возврат ТипПодписиКриптографии.CAdESXLongType2;
		ИначеЕсли ТипПодписиЗначение = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.CAdESAv2") Тогда
			Возврат ТипПодписиКриптографии.CAdESAv2;
		ИначеЕсли ТипПодписиЗначение = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.ОбычнаяCMS") Тогда
			Возврат ТипПодписиКриптографии.CMS;
		ИначеЕсли ТипПодписиЗначение = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.CAdESXLong") Тогда
			Возврат ТипПодписиКриптографии.CAdESXLong;
		ИначеЕсли ТипПодписиЗначение = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.CAdESXLongType1") Тогда
			Возврат ТипПодписиКриптографии.CAdESXLongType1;
		ИначеЕсли ТипПодписиЗначение = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.CAdESXType1") Тогда
			Возврат ТипПодписиКриптографии.CAdESXType1;
		ИначеЕсли ТипПодписиЗначение = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.CAdESXType2") Тогда
			Возврат ТипПодписиКриптографии.CAdESXType2;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Неопределено;

КонецФункции

// Только для внутреннего использования.
Функция НастройкиСозданияПодписи(ТипПодписи, АдресаСерверовМетокВремени) Экспорт
	
	Результат = Новый Структура("ТипПодписи, АдресаСерверовМетокВремени");
	Результат.АдресаСерверовМетокВремени = АдресаСерверовМетокВремени;
	
	Если Не ЗначениеЗаполнено(ТипПодписи) Тогда
		Результат.ТипПодписи = ТипПодписиКриптографии(
			ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.БазоваяCAdESBES"));
		Возврат Результат;
	КонецЕсли;
	
	Если ТипПодписи = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.СМеткойДоверенногоВремениCAdEST") 
		Или ТипПодписи = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.СПолнымНаборомПроверочныхДанныхCAdESC")
		Или ТипПодписи = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.РасширеннаяДолгосрочнаяCAdESXLongType2")
		Или ТипПодписи = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.АрхивнаяCAdESAv3") Тогда 
		
		Если Результат.АдресаСерверовМетокВремени.Количество() = 0 Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru='Для создания подписи типа ""%1"" заполните адреса серверов штампов времени.'"), ТипПодписи);
		КонецЕсли;
		
	ИначеЕсли ТипПодписи <> ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.БазоваяCAdESBES")
		И ТипПодписи <> ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.ОбычнаяCMS") Тогда
		
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Создание подписи типа ""%1"" не поддерживается.'"), ТипПодписи);
	КонецЕсли;
	
	Результат.ТипПодписи = ТипПодписиКриптографии(ТипПодписи);
	
	Возврат Результат;
	
КонецФункции

// Только для внутреннего использования.
Функция ПодлежитУсовершенствованию(ТипПодписи, НовыйТипПодписи) Экспорт
	
	Если НовыйТипПодписи = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.СМеткойДоверенногоВремениCAdEST")
		И ТипПодписи = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.БазоваяCAdESBES") Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если НовыйТипПодписи = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.АрхивнаяCAdESAv3")
		И (ТипПодписи = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.БазоваяCAdESBES")
		Или ТипПодписи = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.СМеткойДоверенногоВремениCAdEST")
		Или ТипПодписи = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.СПолнымНаборомПроверочныхДанныхCAdESC")
		Или ТипПодписи = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.CAdESXLong")
		Или ТипПодписи = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.CAdESXType1")
		Или ТипПодписи = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.CAdESXType2")
		Или ТипПодписи = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.CAdESXLongType1")
		Или ТипПодписи = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.РасширеннаяДолгосрочнаяCAdESXLongType2")) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Только для внутреннего использования.
Функция ЗаголовокОшибкиПолученияДанных(Операция) Экспорт
	
	Если Операция = "Подписание" Тогда
		Возврат НСтр("ru = 'При получении данных для подписания возникла ошибка:'");
	ИначеЕсли Операция = "Шифрование" Тогда
		Возврат НСтр("ru = 'При получении данных для шифрования возникла ошибка:'");
	ИначеЕсли Операция = "ПродлениеСрокаДействияПодписи" Тогда
		Возврат НСтр("ru = 'При получении данных подписи для продления возникла ошибка:'");
	Иначе
		Возврат НСтр("ru = 'При получении данных для расшифровки возникла ошибка:'");
	КонецЕсли;
	
КонецФункции

// Только для внутреннего использования.
Функция ПустыеДанныеПодписи(ДанныеПодписи, ОписаниеОшибки) Экспорт
	
	Если Не ЗначениеЗаполнено(ДанныеПодписи) Тогда
		ОписаниеОшибки = НСтр("ru = 'Сформирована пустая подпись.'");
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Только для внутреннего использования.
Функция ПустыеЗашифрованныеДанные(ЗашифрованныеДанные, ОписаниеОшибки) Экспорт
	
	Если Не ЗначениеЗаполнено(ЗашифрованныеДанные) Тогда
		ОписаниеОшибки = НСтр("ru = 'Сформированы пустые зашифрованные данные.'");
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Только для внутреннего использования.
Функция ПустыеРасшифрованныеДанные(РасшифрованныеДанные, ОписаниеОшибки) Экспорт
	
	Если Не ЗначениеЗаполнено(РасшифрованныеДанные) Тогда
		ОписаниеОшибки = НСтр("ru = 'Сформированы пустые расшифрованные данные.'");
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Только для внутреннего использования.
Функция ОбщееОписаниеОшибки(ОшибкаНаКлиенте, ОшибкаНаСервере, ЗаголовокОшибки = "") Экспорт
	
	ОписаниеОшибкиНаКлиенте = УпрощеннаяСтруктураОшибки(ОшибкаНаКлиенте, ЗаголовокОшибки);
	ОписаниеОшибкиНаСервере = УпрощеннаяСтруктураОшибки(ОшибкаНаСервере, ЗаголовокОшибки);
	
	Если Не ЗначениеЗаполнено(ОписаниеОшибкиНаКлиенте.ОписаниеОшибки)
	   И Не ЗначениеЗаполнено(ОписаниеОшибкиНаСервере.ОписаниеОшибки) Тогда
	
		ОбщееОписаниеОшибки = НСтр("ru = 'Неизвестная ошибка'");
		
	ИначеЕсли Не ЗначениеЗаполнено(ОписаниеОшибкиНаКлиенте.ОписаниеОшибки)
	      Или ОписаниеОшибкиНаКлиенте.НеПоддерживается
	        И ЗначениеЗаполнено(ОписаниеОшибкиНаСервере.ОписаниеОшибки) Тогда
		
		Если ЗначениеЗаполнено(ОписаниеОшибкиНаСервере.ЗаголовокОшибки)
		   И ЗначениеЗаполнено(ОписаниеОшибкиНаСервере.Описание) Тогда
		
			ОбщееОписаниеОшибки =
				  ОписаниеОшибкиНаСервере.ЗаголовокОшибки
				+ Символы.ПС + Символы.ПС
				+ НСтр("ru = 'НА СЕРВЕРЕ:'")
				+ Символы.ПС + Символы.ПС + ОписаниеОшибкиНаСервере.Описание;
		Иначе
			ОбщееОписаниеОшибки =
				  НСтр("ru = 'НА СЕРВЕРЕ:'")
				+ Символы.ПС + Символы.ПС + ОписаниеОшибкиНаСервере.ОписаниеОшибки;
		КонецЕсли;
		
	ИначеЕсли Не ЗначениеЗаполнено(ОписаниеОшибкиНаСервере.ОписаниеОшибки) Тогда
		ОбщееОписаниеОшибки = ОписаниеОшибкиНаКлиенте.ОписаниеОшибки;
	Иначе
		Если ОписаниеОшибкиНаКлиенте.ЗаголовокОшибки = ОписаниеОшибкиНаСервере.ЗаголовокОшибки
		   И ЗначениеЗаполнено(ОписаниеОшибкиНаКлиенте.ЗаголовокОшибки) Тогда
			
			ОбщееОписаниеОшибки = ОписаниеОшибкиНаКлиенте.ЗаголовокОшибки + Символы.ПС + Символы.ПС;
			ТекстОшибкиНаКлиенте = ОписаниеОшибкиНаКлиенте.Описание;
			ТекстОшибкиНаСервере = ОписаниеОшибкиНаСервере.Описание;
		Иначе
			ОбщееОписаниеОшибки = "";
			ТекстОшибкиНаКлиенте = ОписаниеОшибкиНаКлиенте.ОписаниеОшибки;
			ТекстОшибкиНаСервере = ОписаниеОшибкиНаСервере.ОписаниеОшибки;
		КонецЕсли;
		
		ОбщееОписаниеОшибки = ОбщееОписаниеОшибки
			+ НСтр("ru = 'НА СЕРВЕРЕ:'")
			+ Символы.ПС + Символы.ПС + ТекстОшибкиНаСервере
			+ Символы.ПС + Символы.ПС
			+ НСтр("ru = 'НА КОМПЬЮТЕРЕ:'")
			+ Символы.ПС + Символы.ПС + ТекстОшибкиНаКлиенте;
	КонецЕсли;
	
	Возврат ОбщееОписаниеОшибки;
	
КонецФункции

// Только для внутреннего использования.
Функция ДатаПодписанияУниверсальная(Данные) Экспорт
	
	ДвоичныеДанные = ДвоичныеДанныеИзДанных(Данные,
		"ЭлектроннаяПодписьСлужебныйКлиентСервер.АлгоритмПодписи");
	
	АнализДанных = НовыйАнализДанных(ДвоичныеДанные);
		
	// SEQUENCE (PKCS #7 ContentInfo).
	ПропуститьНачалоБлока(АнализДанных, 0, 16);
		// OBJECT IDENTIFIER (contentType).
		ПропуститьНачалоБлока(АнализДанных, 0, 6);
			// 1.2.840.113549.1.7.2 signedData (PKCS #7).
			ПроверитьДанныеБлока(АнализДанных, "2A864886F70D010702");
			ПропуститьРодительскийБлок(АнализДанных);
		// [0]CS             (content [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL).
		ПропуститьНачалоБлока(АнализДанных, 2, 0);
			// SEQUENCE (content SignedData).
			ПропуститьНачалоБлока(АнализДанных, 0, 16);
				// INTEGER  (version          Version).
				ПропуститьБлок(АнализДанных, 0, 2);
				// SET      (digestAlgorithms DigestAlgorithmIdentifiers).
				ПропуститьБлок(АнализДанных, 0, 17);
				// SEQUENCE (contentInfo      ContentInfo).
				ПропуститьБлок(АнализДанных, 0, 16);
				// [0]CS    (certificates     [0] IMPLICIT ExtendedCertificatesAndCertificates OPTIONAL).
				ПропуститьБлок(АнализДанных, 2, 0, Ложь);
				// [1]CS    (crls             [1] IMPLICIT CertificateRevocationLists OPTIONAL).
				ПропуститьБлок(АнализДанных, 2, 1, Ложь);
				// SET      (signerInfos      SET OF SignerInfo).
				ПропуститьНачалоБлока(АнализДанных, 0, 17);
					// SEQUENCE (signerInfo SignerInfo).
					ПропуститьНачалоБлока(АнализДанных, 0, 16);
						// INTEGER  (version                   Version).
						ПропуститьБлок(АнализДанных, 0, 2);
						// SEQUENCE (issuerAndSerialNumber     IssuerAndSerialNumber).
						ПропуститьБлок(АнализДанных, 0, 16);
						// SEQUENCE (digestAlgorithm           DigestAlgorithmIdentifier).
						ПропуститьБлок(АнализДанных, 0, 16);
						// [0]CS    (authenticatedAttributes   [0] IMPLICIT Attributes OPTIONAL).
						ПропуститьНачалоБлока(АнализДанных, 2, 0);

	Если АнализДанных.ЕстьОшибка Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СмещениеСледующего = АнализДанных.Родители[0].СмещениеСледующего;
	Пока АнализДанных.Смещение < СмещениеСледующего Цикл
		
		// SEQUENCE (Attributes).
		ПропуститьНачалоБлока(АнализДанных, 0, 16);
		
		Если АнализДанных.ЕстьОшибка Тогда
			Возврат Неопределено;
		КонецЕсли; 
		
		// OBJECT IDENTIFIER
		ПропуститьНачалоБлока(АнализДанных, 0, 6);
		
		РазмерДанных = АнализДанных.Родители[0].РазмерДанных;
		Если РазмерДанных = 0 Тогда
			ПриОшибкеСтруктурыДанных(АнализДанных);
			Возврат Неопределено;
		КонецЕсли;
		
		Если РазмерДанных = 9 Тогда
			Буфер = АнализДанных.Буфер.Прочитать(АнализДанных.Смещение, РазмерДанных); // БуферДвоичныхДанных
			СтрокаБуфера = ПолучитьHexСтрокуИзБуфераДвоичныхДанных(Буфер);
			Если СтрокаБуфера = "2A864886F70D010905" Тогда // 1.2.840.113549.1.9.5 signingTime
				
				ДатаПодписания = ПрочитатьДатуПодписанияИзБуфера(АнализДанных.Буфер, АнализДанных.Смещение + 11);
				
				Если ЗначениеЗаполнено(ДатаПодписания) Тогда
					Возврат ДатаПодписания;
				Иначе
					Возврат Неопределено;
				КонецЕсли;
				
			КонецЕсли;
		КонецЕсли; 
		ПропуститьРодительскийБлок(АнализДанных); // OBJECT IDENTIFIER
		ПропуститьРодительскийБлок(АнализДанных); // SEQUENCE
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Только для внутреннего использования.
Функция СвойстваПодписиИзДвоичныхДанных(Данные) Экспорт
	
	СвойстваПодписи = Новый Структура("ТипПодписи, ДатаПодписания, ДатаШтампаВремени", 
		ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.ОбычнаяCMS"), Неопределено, Неопределено);
	
	ДвоичныеДанные = ДвоичныеДанныеИзДанных(Данные,
		"ЭлектроннаяПодписьСлужебныйКлиентСервер.АлгоритмПодписи");
	
	АнализДанных = НовыйАнализДанных(ДвоичныеДанные);
		
	// SEQUENCE (PKCS #7 ContentInfo).
	ПропуститьНачалоБлока(АнализДанных, 0, 16);
		// OBJECT IDENTIFIER (contentType).
		ПропуститьНачалоБлока(АнализДанных, 0, 6);
			// 1.2.840.113549.1.7.2 signedData (PKCS #7).
			ПроверитьДанныеБлока(АнализДанных, "2A864886F70D010702");
			ПропуститьРодительскийБлок(АнализДанных);
		// [0]CS             (content [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL).
		ПропуститьНачалоБлока(АнализДанных, 2, 0);
			// SEQUENCE (content SignedData).
			ПропуститьНачалоБлока(АнализДанных, 0, 16);
				// INTEGER  (version          Version).
				ПропуститьБлок(АнализДанных, 0, 2);
				// SET      (digestAlgorithms DigestAlgorithmIdentifiers).
				ПропуститьБлок(АнализДанных, 0, 17);
				// SEQUENCE (contentInfo      ContentInfo).
				ПропуститьБлок(АнализДанных, 0, 16);
				// [0]CS    (certificates     [0] IMPLICIT ExtendedCertificatesAndCertificates OPTIONAL).
				ПропуститьБлок(АнализДанных, 2, 0, Ложь);
				// [1]CS    (crls             [1] IMPLICIT CertificateRevocationLists OPTIONAL).
				ПропуститьБлок(АнализДанных, 2, 1, Ложь);
				// SET      (signerInfos      SET OF SignerInfo).
				ПропуститьНачалоБлока(АнализДанных, 0, 17);
					// SEQUENCE (signerInfo SignerInfo).
					ПропуститьНачалоБлока(АнализДанных, 0, 16);
						// INTEGER  (version                   Version).
						ПропуститьБлок(АнализДанных, 0, 2);
						// SEQUENCE (issuerAndSerialNumber     IssuerAndSerialNumber).
						ПропуститьБлок(АнализДанных, 0, 16);
						// SEQUENCE (digestAlgorithm           DigestAlgorithmIdentifier).
						ПропуститьБлок(АнализДанных, 0, 16);
						// [0]CS    (authenticatedAttributes   [0] IMPLICIT Attributes OPTIONAL).
						ПропуститьНачалоБлока(АнализДанных, 2, 0);

	Если АнализДанных.ЕстьОшибка Тогда
		Возврат СвойстваПодписи;
	КонецЕсли;
	
	ЕстьДайджестСообщения = Ложь; // 1.2.840.113549.1.9.4
	ЕстьТипКонтента = Ложь; // 1.2.840.113549.1.9.3
	ЕстьВеткаСертификата = Ложь; // 1.2.840.113549.1.9.16.2.47 или 1.2.840.113549.1.9.16.2.12

	СмещениеСледующего = АнализДанных.Родители[0].СмещениеСледующего;
	Пока АнализДанных.Смещение < СмещениеСледующего И Не АнализДанных.ЕстьОшибка Цикл
		
		// SEQUENCE (Attributes).
		ПропуститьНачалоБлока(АнализДанных, 0, 16);
		
		Если АнализДанных.ЕстьОшибка Тогда
			Прервать;
		КонецЕсли; 
		
		// OBJECT IDENTIFIER
		ПропуститьНачалоБлока(АнализДанных, 0, 6);
		
		РазмерДанных = АнализДанных.Родители[0].РазмерДанных;
		Если РазмерДанных = 0 Тогда
			ПриОшибкеСтруктурыДанных(АнализДанных);
			Прервать;
		КонецЕсли;
				
		Если РазмерДанных = 9 Тогда
			Буфер = АнализДанных.Буфер.Прочитать(АнализДанных.Смещение, РазмерДанных); // БуферДвоичныхДанных
			СтрокаБуфера = ПолучитьHexСтрокуИзБуфераДвоичныхДанных(Буфер);

			Если СтрокаБуфера = "2A864886F70D010904" Тогда // 1.2.840.113549.1.9.4 messageDigest
				ЕстьДайджестСообщения = Истина;
			ИначеЕсли СтрокаБуфера = "2A864886F70D010903" Тогда // 1.2.840.113549.1.9.3 contentType
				ЕстьТипКонтента = Истина;
			ИначеЕсли СтрокаБуфера = "2A864886F70D010905" Тогда // 1.2.840.113549.1.9.5 signingTime
				
				ДатаПодписания = ПрочитатьДатуПодписанияИзБуфера(АнализДанных.Буфер, АнализДанных.Смещение + 11);
				
				Если ЗначениеЗаполнено(ДатаПодписания) Тогда
					СвойстваПодписи.ДатаПодписания = ДатаПодписания;
				КонецЕсли;
				
			КонецЕсли;
		
		ИначеЕсли РазмерДанных = 11 Тогда
			Буфер = АнализДанных.Буфер.Прочитать(АнализДанных.Смещение, РазмерДанных); // БуферДвоичныхДанных
			СтрокаБуфера = ПолучитьHexСтрокуИзБуфераДвоичныхДанных(Буфер);
			
			Если СтрокаБуфера = "2A864886F70D010910022F" Тогда // 1.2.840.113549.1.9.16.2.47 signingCertificateV2
				ЕстьВеткаСертификата = Истина;
			ИначеЕсли СтрокаБуфера = "2A864886F70D010910020C" Тогда // 1.2.840.113549.1.9.16.2.12 signingCertificate
				ЕстьВеткаСертификата = Истина;
			КонецЕсли;
		КонецЕсли;
		
		ПропуститьРодительскийБлок(АнализДанных); // OBJECT IDENTIFIER
		ПропуститьРодительскийБлок(АнализДанных); // SEQUENCE
	КонецЦикла;
	
	Если ЕстьВеткаСертификата И ЕстьДайджестСообщения И ЕстьТипКонтента Тогда
		СвойстваПодписи.ТипПодписи = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.БазоваяCAdESBES");
	Иначе
		Возврат СвойстваПодписи;
	КонецЕсли;
	
	ПропуститьРодительскийБлок(АнализДанных); // [0]CS
	
	// SEQUENCE (digestEncryptionAlgorithm AlgorithmIdentifier).
	ПропуститьБлок(АнализДанных, 0, 16);
	// signature SignatureValue
	ПропуститьБлок(АнализДанных, 0, 4); 
	// [1]CS    (unsignedAttrs [1] IMPLICIT UnsignedAttributes OPTIONAL).
	ПропуститьНачалоБлока(АнализДанных, 2, 1);

	ЕстьВеткаМеткиВремени = Ложь; // 1.2.840.113549.1.9.16.2.14 
	ЕстьВеткаОписаниеСертификатов = Ложь; // 1.2.840.113549.1.9.16.2.21
	ЕстьВеткаОписаниеОтзыва = Ложь; // 1.2.840.113549.1.9.16.2.22
	ЕстьВеткаЗначениеСертификатов = Ложь; // 1.2.840.113549.1.9.16.2.23
	ЕстьВеткаЗначениеОтзыва = Ложь; // 1.2.840.113549.1.9.16.2.24
	ЕстьВеткаСписокСерверовОтзыва = Ложь; // 1.2.840.113549.1.9.16.2.26
	ЕстьВеткаАрхива = Ложь; // 0.4.0.1733.2.5
	
	СмещениеСледующего = АнализДанных.Родители[0].СмещениеСледующего;
	Пока АнализДанных.Смещение < СмещениеСледующего И Не АнализДанных.ЕстьОшибка Цикл
		
		// SEQUENCE (Attributes).
		ПропуститьНачалоБлока(АнализДанных, 0, 16);

		Если АнализДанных.ЕстьОшибка Тогда
			Прервать;
		КонецЕсли; 
		
		// OBJECT IDENTIFIER
		ПропуститьНачалоБлока(АнализДанных, 0, 6);

		РазмерДанных = АнализДанных.Родители[0].РазмерДанных;
		Если РазмерДанных = 0 Тогда
			ПриОшибкеСтруктурыДанных(АнализДанных);
			Прервать;
		КонецЕсли;
		
		Если РазмерДанных = 11 Тогда
			
			Буфер = АнализДанных.Буфер.Прочитать(АнализДанных.Смещение, РазмерДанных); // БуферДвоичныхДанных
			СтрокаБуфера = ПолучитьHexСтрокуИзБуфераДвоичныхДанных(Буфер);
			Если СтрокаБуфера = "2A864886F70D010910020E" Тогда // 1.2.840.113549.1.9.16.2.14 timeStampToken
				
				ЕстьВеткаМеткиВремени = Истина;
				
				РазмерДанных = АнализДанных.Родители[1].РазмерДанных - 13;
				
				// SET
				Буфер = АнализДанных.Буфер.Прочитать(АнализДанных.Смещение + 11, РазмерДанных);
				ДатаШтампаВремени = ПрочитатьДатуИзШтампаВремени(Буфер);
				Если ЗначениеЗаполнено(ДатаШтампаВремени) Тогда
					СвойстваПодписи.ДатаШтампаВремени = ДатаШтампаВремени;
				КонецЕсли;
				
			ИначеЕсли СтрокаБуфера = "2A864886F70D0109100215" Тогда // 1.2.840.113549.1.9.16.2.21 certificateRefs
				ЕстьВеткаОписаниеСертификатов = Истина;	
			ИначеЕсли СтрокаБуфера = "2A864886F70D0109100216" Тогда // 1.2.840.113549.1.9.16.2.22 revocationRefs
				ЕстьВеткаОписаниеОтзыва = Истина;
			ИначеЕсли СтрокаБуфера = "2A864886F70D0109100217" Тогда // 1.2.840.113549.1.9.16.2.23 certValues
				ЕстьВеткаЗначениеСертификатов = Истина;
			ИначеЕсли СтрокаБуфера = "2A864886F70D0109100218" Тогда // 1.2.840.113549.1.9.16.2.24 revocationValues
				ЕстьВеткаЗначениеОтзыва = Истина;
			ИначеЕсли СтрокаБуфера = "2A864886F70D010910021A" Тогда // 1.2.840.113549.1.9.16.2.26 certCRLTimestamp
				ЕстьВеткаСписокСерверовОтзыва = Истина; 
			КонецЕсли;
			
		КонецЕсли;

		Если РазмерДанных = 6 Тогда
			Буфер = АнализДанных.Буфер.Прочитать(АнализДанных.Смещение, РазмерДанных); // БуферДвоичныхДанных
			СтрокаБуфера = ПолучитьHexСтрокуИзБуфераДвоичныхДанных(Буфер);
			Если СтрокаБуфера = "04008D450204" Тогда // 0.4.0.1733.2.4 archiveTimestampV3 attribute
				ЕстьВеткаАрхива = Истина;
			КонецЕсли;
		КонецЕсли;

		ПропуститьРодительскийБлок(АнализДанных); // OBJECT IDENTIFIER
		ПропуститьРодительскийБлок(АнализДанных); // SEQUENCE
	КонецЦикла;

	Если ЕстьВеткаАрхива Тогда
		ТипПодписи = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.АрхивнаяCAdESAv3");
	ИначеЕсли ЕстьВеткаМеткиВремени И ЕстьВеткаОписаниеСертификатов И ЕстьВеткаОписаниеОтзыва
		И ЕстьВеткаЗначениеСертификатов И ЕстьВеткаЗначениеОтзыва И ЕстьВеткаСписокСерверовОтзыва Тогда
		ТипПодписи = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.РасширеннаяДолгосрочнаяCAdESXLongType2");
	ИначеЕсли ЕстьВеткаМеткиВремени И ЕстьВеткаОписаниеСертификатов И ЕстьВеткаОписаниеОтзыва Тогда
		ТипПодписи = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.СПолнымНаборомПроверочныхДанныхCAdESC");
	ИначеЕсли ЕстьВеткаМеткиВремени Тогда
		ТипПодписи = ПредопределенноеЗначение("Перечисление.ТипыПодписиКриптографии.СМеткойДоверенногоВремениCAdEST");
	КонецЕсли;

	СвойстваПодписи.ТипПодписи = ТипПодписи;
	
	Возврат СвойстваПодписи;
	
КонецФункции

Функция ПрочитатьДатуПодписанияИзБуфера(Буфер, Смещение)
	
	ТипДаты = ПолучитьHexСтрокуИзБуфераДвоичныхДанных(Буфер.Прочитать(Смещение, 2));
	Если ТипДаты = "170D" Тогда // UTCTime
		БуферДаты = Буфер.Прочитать(Смещение + 2, 12);
		ПредставлениеДаты = "20" + ПолучитьСтрокуИзБуфераДвоичныхДанных(БуферДаты);
	Иначе // GeneralizedTime
		БуферДаты = Буфер.Прочитать(Смещение + 2, 14);
		ПредставлениеДаты = ПолучитьСтрокуИзБуфераДвоичныхДанных(БуферДаты);
	КонецЕсли;

	ОписаниеТипа = Новый ОписаниеТипов("Дата");
	ДатаПодписания = ОписаниеТипа.ПривестиЗначение(ПредставлениеДаты);
	Возврат ДатаПодписания;
	
КонецФункции

// Для функции СвойстваПодписиИзДвоичныхДанных.
Функция ПрочитатьДатуИзШтампаВремени(Буфер)
	
	АнализДанных = Новый Структура;
	АнализДанных.Вставить("ЕстьОшибка", Ложь);
	АнализДанных.Вставить("ЭтоОшибкаКодированияASN1", Ложь); // Возможно данные повреждены.
	АнализДанных.Вставить("ЭтоОшибкаСтруктурыДанных", Ложь); // Не найден ожидаемый элемент данных.
	АнализДанных.Вставить("Смещение", 0);
	АнализДанных.Вставить("Родители", Новый Массив);
	АнализДанных.Вставить("Буфер", Буфер);
	
	// SET
	ПропуститьНачалоБлока(АнализДанных, 0, 17);
	// SEQUENCE
	ПропуститьНачалоБлока(АнализДанных, 0, 16);
	// OBJECT IDENTIFIER signedData
	ПропуститьБлок(АнализДанных, 0, 6);
		// [0]
		ПропуститьНачалоБлока(АнализДанных, 2, 0);
			// SEQUENCE
			ПропуститьНачалоБлока(АнализДанных, 0, 16);
			// INTEGER  (version          Version).
			ПропуститьБлок(АнализДанных, 0, 2);
			// SET
			ПропуститьБлок(АнализДанных, 0, 17);
				// SEQUENCE
				ПропуститьНачалоБлока(АнализДанных, 0, 16); 
				// OBJECT IDENTIFIER
				ПропуститьБлок(АнализДанных, 0, 6); 
					// [0]
					ПропуститьНачалоБлока(АнализДанных, 2, 0);
						// OCTET STRING
						ПропуститьНачалоБлока(АнализДанных, 0, 4);
						// SEQUENCE
						ПропуститьНачалоБлока(АнализДанных, 0, 16);
						// INTEGER
						ПропуститьБлок(АнализДанных, 0, 2);
						// OBJECT IDENTIFIER
						ПропуститьБлок(АнализДанных, 0, 6);
						// SEQUENCE
						ПропуститьБлок(АнализДанных, 0, 16);
						// INTEGER
						ПропуститьБлок(АнализДанных, 0, 2);

	Если АнализДанных.ЕстьОшибка Тогда
		ДатаШтампа = Неопределено;
	Иначе
		// GeneralizedTime
		БуферДаты = АнализДанных.Буфер.Прочитать(АнализДанных.Смещение + 2, 14);
		ПредставлениеДаты = ПолучитьСтрокуИзБуфераДвоичныхДанных(БуферДаты);
		ОписаниеТипа = Новый ОписаниеТипов("Дата");
		ДатаШтампа = ОписаниеТипа.ПривестиЗначение(ПредставлениеДаты);
	КонецЕсли;
	
	Возврат ДатаШтампа;
	
КонецФункции

// Находит в XML содержимое находящееся в теге.
//
// Параметры:
//  Текст                             - Строка - текст XML, в котором выполняется поиск.
//  ИмяТега                           - Строка - тег, содержимое которого необходимо найти.
//  ВключатьОткрывающийЗакрывающийТег - Булево - признак необходимости найденного тегом,
//                                               по которому выполнялся поиск, по умолчанию Ложь.
//  НомерПоПорядку                    - Число  - позиция, с которой начинается поиск, по умолчанию 1.
// 
// Возвращаемое значение:
//   Строка - строка, из которой удалены символы перевода строки и возврата каретки.
//
Функция НайтиВXML(Текст, ИмяТега, ВключатьОткрывающийЗакрывающийТег = Ложь, НомерПоПорядку = 1) Экспорт
	
	Результат = Неопределено;
	
	Начало    = "<"  + ИмяТега;
	Окончание = "</" + ИмяТега + ">";
	
	Содержимое = Сред(
		Текст,
		СтрНайти(Текст, Начало, НаправлениеПоиска.СНачала, 1, НомерПоПорядку),
		СтрНайти(Текст, Окончание, НаправлениеПоиска.СНачала, 1, НомерПоПорядку) + СтрДлина(Окончание) - СтрНайти(Текст, Начало, НаправлениеПоиска.СНачала, 1, НомерПоПорядку));
		
	Если ВключатьОткрывающийЗакрывающийТег Тогда
		
		Результат = СокрЛП(Содержимое);
		
	Иначе
		
		ОткрывающийТег = Лев(Содержимое, СтрНайти(Содержимое, ">"));
		Содержимое = СтрЗаменить(Содержимое, ОткрывающийТег, "");
		
		ЗакрывающийТег = Прав(Содержимое, СтрДлина(Содержимое) - СтрНайти(Содержимое, "<", НаправлениеПоиска.СКонца) + 1);
		Содержимое = СтрЗаменить(Содержимое, ЗакрывающийТег, "");
		
		Результат = СокрЛП(Содержимое);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Только для внутреннего использования.
Функция СертификатИзКонвертаSOAP(КонвертSOAP, ВФорматеBase64 = Истина) Экспорт
	
	СертификатBase64 = НайтиВXML(КонвертSOAP, "wsse:BinarySecurityToken");
	
	Если ВФорматеBase64 Тогда
		Возврат СертификатBase64;
	КонецЕсли;
	
	Возврат Base64Значение(СертификатBase64);
	
КонецФункции

// См. ЭлектроннаяПодписьКлиент.ПредставлениеСертификата.
Функция ПредставлениеСертификата(Сертификат, ДобавкаВремени) Экспорт
	
	Представление = "";
	ЭлектроннаяПодписьКлиентСерверЛокализация.ПриПолученииПредставленияСертификата(Сертификат, ДобавкаВремени, Представление);
	Если ПустаяСтрока(Представление) Тогда
		ДатыСертификата = ДатыСертификата(Сертификат, ДобавкаВремени);
		Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = '%1, до %2'"),
			ПредставлениеСубъекта(Сертификат),
			Формат(ДатыСертификата.ДатаОкончания, "ДФ=MM.yyyy"));
	КонецЕсли;	
	Возврат Представление;
	
КонецФункции

// См. ЭлектроннаяПодписьКлиент.ПредставлениеСубъекта.
Функция ПредставлениеСубъекта(Сертификат) Экспорт 
	
	Представление = "";
	ЭлектроннаяПодписьКлиентСерверЛокализация.ПриПолученииПредставленияСубъекта(Сертификат, Представление);
	Если ПустаяСтрока(Представление) Тогда
		Субъект = СвойстваСубъектаСертификата(Сертификат);
		Если ЗначениеЗаполнено(Субъект.ОбщееИмя) Тогда
			Представление = Субъект.ОбщееИмя;
		КонецЕсли;
	КонецЕсли;	
	Возврат Представление;
	
КонецФункции

// См. ЭлектроннаяПодписьКлиент.ПредставлениеИздателя.
Функция ПредставлениеИздателя(Сертификат) Экспорт
	
	Издатель = СвойстваИздателяСертификата(Сертификат);
	
	Представление = "";
	
	Если ЗначениеЗаполнено(Издатель.ОбщееИмя) Тогда
		Представление = Издатель.ОбщееИмя;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Издатель.ОбщееИмя)
	   И ЗначениеЗаполнено(Издатель.Организация)
	   И СтрНайти(Издатель.ОбщееИмя, Издатель.Организация) = 0 Тогда
		
		Представление = Издатель.ОбщееИмя + ", " + Издатель.Организация;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Издатель.Подразделение) Тогда
		Представление = Представление + ", " + Издатель.Подразделение;
	КонецЕсли;
	
	Возврат Представление;
	
КонецФункции

Функция СвойстваСертификата(Сертификат, ДобавкаВремени) Экспорт
	
	ДатыСертификата = ДатыСертификата(Сертификат, ДобавкаВремени);
	
	Свойства = Новый Структура;
	Свойства.Вставить("Отпечаток",      Base64Строка(Сертификат.Отпечаток));
	Свойства.Вставить("СерийныйНомер",  Сертификат.СерийныйНомер);
	Свойства.Вставить("Представление",  ПредставлениеСертификата(Сертификат, ДобавкаВремени));
	Свойства.Вставить("КомуВыдан",      ПредставлениеСубъекта(Сертификат));
	Свойства.Вставить("КемВыдан",       ПредставлениеИздателя(Сертификат));
	Свойства.Вставить("ДатаНачала",     ДатыСертификата.ДатаНачала);
	Свойства.Вставить("ДатаОкончания",  ДатыСертификата.ДатаОкончания);
	Свойства.Вставить("ДействителенДо", ДатыСертификата.ДатаОкончания);
	Свойства.Вставить("Назначение",     ПолучитьНазначение(Сертификат));
	Свойства.Вставить("Подписание",     Сертификат.ИспользоватьДляПодписи);
	Свойства.Вставить("Шифрование",     Сертификат.ИспользоватьДляШифрования);
	
	Возврат Свойства;
	
КонецФункции

// Заполняет таблицу описания сертификата из четырех полей: КомуВыдан, КемВыдан, ДействуетДо, Назначение.
Процедура ЗаполнитьОписаниеДанныхСертификата(Таблица, СвойстваСертификата) Экспорт
	
	Если СвойстваСертификата.Подписание И СвойстваСертификата.Шифрование Тогда
		Назначение = НСтр("ru = 'Подписание данных, Шифрование данных'");
		
	ИначеЕсли СвойстваСертификата.Подписание Тогда
		Назначение = НСтр("ru = 'Подписание данных'");
	Иначе
		Назначение = НСтр("ru = 'Шифрование данных'");
	КонецЕсли;
	
	Таблица.Очистить();
	Строка = Таблица.Добавить();
	Строка.Свойство = НСтр("ru = 'Кому выдан:'");
	Строка.Значение = СокрЛП(СвойстваСертификата.КомуВыдан);
	
	Строка = Таблица.Добавить();
	Строка.Свойство = НСтр("ru = 'Кем выдан:'");
	Строка.Значение = СокрЛП(СвойстваСертификата.КемВыдан);
	
	Строка = Таблица.Добавить();
	Строка.Свойство = НСтр("ru = 'Действителен до:'");
	Строка.Значение = Формат(СвойстваСертификата.ДействителенДо, "ДЛФ=D");
	
	Строка = Таблица.Добавить();
	Строка.Свойство = НСтр("ru = 'Назначение:'");
	Строка.Значение = Назначение;
	
КонецПроцедуры

Функция СвойстваСубъектаСертификата(Сертификат) Экспорт
	
	Субъект = Сертификат.Субъект;
	
	Свойства = Новый Структура;
	Свойства.Вставить("ОбщееИмя");
	Свойства.Вставить("Страна");
	Свойства.Вставить("Регион");
	Свойства.Вставить("НаселенныйПункт");
	Свойства.Вставить("Улица");
	Свойства.Вставить("Организация");
	Свойства.Вставить("Подразделение");
	Свойства.Вставить("ЭлектроннаяПочта");
	Свойства.Вставить("Фамилия");
	Свойства.Вставить("Имя");
	
	Если Субъект.Свойство("CN") Тогда
		Свойства.ОбщееИмя = ПодготовитьСтроку(Субъект.CN);
	КонецЕсли;
	
	Если Субъект.Свойство("C") Тогда
		Свойства.Страна = ПодготовитьСтроку(Субъект.C);
	КонецЕсли;
	
	Если Субъект.Свойство("ST") Тогда
		Свойства.Регион = ПодготовитьСтроку(Субъект.ST);
	КонецЕсли;
	
	Если Субъект.Свойство("L") Тогда
		Свойства.НаселенныйПункт = ПодготовитьСтроку(Субъект.L);
	КонецЕсли;
	
	Если Субъект.Свойство("Street") Тогда
		Свойства.Улица = ПодготовитьСтроку(Субъект.Street);
	КонецЕсли;
	
	Если Субъект.Свойство("O") Тогда
		Свойства.Организация = ПодготовитьСтроку(Субъект.O);
	КонецЕсли;
	
	Если Субъект.Свойство("OU") Тогда
		Свойства.Подразделение = ПодготовитьСтроку(Субъект.OU);
	КонецЕсли;
	
	Если Субъект.Свойство("E") Тогда
		Свойства.ЭлектроннаяПочта = ПодготовитьСтроку(Субъект.E);
	КонецЕсли;
	
	РасширенныеСвойства = Неопределено;
	ЭлектроннаяПодписьКлиентСерверЛокализация.ПриПолученииРасширенныхСвойствСубъектаСертификата(Субъект, РасширенныеСвойства);
	Если ТипЗнч(РасширенныеСвойства) = Тип("Структура") Тогда
		ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(Свойства, РасширенныеСвойства, Истина);
	КонецЕсли;
	
	Возврат Свойства;
	
КонецФункции

// См. ЭлектроннаяПодписьКлиент.СвойстваИздателяСертификата.
Функция СвойстваИздателяСертификата(Сертификат) Экспорт
	
	Издатель = Сертификат.Издатель;
	
	Свойства = Новый Структура;
	Свойства.Вставить("ОбщееИмя");
	Свойства.Вставить("Страна");
	Свойства.Вставить("Регион");
	Свойства.Вставить("НаселенныйПункт");
	Свойства.Вставить("Улица");
	Свойства.Вставить("Организация");
	Свойства.Вставить("Подразделение");
	Свойства.Вставить("ЭлектроннаяПочта");
	
	Если Издатель.Свойство("CN") Тогда
		Свойства.ОбщееИмя = ПодготовитьСтроку(Издатель.CN);
	КонецЕсли;
	
	Если Издатель.Свойство("C") Тогда
		Свойства.Страна = ПодготовитьСтроку(Издатель.C);
	КонецЕсли;
	
	Если Издатель.Свойство("ST") Тогда
		Свойства.Регион = ПодготовитьСтроку(Издатель.ST);
	КонецЕсли;
	
	Если Издатель.Свойство("L") Тогда
		Свойства.НаселенныйПункт = ПодготовитьСтроку(Издатель.L);
	КонецЕсли;
	
	Если Издатель.Свойство("Street") Тогда
		Свойства.Улица = ПодготовитьСтроку(Издатель.Street);
	КонецЕсли;
	
	Если Издатель.Свойство("O") Тогда
		Свойства.Организация = ПодготовитьСтроку(Издатель.O);
	КонецЕсли;
	
	Если Издатель.Свойство("OU") Тогда
		Свойства.Подразделение = ПодготовитьСтроку(Издатель.OU);
	КонецЕсли;
	
	Если Издатель.Свойство("E") Тогда
		Свойства.ЭлектроннаяПочта = ПодготовитьСтроку(Издатель.E);
	КонецЕсли;
	
	РасширенныеСвойства = Неопределено;
	ЭлектроннаяПодписьКлиентСерверЛокализация.ПриПолученииРасширенныхСвойствИздателяСертификата(Издатель, РасширенныеСвойства);
	Если ТипЗнч(РасширенныеСвойства) = Тип("Структура") Тогда
		ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(Свойства, РасширенныеСвойства, Истина);
	КонецЕсли;
	
	Возврат Свойства;
	
КонецФункции

// Описание подключения внешней компоненты (ExtraCryptoAPI).
//
// Возвращаемое значение:
//  Структура:
//   * ПолноеИмяМакета - Строка
//   * ИмяОбъекта      - Строка
//
Функция ОписаниеКомпоненты() Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("ИмяОбъекта", "ExtraCryptoAPI");
	Параметры.Вставить("ПолноеИмяМакета",
		"Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования.Макет.КомпонентаExtraCryptoAPI");
	Возврат Параметры;
	
КонецФункции

Функция ИдентификаторыАлгоритмовХешированияИОткрытогоКлюча() Экспорт
	
	Идентификаторы = Новый Массив;
	
	Наборы = НаборыАлгоритмовДляСозданияПодписи();
	Для Каждого Набор Из Наборы Цикл
		Идентификаторы.Добавить("<" + Набор.ИдентификаторАлгоритмаОткрытогоКлюча + "> <" + Набор.ИдентификаторАлгоритмаХеширования + ">");
	КонецЦикла;
	
	Возврат СтрСоединить(Идентификаторы, Символы.ПС) + Символы.ПС;
	
КонецФункции

// См. ЭлектроннаяПодписьКлиент.КонвертXML.
Функция КонвертXML(Параметры) Экспорт
	
	Если Параметры = Неопределено Тогда
		Параметры = ПараметрыКонвертаXML();
	КонецЕсли;
	
	Если Параметры.Вариант = "furs.mark.crpt.ru_v1" Тогда
		КонвертXML = КонвертXML1();
		
	ИначеЕсли Параметры.Вариант = "dmdk.goznak.ru_v1" Тогда
		КонвертXML = КонвертXML2();
	Иначе
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Указано неизвестное значение ""%1"" параметра %2 в функции %3'"),
			Параметры.Вариант, "Вариант", "КонвертXML");
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Параметры.СообщениеXML) Тогда
		КонвертXML = СтрЗаменить(КонвертXML, "%MessageXML%", СокрЛП(Параметры.СообщениеXML));
	КонецЕсли;
	
	Возврат КонвертXML;
	
КонецФункции

// См. ЭлектроннаяПодписьКлиент.ПараметрыКонвертаXML.
Функция ПараметрыКонвертаXML() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Вариант", "furs.mark.crpt.ru_v1");
	Результат.Вставить("СообщениеXML", "");
	
	Возврат Результат;
	
КонецФункции

// См. ЭлектроннаяПодписьКлиент.ПараметрыXMLDSig.
Функция ПараметрыXMLDSig() Экспорт
	
	ДанныеАлгоритмаПодписания = Новый Структура;
	
	ДанныеАлгоритмаПодписания.Вставить("XPathSignedInfo",       "");
	ДанныеАлгоритмаПодписания.Вставить("XPathПодписываемыйТег", "");
	
	ДанныеАлгоритмаПодписания.Вставить("OIDАлгоритмаОткрытогоКлюча", "");
	
	ДанныеАлгоритмаПодписания.Вставить("ИмяАлгоритмаПодписи", "");
	ДанныеАлгоритмаПодписания.Вставить("OIDАлгоритмаПодписи", "");
	
	ДанныеАлгоритмаПодписания.Вставить("ИмяАлгоритмаХеширования", "");
	ДанныеАлгоритмаПодписания.Вставить("OIDАлгоритмаХеширования", "");
	
	ДанныеАлгоритмаПодписания.Вставить("АлгоритмПодписи",     "");
	ДанныеАлгоритмаПодписания.Вставить("АлгоритмХеширования", "");
	
	Возврат ДанныеАлгоритмаПодписания;
	
КонецФункции

// Возвращаемое значение:
//   см. НовыйНаборАлгоритмовДляСозданияПодписи
//  Неопределено - если набор не найден.
//
Функция НаборАлгоритмовДляСозданияПодписи(ИдентификаторАлгоритмаОткрытогоКлюча)
	
	Наборы = НаборыАлгоритмовДляСозданияПодписи();
	Для Каждого Набор Из Наборы Цикл
		Если Набор.ИдентификаторАлгоритмаОткрытогоКлюча = ИдентификаторАлгоритмаОткрытогоКлюча Тогда
			Возврат Набор;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Преобразует двоичные данные сертификата криптографии
// в корректно отформатированную строку в формате Base64.
//
// Параметры:
//  ДанныеСертификата - ДвоичныеДанные - двоичные данные сертификата криптографии.
// 
// Возвращаемое значение:
//  Строка - двоичные данные сертификата в формате Base64.
//
Функция СертификатКриптографииBase64(ДанныеСертификата) Экспорт
	
	СтрокаBase64 = Base64Строка(ДанныеСертификата);
	
	Значение = СтрЗаменить(СтрокаBase64, Символы.ВК, "");
	Значение = СтрЗаменить(Значение, Символы.ПС, "");
	
	Возврат Значение;
	
КонецФункции

// Параметры:
//  СертификатКриптографииBase64 - Строка - Base64 строка.
//  ДанныеАлгоритмаПодписания    - см. ЭлектроннаяПодписьКлиент.ПараметрыXMLDSig
//  ВызыватьИсключение           - Булево
//  СвойстваКонвертаXML          - см. ЭлектроннаяПодписьСлужебный.СвойстваКонвертаXML
//  
// Возвращаемое значение:
//   Строка - текст ошибки, если заполнена.
//
Функция ПроверитьВыбратьАлгоритмПодписи(СертификатКриптографииBase64, ДанныеАлгоритмаПодписания,
			ВызыватьИсключение = Ложь, СвойстваКонвертаXML = Неопределено) Экспорт
	
	OIDАлгоритмаОткрытогоКлюча = АлгоритмПодписиСертификата(
		Base64Значение(СертификатКриптографииBase64),, Истина);
	
	Если Не ЗначениеЗаполнено(OIDАлгоритмаОткрытогоКлюча) Тогда
		ТекстОшибки = НСтр("ru = 'Не удалось получить алгоритм открытого ключа из сертификата.'");
		Если ВызыватьИсключение Тогда
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
		Возврат ТекстОшибки;
	КонецЕсли;
	
	ДанныеАлгоритмаПодписания.Вставить("OIDВыбранногоАлгоритмаПодписи",     Неопределено);
	ДанныеАлгоритмаПодписания.Вставить("OIDВыбранногоАлгоритмаХеширования", Неопределено);
	ДанныеАлгоритмаПодписания.Вставить("ВыбранныйАлгоритмПодписи",          Неопределено);
	ДанныеАлгоритмаПодписания.Вставить("ВыбранныйАлгоритмХеширования",      Неопределено);
	
	OIDАлгоритмовОткрытогоКлюча = СтрРазделить(ДанныеАлгоритмаПодписания.OIDАлгоритмаОткрытогоКлюча, Символы.ПС);
	OIDАлгоритмовПодписи        = СтрРазделить(ДанныеАлгоритмаПодписания.OIDАлгоритмаПодписи,        Символы.ПС);
	OIDАлгоритмовХеширования    = СтрРазделить(ДанныеАлгоритмаПодписания.OIDАлгоритмаХеширования,    Символы.ПС);
	АлгоритмыПодписи            = СтрРазделить(ДанныеАлгоритмаПодписания.АлгоритмПодписи,            Символы.ПС);
	АлгоритмыХеширования        = СтрРазделить(ДанныеАлгоритмаПодписания.АлгоритмХеширования,        Символы.ПС);
	
	АлгоритмыУказаны = Ложь;
	Для Индекс = 0 По OIDАлгоритмовОткрытогоКлюча.Количество() - 1 Цикл
		
		Если OIDАлгоритмаОткрытогоКлюча = OIDАлгоритмовОткрытогоКлюча[Индекс] Тогда
			
			ДанныеАлгоритмаПодписания.OIDВыбранногоАлгоритмаПодписи     = OIDАлгоритмовПодписи[Индекс];
			ДанныеАлгоритмаПодписания.OIDВыбранногоАлгоритмаХеширования = OIDАлгоритмовХеширования[Индекс];
			ДанныеАлгоритмаПодписания.ВыбранныйАлгоритмПодписи          = АлгоритмыПодписи[Индекс];
			ДанныеАлгоритмаПодписания.ВыбранныйАлгоритмХеширования      = АлгоритмыХеширования[Индекс];
			
			АлгоритмыУказаны = Истина;
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если Не АлгоритмыУказаны Тогда
		НаборАлгоритмов = НаборАлгоритмовДляСозданияПодписи(
			OIDАлгоритмаОткрытогоКлюча);
		
		Если НаборАлгоритмов <> Неопределено Тогда
			ДанныеАлгоритмаПодписания.OIDВыбранногоАлгоритмаПодписи     = НаборАлгоритмов.ИдентификаторАлгоритмаПодписи;
			ДанныеАлгоритмаПодписания.OIDВыбранногоАлгоритмаХеширования = НаборАлгоритмов.ИдентификаторАлгоритмаХеширования;
			ДанныеАлгоритмаПодписания.ВыбранныйАлгоритмПодписи          = НаборАлгоритмов.ИмяАлгоритмаПодписиXML;
			ДанныеАлгоритмаПодписания.ВыбранныйАлгоритмХеширования      = НаборАлгоритмов.ИмяАлгоритмаХешированияXML;
		КонецЕсли;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ДанныеАлгоритмаПодписания.OIDВыбранногоАлгоритмаПодписи)
	 Или Не ЗначениеЗаполнено(ДанныеАлгоритмаПодписания.OIDВыбранногоАлгоритмаХеширования)
	 Или Не ЗначениеЗаполнено(ДанныеАлгоритмаПодписания.ВыбранныйАлгоритмПодписи)
	 Или Не ЗначениеЗаполнено(ДанныеАлгоритмаПодписания.ВыбранныйАлгоритмХеширования) Тогда
		
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не указаны алгоритмы подписания и хеширования для создания подписи,
			           |соответствующие алгоритму открытого ключа сертификата (OID %1).'"),
			OIDАлгоритмаОткрытогоКлюча);
		
		Если ВызыватьИсключение Тогда
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
		Возврат ТекстОшибки;
	КонецЕсли;
	
	Если АлгоритмыУказаны
	 Или СвойстваКонвертаXML = Неопределено
	 Или Не СвойстваКонвертаXML.ПроверкаПодписи Тогда
		Возврат "";
	КонецЕсли;
	
	Если СвойстваКонвертаXML.АлгоритмПодписи.Идентификатор
	     <> ДанныеАлгоритмаПодписания.OIDВыбранногоАлгоритмаПодписи Тогда
		
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В документе XML указанный алгоритм подписи
			           |""%1"" (OID ""%2"")
			           |не совпадает с алгоритмом подписи в сертификате OID ""%3"".'"),
			СвойстваКонвертаXML.АлгоритмПодписи.Имя,
			СвойстваКонвертаXML.АлгоритмПодписи.Идентификатор,
			ДанныеАлгоритмаПодписания.OIDВыбранногоАлгоритмаПодписи);
		
		Если ВызыватьИсключение Тогда
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
		Возврат ТекстОшибки;
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

// См. ЭлектроннаяПодписьКлиент.ПараметрыCMS.
Функция ПараметрыCMS() Экспорт
	
	Параметры = Новый Структура;
	
	Параметры.Вставить("ТипПодписи",   "CAdES-BES");
	Параметры.Вставить("Открепленная", Ложь);
	Параметры.Вставить("ВключениеСертификатовВПодпись",
		РежимВключенияСертификатовКриптографии.ВключатьПолнуюЦепочку);
	
	Возврат Параметры;
	
КонецФункции

Функция ПараметрыКомпонентыCMSSign(ПараметрыCMS, ОписаниеДанных) Экспорт
	
	ПараметрыКомпоненты = Новый Структура;
	
	Если ТипЗнч(ОписаниеДанных) = Тип("Строка")
	   И ЭтоАдресВременногоХранилища(ОписаниеДанных) Тогда
	
		Данные = ПолучитьИзВременногоХранилища(ОписаниеДанных);
	Иначе
		Данные = ОписаниеДанных;
	КонецЕсли;
	
	Если ПараметрыCMS.ТипПодписи = "CAdES-BES" Тогда
		ПараметрыКомпоненты.Вставить("ТипПодписи", 0);
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Некорректный параметр %1 метода %2 компоненты %3.'"),
			"ТипПодписи", "CMSSign", "ExtraCryptoAPI");
	КонецЕсли;
	
	Если ТипЗнч(Данные) = Тип("Строка")
	 Или ТипЗнч(Данные) = Тип("ДвоичныеДанные") Тогда
		
		ПараметрыКомпоненты.Вставить("Данные", Данные);
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Некорректный параметр %1 метода %2 компоненты %3.'"),
			"Данные", "CMSSign", "ExtraCryptoAPI");
	КонецЕсли;
	
	Если ТипЗнч(ПараметрыCMS.Открепленная) = Тип("Булево") Тогда
		ПараметрыКомпоненты.Вставить("Открепленная", ПараметрыCMS.Открепленная);
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Некорректный параметр %1 метода %2 компоненты %3.'"),
			"Открепленная", "CMSSign", "ExtraCryptoAPI");
	КонецЕсли;
	
	//  0 - РежимВключенияСертификатовКриптографии.НеВключать.
	//  1 - РежимВключенияСертификатовКриптографии.ВключатьСертификатСубъекта.
	// 17 - РежимВключенияСертификатовКриптографии.ВключатьПолнуюЦепочку.
	ПараметрыКомпоненты.Вставить("ВключениеСертификатовВПодпись", 17);
	Если ПараметрыCMS.ВключениеСертификатовВПодпись = "НеВключать"
		Или ПараметрыCMS.ВключениеСертификатовВПодпись = РежимВключенияСертификатовКриптографии.НеВключать Тогда
		
		ПараметрыКомпоненты.ВключениеСертификатовВПодпись = 0;
	ИначеЕсли ПараметрыCMS.ВключениеСертификатовВПодпись = "ВключатьСертификатСубъекта"
		Или ПараметрыCMS.ВключениеСертификатовВПодпись = РежимВключенияСертификатовКриптографии.ВключатьСертификатСубъекта Тогда
		
		ПараметрыКомпоненты.ВключениеСертификатовВПодпись = 1;
	КонецЕсли;
	
	Возврат ПараметрыКомпоненты;
	
КонецФункции

Функция ТипПлатформыСтрокой() Экспорт
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	
	Если СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86 Тогда
		Возврат "Linux_x86";
	ИначеЕсли СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86_64 Тогда
		Возврат "Linux_x86_64";
	ИначеЕсли СистемнаяИнформация.ТипПлатформы = ТипПлатформы.MacOS_x86 Тогда
		Возврат "MacOS_x86";
	ИначеЕсли СистемнаяИнформация.ТипПлатформы = ТипПлатформы.MacOS_x86_64 Тогда
		Возврат "MacOS_x86_64";
	ИначеЕсли СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86 Тогда
		Возврат "Windows_x86";
	ИначеЕсли СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64 Тогда
		Возврат "Windows_x86_64";
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

// Готовит строку для использования в качестве имени файла.
Функция ПодготовитьСтрокуДляИмениФайла(Строка, ЗаменаПробела = Неопределено) Экспорт
	
	ЗаменаСимволов = Новый Соответствие;
	ЗаменаСимволов.Вставить("\", " ");
	ЗаменаСимволов.Вставить("/", " ");
	ЗаменаСимволов.Вставить("*", " ");
	ЗаменаСимволов.Вставить("<", " ");
	ЗаменаСимволов.Вставить(">", " ");
	ЗаменаСимволов.Вставить("|", " ");
	ЗаменаСимволов.Вставить(":", "");
	ЗаменаСимволов.Вставить("""", "");
	ЗаменаСимволов.Вставить("?", "");
	ЗаменаСимволов.Вставить(Символы.ВК, "");
	ЗаменаСимволов.Вставить(Символы.ПС, " ");
	ЗаменаСимволов.Вставить(Символы.Таб, " ");
	ЗаменаСимволов.Вставить(Символы.НПП, " ");
	// замена символов кавычек
	ЗаменаСимволов.Вставить(Символ(171), "");
	ЗаменаСимволов.Вставить(Символ(187), "");
	ЗаменаСимволов.Вставить(Символ(8195), "");
	ЗаменаСимволов.Вставить(Символ(8194), "");
	ЗаменаСимволов.Вставить(Символ(8216), "");
	ЗаменаСимволов.Вставить(Символ(8218), "");
	ЗаменаСимволов.Вставить(Символ(8217), "");
	ЗаменаСимволов.Вставить(Символ(8220), "");
	ЗаменаСимволов.Вставить(Символ(8222), "");
	ЗаменаСимволов.Вставить(Символ(8221), "");
	
	СтрокаПодготовленная = "";
	
	КоличествоСимволов = СтрДлина(Строка);
	
	Для НомерСимвола = 1 По КоличествоСимволов Цикл
		Символ = Сред(Строка, НомерСимвола, 1);
		Если ЗаменаСимволов[Символ] <> Неопределено Тогда
			Символ = ЗаменаСимволов[Символ];
		КонецЕсли;
		СтрокаПодготовленная = СтрокаПодготовленная + Символ;
	КонецЦикла;
	
	Если ЗаменаПробела <> Неопределено Тогда
		СтрокаПодготовленная = СтрЗаменить(ЗаменаПробела, " ", ЗаменаПробела);
	КонецЕсли;
	
	Возврат СокрЛП(СтрокаПодготовленная);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Вспомогательные процедуры и функции.

// Для функций СертификатПросрочен, ПредставлениеСертификата, СвойстваСертификата.
//
// Параметры:
//   Сертификат - СертификатКриптографии
//
Функция ДатыСертификата(Сертификат, ДобавкаВремени) Экспорт
	
	ДатыСертификата = Новый Структура;
	ДатыСертификата.Вставить("ДатаНачала",    Сертификат.ДатаНачала    + ДобавкаВремени);
	ДатыСертификата.Вставить("ДатаОкончания", Сертификат.ДатаОкончания + ДобавкаВремени);
	
	Возврат ДатыСертификата;
	
КонецФункции

// Для функции СвойстваСертификата.
Функция ПолучитьНазначение(Сертификат)
	
	Если Не Сертификат.РасширенныеСвойства.Свойство("EKU") Тогда
		Возврат "";
	КонецЕсли;
	
	ФиксированныйМассивСвойств = Сертификат.РасширенныеСвойства.EKU;
	
	Назначение = "";
	
	Для Индекс = 0 По ФиксированныйМассивСвойств.Количество() - 1 Цикл
		Назначение = Назначение + ФиксированныйМассивСвойств.Получить(Индекс);
		Назначение = Назначение + Символы.ПС;
	КонецЦикла;
	
	Возврат ПодготовитьСтроку(Назначение);
	
КонецФункции


// Возвращает сведения из свойств сертификата строкой.
//
// Параметры:
//  СвойстваСертификата - см. ЭлектроннаяПодпись.СвойстваСертификата
// 
// Возвращаемое значение:
//  Строка
//
Функция СведенияОСертификатеСтрокой(СвойстваСертификата) Экспорт
	
	СведенияОСертификате = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Сертификат: %1
			|Кем выдан: %2
			|Владелец: %3
			|Действителен: с %4 по %5'"),
		Строка(СвойстваСертификата.СерийныйНомер),
		СвойстваСертификата.КемВыдан,
		СвойстваСертификата.КомуВыдан,
		Формат(СвойстваСертификата.ДатаНачала,    "ДЛФ=D"),
		Формат(СвойстваСертификата.ДатаОкончания, "ДЛФ=D"));
	
	Возврат СведенияОСертификате;
	
КонецФункции

// Для функций СвойстваСубъектаСертификата, СвойстваИздателяСертификата.
Функция ПодготовитьСтроку(СтрокаИзСертификата)
	
	Возврат СокрЛП(ОбщегоНазначенияКлиентСервер.ЗаменитьНедопустимыеСимволыXML(СтрокаИзСертификата));
	
КонецФункции

// Для функции ОбщееОписаниеОшибки.
Функция УпрощеннаяСтруктураОшибки(Ошибка, ЗаголовокОшибки)
	
	УпрощеннаяСтруктура = Новый Структура;
	УпрощеннаяСтруктура.Вставить("ОписаниеОшибки",  "");
	УпрощеннаяСтруктура.Вставить("ЗаголовокОшибки", "");
	УпрощеннаяСтруктура.Вставить("Описание",        "");
	УпрощеннаяСтруктура.Вставить("НеПоддерживается", Ложь);
	
	Если ТипЗнч(Ошибка) = Тип("Строка") Тогда
		УпрощеннаяСтруктура.ОписаниеОшибки = СокрЛП(Ошибка);
		Возврат УпрощеннаяСтруктура;
		
	ИначеЕсли ТипЗнч(Ошибка) <> Тип("Структура") Тогда
		Возврат УпрощеннаяСтруктура;
	КонецЕсли;
	
	Если Ошибка.Свойство("ОписаниеОшибки") Тогда
		УпрощеннаяСтруктура.ОписаниеОшибки = СокрЛП(Ошибка.ОписаниеОшибки);
	КонецЕсли;
	
	Если Ошибка.Свойство("ЗаголовокОшибки") Тогда
		Если Ошибка.Свойство("Ошибки") И Ошибка.Ошибки.Количество() = 1 Тогда
			Если ЗаголовокОшибки <> Неопределено Тогда
				УпрощеннаяСтруктура.ЗаголовокОшибки = Ошибка.ЗаголовокОшибки;
			КонецЕсли;
			СвойстваОшибки = Ошибка.Ошибки[0]; // см. НовыеСвойстваОшибки
			Описание = "";
			Если ЗначениеЗаполнено(СвойстваОшибки.Программа) Тогда
				Описание = Описание + Строка(СвойстваОшибки.Программа) + ":" + Символы.ПС;
			КонецЕсли;
			Описание = Описание + СвойстваОшибки.Описание;
			УпрощеннаяСтруктура.Описание = СокрЛП(Описание);
			УпрощеннаяСтруктура.ОписаниеОшибки = СокрЛП(УпрощеннаяСтруктура.ЗаголовокОшибки + Символы.ПС + Описание);
			Если СвойстваОшибки.НеПоддерживается Тогда
				УпрощеннаяСтруктура.НеПоддерживается = Истина;
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли ЗначениеЗаполнено(ЗаголовокОшибки) Тогда
		УпрощеннаяСтруктура.ЗаголовокОшибки = ЗаголовокОшибки;
		УпрощеннаяСтруктура.Описание = УпрощеннаяСтруктура.ОписаниеОшибки;
		УпрощеннаяСтруктура.ОписаниеОшибки = ЗаголовокОшибки
			+ Символы.ПС + УпрощеннаяСтруктура.ОписаниеОшибки;
	КонецЕсли;
	
	Возврат УпрощеннаяСтруктура;
	
КонецФункции

// Возвращает информацию об используемом компьютере.
//
// Возвращаемое значение:
//   Строка - информация о компьютере.
//
Функция ДиагностическаяИнформацияОКомпьютере(ДляКлиента = Ложь) Экспорт
	
	СисИнфо = Новый СистемнаяИнформация;
	ПрограммаПросмотра = ?(ДляКлиента, СисИнфо.ИнформацияПрограммыПросмотра, "");
	
	Если Не ПустаяСтрока(ПрограммаПросмотра) Тогда
		ПрограммаПросмотра = Символы.ПС + НСтр("ru = 'Программа просмотра:'") + " " + ПрограммаПросмотра;
	КонецЕсли;
	
	Возврат НСтр("ru = 'Операционная система:'") + " " + СисИнфо.ВерсияОС
		+ Символы.ПС + НСтр("ru = 'Версия приложения:'") + " " + СисИнфо.ВерсияПриложения
		+ Символы.ПС + НСтр("ru = 'Тип платформы:'") + " " + СисИнфо.ТипПлатформы
		+ ПрограммаПросмотра;
	
КонецФункции

Функция ДиагностическаяИнформацияПоПрограмме(Программа, МенеджерКриптографии, ОписаниеОшибки) Экспорт
	
	Если ТипЗнч(МенеджерКриптографии) = Тип("МенеджерКриптографии") Тогда
		Результат = НСтр("ru = 'ОК'");
	Иначе
		ТекстОшибки = "";
		Если ТипЗнч(ОписаниеОшибки) = Тип("Структура")
		   И ОписаниеОшибки.Свойство("Ошибки")
		   И ТипЗнч(ОписаниеОшибки.Ошибки) = Тип("Массив")
		   И ОписаниеОшибки.Ошибки.Количество() > 0 Тогда
			
			Ошибка = ОписаниеОшибки.Ошибки[0]; // см. НовыеСвойстваОшибки
			ТекстОшибки = Ошибка.Описание;
		КонецЕсли;
		Результат = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка ""%1""'"), ТекстОшибки);
	КонецЕсли;
	
	Возврат Программа.Представление + " - " + Результат + Символы.ПС;
	
КонецФункции

// Только для внутреннего использования.
Функция РазмещениеСертификата(ТипРазмещения) Экспорт
	
	Результат = "Локальный";
	ОбщееРазмещение = (ТипРазмещения - 1) % 4;
	
	Если ОбщееРазмещение = 2 Тогда
		Результат = "ОблачнаяПодпись";
	ИначеЕсли ОбщееРазмещение = 3 Тогда
		Результат = "ПодписьВМоделиСервиса";
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#Область ШаблоныКонвертаXML

// Вариант "furs.mark.crpt.ru_v1".
Функция КонвертXML1()
	
	Возврат
	"<soap:Envelope
	|    xmlns:wsse=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd""
	|    xmlns:wsu=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd""
	|    xmlns:soap=""http://schemas.xmlsoap.org/soap/envelope/"">
	|  <soap:Header>
	|    <wsse:Security soap:actor=""http://smev.gosuslugi.ru/actors/smev"">
	|      <ds:Signature xmlns:ds=""http://www.w3.org/2000/09/xmldsig#"">
	|        <SignedInfo xmlns=""http://www.w3.org/2000/09/xmldsig#"">
	|          <CanonicalizationMethod Algorithm=""http://www.w3.org/2001/10/xml-exc-c14n#""/>
	|          <SignatureMethod Algorithm=""%SignatureMethod%""/>
	|          <Reference URI=""#body"">
	|            <Transforms>
	|              <Transform Algorithm=""http://www.w3.org/2000/09/xmldsig#enveloped-signature""/>
	|              <Transform Algorithm=""http://www.w3.org/2001/10/xml-exc-c14n#""/>
	|            </Transforms>
	|            <DigestMethod Algorithm=""%DigestMethod%""/>
	|            <DigestValue>%DigestValue%</DigestValue>
	|          </Reference>
	|        </SignedInfo>
	|        <SignatureValue xmlns=""http://www.w3.org/2000/09/xmldsig#"">
	|          %SignatureValue%
	|        </SignatureValue>
	|        <ds:KeyInfo>
	|          <wsse:SecurityTokenReference>
	|            <wsse:Reference URI=""#SenderCertificate""
	|                            ValueType=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3""/>
	|          </wsse:SecurityTokenReference>
	|        </ds:KeyInfo>
	|      </ds:Signature>
	|      <wsse:BinarySecurityToken
	|              EncodingType=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary""
	|              ValueType=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3""
	|              wsu:Id=""SenderCertificate"">
	|        %BinarySecurityToken%
	|      </wsse:BinarySecurityToken>
	|    </wsse:Security>
	|  </soap:Header>
	|  <soap:Body wsu:Id=""body"">
	|    %MessageXML%
	|  </soap:Body>
	|</soap:Envelope>";
	
КонецФункции

// Вариант "dmdk.goznak.ru_v1".
Функция КонвертXML2()
	
	Возврат
	"<soapenv:Envelope xmlns:soapenv=""http://schemas.xmlsoap.org/soap/envelope/""
	|    xmlns:ns=""urn://xsd.dmdk.goznak.ru/exchange/1.0""
	|    xmlns:ns1=""urn://xsd.dmdk.goznak.ru/batch/1.0""
	|    xmlns:ns2=""urn://xsd.dmdk.goznak.ru/contractor/1.0""
	|    xmlns:ns3=""urn://xsd.dmdk.goznak.ru/types/1.0"">
	|  <soapenv:Header />
	|  <soapenv:Body>
	|    <ns:CheckBatchRequest>
	|      <ns:CallerSignature>
	|        <ds:Signature xmlns:ds=""http://www.w3.org/2000/09/xmldsig#"">
	|          <ds:SignedInfo>
	|            <ds:CanonicalizationMethod Algorithm=""http://www.w3.org/2001/10/xml-exc-c14n#"" />
	|            <ds:SignatureMethod Algorithm=""%SignatureMethod%"" />
	|            <ds:Reference URI=""#body"">
	|              <ds:Transforms>
	|                <ds:Transform Algorithm=""http://www.w3.org/2001/10/xml-exc-c14n#"" />
	|                <ds:Transform Algorithm=""urn://smev-gov-ru/xmldsig/transform"" />
	|              </ds:Transforms>
	|              <ds:DigestMethod Algorithm=""%DigestMethod%"" />
	|              <ds:DigestValue>%DigestValue%</ds:DigestValue>
	|            </ds:Reference>
	|          </ds:SignedInfo>
	|          <ds:SignatureValue>%SignatureValue%</ds:SignatureValue>
	|          <ds:KeyInfo>
	|            <ds:X509Data>
	|              <ds:X509Certificate>%BinarySecurityToken%</ds:X509Certificate>
	|            </ds:X509Data>
	|          </ds:KeyInfo>
	|        </ds:Signature>
	|      </ns:CallerSignature>
	|      <ns:RequestData Id=""body"">
	|        %MessageXML%
	|      </ns:RequestData>
	|    </ns:CheckBatchRequest>
	|  </soapenv:Body>
	|</soapenv:Envelope>";
	
КонецФункции

#КонецОбласти

#Область ОбластьXML

// Параметры:
//  СтрокаXML   - Строка
//  ИмяЭлемента - Строка
//
// Возвращаемое значение:
//   см. СвойстваОбластиXML
//
Функция ОбластьXML(СтрокаXML, ИмяЭлемента) Экспорт
	
	Результат = СвойстваОбластиXML(ИмяЭлемента);
	ПризнакНачалаОбласти = "<" + ИмяЭлемента;
	ПризнакОкончанияОбласти = "</" + ИмяЭлемента + ">";
	
	Позиция = СтрНайти(СтрокаXML, ПризнакНачалаОбласти);
	Если Позиция = 0 Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не найдена элемент ""%1"" в документе XML.'"), ИмяЭлемента);
		Результат.ТекстОшибки = ТекстОшибки;
	КонецЕсли;
	Результат.ПозицияНачала = Позиция;
	Текст = Сред(СтрокаXML, Позиция);
	
	Позиция = СтрНайти(Текст, ПризнакНачалаОбласти, , 2);
	Если Позиция > 0 Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Найдено более одного элемента ""%1"" в документе XML.'"), ИмяЭлемента);
		Результат.ТекстОшибки = ТекстОшибки;
	КонецЕсли;
	
	Позиция = СтрНайти(Текст, ПризнакОкончанияОбласти);
	Если Позиция = 0 Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не найдено окончание элемента ""%1"" в документе XML.'"), ИмяЭлемента);
		Результат.ТекстОшибки = ТекстОшибки;
	КонецЕсли;
	
	ПозицияСледующейОбласти = Позиция + СтрДлина(ПризнакОкончанияОбласти);
	Результат.Текст = Сред(Текст, 1, ПозицияСледующейОбласти - 1);
	Результат.ПозицияСледующейОбласти = Результат.ПозицияНачала + ПозицияСледующейОбласти;
	
	Текст = Сред(Текст, 1, Позиция - 1);
	
	Позиция = СтрНайти(Текст, ">");
	Если Позиция = 0 Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не найдено окончание заголовка элемента ""%1"" в документе XML.'"), ИмяЭлемента);
		Результат.ТекстОшибки = ТекстОшибки;
	КонецЕсли;
	
	Результат.Начало = Сред(Текст, 1, Позиция);
	Результат.Конец  = ПризнакОкончанияОбласти;
	Результат.Содержимое = Сред(Текст, Позиция + 1);
	
	Возврат Результат;
	
КонецФункции

// Параметры:
//  ОбластьXML - см. СвойстваОбластиXML
//  Начало     - Неопределено
//             - Строка
//
// Возвращаемое значение:
//  Строка
//
Функция ТекстОбластиXML(ОбластьXML, Начало = Неопределено) Экспорт
	
	ЧастиТекста = Новый Массив;
	ЧастиТекста.Добавить(?(Начало = Неопределено, ОбластьXML.Начало, Начало));
	ЧастиТекста.Добавить(ОбластьXML.Содержимое);
	ЧастиТекста.Добавить(ОбластьXML.Конец);
	Результат = СтрСоединить(ЧастиТекста);
	
	Возврат Результат;
	
КонецФункции

// Параметры:
//  ОбластьXML - см. СвойстваОбластиXML
//  Алгоритм   - см. ЭлектроннаяПодписьСлужебный.АлгоритмКанонизации
//  ТекстXML   - Строка
//
// Возвращаемое значение:
//  Строка
//
Функция РасширенноеНачалоОбластиXML(ОбластьXML, Алгоритм, ТекстXML) Экспорт
	
	Результат = Новый Структура("Начало, ТекстОшибки", , "");
	
	Если Алгоритм.Вид = "c14n"
	 Или Алгоритм.Вид = "smev" Тогда
		
		Если ТекстXML = Неопределено Тогда
			ТекущаяОбластьXML = ОбластьXML;
		Иначе
			ТекущаяОбластьXML = ОбластьXML(ТекстXML, ОбластьXML.ИмяЭлемента);
			Если ЗначениеЗаполнено(ТекущаяОбластьXML.ТекстОшибки) Тогда
				Результат.ТекстОшибки = ТекущаяОбластьXML.ТекстОшибки;
				Возврат Результат;
			КонецЕсли;
			ТекущаяОбластьXML.ПространстваИменДоУзла = ОбластьXML.ПространстваИменДоУзла;
		КонецЕсли;
		Результат.Начало = РасширенноеНачало(ТекущаяОбластьXML);
	Иначе
		Результат.Начало = ОбластьXML.Начало;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Параметры:
//  ОбластьXML - см. СвойстваОбластиXML
//
// Возвращаемое значение:
//  Строка
//
Функция РасширенноеНачало(ОбластьXML)
	
	Если Не ЗначениеЗаполнено(ОбластьXML.ПространстваИменДоУзла) Тогда
		Возврат ОбластьXML.Начало;
	КонецЕсли;
	
	Дополнительные = Новый Массив;
	Для Каждого ИмяПространства Из ОбластьXML.ПространстваИменДоУзла Цикл
		Позиция = СтрНайти(ИмяПространства, "=""");
		ОбъявлениеПространства = Лев(ИмяПространства, Позиция + 1);
		Если СтрНайти(ОбластьXML.Начало, ОбъявлениеПространства) > 0 Тогда
			Продолжить;
		КонецЕсли;
		Дополнительные.Добавить(ИмяПространства);
	КонецЦикла;
	
	Результат = Лев(ОбластьXML.Начало, СтрДлина(ОбластьXML.ИмяЭлемента) + 1)
		+ " " + СтрСоединить(Дополнительные, " ")
		+ " " + Сред(ОбластьXML.Начало, СтрДлина(ОбластьXML.ИмяЭлемента) + 2);
	
	Возврат Результат;
	
КонецФункции

// Параметры:
//  ИмяЭлемента - Строка
//
// Возвращаемое значение:
//  Структура:
//   * ИмяЭлемента - Строка
//   * ТекстОшибки - Строка
//   * ПозицияНачала - Число
//   * ПозицияСледующейОбласти - Число
//   * Начало      - Строка
//   * Содержимое - Строка
//   * Конец - Строка
//   * ПространстваИменДоУзла - Массив из Строка
//                            - Неопределено
//
Функция СвойстваОбластиXML(ИмяЭлемента)
	
	Результат = Новый Структура;
	Результат.Вставить("ИмяЭлемента", ИмяЭлемента);
	Результат.Вставить("ТекстОшибки", "");
	Результат.Вставить("ПозицияНачала", 0);
	Результат.Вставить("ПозицияСледующейОбласти", 0);
	Результат.Вставить("Начало", "");
	Результат.Вставить("Содержимое", "");
	Результат.Вставить("Конец", "");
	Результат.Вставить("Текст", "");
	Результат.Вставить("ПространстваИменДоУзла");
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область СодержимоеСертификата

Функция АлгоритмСформированнойПодписи(ДанныеПодписи, ВключаяOID = Ложь, ТолькоOID = Ложь) Экспорт
	
	Возврат АлгоритмПодписи(ДанныеПодписи, Ложь, ВключаяOID, ТолькоOID);
	
КонецФункции

Функция АлгоритмПодписиСертификата(ДанныеСертификата, ВключаяOID = Ложь, ТолькоOID = Ложь) Экспорт
	
	Возврат АлгоритмПодписи(ДанныеСертификата, Истина, ВключаяOID, ТолькоOID);
	
КонецФункции

Функция АлгоритмПодписи(Данные, ЭтоДанныеСертификата, ВключаяOID = Ложь, ТолькоOID = Ложь)
	
	ДвоичныеДанные = ДвоичныеДанныеИзДанных(Данные,
		"ЭлектроннаяПодписьСлужебныйКлиентСервер.АлгоритмПодписи");
	
	АнализДанных = НовыйАнализДанных(ДвоичныеДанные);
	
	Если ЭтоДанныеСертификата Тогда
		// SEQUENCE (Certificate).
		ПропуститьНачалоБлока(АнализДанных, 0, 16);
			// SEQUENCE (tbsCertificate).
			ПропуститьНачалоБлока(АнализДанных, 0, 16);
				//          (version              [0]  EXPLICIT Version DEFAULT v1).
				ПропуститьБлок(АнализДанных, 2, 0);
				// INTEGER  (serialNumber         CertificateSerialNumber).
				ПропуститьБлок(АнализДанных, 0, 2);
				// SEQUENCE (signature            AlgorithmIdentifier).
				ПропуститьБлок(АнализДанных, 0, 16);
				// SEQUENCE (issuer               Name).
				ПропуститьБлок(АнализДанных, 0, 16);
				// SEQUENCE (validity             Validity).
				ПропуститьБлок(АнализДанных, 0, 16);
				// SEQUENCE (subject              Name).
				ПропуститьБлок(АнализДанных, 0, 16);
				// SEQUENCE (subjectPublicKeyInfo SubjectPublicKeyInfo).
				ПропуститьНачалоБлока(АнализДанных, 0, 16);
					// SEQUENCE (algorithm  AlgorithmIdentifier).
					ПропуститьНачалоБлока(АнализДанных, 0, 16);
						// OBJECT IDENTIFIER (algorithm).
						ПропуститьНачалоБлока(АнализДанных, 0, 6);
	Иначе
		// SEQUENCE (PKCS #7 ContentInfo).
		ПропуститьНачалоБлока(АнализДанных, 0, 16);
			// OBJECT IDENTIFIER (contentType).
			ПропуститьНачалоБлока(АнализДанных, 0, 6);
				// 1.2.840.113549.1.7.2 signedData (PKCS #7).
				ПроверитьДанныеБлока(АнализДанных, "2A864886F70D010702");
				ПропуститьРодительскийБлок(АнализДанных);
			// [0]CS             (content [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL).
			ПропуститьНачалоБлока(АнализДанных, 2, 0);
				// SEQUENCE (content SignedData).
				ПропуститьНачалоБлока(АнализДанных, 0, 16);
					// INTEGER  (version          Version).
					ПропуститьБлок(АнализДанных, 0, 2);
					// SET      (digestAlgorithms DigestAlgorithmIdentifiers).
					ПропуститьБлок(АнализДанных, 0, 17);
					// SEQUENCE (contentInfo      ContentInfo).
					ПропуститьБлок(АнализДанных, 0, 16);
					// [0]CS    (certificates     [0] IMPLICIT ExtendedCertificatesAndCertificates OPTIONAL).
					ПропуститьБлок(АнализДанных, 2, 0, Ложь);
					// [1]CS    (crls             [1] IMPLICIT CertificateRevocationLists OPTIONAL).
					ПропуститьБлок(АнализДанных, 2, 1, Ложь);
					// SET      (signerInfos      SET OF SignerInfo).
					ПропуститьНачалоБлока(АнализДанных, 0, 17);
						// SEQUENCE (signerInfo SignerInfo).
						ПропуститьНачалоБлока(АнализДанных, 0, 16);
							// INTEGER  (version                   Version).
							ПропуститьБлок(АнализДанных, 0, 2);
							// SEQUENCE (issuerAndSerialNumber     IssuerAndSerialNumber).
							ПропуститьБлок(АнализДанных, 0, 16);
							// SEQUENCE (digestAlgorithm           DigestAlgorithmIdentifier).
							ПропуститьБлок(АнализДанных, 0, 16);
							// [0]CS    (authenticatedAttributes   [0] IMPLICIT Attributes OPTIONAL).
							ПропуститьБлок(АнализДанных, 2, 0, Ложь);
							// SEQUENCE (digestEncryptionAlgorithm AlgorithmIdentifier).
							ПропуститьНачалоБлока(АнализДанных, 0, 16);
								// OBJECT IDENTIFIER (algorithm).
								ПропуститьНачалоБлока(АнализДанных, 0, 6);
	КонецЕсли;
	
	OIDАлгоритмаПодписи = ПрочитанныйOID(АнализДанных);
	Если АнализДанных.ЕстьОшибка Тогда
		Возврат "";
	КонецЕсли;
	
	Если ТолькоOID Тогда
		Возврат OIDАлгоритмаПодписи;
	КонецЕсли;
	
	ИдентификаторыАлгоритмов = ИдентификаторыАлгоритмовПодписи(ЭтоДанныеСертификата);
	Алгоритм = АлгоритмПоOID(OIDАлгоритмаПодписи, ИдентификаторыАлгоритмов, ВключаяOID);
	
	Возврат Алгоритм;
	
КонецФункции

Функция АлгоритмХеширования(Данные, ВключаяOID = Ложь) Экспорт
	
	ДвоичныеДанные = ДвоичныеДанныеИзДанных(Данные,
		"ЭлектроннаяПодписьСлужебныйКлиентСервер.АлгоритмХеширования");
	
	АнализДанных = НовыйАнализДанных(ДвоичныеДанные);
	
	// SEQUENCE (PKCS #7 ContentInfo).
	ПропуститьНачалоБлока(АнализДанных, 0, 16);
		// OBJECT IDENTIFIER (contentType).
		ПропуститьНачалоБлока(АнализДанных, 0, 6);
			// 1.2.840.113549.1.7.2 signedData (PKCS #7).
			ПроверитьДанныеБлока(АнализДанных, "2A864886F70D010702");
			ПропуститьРодительскийБлок(АнализДанных);
		// [0]CS             (content [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL).
		ПропуститьНачалоБлока(АнализДанных, 2, 0);
			// SEQUENCE (content SignedData).
			ПропуститьНачалоБлока(АнализДанных, 0, 16);
				// INTEGER  (version          Version).
				ПропуститьБлок(АнализДанных, 0, 2);
				// SET      (digestAlgorithms DigestAlgorithmIdentifiers).
				ПропуститьБлок(АнализДанных, 0, 17);
				// SEQUENCE (contentInfo      ContentInfo).
				ПропуститьБлок(АнализДанных, 0, 16);
				// [0]CS    (certificates     [0] IMPLICIT ExtendedCertificatesAndCertificates OPTIONAL).
				ПропуститьБлок(АнализДанных, 2, 0, Ложь);
				// [1]CS    (crls             [1] IMPLICIT CertificateRevocationLists OPTIONAL).
				ПропуститьБлок(АнализДанных, 2, 1, Ложь);
				// SET      (signerInfos      SET OF SignerInfo).
				ПропуститьНачалоБлока(АнализДанных, 0, 17);
					// SEQUENCE (signerInfo SignerInfo).
					ПропуститьНачалоБлока(АнализДанных, 0, 16);
						// INTEGER  (version                   Version).
						ПропуститьБлок(АнализДанных, 0, 2);
						// SEQUENCE (issuerAndSerialNumber     IssuerAndSerialNumber).
						ПропуститьБлок(АнализДанных, 0, 16);
						// SEQUENCE (digestAlgorithm           DigestAlgorithmIdentifier).
						ПропуститьНачалоБлока(АнализДанных, 0, 16);
							// OBJECT IDENTIFIER (algorithm).
							ПропуститьНачалоБлока(АнализДанных, 0, 6);
	
	OIDАлгоритмаХеширования = ПрочитанныйOID(АнализДанных);
	Если АнализДанных.ЕстьОшибка Тогда
		Возврат "";
	КонецЕсли;
	
	ИдентификаторыАлгоритмов = ИдентификаторыАлгоритмовХеширования();
	Алгоритм = АлгоритмПоOID(OIDАлгоритмаХеширования, ИдентификаторыАлгоритмов, ВключаяOID);
	
	Возврат Алгоритм;
	
КонецФункции

Функция ДвоичныеДанныеИзДанных(Данные, ИмяФункции)
	
	ОжидаемыеТипы = Новый Массив;
	ОжидаемыеТипы.Добавить(Тип("ДвоичныеДанные"));
	ОжидаемыеТипы.Добавить(Тип("Строка"));
	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		ИмяФункции,
		"Данные", Данные, ОжидаемыеТипы);
	
	Если ТипЗнч(Данные) = Тип("Строка") Тогда
		Если ЭтоАдресВременногоХранилища(Данные) Тогда
			ДвоичныеДанные = ПолучитьИзВременногоХранилища(Данные);
		Иначе
			ОбщегоНазначенияКлиентСервер.Проверить(Ложь,
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Недопустимый адрес временного хранилища в параметре Данные:
					           |%1'") + Символы.ПС, Данные),
				ИмяФункции);
		КонецЕсли;
		Если ТипЗнч(ДвоичныеДанные) <> Тип("ДвоичныеДанные") Тогда
			ОбщегоНазначенияКлиентСервер.Проверить(Ложь,
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Недопустимый тип значения ""%1""
					           |по адресу временного хранилища, указанному в параметре Данные'") + Символы.ПС,
					Строка(ТипЗнч(ДвоичныеДанные))),
				ИмяФункции);
		КонецЕсли;
	Иначе
		ДвоичныеДанные = Данные;
	КонецЕсли;
	
	Возврат ДвоичныеДанные;
	
	
КонецФункции

// Возвращаемое значение:
//  Структура:
//   * ЕстьОшибка - Булево
//   * ЭтоОшибкаКодированияASN1 - Булево
//   * ЭтоОшибкаСтруктурыДанных - Булево
//   * Смещение - Число
//   * Родители - Массив из Структура
//   * Буфер - БуферДвоичныхДанных
// 
Функция НовыйАнализДанных(ДвоичныеДанные) Экспорт
	
	АнализДанных = Новый Структура;
	АнализДанных.Вставить("ЕстьОшибка", Ложь);
	АнализДанных.Вставить("ЭтоОшибкаКодированияASN1", Ложь); // Возможно данные повреждены.
	АнализДанных.Вставить("ЭтоОшибкаСтруктурыДанных", Ложь); // Не найден ожидаемый элемент данных.
	АнализДанных.Вставить("Смещение", 0);
	АнализДанных.Вставить("Родители", Новый Массив);
	АнализДанных.Вставить("Буфер", ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(ДвоичныеДанные));
	
	Возврат АнализДанных;
	
КонецФункции

Функция АлгоритмПоOID(OIDАлгоритма, ИдентификаторыАлгоритмов, ВключаяOID)
	
	ИмяАлгоритма = ИдентификаторыАлгоритмов.Получить(OIDАлгоритма);
	
	Если ИмяАлгоритма = Неопределено Тогда
		Если ВключаяOID Тогда
			Возврат НСтр("ru = 'Неизвестный'") + " (OID " + OIDАлгоритма + ")";
		КонецЕсли;
		Возврат "";
	ИначеЕсли ВключаяOID Тогда
		Возврат СтрРазделить(ИмяАлгоритма, ",", Ложь)[0] + " (OID " + OIDАлгоритма + ")";
	Иначе
		Возврат ИмяАлгоритма;
	КонецЕсли;
	
КонецФункции

Процедура ПропуститьНачалоБлока(АнализДанных, КлассДанных = Неопределено, ТипДанных = Неопределено) Экспорт
	
	ПропуститьНачалоБлокаИлиБлок(АнализДанных, Истина, КлассДанных, ТипДанных, Истина)
	
КонецПроцедуры

Процедура ПропуститьБлок(АнализДанных, КлассДанных = Неопределено, ТипДанных = Неопределено, ОбязательныйБлок = Истина) Экспорт
	
	Если АнализДанных.ЕстьОшибка Тогда
		Возврат;
	КонецЕсли;
	
	Если АнализДанных.Родители.Количество() = 0
	 Или Не АнализДанных.Родители[0].ЕстьВложения Тогда
		
		ПриОшибкеСтруктурыДанных(АнализДанных);
		Возврат;
	КонецЕсли;
	
	ПропуститьНачалоБлокаИлиБлок(АнализДанных, Ложь, КлассДанных, ТипДанных, ОбязательныйБлок)
	
КонецПроцедуры

Процедура ПропуститьРодительскийБлок(АнализДанных) Экспорт
	
	Если АнализДанных.ЕстьОшибка Тогда
		Возврат;
	КонецЕсли;
	
	Если АнализДанных.Родители.Количество() < 2
	 Или Не АнализДанных.Родители[1].ЕстьВложения Тогда
		
		ПриОшибкеСтруктурыДанных(АнализДанных);
		Возврат;
	КонецЕсли;
	
	Если АнализДанных.Родители[0].РазмерДанных > 0 Тогда
		ОсталосьБайт = АнализДанных.Родители[0].СмещениеСледующего - АнализДанных.Смещение;
		
		Если ОсталосьБайт > 0 Тогда
			ПрочитатьБайт(АнализДанных, ОсталосьБайт);
			Если АнализДанных.ЕстьОшибка Тогда
				Возврат;
			КонецЕсли;
		ИначеЕсли ОсталосьБайт < 0 Тогда
			ПриОшибкеКодированияASN1(АнализДанных);
			Возврат;
		КонецЕсли;
	Иначе
		Пока Истина Цикл
			Если КонецБлокаНеопределеннойДлины(АнализДанных) Тогда
				Если АнализДанных.ЕстьОшибка Тогда
					Возврат;
				КонецЕсли;
				АнализДанных.Смещение = АнализДанных.Смещение + 2;
				Прервать;
			КонецЕсли;
			ПропуститьБлок(АнализДанных);
		КонецЦикла;
	КонецЕсли;
	
	АнализДанных.Родители.Удалить(0);
	
КонецПроцедуры

Процедура ПроверитьДанныеБлока(АнализДанных, СтрокаДанных)
	
	Если АнализДанных.ЕстьОшибка Тогда
		Возврат;
	КонецЕсли;
	
	Если АнализДанных.Родители.Количество() = 0 Тогда
		ПриОшибкеСтруктурыДанных(АнализДанных);
		Возврат;
	КонецЕсли;
	
	РазмерДанных = АнализДанных.Родители[0].РазмерДанных;
	Если РазмерДанных = 0 Тогда
		ПриОшибкеСтруктурыДанных(АнализДанных);
		Возврат;
	КонецЕсли;
	Буфер = АнализДанных.Буфер.Прочитать(АнализДанных.Смещение, РазмерДанных); // БуферДвоичныхДанных
	
	Если Буфер.Размер <> РазмерДанных Тогда
		ПриОшибкеКодированияASN1(АнализДанных);
		Возврат;
	КонецЕсли;
	АнализДанных.Смещение = АнализДанных.Смещение + РазмерДанных;
	
	СтрокаБуфера = ПолучитьHexСтрокуИзБуфераДвоичныхДанных(Буфер);
	Если СтрокаДанных <> СтрокаБуфера Тогда
		ПриОшибкеСтруктурыДанных(АнализДанных);
		Возврат;
	КонецЕсли;
	
КонецПроцедуры

Функция ПрочитанныйOID(АнализДанных)
	
	Если АнализДанных.ЕстьОшибка Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если АнализДанных.Родители.Количество() = 0 Тогда
		ПриОшибкеСтруктурыДанных(АнализДанных);
		Возврат Неопределено;
	КонецЕсли;
	
	ЦелыеЧисла = Новый Массив;
	РазмерДанных = АнализДанных.Родители[0].РазмерДанных;
	Если РазмерДанных = 0 Тогда
		ПриОшибкеСтруктурыДанных(АнализДанных);
		Возврат Неопределено;
	КонецЕсли;
	ГраницаСмещения = АнализДанных.Смещение + РазмерДанных;
	
	Пока АнализДанных.Смещение < ГраницаСмещения Цикл
		ЦелоеЧисло = ПрочитатьПотоковоеЦелое(АнализДанных);
		Если АнализДанных.ЕстьОшибка Тогда
			Возврат Неопределено;
		КонецЕсли;
		ЦелыеЧисла.Добавить(ЦелоеЧисло);
	КонецЦикла;
	
	Если АнализДанных.Смещение <> ГраницаСмещения
	 Или ЦелыеЧисла.Количество() = 0 Тогда
		
		ПриОшибкеКодированияASN1(АнализДанных);
		Возврат Неопределено;
	КонецЕсли;
	
	ЧислоSID2 = ЦелыеЧисла[0];
	Если ЧислоSID2 < 40 Тогда
		SID1 = 0;
	ИначеЕсли ЧислоSID2 < 80 Тогда
		SID1 = 1;
	Иначе
		SID1 = 2;
	КонецЕсли;
	ЦелыеЧисла[0] = ЧислоSID2 - SID1*40;
	ЦелыеЧисла.Вставить(0, SID1);
	
	СтрокиЧисел = Новый Массив;
	Для Каждого ЦелоеЧисло Из ЦелыеЧисла Цикл
		СтрокиЧисел.Добавить(Формат(ЦелоеЧисло, "ЧН=0; ЧГ="));
	КонецЦикла;
	
	Возврат СтрСоединить(СтрокиЧисел, ".");
	
КонецФункции

Процедура ПропуститьНачалоБлокаИлиБлок(АнализДанных, НачалоБлока,
			ТребуемыйКлассДанных, ТребуемыйТипДанных, ОбязательныйБлок)
	
	Если АнализДанных.Родители.Количество() > 0
	   И АнализДанных.Смещение >= АнализДанных.Родители[0].СмещениеСледующего Тогда
	
		ПриОшибкеСтруктурыДанных(АнализДанных);
		Возврат;
	КонецЕсли;
	
	СмещениеБлока = АнализДанных.Смещение;
	Байт = ПрочитатьБайт(АнализДанных);
	Если АнализДанных.ЕстьОшибка Тогда
		Возврат;
	КонецЕсли;
	
	КлассДанных = ПобитовыйСдвигВправо(Байт, 6);
	ТипДанных = Байт - КлассДанных * 64;
	ЕстьВложения = Ложь;
	
	Если ТипДанных > 31 Тогда
		ЕстьВложения = Истина;
		ТипДанных = ТипДанных - 32;
	КонецЕсли;
	
	Если ТипДанных > 30 Тогда
		ТипДанных = ПрочитатьПотоковоеЦелое(АнализДанных);
		Если АнализДанных.ЕстьОшибка Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	Если ТребуемыйКлассДанных <> Неопределено
	   И ТребуемыйКлассДанных <> КлассДанных
	 Или ТребуемыйТипДанных <> Неопределено
	   И ТребуемыйТипДанных <> ТипДанных Тогда
	
		Если ОбязательныйБлок Тогда
			ПриОшибкеСтруктурыДанных(АнализДанных);
		Иначе
			АнализДанных.Смещение = СмещениеБлока;
		КонецЕсли;
		Возврат;
	КонецЕсли;
	
	РазмерДанных = ПрочитатьРазмерДанных(АнализДанных);
	Если АнализДанных.ЕстьОшибка Тогда
		Возврат;
	КонецЕсли;
	
	Если НачалоБлока Или ЕстьВложения И РазмерДанных = 0 Тогда
		Если РазмерДанных = 0 Тогда
			Если АнализДанных.Родители.Количество() = 0 Тогда
				Если Не КонецБлокаНеопределеннойДлины(АнализДанных, Истина) Тогда
					ПриОшибкеКодированияASN1(АнализДанных);
					Возврат;
				КонецЕсли;
				СмещениеСледующего = АнализДанных.Буфер.Размер - 2;
				РазмерДанных = СмещениеСледующего - АнализДанных.Смещение;
			Иначе
				// Для блока неопределенной длины СмещениеСледующего - это только граница.
				СмещениеСледующего = АнализДанных.Родители[0].СмещениеСледующего;
			КонецЕсли;
		Иначе
			СмещениеСледующего = АнализДанных.Смещение + РазмерДанных;
			Если АнализДанных.Родители.Количество() = 0
			   И СмещениеСледующего <> АнализДанных.Буфер.Размер Тогда
				
				ПриОшибкеКодированияASN1(АнализДанных);
				Возврат;
			КонецЕсли;
		КонецЕсли;
		ТекущийБлок = Новый Структура("ЕстьВложения, СмещениеСледующего, РазмерДанных",
			ЕстьВложения, СмещениеСледующего, РазмерДанных);
		АнализДанных.Родители.Вставить(0, ТекущийБлок);
		Если Не НачалоБлока Тогда
			ПропуститьРодительскийБлок(АнализДанных);
		КонецЕсли;
	Иначе
		Если РазмерДанных = 0 Тогда
			ПрочитатьКонецБлокаБезВложенийНеопределеннойДлины(АнализДанных);
		Иначе
			ПрочитатьБайт(АнализДанных, РазмерДанных);
		КонецЕсли;
		Если АнализДанных.ЕстьОшибка Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Функция КонецБлокаНеопределеннойДлины(АнализДанных, ОбщийБлок = Ложь)
	
	Буфер = АнализДанных.Буфер;
	
	Если ОбщийБлок Тогда
		Смещение = Буфер.Размер - 2;
		Если Смещение < 2 Тогда
			ПриОшибкеКодированияASN1(АнализДанных);
			Возврат Ложь;
		КонецЕсли;
	Иначе
		Смещение = АнализДанных.Смещение;
		Если Смещение + 2 > АнализДанных.Родители[0].СмещениеСледующего Тогда
			ПриОшибкеКодированияASN1(АнализДанных);
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Буфер[Смещение] = 0 И Буфер[Смещение + 1] = 0;
	
КонецФункции

Процедура ПрочитатьКонецБлокаБезВложенийНеопределеннойДлины(АнализДанных)
	
	ПредыдущийБайт = -1;
	Байт = -1;
	
	Пока Истина Цикл
		ПредыдущийБайт = Байт;
		Байт = ПрочитатьБайт(АнализДанных);
		Если АнализДанных.ЕстьОшибка Тогда
			Возврат;
		КонецЕсли;
		Если Байт = 0 И ПредыдущийБайт = 0 Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция ПрочитатьПотоковоеЦелое(АнализДанных) Экспорт
	
	Целое = 0;
	Для Счетчик = 1 По 9 Цикл
		Байт = ПрочитатьБайт(АнализДанных);
		Если АнализДанных.ЕстьОшибка Тогда
			Возврат Неопределено;
		КонецЕсли;
		Если Байт < 128 Тогда
			Целое = Целое * 128 + Байт;
			Прервать;
		Иначе
			Целое = Целое * 128 + (Байт - 128);
		КонецЕсли;
	КонецЦикла;
	
	Если Счетчик > 8 Тогда
		ПриОшибкеКодированияASN1(АнализДанных);
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Целое;
	
КонецФункции

Функция ПрочитатьРазмерДанных(АнализДанных)
	
	Байт = ПрочитатьБайт(АнализДанных);
	Если АнализДанных.ЕстьОшибка Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если Байт < 128 Тогда
		Возврат Байт;
	КонецЕсли;
	
	КоличествоБайт = Байт - 128;
	Если КоличествоБайт = 0 Или КоличествоБайт > 8 Тогда
		Если Байт = 128 Тогда
			Возврат 0; // Блок неопределенной длины.
		КонецЕсли;
		ПриОшибкеКодированияASN1(АнализДанных);
		Возврат Неопределено;
	КонецЕсли;
	
	Целое = 0;
	Для Счетчик = 1 По КоличествоБайт Цикл
		Байт = ПрочитатьБайт(АнализДанных);
		Если АнализДанных.ЕстьОшибка Тогда
			Возврат Неопределено;
		КонецЕсли;
		Целое = Целое * 256 + Байт;
	КонецЦикла;
	
	Возврат Целое;
	
КонецФункции

Функция ПрочитатьБайт(АнализДанных, КоличествоРаз = 1)
	
	Если АнализДанных.ЕстьОшибка Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если АнализДанных.Смещение + КоличествоРаз <= АнализДанных.Буфер.Размер Тогда
		Байт = АнализДанных.Буфер.Получить(АнализДанных.Смещение + КоличествоРаз - 1);
		АнализДанных.Смещение = АнализДанных.Смещение + КоличествоРаз;
	Иначе
		Байт = Неопределено;
		ПриОшибкеКодированияASN1(АнализДанных);
	КонецЕсли;
	
	Возврат Байт;
	
КонецФункции

Процедура ПриОшибкеКодированияASN1(АнализДанных)
	
	АнализДанных.ЭтоОшибкаКодированияASN1 = Истина;
	АнализДанных.ЕстьОшибка = Истина;
	
КонецПроцедуры

Процедура ПриОшибкеСтруктурыДанных(АнализДанных) Экспорт
	
	АнализДанных.ЭтоОшибкаСтруктурыДанных = Истина;
	АнализДанных.ЕстьОшибка = Истина;
	
КонецПроцедуры

Функция ИдентификаторыАлгоритмовПодписи(ТолькоАлгоритмыОткрытогоКлюча)
	
	ИдентификаторыАлгоритмов = Новый Соответствие;
	
	Наборы = НаборыАлгоритмовДляСозданияПодписи();
	Для Каждого Набор Из Наборы Цикл
		ИдентификаторыАлгоритмов.Вставить(Набор.ИдентификаторАлгоритмаОткрытогоКлюча,
			СтрСоединить(Набор.ИменаАлгоритмаПодписи, ", "));
		
		Если ТолькоАлгоритмыОткрытогоКлюча Тогда
			Продолжить;
		КонецЕсли;
		
		ИдентификаторыАлгоритмов.Вставить(Набор.ИдентификаторАлгоритмаПодписи,
			СтрСоединить(Набор.ИменаАлгоритмаПодписи, ", "));
		
		Если ЗначениеЗаполнено(Набор.ИдентификаторАлгоритмаОбмена) Тогда
			ИдентификаторыАлгоритмов.Вставить(Набор.ИдентификаторАлгоритмаОбмена,
				СтрСоединить(Набор.ИменаАлгоритмаПодписи, ", "));
		КонецЕсли;
	КонецЦикла;
	
	Возврат ИдентификаторыАлгоритмов;
	
КонецФункции

Функция ИдентификаторыАлгоритмовХеширования()
	
	ИдентификаторыАлгоритмов = Новый Соответствие;
	
	Наборы = НаборыАлгоритмовДляСозданияПодписи();
	Для Каждого Набор Из Наборы Цикл
		ИдентификаторыАлгоритмов.Вставить(Набор.ИдентификаторАлгоритмаХеширования,
			СтрСоединить(Набор.ИменаАлгоритмаХеширования, ", "));
	КонецЦикла;
	
	Возврат ИдентификаторыАлгоритмов;
	
КонецФункции

// Возвращаемое значение:
//  Массив из см. НовыйНаборАлгоритмовДляСозданияПодписи
//
Функция НаборыАлгоритмовДляСозданияПодписи() Экспорт
	
	Наборы = Новый Массив;
	
	// ГОСТ 94
	Свойства = НовыйНаборАлгоритмовДляСозданияПодписи();
	Свойства.ИдентификаторАлгоритмаОткрытогоКлюча = "1.2.643.2.2.20";
	Свойства.ИдентификаторАлгоритмаПодписи        = "1.2.643.2.2.4";
	Свойства.ИменаАлгоритмаПодписи                = ИменаАлгоритмовПодписиГОСТ_34_10_94();
	Свойства.ИдентификаторАлгоритмаХеширования    = "1.2.643.2.2.9";
	Свойства.ИменаАлгоритмаХеширования            = ИменаАлгоритмовХешированияГОСТ_34_11_94();
	Свойства.ИмяАлгоритмаПодписиXML     = "http://www.w3.org/2001/04/xmldsig-more#gostr341094-gostr3411";
	Свойства.ИмяАлгоритмаХешированияXML = "http://www.w3.org/2001/04/xmldsig-more#gostr3411";
	Наборы.Добавить(Свойства);
	
	// ГОСТ 2001
	Свойства = НовыйНаборАлгоритмовДляСозданияПодписи();
	Свойства.ИдентификаторАлгоритмаОткрытогоКлюча = "1.2.643.2.2.19";
	Свойства.ИдентификаторАлгоритмаПодписи        = "1.2.643.2.2.3";
	Свойства.ИменаАлгоритмаПодписи                = ИменаАлгоритмовПодписиГОСТ_34_10_2001();
	Свойства.ИдентификаторАлгоритмаХеширования    = "1.2.643.2.2.9";
	Свойства.ИменаАлгоритмаХеширования            = ИменаАлгоритмовХешированияГОСТ_34_11_94();
	Свойства.ИмяАлгоритмаПодписиXML     = "http://www.w3.org/2001/04/xmldsig-more#gostr34102001-gostr3411";
	Свойства.ИмяАлгоритмаХешированияXML = "http://www.w3.org/2001/04/xmldsig-more#gostr3411";
	Наборы.Добавить(Свойства);
	
	// ГОСТ 2012/256
	Свойства = НовыйНаборАлгоритмовДляСозданияПодписи();
	Свойства.ИдентификаторАлгоритмаОткрытогоКлюча = "1.2.643.7.1.1.1.1";
	Свойства.ИдентификаторАлгоритмаПодписи        = "1.2.643.7.1.1.3.2";
	Свойства.ИменаАлгоритмаПодписи                = ИменаАлгоритмовПодписиГОСТ_34_10_2012_256();
	Свойства.ИдентификаторАлгоритмаОбмена         = "1.2.643.7.1.1.6.1";
	Свойства.ИдентификаторАлгоритмаХеширования    = "1.2.643.7.1.1.2.2";
	Свойства.ИменаАлгоритмаХеширования            = ИменаАлгоритмовХешированияГОСТ_34_11_2012_256();
	Свойства.ИмяАлгоритмаПодписиXML     = "urn:ietf:params:xml:ns:cpxmlsec:algorithms:gostr34102012-gostr34112012-256";
	Свойства.ИмяАлгоритмаХешированияXML = "urn:ietf:params:xml:ns:cpxmlsec:algorithms:gostr34112012-256";
	Наборы.Добавить(Свойства);
	
	// ГОСТ 2012/512
	Свойства = НовыйНаборАлгоритмовДляСозданияПодписи();
	Свойства.ИдентификаторАлгоритмаОткрытогоКлюча = "1.2.643.7.1.1.1.2";
	Свойства.ИдентификаторАлгоритмаПодписи        = "1.2.643.7.1.1.3.3";
	Свойства.ИменаАлгоритмаПодписи                = ИменаАлгоритмовПодписиГОСТ_34_10_2012_512();
	Свойства.ИдентификаторАлгоритмаОбмена         = "1.2.643.7.1.1.6.2";
	Свойства.ИдентификаторАлгоритмаХеширования    = "1.2.643.7.1.1.2.3";
	Свойства.ИменаАлгоритмаХеширования            = ИменаАлгоритмовХешированияГОСТ_34_11_2012_512();
	Свойства.ИмяАлгоритмаПодписиXML     = "urn:ietf:params:xml:ns:cpxmlsec:algorithms:gostr34102012-gostr34112012-512";
	Свойства.ИмяАлгоритмаХешированияXML = "urn:ietf:params:xml:ns:cpxmlsec:algorithms:gostr34112012-512";
	Наборы.Добавить(Свойства);
	
	// md2WithRSAEncryption
	Свойства = НовыйНаборАлгоритмовДляСозданияПодписи();
	Свойства.ИдентификаторАлгоритмаОткрытогоКлюча = "1.2.840.113549.1.1.1";
	Свойства.ИдентификаторАлгоритмаПодписи        = "1.2.840.113549.1.1.2";
	Свойства.ИменаАлгоритмаПодписи                = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве("RSA_SIGN");
	Свойства.ИдентификаторАлгоритмаХеширования    = "1.2.840.113549.2.2";
	Свойства.ИменаАлгоритмаХеширования            = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве("MD2");
	Свойства.ИмяАлгоритмаПодписиXML     = "";
	Свойства.ИмяАлгоритмаХешированияXML = "";
	Наборы.Добавить(Свойства);
	
	// md4withRSAEncryption
	Свойства = НовыйНаборАлгоритмовДляСозданияПодписи();
	Свойства.ИдентификаторАлгоритмаОткрытогоКлюча = "1.2.840.113549.1.1.1";
	Свойства.ИдентификаторАлгоритмаПодписи        = "1.2.840.113549.1.1.3";
	Свойства.ИменаАлгоритмаПодписи                = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве("RSA_SIGN");
	Свойства.ИдентификаторАлгоритмаХеширования    = "1.2.840.113549.2.4";
	Свойства.ИменаАлгоритмаХеширования            = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве("MD4");
	Свойства.ИмяАлгоритмаПодписиXML     = "";
	Свойства.ИмяАлгоритмаХешированияXML = "";
	Наборы.Добавить(Свойства);
	
	// md5WithRSAEncryption
	Свойства = НовыйНаборАлгоритмовДляСозданияПодписи();
	Свойства.ИдентификаторАлгоритмаОткрытогоКлюча = "1.2.840.113549.1.1.1";
	Свойства.ИдентификаторАлгоритмаПодписи        = "1.2.840.113549.1.1.4";
	Свойства.ИменаАлгоритмаПодписи                = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве("RSA_SIGN");
	Свойства.ИдентификаторАлгоритмаХеширования    = "1.2.840.113549.2.5";
	Свойства.ИменаАлгоритмаХеширования            = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве("MD5");
	Свойства.ИмяАлгоритмаПодписиXML     = "";
	Свойства.ИмяАлгоритмаХешированияXML = "";
	Наборы.Добавить(Свойства);
	
	// sha1WithRSAEncryption
	Свойства = НовыйНаборАлгоритмовДляСозданияПодписи();
	Свойства.ИдентификаторАлгоритмаОткрытогоКлюча = "1.2.840.113549.1.1.1";
	Свойства.ИдентификаторАлгоритмаПодписи        = "1.2.840.113549.1.1.5";
	Свойства.ИменаАлгоритмаПодписи                = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве("RSA_SIGN");
	Свойства.ИдентификаторАлгоритмаХеширования    = "1.3.14.3.2.26";
	Свойства.ИменаАлгоритмаХеширования            = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве("SHA-1");
	Свойства.ИмяАлгоритмаПодписиXML     = "";
	Свойства.ИмяАлгоритмаХешированияXML = "";
	Наборы.Добавить(Свойства);
	
	// sha256WithRSAEncryption
	Свойства = НовыйНаборАлгоритмовДляСозданияПодписи();
	Свойства.ИдентификаторАлгоритмаОткрытогоКлюча = "1.2.840.113549.1.1.1";
	Свойства.ИдентификаторАлгоритмаПодписи        = "1.2.840.113549.1.1.11";
	Свойства.ИменаАлгоритмаПодписи                = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве("RSA_SIGN");
	Свойства.ИдентификаторАлгоритмаХеширования    = "2.16.840.1.101.3.4.2.1";
	Свойства.ИменаАлгоритмаХеширования            = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве("SHA-256");
	Свойства.ИмяАлгоритмаПодписиXML     = "";
	Свойства.ИмяАлгоритмаХешированияXML = "";
	Наборы.Добавить(Свойства);
	
	// sha384WithRSAEncryption
	Свойства = НовыйНаборАлгоритмовДляСозданияПодписи();
	Свойства.ИдентификаторАлгоритмаОткрытогоКлюча = "1.2.840.113549.1.1.1";
	Свойства.ИдентификаторАлгоритмаПодписи        = "1.2.840.113549.1.1.12";
	Свойства.ИменаАлгоритмаПодписи                = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве("RSA_SIGN");
	Свойства.ИдентификаторАлгоритмаХеширования    = "2.16.840.1.101.3.4.2.2";
	Свойства.ИменаАлгоритмаХеширования            = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве("SHA-384");
	Свойства.ИмяАлгоритмаПодписиXML     = "";
	Свойства.ИмяАлгоритмаХешированияXML = "";
	Наборы.Добавить(Свойства);
	
	// sha512WithRSAEncryption
	Свойства = НовыйНаборАлгоритмовДляСозданияПодписи();
	Свойства.ИдентификаторАлгоритмаОткрытогоКлюча = "1.2.840.113549.1.1.1";
	Свойства.ИдентификаторАлгоритмаПодписи        = "1.2.840.113549.1.1.13";
	Свойства.ИменаАлгоритмаПодписи                = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве("RSA_SIGN");
	Свойства.ИдентификаторАлгоритмаХеширования    = "2.16.840.1.101.3.4.2.3";
	Свойства.ИменаАлгоритмаХеширования            = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве("SHA-512");
	Свойства.ИмяАлгоритмаПодписиXML     = "";
	Свойства.ИмяАлгоритмаХешированияXML = "";
	Наборы.Добавить(Свойства);
	
	Возврат Наборы;
	
КонецФункции

// Возвращаемое значение:
//  Структура:
//   * ИдентификаторАлгоритмаОткрытогоКлюча - Строка
//   * ИдентификаторАлгоритмаПодписи - Строка
//   * ИменаАлгоритмаПодписи - Массив из Строка
//   * ИдентификаторАлгоритмаХеширования - Строка
//   * ИменаАлгоритмаХеширования - Массив из Строка
//   * ИмяАлгоритмаПодписиXML - Строка
//   * ИмяАлгоритмаХешированияXML - Строка
//    
Функция НовыйНаборАлгоритмовДляСозданияПодписи()
	
	Свойства = Новый Структура;
	Свойства.Вставить("ИдентификаторАлгоритмаОткрытогоКлюча", "");
	Свойства.Вставить("ИдентификаторАлгоритмаПодписи", "");
	Свойства.Вставить("ИменаАлгоритмаПодписи", Новый Массив);
	Свойства.Вставить("ИдентификаторАлгоритмаОбмена", "");
	Свойства.Вставить("ИдентификаторАлгоритмаХеширования", "");
	Свойства.Вставить("ИменаАлгоритмаХеширования", Новый Массив);
	Свойства.Вставить("ИмяАлгоритмаПодписиXML", "");
	Свойства.Вставить("ИмяАлгоритмаХешированияXML", "");
	
	Возврат Свойства;
	
КонецФункции

Функция ИменаАлгоритмовПодписиГОСТ_34_10_94()
	
	Имена = Новый Массив;
	Имена.Добавить("ГОСТ 34.10-94"); // Представление.
	Имена.Добавить("GOST R 34.10-94");
	
	Возврат Имена;
	
КонецФункции

Функция ИменаАлгоритмовПодписиГОСТ_34_10_2001()
	
	Имена = Новый Массив;
	Имена.Добавить("ГОСТ 34.10-2001"); // Представление.
	Имена.Добавить("GOST R 34.10-2001");
	Имена.Добавить("ECR3410-CP");
	
	Возврат Имена;
	
КонецФункции

Функция ИменаАлгоритмовПодписиГОСТ_34_10_2012_256()
	
	Имена = Новый Массив;
	Имена.Добавить("ГОСТ 34.10-2012 256"); // Представление.
	Имена.Добавить("GR 34.10-2012 256");
	Имена.Добавить("GOST 34.10-2012 256");
	Имена.Добавить("GOST R 34.10-12 256");
	Имена.Добавить("GOST3410-12-256");
	
	Возврат Имена;
	
КонецФункции

Функция ИменаАлгоритмовПодписиГОСТ_34_10_2012_512()
	
	Имена = Новый Массив;
	Имена.Добавить("ГОСТ 34.10-2012 512"); // Представление.
	Имена.Добавить("GR 34.10-2012 512");
	Имена.Добавить("GOST 34.10-2012 512");
	
	Возврат Имена;
	
КонецФункции

Функция ИменаАлгоритмовХешированияГОСТ_34_11_94()
	
	Имена = Новый Массив;
	Имена.Добавить("ГОСТ 34.11-94"); // Представление.
	Имена.Добавить("GOST R 34.11-94");
	Имена.Добавить("RUS-HASH-CP");
	
	Возврат Имена;
	
КонецФункции

Функция ИменаАлгоритмовХешированияГОСТ_34_11_2012_256()
	
	Имена = Новый Массив;
	Имена.Добавить("ГОСТ 34.11-2012 256"); // Представление.
	Имена.Добавить("GR 34.11-2012 256");
	Имена.Добавить("GOST 34.11-2012 256");
	Имена.Добавить("GOST R 34.11-12 256");
	Имена.Добавить("GOST3411-12-256");
	
	Возврат Имена;
	
КонецФункции

Функция ИменаАлгоритмовХешированияГОСТ_34_11_2012_512()
	
	Имена = Новый Массив;
	Имена.Добавить("ГОСТ 34.11-2012 512"); // Представление.
	Имена.Добавить("GR 34.11-2012 512");
	Имена.Добавить("GOST 34.11-2012 512");
	
	Возврат Имена;
	
КонецФункции

#КонецОбласти

#КонецОбласти